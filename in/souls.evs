#memory(
    string_key(0x0546)..string_key(0x232b), // last half of string keys
    function_key(0x0000)..function_key(0x1668), // 0x1719 seems to be used by the engine
    function_key(0x1986)..function_key(0x232b), // 0x1719 seems to be used by the engine

    0x300000..0x3fffff, // extension

    // SRAM
    // <0x2265>..<0x2266>, // reserved: map+variant
    <0x2267>..<0x22D9>, // vanilla sniff spots
    <0x22dd>..<0x22e9>, // experimental
    <0x236D>..<0x2378>, // act4 codes
    // <0x2379>..<0x237C>, // landing spots
    <0x253d>..<0x2558>, // sliver extension "save_file_growth" (excluded string params)

    // RAM
    <0x2463>..<0x2512>, // experimental

    // TEMP RAM
    <0x2834>..<0x2890>
    // <0x2834>..<0x28fb> // 199 room specific bytes
)
#include("in/core.evs")

#patch(
    // "skip_intro",
    "assassin_silversheath",
    "assassin_bazooka_ammo",
    "assassin_bazooka_charge",
    "save_file_growth",
    "no_alchemy_xp",

    // asm
    "temp_jaguar_ring(!ROM_EXTENSION=$FE6000)",
    "debug_menu__generic(!ROM_EXTENSION=$FE0000)",
    "_hook_input(!ROM_EXTENSION=$FE5000)",
        "hotkeys(!ROM_EXTENSION=$FD0000, !ROM_HOOK=$FE5000, !WITH_HOTKEY_B=0)",
        // "room_timer(!ROM_EXTENSION=$F00000, !ROM_HOOK=$FE5000)",
    // "_hook_trigger",
    "menu_close",
    "five_status_effects_fix(!ROM_EXTENSION=$FE7000)",
    "scale_enemies(!ROM_EXTENSION=$FE8000, !WITH_DEBUG_PALETTE=0)",
    "scale_boy(!BOY_HP_INCREMENT=3, !DOG_HP_INCREMENT=3)",
)

group non_maps() {
    group strings() {
        @install(0x4713f, False)
        fun string_revealer_entity_name() {
            'SECRET[END]'; // "Bridge"
        }

        @install(0x92c98b) // originally script id 0x51
        fun currency_name() {
            text("Souls");
        }
    };

    group enemy_properties() {
        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.BOY * CHARACTER_DATA.SIZE) + CHARACTER_DATA.ATTACK_PROC, False)
        fun boy_proc() {
            code(ATTACK_PROC.DEFAULT, "// boy proc"); // disables weapon xp
        }
        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.DOG * CHARACTER_DATA.SIZE) + CHARACTER_DATA.ATTACK_PROC, False)
        fun dog_proc() {
            code(ATTACK_PROC.DEFAULT, "// dog proc"); // disables weapon xp
        }

        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.FLOWER_PURPLE * CHARACTER_DATA.SIZE) + CHARACTER_DATA.ATTACK_PROC, False)
        fun flower_purple_proc() {
            code(ATTACK_PROC.VORE, "// flower purple proc");
        }

        // @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.TUMBLING_WEED * CHARACTER_DATA.SIZE) + CHARACTER_DATA.ATTACK_PROC, False)
        // fun tumbling_weed_proc() {
        //     code(ATTACK_PROC.VORE, "// flower purple proc value");
        // }
        
        // @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.THRAXX * CHARACTER_DATA.SIZE) + CHARACTER_DATA.HIT_RATE, False)
        // fun thraxx_hit() {
        //     code(0d110, "// thraxx hit");
        // }
        // @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.THRAXX * CHARACTER_DATA.SIZE) + CHARACTER_DATA.ATTACK, False)
        // fun thraxx_hit() {
        //     code(0d10, "// thraxx damage");
        // }

        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.SPARK * CHARACTER_DATA.SIZE) + CHARACTER_DATA.EVADE, False)
        fun spark_evade() {
            code(0x0000, "// spark evade");
        }

        // @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.BOY_BLACK * CHARACTER_DATA.SIZE) + CHARACTER_DATA.EVADE, False)
        // fun boy_black_evade() {
        //     code(0x0009, "// BOY_BLACK evade");
        // }

        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.RAPTOR_TEAL * CHARACTER_DATA.SIZE) + CHARACTER_DATA.EVADE, False)
        fun raptor_teal_evade() {
            code(0x0009, "// raptor teal evade");
        }
        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.RAPTOR_TEAL * CHARACTER_DATA.SIZE) + CHARACTER_DATA.PRIZE_CHANCE, False)
        fun raptor_teal_prize_chance() {
            code(0x0000, "// raptor teal prize chance");
        }

        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.RIMSALA_2 * CHARACTER_DATA.SIZE) + CHARACTER_DATA.PRIZE_CHANCE, False)
        fun rimsala_2_prize_chance() {
            code(0x0000, "// rimsala 2 prize chance");
        }

        @install(CHARACTER_DATA.POINTER + (CHARACTER_INDEX.DOG_4_BLACK * CHARACTER_DATA.SIZE) + CHARACTER_DATA.PRIZE_CHANCE, False)
        fun dog_4_black_prize_chance() {
            code(0x0000, "// DOG_4_BLACK prize chance");
        }
    };

    // group alchemy_ingredients() {
    //     @install(ALCHEMY_COST_DATA.POINTER + ALCHEMY_COST_DATA.SIZE * (ALCHEMY_INDEX.BARRIER / 0d02))
    //     fun barrier() {
    //         code(INGREDIENT.DRY_ICE, INGREDIENT.DRY_ICE, 0d01, 0d01, "// barrier ingredients");
    //     }
    // };

    group alchemy_target() {
        @install(ALCHEMY_TARGET.POINTER + ALCHEMY_TARGET.SIZE * (ALCHEMY_INDEX.HEAL / 0d02))
        fun alchemy_target_heal() {
            code(ALCHEMY_TARGET.ENEMY_ALL, "// heal (enemy or all enemies)");
        }
    };

    group armor() {
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_1_1 - 0d01))
        fun armor_chest_1_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_1_2 - 0d01))
        fun armor_chest_1_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_1_3 - 0d01))
        fun armor_chest_1_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_2_1 - 0d01))
        fun armor_chest_2_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_2_2 - 0d01))
        fun armor_chest_2_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_2_3 - 0d01))
        fun armor_chest_2_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_3_1 - 0d01))
        fun armor_chest_3_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_3_2 - 0d01))
        fun armor_chest_3_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_3_3 - 0d01))
        fun armor_chest_3_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_4_1 - 0d01))
        fun armor_chest_4_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_4_2 - 0d01))
        fun armor_chest_4_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.CHEST_4_3 - 0d01))
        fun armor_chest_4_3() {
            code(0d0000, 0d0000, "// armor");
        }

        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_1_1 - 0d01))
        fun armor_helm_1_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_1_2 - 0d01))
        fun armor_helm_1_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_1_3 - 0d01))
        fun armor_helm_1_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_2_1 - 0d01))
        fun armor_helm_2_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_2_2 - 0d01))
        fun armor_helm_2_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_2_3 - 0d01))
        fun armor_helm_2_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_3_1 - 0d01))
        fun armor_helm_3_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_3_2 - 0d01))
        fun armor_helm_3_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_3_3 - 0d01))
        fun armor_helm_3_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_4_1 - 0d01))
        fun armor_helm_4_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_4_2 - 0d01))
        fun armor_helm_4_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.HELM_4_3 - 0d01))
        fun armor_helm_4_3() {
            code(0d0000, 0d0000, "// armor");
        }

        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_1_1 - 0d01))
        fun armor_glove_1_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_1_2 - 0d01))
        fun armor_glove_1_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_1_3 - 0d01))
        fun armor_glove_1_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_2_1 - 0d01))
        fun armor_glove_2_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_2_2 - 0d01))
        fun armor_glove_2_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_2_3 - 0d01))
        fun armor_glove_2_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_3_1 - 0d01))
        fun armor_glove_3_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_3_2 - 0d01))
        fun armor_glove_3_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_3_3 - 0d01))
        fun armor_glove_3_3() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_4_1 - 0d01))
        fun armor_glove_4_1() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_4_2 - 0d01))
        fun armor_glove_4_2() {
            code(0d0000, 0d0000, "// armor");
        }
        @install(ARMOR_DATA.POINTER + ARMOR_DATA.SIZE * (ARMOR_INDEX.GLOVE_4_3 - 0d01))
        fun armor_glove_4_3() {
            code(0d0000, 0d0000, "// armor");
        }
    };

    group weapon() {
        @install(WEAPON_DATA.POINTER + WEAPON_DATA.SIZE * (WEAPON_INDEX.SWORD_1 / 0d02 - 0d01), False)
        fun bone_crusher_attack() {
            code(0d0010 + 0d2, "// bone crusher attack"); // compensates for fixed silver sheath
        }

        @install(WEAPON_DATA.POINTER + WEAPON_DATA.SIZE * (WEAPON_INDEX.BAZOOKA_1 / 0d02 - 0d01), False)
        fun bone_crusher_attack() {
            code(0d0020, "// bazooka (red) attack");
        }
        @install(WEAPON_DATA.POINTER + WEAPON_DATA.SIZE * (WEAPON_INDEX.BAZOOKA_2 / 0d02 - 0d01), False)
        fun bone_crusher_attack() {
            code(0d0030, "// bazooka (green) attack");
        }
        @install(WEAPON_DATA.POINTER + WEAPON_DATA.SIZE * (WEAPON_INDEX.BAZOOKA_3 / 0d02 - 0d01), False)
        fun bone_crusher_attack() {
            code(0d0040, "// bazooka (blue) attack");
        }
    };

    group helper() {
        fun add_pillar(x, y) {
            add_enemy(LIZARD, x, y, INACTIVE_IMORTAL);
            animate(LAST_ENTITY, LOOP, ANIMATION_PLACEHOLDER.PILLAR_VIGOR);
        }

        fun notification_door_opened() {
            subtext("Somewhere a door has opened.");
        }

        @install()
        fun enemy_triggered_invincible() {
            heal(SCRIPT_OWNER, 0x00, False);
        }

        @install()
        fun enemy_triggered_invincible_with_knockback() {
            heal(SCRIPT_OWNER, 0x00, False);
            yield();
            damage(SCRIPT_OWNER, 0x00, True);
        }

        fun guard_boy_damage() {
            if(<ACTIVE> == <DOG>) {
                end();
            }
            if(<SCRIPT_OWNER>[DAMAGE_SOURCE] == CHARACTER_ADDRESS.DOG) {
                end();
            }
        }
    };

    group souls_helper() {
        enum BUTTON_MAP {
            NORMAL = 0x00,
            PUPPER = 0x01,
            SPEAR_TOSS = 0x02,

            ISAAC = 0x10,
            BOMBS = 0x11,

            MARIO = 0x20,
            MARIO_FIREFLOWER = 0x21,

            AIRSHIP = 0x30,
            SPACESHIP = 0x31,
        }
        enum DEBUG_MENU_ENTRY {
            BOMBS = 0d1,
            ISAAC = 0d2,
            MARIO = 0d3,
            PUPPER = 0d4,
            ROCKET_JUMP = 0d5,
            QUANTUM_JUMP = 0d6,

            NONE = 0d0,
        }

        enum CUSTOM_ITEM {
            NO_ITEM = 0x0000,

            // weapons
            SWORD_ORB = 0xf000, // available: 2
            SPEAR_ORB = 0xf001, // available: 3
            AXE_ORB = 0xf002, // available: 3

            // armor
            CHEST_HEAVY = 0xf010,
            CHEST_RED = 0xf011,
            HELM_ARCHAEOLOGY = 0xf020,
            GLOVE_HACKER = 0xf030,
            GLOVE_PIPBOY_NORTH_EAST = 0xf031,
            GLOVE_PIPBOY_NORTH_WEST = 0xf032,

            // quest items
            SMITH_KEY = 0xf100, // unlocks orb upgrades
            BIG_MUSHROOM = 0xf101, // unlocks jumping in the sewers
            ISAAC_LETTER = 0xf102, // unlocks isaac wanted poster
            ISAAC_WANTED_POSTER = 0xf103, // unlocks ?
            BUG_CATCHER_BROKEN = 0xf104, // unlocks bee collecting
            BUG_CATCHER = 0xf105, // unlocks bee collecting

            // active abilities
            ZELDA_POWER_GLOVE = 0xf200, // unlocks levitate stones
            ISAAC_TEARS = 0xf201,
            ISAAC_BOMB = 0xf202,
            MARIO_YUMP = 0xf203,
            ROCKET_JUMP = 0xf204,
            PUPPER_MODE = 0xf205,

            // fake items
            TUNIC_GREEN = 0xf300,
            TUNIC_RED = 0xf301,
            ESTUS_SHARD = 0xf302,
            PICKAXE_HEAD = 0xf303,
            PICKAXE_SHAFT = 0xf304,
            PICKAXE = 0xf305,
        }
        enum SOULS_MEMORY {
            INIT = memory(FLAG, SRAM),
            INIT_SESSION = memory(FLAG, RAM),
            INTRO_WATCHED = memory(FLAG, SRAM),
            // debug
            DEBUG = True,
            DEBUG_BOMBABLE_WALLS = False,

            // features
            WITH_OPENING = False, // doesn't work?
            WITH_SAVESTATE_LOAD = True, // after splash screen
            WITH_SAVESTATE_SAVE = True, // bonfire menu
            // souls specific features
            WITH_INTRO = True,
            WITH_STARTING_CLASS = False,
            WITH_SHRINE_INTRO = True,
            WITH_SOULS_ON_DEATH = True,
            WITH_RETURN_TO_BONFIRE_ON_DEATH = True,
            WITH_TRASH_ENEMIES = True,
            WITH_FOG_WALL = True,
            WITH_FOGWALL_WALKBACK = False,
            WITH_SIDE_QUESTS = True,
            WITH_CHEAP_SWORD2 = True,
            WITH_WEATHER = False, // TODO: has to be persistent to be playable
            WITH_COLOR_FILTER = True, // produces lag, requires an ASM to not change the filter during menus
            WITH_AREA_NAMES = False,
            // cheats
            WITH_CHEATS = True, // fixes no clip after screen transitions
            WITH_CHEATS_FULL_INGREDIENTS = True,
            WITH_CHEATS_HOTKEYS = True,
            WITH_CHEATS_ALL_BONFIRES = False,
            WITH_CHEATS_MARIO_YUMP = False,
            WITH_DEBUG_ENTITIES = False,
            WITH_DEBUG_ENTITY_ALCHEMY_SELECTION = False,
            // areas
            WITH_ENDBOSS = True,
            WITH_BOAT_RIDE = False,
            WITH_CODE = True,
            WITH_SATURN_ROOM = True,
            WITH_METRO = True,

            // dog
            DOG_PREFERENCE = memory(BYTE, SRAM),
            DOG_SHIP = memory(FLAG, SRAM),
            DOG_SHIP_STAIRS = memory(FLAG, SRAM),

            // boy
            SLOW_ON_HIT = memory(FLAG, TEMP_RESERVED),
            // boy dust
            DUST_ENTITY = memory(WORD, TEMP_RESERVED),
            DUST_DROP_X = memory(WORD, SRAM),
            DUST_DROP_Y = memory(WORD, SRAM),
            DUST_DROP_MAP = memory(BYTE, SRAM),
            DUST_DROP_VARIANT = memory(BYTE, SRAM),
            DUST_UNREACHABLE = memory(FLAG, SRAM),

            // wings
            WINGS_BLOCKED = memory(FLAG, SRAM),
            
            // custom items
            ESTUS_CHARGES = memory(BYTE, SRAM),
            ESTUS_SHARDS = memory(BYTE, SRAM),
            ESTUS_CHARGES_INIT = 0d1,

            ORB_USED = memory(FLAG, SRAM),
            ORB_SWORD = memory(BYTE, SRAM),
            ORB_AXE = memory(BYTE, SRAM),
            ORB_SPEAR = memory(BYTE, SRAM),

            BEES = memory(BYTE, SRAM),
            // ISAAC_BOMBS = memory(BYTE, SRAM),
            
            SMITH_KEY = memory(FLAG, SRAM),
            BIG_MUSHROOM = memory(FLAG, SRAM),
            ISAAC_LETTER = memory(FLAG, SRAM),
            ISAAC_WANTED_POSTER = memory(FLAG, SRAM),
            BUG_CATCHER_BROKEN = memory(FLAG, SRAM),
            BUG_CATCHER = memory(FLAG, SRAM),
            PICKAXE_HEAD = memory(FLAG, SRAM),
            PICKAXE_SHAFT = memory(FLAG, SRAM),
            PICKAXE = memory(FLAG, SRAM),

            CLEARANCE_VAULT_NORTH_EAST = memory(FLAG, SRAM),

            // custom item helper

            HIT_BONUS_HELM = memory(FLAG, SRAM),
            HIT_BONUS_CHEST = memory(FLAG, SRAM),
            HIT_BONUS_ARMLET = memory(FLAG, SRAM),
            NO_RUNNING_CHEST = memory(FLAG, TEMP_RESERVED),
            ARCHAEOLOGY_TARGET = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_1 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_2 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_3 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_4 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_5 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_6 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_7 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_8 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_9 = memory(WORD, TEMP_RESERVED),
            RADIATION_SOURCE_10 = memory(WORD, TEMP_RESERVED),

            // button map
            BUTTON_MAP = memory(BYTE, TEMP_RESERVED),
            MENU_CHOICE = memory(BYTE, SRAM),
            
            DEBUG_MENU_BUTTON_1 = memory(BYTE, SRAM),
            DEBUG_MENU_BUTTON_2 = memory(BYTE, SRAM),
            DEBUG_MENU_BUTTON_3 = memory(BYTE, SRAM),
            DEBUG_MENU_BUTTON_4 = memory(BYTE, SRAM),
            DEBUG_MENU_BUTTON_5 = memory(BYTE, SRAM),
            DEBUG_MENU_BUTTON_6 = memory(BYTE, SRAM),
            DEBUG_MENU_BUTTON_7 = memory(BYTE, SRAM),

            WEAPON_CYCLE_ENABLED = memory(FLAG, SRAM),
            CHARACTER_SWITCH_ENABLED = memory(FLAG, SRAM),

            BOMB_ENABLED = memory(FLAG, SRAM),
            MARIO_YUMP_ENABLED = memory(FLAG, SRAM),
            ISAAC_TEARS_ENABLED = memory(FLAG, SRAM),
            PUPPER_ENABLED = memory(FLAG, SRAM),
            ROCKET_JUMP_ENABLED = memory(FLAG, SRAM),
            QUANTUM_JUMP_ENABLED = memory(FLAG, SRAM),

            ///////////////////////////////////////////////////////
            // bonfire
            ///////////////////////////////////////////////////////

            BONFIRE_FIRST_TRIGGER = memory(FLAG, SRAM),
            BONFIRE_X = memory(WORD, SRAM),
            BONFIRE_Y = memory(WORD, SRAM),
            BONFIRE_MAP = memory(BYTE, SRAM),
            BONFIRE_VARIANT = memory(BYTE, SRAM),
            BONFIRE_TELEPORT_REQUIRED = memory(FLAG, SRAM),
            BONFIRE_TELEPORT_BIND = memory(FLAG, SRAM),

            // center
            BONFIRE_INBETWIXX = memory(FLAG, SRAM),

            // east
            BONFIRE_EAST_CROSSING = memory(FLAG, SRAM),
            BONFIRE_PIPES = memory(FLAG, SRAM),
            BONFIRE_TOWN_CENTER = memory(FLAG, SRAM),
            BONFIRE_TEMPLE_PIT = memory(FLAG, SRAM),

            // west
            BONFIRE_ISAAC_DUNGEON = memory(FLAG, SRAM),
            BONFIRE_VOLCANO_TOWER = memory(FLAG, SRAM),

            // south
            BONFIRE_JUNGLE_PIT = memory(FLAG, SRAM),

            BONFIRE_BUG = memory(FLAG, SRAM),
            BONFIRE_DESERT = memory(FLAG, SRAM),

            // altus
            BONFIRE_ALTUS_WELL = memory(FLAG, SRAM),
            BONFIRE_ALTUS_STAIRS = memory(FLAG, SRAM),
            BONFIRE_CASTLE_PIT = memory(FLAG, SRAM),

            // omnitopia
            
            ///////////////////////////////////////////////////////
            // bosses
            ///////////////////////////////////////////////////////

            PROGRESS_COUNTER = memory(BYTE, SRAM),
            FAME_THRESHOLD = 0d20,
            BOSSES_DEFEATED_COUNTER = memory(BYTE, SRAM),
            COLLECTIBLE_COUNTER = memory(BYTE, SRAM),

            // west
            DEAD_OWL_BOY = memory(FLAG, SRAM), // t0+
            REWARD_OWL_BOY = CUSTOM_ITEM.PICKAXE_HEAD,

            DEAD_MONSTRO = memory(FLAG, SRAM), // t0
            REWARD_MONSTRO = CUSTOM_ITEM.SWORD_ORB,
            DEAD_DARK_ONE = memory(FLAG, SRAM), // t2
            REWARD_DARK_ONE = CUSTOM_ITEM.ISAAC_BOMB,

            // altus
            DEAD_SIDESCROLLER = memory(FLAG, SRAM), // t0
            REWARD_SIDESCROLLER = CUSTOM_ITEM.SPEAR_ORB,

            DEAD_CHESS = memory(FLAG, SRAM), // t0
            REWARD_CHESS = CUSTOM_ITEM.AXE_ORB,

            DEAD_UNNAMED_STAIRWELL_BOSS = memory(FLAG, SRAM),
            REWARD_UNNAMED_STAIRWELL_BOSS = CUSTOM_ITEM.TUNIC_RED,

            // east
            DEAD_PIT_EGG = memory(FLAG, SRAM), // t0
            REWARD_PIT_EGG = ITEM.WINGS,

            DEAD_ARENA_RADAHN = memory(FLAG, SRAM), // t?
            REWARD_ARENA_RADAHN = CUSTOM_ITEM.ROCKET_JUMP,
            DEAD_STOMPY_RADAHN = memory(FLAG, SRAM), // t?
            REWARD_STOMPY_RADAHN = ITEM.NECTAR, // TODO
            
            DEAD_ARENA_MOSQUITO = memory(FLAG, SRAM), // t0
            REWARD_ARENA_MOSQUITO = ITEM.PIXIE_DUST,

            DEAD_BOWSER = memory(FLAG, SRAM), // t?
            REWARD_BOWSER = CUSTOM_ITEM.MARIO_YUMP,

            DEAD_TAVERN_BOXERS = memory(FLAG, SRAM), // t0
            REWARD_TAVERN_BOXERS = ITEM.TICKET_FOR_EXHIBITION,
            DEAD_TOWN_PUPPETS = memory(FLAG, SRAM),
            REWARD_TOWN_PUPPETS = CUSTOM_ITEM.SWORD_ORB,
            DEAD_DOG_STATUE = memory(FLAG, SRAM), // t0
            REWARD_DOG_STATUE = ITEM.NECTAR, // TODO

            DEAD_TEMPLE_MINITAUR = memory(FLAG, SRAM),
            REWARD_TEMPLE_MINITAUR = CUSTOM_ITEM.SPEAR_ORB,
            DEAD_TEMPLE_SQUAD = memory(FLAG, SRAM), // t2 (nerfed from t3+) - locked: spear2
            REWARD_TEMPLE_SQUAD = CUSTOM_ITEM.AXE_ORB,
            DEAD_WALL = memory(FLAG, SRAM), // t2
            REWARD_WALL = CUSTOM_ITEM.PICKAXE_SHAFT,
            DEAD_NARIS = memory(FLAG, SRAM),
            REWARD_NARIS = CUSTOM_ITEM.ZELDA_POWER_GLOVE,
            PROGRESS_NARIS = memory(FLAG, SRAM),

            DEAD_HEART = memory(FLAG, SRAM), // t0
            REWARD_HEART = CUSTOM_ITEM.SWORD_ORB,

            DEAD_TRAP_RIMSALA = memory(FLAG, SRAM), // t1
            REWARD_TRAP_RIMSALA = CUSTOM_ITEM.SPEAR_ORB,

            DEAD_AQUAGOTH = memory(FLAG, SRAM), // t0
            REWARD_AQUAGOTH = ITEM.NO_ITEM,
            DEAD_SQUIDMAR = memory(FLAG, SRAM), // t2 (nerfed from t3+) - locked: axe2
            REWARD_SQUIDMAR = CUSTOM_ITEM.SPEAR_ORB,

            // north

            DEAD_GIDEON = memory(FLAG, SRAM), // t?
            REWARD_GIDEON = CUSTOM_ITEM.GLOVE_PIPBOY_NORTH_EAST,

            // southern jungle

            DEAD_DOUBLE_THRAXX = memory(FLAG, SRAM),
            REWARD_DOUBLE_THRAXX = ITEM.STAFF_OF_LIFE,
            PROGRESS_DOUBLE_THRAXX = memory(FLAG, SRAM),

            DEAD_UNNAMED_DESERT_TEMPLE_BOSS = memory(FLAG, SRAM),
            REWARD_UNNAMED_DESERT_TEMPLE_BOSS = CUSTOM_ITEM.ZELDA_POWER_GLOVE,

            // metro

            DEAD_TOASTER_ARENA = memory(FLAG, SRAM),
            REWARD_TOASTER_ARENA = ITEM.METEORITE,

            DEAD_TURRET_ARENA = memory(FLAG, SRAM),
            REWARD_TURRET_ARENA = ITEM.METEORITE,

            DEAD_SPACESHIP_DESERT = memory(FLAG, SRAM),
            REWARD_SPACESHIP_DESERT = {
                subtext("Gained Arcade Coin");
            },
            DEAD_ABOMINATION = memory(FLAG, SRAM),
            REWARD_ABOMINATION = {
                subtext("Gained Arcade Coin");
            },

            DEAD_FINAL_BOSS = memory(FLAG, SRAM),

            ///////////////////////////////////////////////////////
            // quests
            ///////////////////////////////////////////////////////

            REWARD_ARENA_BOMB_1 = ITEM.LEVITATE,
            REWARD_ARENA_BOMB_2 = ITEM.NECTAR, // TODO
            REWARD_ARENA_BOMB_3 = ITEM.NECTAR, // TODO
            REWARD_ARENA_BOMB_4 = ITEM.NECTAR, // TODO

            REWARD_ARENA_DUEL = ITEM.ATLAS,

            COST_BEE_BOY_QUEST_1 = 0d1,
            REWARD_BEE_BOY_QUEST_1 = ITEM.FLASH,
            COST_BEE_BOY_QUEST_2 = 0d3,
            REWARD_BEE_BOY_QUEST_2 = ITEM.FORCE_FIELD,
            COST_BEE_BOY_QUEST_3 = 0d5,
            REWARD_BEE_BOY_QUEST_3 = ITEM.GLOVE_1_3,
            COST_BEE_BOY_QUEST_4 = 0d8,
            REWARD_BEE_BOY_QUEST_4 = CUSTOM_ITEM.ZELDA_POWER_GLOVE,

            REWARD_SQUIDMAR_QUEST = ITEM.NECTAR, // TODO

            REWARD_MARIO_QUEST = ITEM.NECTAR, // TODO

            REWARD_ISAAC_QUEST = CUSTOM_ITEM.ISAAC_TEARS,

            CLEARED_TRAP_WOLF = memory(FLAG, SRAM),
            REWARD_TRAP_WOLF = {
                subtext("Gained 2 Dog Biscuits");

                MEMORY.DOG_BISCUIT += 0d2;
            },
            CLEARED_TRAP_GREYHOUND = memory(FLAG, SRAM),
            REWARD_TRAP_GREYHOUND = {
                subtext("Gained 2 Dog Biscuits");

                MEMORY.DOG_BISCUIT += 0d2;
            },
            CLEARED_TRAP_POODLE = memory(FLAG, SRAM),
            REWARD_TRAP_POODLE = {
                subtext("Gained 2 Dog Biscuits");

                MEMORY.DOG_BISCUIT += 0d2;
            },
        }

        fun asign_debug_button_function(flag, feature) {
            if(flag) {
                arg[0x00]++;

                if(
                    (SOULS_MEMORY.DEBUG_MENU_BUTTON_1 != feature)
                    && (SOULS_MEMORY.DEBUG_MENU_BUTTON_2 != feature)
                    && (SOULS_MEMORY.DEBUG_MENU_BUTTON_3 != feature)
                    && (SOULS_MEMORY.DEBUG_MENU_BUTTON_4 != feature)
                    && (SOULS_MEMORY.DEBUG_MENU_BUTTON_5 != feature)
                    && (SOULS_MEMORY.DEBUG_MENU_BUTTON_6 != feature)
                    && (SOULS_MEMORY.DEBUG_MENU_BUTTON_7 != feature)
                ) {
                    if(SOULS_MEMORY.DEBUG_MENU_BUTTON_1 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_1 = feature;
                    } else if(SOULS_MEMORY.DEBUG_MENU_BUTTON_2 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_2 = feature;
                    } else if(SOULS_MEMORY.DEBUG_MENU_BUTTON_3 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_3 = feature;
                    } else if(SOULS_MEMORY.DEBUG_MENU_BUTTON_4 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_4 = feature;
                    } else if(SOULS_MEMORY.DEBUG_MENU_BUTTON_5 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_5 = feature;
                    } else if(SOULS_MEMORY.DEBUG_MENU_BUTTON_6 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_6 = feature;
                    } else if(SOULS_MEMORY.DEBUG_MENU_BUTTON_7 == 0d0) {
                        SOULS_MEMORY.DEBUG_MENU_BUTTON_7 = feature;
                    }
                }
            }
        }

        @install()
        fun update_debug_menu() {
            if(False) {
                SOULS_MEMORY.DEBUG_MENU_BUTTON_1 = 0d0;
                SOULS_MEMORY.DEBUG_MENU_BUTTON_2 = 0d0;
                SOULS_MEMORY.DEBUG_MENU_BUTTON_3 = 0d0;
                SOULS_MEMORY.DEBUG_MENU_BUTTON_4 = 0d0;
                SOULS_MEMORY.DEBUG_MENU_BUTTON_5 = 0d0;
                SOULS_MEMORY.DEBUG_MENU_BUTTON_6 = 0d0;
                SOULS_MEMORY.DEBUG_MENU_BUTTON_7 = 0d0;
            }

            asign_debug_button_function(SOULS_MEMORY.BOMB_ENABLED, DEBUG_MENU_ENTRY.BOMBS);
            asign_debug_button_function(SOULS_MEMORY.ISAAC_TEARS_ENABLED, DEBUG_MENU_ENTRY.ISAAC);
            asign_debug_button_function(SOULS_MEMORY.MARIO_YUMP_ENABLED, DEBUG_MENU_ENTRY.MARIO);
            asign_debug_button_function(SOULS_MEMORY.PUPPER_ENABLED, DEBUG_MENU_ENTRY.PUPPER);
            asign_debug_button_function(SOULS_MEMORY.ROCKET_JUMP_ENABLED, DEBUG_MENU_ENTRY.ROCKET_JUMP);
            asign_debug_button_function(SOULS_MEMORY.QUANTUM_JUMP_ENABLED, DEBUG_MENU_ENTRY.QUANTUM_JUMP);

            MEMORY.RING_MENU_DEBUG = arg[0x00];
        }
        @install()
        fun debug_menu_select(index) {
            nop();
        }

        @install()
        fun orb_helper_dialog() {
            if!(SOULS_MEMORY.ORB_USED) {
                dialog("I should bring the orb to the black smith.[B]", True);
            }
        }
        fun custom_reward(item:CUSTOM_ITEM, push_music) {
            if(item < 0xf000) {
                reward(item, push_music);
            } else if(item == CUSTOM_ITEM.SWORD_ORB) { // weapons
                subtext("Sword Orb");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ORB_SWORD++;

                orb_helper_dialog();
            } else if(item == CUSTOM_ITEM.SPEAR_ORB) {
                subtext("Spear Orb");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ORB_SPEAR++;

                orb_helper_dialog();
            } else if(item == CUSTOM_ITEM.AXE_ORB) {
                subtext("Axe Orb");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ORB_AXE++;

                orb_helper_dialog();
            
            } else if(item == CUSTOM_ITEM.CHEST_HEAVY) { // armor
                reward(CHEST_2_2, push_music);
            } else if(item == CUSTOM_ITEM.CHEST_RED) {
                reward(CHEST_2_3, push_music);
            } else if(item == CUSTOM_ITEM.HELM_ARCHAEOLOGY) {
                reward(HELM_4_3, push_music);

                dialog("[SLOW]What in the world is this? I hope someone can help me understand it.[B]");
            } else if(item == CUSTOM_ITEM.GLOVE_HACKER) {
                reward(GLOVE_4_1, push_music);

                dialog("[SLOW]You feel like hacker man.[B]");
            } else if(item == CUSTOM_ITEM.GLOVE_PIPBOY_NORTH_EAST) {
                reward(GLOVE_4_2, push_music);

                dialog("[SLOW]It has a glowing display that says `Pip-Boy´.[B]");
            } else if(item == CUSTOM_ITEM.GLOVE_PIPBOY_NORTH_WEST) {
                SOULS_MEMORY.CLEARANCE_VAULT_NORTH_EAST = True;
                reward(GLOVE_4_2, push_music);

                dialog("[SLOW]It has a glowing display that says `Pip-Boy´.[B]");
            } else if(item == CUSTOM_ITEM.SMITH_KEY) { // quest items
                subtext("Gained Smith Key");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.SMITH_KEY = True;
            } else if(item == CUSTOM_ITEM.BIG_MUSHROOM) {
                subtext("Gained Big Mushroom");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.BIG_MUSHROOM = True;
            } else if(item == CUSTOM_ITEM.ISAAC_LETTER) {
                subtext("Gained Letter to Maggy");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ISAAC_LETTER = True;
            } else if(item == CUSTOM_ITEM.ISAAC_WANTED_POSTER) {
                subtext("Gained Article `Wanted: Maggy´");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ISAAC_WANTED_POSTER = True;
            } else if(item == CUSTOM_ITEM.BUG_CATCHER_BROKEN) {
                subtext("Gained Broken Bug Catcher");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.BUG_CATCHER_BROKEN = True;
            } else if(item == CUSTOM_ITEM.BUG_CATCHER) {
                subtext("Gained Bug Catcher");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.BUG_CATCHER = True;
            } else if(item == CUSTOM_ITEM.ISAAC_BOMB) { // active abilties
                subtext("Unlocked Bombs");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.BOMB_ENABLED = True;
                update_debug_menu();

                dialog("[SLOW]Press [START] to drop a bomb.[B]");
            } else if(item == CUSTOM_ITEM.MARIO_YUMP) {
                subtext("Unlocked Yump");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.MARIO_YUMP_ENABLED = True;
                update_debug_menu();

                dialog("[SLOW]Press [START] to yump.[B]");
            } else if(item == CUSTOM_ITEM.ISAAC_TEARS) {
                subtext("Unlocked Tears");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ISAAC_TEARS_ENABLED = True;
            } else if(item == CUSTOM_ITEM.ROCKET_JUMP) {
                subtext("Unlocked Rocket Jump");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.ROCKET_JUMP_ENABLED = True;
                update_debug_menu();

                dialog("[SLOW]Press [START] to rocket jump.[B]");
            } else if(item == CUSTOM_ITEM.PUPPER_MODE) {
                subtext("Unlocked Pupper Mode");
                    
                fanfare_item(push_music);

                SOULS_MEMORY.PUPPER_ENABLED = True;
                update_debug_menu();

                dialog("[SLOW]Press [START] enable pupper mode.[B]");
            } else if(item == CUSTOM_ITEM.ZELDA_POWER_GLOVE) { // passive abilties
                if(MEMORY.GLOVE_2_3 == 0d0) {
                    subtext("Gained Power Gloves");
                    unlock(GLOVE_2_3);

                    fanfare_item(push_music);
                } else if(MEMORY.GLOVE_2_2 == 0d0) {
                    subtext("Gained Golden Power Gloves");
                    unlock(GLOVE_2_2);

                    fanfare_item(push_music);
                }
            } else if(item == CUSTOM_ITEM.TUNIC_GREEN) {
                subtext("Gained Green Tunic");
                unlock(CHEST_1_1);
                    
                fanfare_item(True, push_music);
            } else if(item == CUSTOM_ITEM.TUNIC_RED) {
                subtext("Gained Red Tunic");
                unlock(CHEST_2_3);
                    
                fanfare_item(True, push_music);
            } else if(item == CUSTOM_ITEM.ESTUS_SHARD) {
                subtext("Estus Shard");
                SOULS_MEMORY.ESTUS_SHARDS++;
                    
                fanfare_item(True, push_music);
            } else if(item == CUSTOM_ITEM.PICKAXE_HEAD) {
                subtext("Pickaxe Head");
                SOULS_MEMORY.PICKAXE_HEAD = True;

                fanfare_item(True, push_music);
                
                if!(SOULS_MEMORY.PICKAXE_SHAFT) {
                    dialog("[SLOW]Wait, only the head, without the shaft?[B]");
                }
            } else if(item == CUSTOM_ITEM.PICKAXE_HEAD) {
                subtext("Pickaxe Shaft");
                SOULS_MEMORY.PICKAXE_SHAFT = True;

                fanfare_item(True, push_music);
                
                if!(SOULS_MEMORY.PICKAXE_HEAD) {
                    dialog("[SLOW]Wait, only the shaft, without the head?[B]");
                }
            } else if(item == CUSTOM_ITEM.PICKAXE) {
                subtext("Pickaxe");
                SOULS_MEMORY.PICKAXE = True;

                fanfare_item(True, push_music);
            } else {
                subtext("Found Invalid Custom Item");
            }
        }
        @install()
        fun trade_custom_items(out_type:CUSTOM_ITEM, out_count, in_1_type:ITEM, in_1_count, in_2_type:ITEM, in_2_count, in_3_type:ITEM, in_3_count) {
            trade_items(out_type, out_count, in_1_type, in_1_count, in_2_type, in_2_count, in_3_type, in_3_count);

            if(CUSTOM_MEMORY.RETURN > 0d0) {
                if(out_type != ITEM.NO_ITEM) {
                    MEMORY.STRING_PARAMETER_1 = out_count;

                    if(out_type == CUSTOM_ITEM.AXE_ORB) {
                        SOULS_MEMORY.ORB_AXE += out_count;
                        subtext("Gained [MEM1] axe orbs");
                    } else {
                        MEMORY.STRING_PARAMETER_1 = out_type;
                        debug_subtext("unknown custom item #[MEM1]");
                    }
                }
            }
        }

        @install()
        fun souls_quest_progress() {
            SOULS_MEMORY.PROGRESS_COUNTER++;
        }

        @install()
        fun _souls_boss_defeated() {
            control(NONE);

            attribute(BOY, INVINCIBLE_TEMP, True);
            attribute(DOG, INVINCIBLE_TEMP, True);

            // if!(ITEM.NO_ITEM) {
            //     reward(reward_item);
            // }

            SOULS_MEMORY.BOSSES_DEFEATED_COUNTER++;
            SOULS_MEMORY.PROGRESS_COUNTER++;

            subtext("Enemy Felled");

            fanfare_boss();

            if(SOULS_MEMORY.BOSSES_DEFEATED_COUNTER >= 0d02) {
                if!(FLAG.JAGUAR_RING) {
                    reward(JAGUAR_RING);
                }
            }
        }
        fun souls_boss_defeated(flag:SOULS_MEMORY, reward_item:SOULS_MEMORY) {
            if(flag is Memory) {
                set(flag);
            }

            _souls_boss_defeated();

            if(reward_item is Function) {
                reward_item();
            } else {
                if(reward_item != ITEM.NO_ITEM) {
                    if(reward_item < 0xf000) {
                        reward(reward_item);
                    } else {
                        custom_reward(reward_item, True);
                    }
                }
            }

            // subtext("Enemy Felled");

            pop_music();

            attribute(BOY, INVINCIBLE_TEMP, False);
            attribute(DOG, INVINCIBLE_TEMP, False);
            control(BOTH);
        }

        fun fog_wall_outside(condition:SOULS_MEMORY, exit_direction:DIRECTION) {
            if(SOULS_MEMORY.WITH_FOG_WALL) {
                if(condition) {
                    question("[SLOW]A wall of white light[CHOICE]traverse…[CHOICE]leave…");

                    if(MEMORY.QUESTION_ANSWER != 0d0) {
                        error_walk_back(exit_direction);
                        end();
                    }
                }
            }
        }
        fun fog_wall_inside(condition:SOULS_MEMORY, exit_direction:DIRECTION) {
            if(SOULS_MEMORY.WITH_FOG_WALL) {
                if(condition) {
                    subtext("Fog wall active…");

                    if(SOULS_MEMORY.WITH_FOGWALL_WALKBACK) {
                        error_walk_back(exit_direction);
                    }

                    end();
                }
            }
        }

        fun _update_armor_effects_hit_bonus(armor_slot:CUSTOM_MEMORY, armor:ARMOR_STATS, helper_flag:SOULS_MEMORY, bonus) {
            if(armor_slot == armor) {
                if!(helper_flag) {
                    helper_flag = True;

                    <BOY>[BOOST_HIT] += bonus;
                }
            } else {
                if(helper_flag) {
                    helper_flag = False;

                    <BOY>[BOOST_HIT] -= bonus;
                }
            }
        }
        fun _update_armor_effects_no_running(armor_slot:CUSTOM_MEMORY, armor:ARMOR_STATS, helper_flag:SOULS_MEMORY) {
            if(armor_slot == armor) {
                increment_no_running(helper_flag);
            } else {
                decrement_no_running(helper_flag);
            }
        }
        @install()
        fun update_armor_effects() {
            // BOOST_HIT = CHEST_1_1, HELM_1_1, GLOVE_1_1
            // POWER = GLOVE_2_3 (+1), GLOVE_2_2 (+2)
            // fall damage = GLOVE_3_2
            // heat = CHEST_2_3
            // thorne = GLOVE_1_3
            // NO_RUNNING = CHEST_2_2
            // pip boy = GLOVE_4_2

            _update_armor_effects_hit_bonus(CURRENT_ARMOR_CHEST, CHEST_1_1, HIT_BONUS_CHEST, 0d15);
            _update_armor_effects_hit_bonus(CURRENT_ARMOR_HELM, HELM_1_1, HIT_BONUS_HELM, 0d15);
            _update_armor_effects_hit_bonus(CURRENT_ARMOR_GLOVE, GLOVE_1_1, HIT_BONUS_ARMLET, 0d15);

            _update_armor_effects_no_running(CURRENT_ARMOR_CHEST, CHEST_2_2, NO_RUNNING_CHEST);
        }

        @install()
        @async()
        fun bonfire_wakeup(offset_boy_x, offset_boy_y, offset_dog_x, offset_dog_y) {
            if!(SOULS_MEMORY.BONFIRE_TELEPORT_REQUIRED) {
                // if(SOULS_MEMORY.BONFIRE_X == 0d0 && SOULS_MEMORY.BONFIRE_Y == 0d0 && SOULS_MEMORY.BONFIRE_Z == 0d0) {
                    <BOY>[X] += signed arg[0x00];
                    <BOY>[Y] += signed arg[0x02];

                    <DOG>[X] += signed arg[0x04];
                    <DOG>[Y] += signed arg[0x06];
                // }
            }

            attribute(BOY, INVINCIBLE_TEMP, True);
            attribute(DOG, INVINCIBLE_TEMP, True);

            animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_SLEEP);

            animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);

            animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);
            sleep(0d30);
            animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);
            sleep(0d40);

            animate(BOY, ONCE, ANIMATION_BOY.KNEEL);

            sleep(0d20);
            animate(DOG, ONCE, DEFAULT);

            attribute(BOY, INVINCIBLE_TEMP, False);
            attribute(DOG, INVINCIBLE_TEMP, False);
        }

        fun dust_unreachable(x, y) {
            SOULS_MEMORY.DUST_UNREACHABLE = True;

            SOULS_MEMORY.DUST_DROP_X = x * 0x0008;
            SOULS_MEMORY.DUST_DROP_Y = y * 0x0008;
        }

        fun refresh_flask() {
            MEMORY.PETAL = SOULS_MEMORY.ESTUS_CHARGES;
        }

        @install()
        fun dust_loot() {
            SOULS_MEMORY.DUST_UNREACHABLE = False;

            SOULS_MEMORY.DUST_DROP_MAP = 0xffff;
            SOULS_MEMORY.DUST_DROP_VARIANT = 0xffff;

            // attach_script(SCRIPT_OWNER, LOOT, 0x172b);

            // subtext("Reclaimed souls");

            currency_convert(0x01, CURRENCY.JEWELES, 0x01, CURRENCY.TALONS);

            // <0x2391> = 0x0000;
            // <0x2395> = 0x0000;
            // call_id(0x3d);
            animate(BOY, ONCE, ANIMATION_BOY.LOOT);

            destroy(SOULS_MEMORY.DUST_ENTITY);

            // sleep(0x80);

            if!(CUSTOM_FLAG.NO_CURRENCY_DISPLAY) {
                show_currency(True);
                sleep(0x40);
                show_currency(False);
            }
        }

        fun eternal_dust(x, y, callback) {
            add_enemy(ENEMY.BEE, x, y);
            attach_script(LAST_ENTITY, DEATH, reference(@install() {
                animate_eternal_dust();
            }));
            
            attribute(LAST_ENTITY, MUTE, True);
            damage(LAST_ENTITY, 0d999, False);
            yield();
            attach_script(LAST_ENTITY, B, callback);
        }

        @install()
        fun dust_drop() {
            SOULS_MEMORY.DUST_UNREACHABLE = False;

            // subtext("Souls in reach...");

            attach_script(SCRIPT_OWNER, B, reference(dust_loot));

            animate_eternal_dust();
        }

        @install()
        fun return_to_bonfire() {
            refresh_flask();

            // SOULS_MEMORY.BONFIRE_TELEPORT_REQUIRED = True;

            if(SOULS_MEMORY.BONFIRE_MAP == MAP.CROSSING) { // center
                map_transition(inbetwixx, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.BLIMP_EXTERIOR) { // east
                map_transition(east_crossing, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.PIPEMAZE_ROOMS) {
                map_transition(pipe_entrance, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.NOBILIA_SQUARE) {
                map_transition(town_center, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.DARK_FOREST) { // west
                map_transition(basement_0_start, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.STERLING) {
                map_transition(volcano_tower, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.FIREPIT_JUNGLE) { // south
                map_transition(jungle_firepit, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.VOLCANO_ROOMS) {
                map_transition(bugmuck_cave_1, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.HALLS_NE) {
                map_transition(desert_temple_main, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.WELL) { // altus
                map_transition(well, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP == MAP.CHESSBOARD_STAIRS) {
                map_transition(stairs, bonfire, NONE);
            } else if((SOULS_MEMORY.BONFIRE_MAP == MAP.FIREPIT_NOBILIA) && (SOULS_MEMORY.BONFIRE_VARIANT == 0d0)) {
                map_transition(castle_fire_pit, bonfire, NONE);
            } else if((SOULS_MEMORY.BONFIRE_MAP == MAP.FIREPIT_NOBILIA) && (SOULS_MEMORY.BONFIRE_VARIANT == 0d1)) {
                map_transition(temple_underground_firepit, bonfire, NONE);
            } else if(SOULS_MEMORY.BONFIRE_MAP != 0x0000){
                fade_in();
                sleep(0d30);
                
                MEMORY.STRING_PARAMETER_1 = SOULS_MEMORY.BONFIRE_MAP;

                subtext("Game could not find bonfire map #[MEM1]");
                sleep(0d200);
            }

            map_transition(inbetwixx, center, NONE);
        }

        fun show_credits() {
            control(NONE);
            available(NONE);

            outro_stats(SOULS_MEMORY.PROGRESS_COUNTER, SOULS_MEMORY.BOSSES_DEFEATED_COUNTER, SOULS_MEMORY.COLLECTIBLE_COUNTER);
            
            outro_text_box("Created by", "[LF][LF]twitch.tv/ps3003");

            outro_text_box("Shoutouts Devs/Designers", "[LF][LF]twitch.tv/Black_Sliver[LF](evermizer.com)[LF][LF]twitch.tv/skarsnikus[LF](Evermore hacking)[LF][LF]twitch.tv/BarbarousKing[LF](Lunar Magic Streams)[LF][LF]twitch.tv/Dennsen86[LF](Lunar Magic Streams)");

            outro_text_box("Shoutouts Players", "[LF][LF]twitch.tv/its_cliqz[LF][LF]twitch.tv/solarcell007");

            outro_text_box("", "[LF][LF]The End", True);

            sleep(0d3600);

            return_to_bonfire();
        }

        @install()
        fun wings_used() {
            return_to_bonfire();
        }

        fun refresh_both(with_animation) {
            if(False) {
                // TODO: set confound timer to 30s to avaid perma confound
                if((<BOY>[STATUS_ID_1] & 0xff) == STATUS_ID.CONFOUND) {
                    <BOY>[STATUS_TIMER_1] = 0d1800;
                } else if((<BOY>[STATUS_ID_2] & 0xff) == STATUS_ID.CONFOUND) {
                    <BOY>[STATUS_TIMER_2] = 0d1800;
                } else if((<BOY>[STATUS_ID_3] & 0xff) == STATUS_ID.CONFOUND) {
                    <BOY>[STATUS_TIMER_3] = 0d1800;
                } else if((<BOY>[STATUS_ID_4] & 0xff) == STATUS_ID.CONFOUND) {
                    <BOY>[STATUS_TIMER_4] = 0d1800;
                }

                if((<DOG>[STATUS_ID_1] & 0xff) == STATUS_ID.CONFOUND) {
                    <DOG>[STATUS_TIMER_1] = 0d1800;
                } else if((<DOG>[STATUS_ID_2] & 0xff) == STATUS_ID.CONFOUND) {
                    <DOG>[STATUS_TIMER_2] = 0d1800;
                } else if((<DOG>[STATUS_ID_3] & 0xff) == STATUS_ID.CONFOUND) {
                    <DOG>[STATUS_TIMER_3] = 0d1800;
                } else if((<DOG>[STATUS_ID_4] & 0xff) == STATUS_ID.CONFOUND) {
                    <DOG>[STATUS_TIMER_4] = 0d1800;
                }
            } else {
                <BOY>[FLAGS_5] = 0x0000;
                <DOG>[FLAGS_5] = 0x0000;
            }

            yield();

            cure();
            full_heal(BOTH, with_animation);
        }

        fun _boy_death() {
            if(<ACTIVE>[HP] > 0d0) {
                if(<SCRIPT_OWNER> == <BOY>) {
                    CUSTOM_FLAG.START_MARIO_FIREFLOWER = False;

                    if(CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_1_3) {
                        arg[0x10] = <SCRIPT_OWNER>[DAMAGE_SOURCE];
                        arg[0x12] = !randrange(0d5);

                        if(arg[0x12] && arg[0x10]) {
                            damage(arg[0x10], 0d10, True);
                        }
                    }
                }

                if(<SCRIPT_OWNER>[DAMAGE_SOURCE] && SOULS_MEMORY.SLOW_ON_HIT) {
                    movement_amplification(<BOY>, 0d180, 0d1, True);
                }

                end();
            }

            if(<SCRIPT_OWNER>[PIXIE_DUST] > 0d0) {
                if!(SOULS_MEMORY.DUST_UNREACHABLE) {
                    while(<SCRIPT_OWNER>[HP] <= 0d0) {
                        yield();
                    }
                    attach_script(BOY, DAMAGE_DEATH, reference(boy_death));
                    end();
                } else {
                    <SCRIPT_OWNER>[PIXIE_DUST] = False;
                }
            }

            currency_get(CURRENCY.CREDITS, 0d1);

            control(NONE);
            enable_subtext(False);
            attribute(BOY, INVINCIBLE_TEMP, True);
            attribute(DOG, INVINCIBLE_TEMP, True);
        }
        @install()
        fun boy_death() {
            _boy_death();

            yield();
            
            animate(BOY, ONCE, ANIMATION_ENEMY.DUST);
            animate(DOG, ONCE, ANIMATION_ENEMY.DUST);

            if(SOULS_MEMORY.WITH_SOULS_ON_DEATH) {
                if!(CUSTOM_FLAG.NO_CURRENCY_DISPLAY) {
                    show_currency(True);
                }

                sleep(0d120);
                
                currency_convert(0d1, JEWELES, 0d1, GOLD_COINS);
                currency_convert(0d1, TALONS, 0d1, JEWELES);

                if((SOULS_MEMORY.DUST_DROP_MAP == MEMORY.CURRENT_MAP) && (SOULS_MEMORY.DUST_DROP_VARIANT == MEMORY.CURRENT_MAP_VARIANT)) {
                    destroy(SOULS_MEMORY.DUST_ENTITY);
                }

                if!(SOULS_MEMORY.DUST_UNREACHABLE) {
                    SOULS_MEMORY.DUST_DROP_X = <SCRIPT_OWNER>[X];
                    SOULS_MEMORY.DUST_DROP_Y = <SCRIPT_OWNER>[Y];
                }
                unset(SOULS_MEMORY.DUST_UNREACHABLE);

                // <0x2503> = MEMORY.CURRENT_MAP;
                SOULS_MEMORY.DUST_DROP_MAP = MEMORY.CURRENT_MAP;
                SOULS_MEMORY.DUST_DROP_VARIANT = MEMORY.CURRENT_MAP_VARIANT;

                if!(CUSTOM_FLAG.NO_CURRENCY_DISPLAY) {
                    show_currency(True);
                }
            }

            sleep(0d160);

            fade_out();

            show_currency(False);
            yield();

            sleep(0d80);

            refresh_both(False);

            return_to_bonfire();

            control(BOTH);
        }

        @install()
        fun bonfire_triggered() {
            guard_boy_damage();

            if(True) {
                SOULS_MEMORY.BONFIRE_X = <ACTIVE>[X];
                SOULS_MEMORY.BONFIRE_Y = <ACTIVE>[Y];
            }

            if(SOULS_MEMORY.WINGS_BLOCKED) {
                unset(SOULS_MEMORY.WINGS_BLOCKED);
                special_script(WINGS, reference(wings_used));
            }

            // animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_WATER);
            
            refresh_flask();
            refresh_both(True);

            if!(SOULS_MEMORY.WITH_SAVESTATE_SAVE) {
                question("[SLOW]Bonfire:[CHOICE]Return to shrine.[CHOICE]Attune Spell.");
            } else {
                question("[SLOW]Bonfire:[CHOICE]Return to shrine.[CHOICE]Attune Spell.[CHOICE]Save.");
            }

            if(MEMORY.QUESTION_ANSWER == 0d00) {
                map_transition(shrine, crash, NONE);
            } else if(MEMORY.QUESTION_ANSWER == 0d01) {
                select_alchemy();
            } else if(MEMORY.QUESTION_ANSWER == 0d02) {
                if(MEMORY.CURRENT_MAP == MAP.CROSSING) { // center
                    save("Inbetwixx");
                } else if(MEMORY.CURRENT_MAP == MAP.BLIMP_EXTERIOR) { // east
                    save("East Inbetwixx");
                } else if(MEMORY.CURRENT_MAP == MAP.PIPEMAZE_ROOMS) {
                    save("Sewers");
                } else if(MEMORY.CURRENT_MAP == MAP.NOBILIA_SQUARE) {
                    save("Town Center");
                } else if((MEMORY.CURRENT_MAP == MAP.FIREPIT_NOBILIA) && (MEMORY.CURRENT_MAP_VARIANT == 0d1)) {
                    save("Temple Lvl.2");
                } else if(MEMORY.CURRENT_MAP == MAP.DARK_FOREST) { // west
                    save("Basement Lvl.1");
                } else if(MEMORY.CURRENT_MAP == MAP.STERLING) {
                    save("Volcano Tower");
                } else if(MEMORY.CURRENT_MAP == MAP.WELL) { // altus
                    save("Plateau");
                } else if(MEMORY.CURRENT_MAP == MAP.CHESSBOARD_STAIRS) {
                    save("Stairs");
                } else if((MEMORY.CURRENT_MAP == MAP.FIREPIT_NOBILIA) && (MEMORY.CURRENT_MAP_VARIANT == 0d0)) {
                    save("Castle");
                } else if(MEMORY.CURRENT_MAP == MAP.FIREPIT_JUNGLE) { // south
                    save("Southern Jungle");
                } else if(MEMORY.CURRENT_MAP == MAP.VOLCANO_ROOMS) {
                    save("Bugmuck");
                } else if(MEMORY.CURRENT_MAP == MAP.HALLS_NE) {
                    save("Desert Temple");
                } else if(MEMORY.CURRENT_MAP != 0x0000){
                    subtext("Game could not find bonfire #[MEM1]");
                }

                // TODO
            }

            // animate(BOY, ONCE, DEFAULT);
        }

        fun replace_bonfire(entity, trigger) {
            _add_enemy(LANTERN_LIGHT_RED, entity[X], entity[Y], INACTIVE);
            <LAST_ENTITY>[Z_LEVEL] = entity[Z_LEVEL];
            attach_script(LAST_ENTITY, DAMAGE, trigger);

            attribute(LAST_ENTITY, ROOT, True);
            <LAST_ENTITY>[HP] = SYSTEM.HP_MAX;

            destroy(entity);
        }

        @install()
        fun bonfire_bond() {
            guard_boy_damage();

            // replace_bonfire(<SCRIPT_OWNER>, reference(bonfire_triggered));

            if(True) {
                SOULS_MEMORY.BONFIRE_X = <ACTIVE>[X];
                SOULS_MEMORY.BONFIRE_Y = <ACTIVE>[Y];
            }

            SOULS_MEMORY.BONFIRE_MAP = MEMORY.CURRENT_MAP;
            SOULS_MEMORY.BONFIRE_VARIANT = MEMORY.CURRENT_MAP_VARIANT;

            bonfire_triggered();
        }

        @install()
        fun shrine_intro() {
            control(NONE);

            sound(TESLA);

            if(False) {
                add_enemy(FIRE_EYES, 0d0, 0d0, INACTIVE_INVISIBLE);
                yield();
            }
            _add_placeholder(FIRE_EYES_CAST, <BOY>[X], <BOY>[Y] - 0d20);
            attach_to_script(LAST_ENTITY);

            wait(LAST_ENTITY);

            face_target(BOY, SCRIPT_OWNER);
            yield();

            map_transition(shrine, crash, NONE);
        }

        @install()
        fun bonfire_lit() {
            guard_boy_damage();

            if(MEMORY.CURRENT_MAP == MAP.CROSSING) { // center
                SOULS_MEMORY.BONFIRE_INBETWIXX = True;
            } else if(MEMORY.CURRENT_MAP == MAP.BLIMP_EXTERIOR) { // east
                SOULS_MEMORY.BONFIRE_EAST_CROSSING = True;
            } else if(MEMORY.CURRENT_MAP == MAP.PIPEMAZE_ROOMS) {
                SOULS_MEMORY.BONFIRE_PIPES = True;
            } else if(MEMORY.CURRENT_MAP == MAP.NOBILIA_SQUARE) {
                SOULS_MEMORY.BONFIRE_TOWN_CENTER = True;
            } else if(MEMORY.CURRENT_MAP == MAP.DARK_FOREST) { // west
                SOULS_MEMORY.BONFIRE_ISAAC_DUNGEON = True;
            } else if(MEMORY.CURRENT_MAP == MAP.STERLING) {
                SOULS_MEMORY.BONFIRE_VOLCANO_TOWER = True;
            } else if(MEMORY.CURRENT_MAP == MAP.WELL) {
                SOULS_MEMORY.BONFIRE_ALTUS_WELL = True;
            } else if(MEMORY.CURRENT_MAP == MAP.CHESSBOARD_STAIRS) {
                SOULS_MEMORY.BONFIRE_ALTUS_STAIRS = True;
            } else if(MEMORY.CURRENT_MAP == MAP.VOLCANO_ROOMS) {
                SOULS_MEMORY.BONFIRE_BUG = True;
            } else if(MEMORY.CURRENT_MAP == MAP.HALLS_NE) {
                SOULS_MEMORY.BONFIRE_DESERT = True;
            } else if(MEMORY.CURRENT_MAP != 0x0000){
                subtext("Game could not find bonfire #[MEM1]");
            }

            replace_bonfire(<SCRIPT_OWNER>, reference(bonfire_bond));

            subtext("Bonfire Lit");

            if(SOULS_MEMORY.DEBUG && SOULS_MEMORY.WITH_SHRINE_INTRO) {
                if!(SOULS_MEMORY.BONFIRE_FIRST_TRIGGER) {
                    SOULS_MEMORY.BONFIRE_FIRST_TRIGGER = True;

                    shrine_intro();
                }
            } else {
                SOULS_MEMORY.BONFIRE_FIRST_TRIGGER = True;
            }
        }

        fun bonfire(x, y, flag) {
            // add_enemy(LANTERN_LIGHT, x, y, FLAG_ENEMY.INACTIVE_IMORTAL);
            // attach_script(LAST_ENTITY, B, 0x181e);
            // entity_script_controlled(LAST_ENTITY);

            if(flag) {
                if((SOULS_MEMORY.BONFIRE_MAP == MEMORY.CURRENT_MAP) && (SOULS_MEMORY.BONFIRE_VARIANT == MEMORY.CURRENT_MAP_VARIANT)) {
                    add_enemy(LANTERN_LIGHT_RED, x, y, INACTIVE);
                    attach_script(LAST_ENTITY, DAMAGE, reference(bonfire_triggered));
                } else {
                    add_enemy(LANTERN_LIGHT_RED, x, y, INACTIVE);
                    attach_script(LAST_ENTITY, DAMAGE, reference(bonfire_bond));
                }
            } else {
                add_enemy(LANTERN_LIGHT, x, y, INACTIVE);
                attach_script(LAST_ENTITY, DAMAGE, reference(bonfire_lit));
            }
            
            attribute(LAST_ENTITY, ROOT, True);
            <LAST_ENTITY>[HP] = SYSTEM.HP_MAX;
        }

        fun choose_starting_class() {
            question("Starting Class:[CHOICE]Warrior[CHOICE]Explorer[CHOICE]Alchemist[CHOICE]Cleric", 0d05);

            if(MEMORY.QUESTION_ANSWER == 0d0) { // warrior
                subtext("todo");
            } else if(MEMORY.QUESTION_ANSWER == 0d1) { // explorer
                subtext("todo");
            } else if(MEMORY.QUESTION_ANSWER == 0d2) { // alchemist
                subtext("todo");
            } else if(MEMORY.QUESTION_ANSWER == 0d3) { // cleric
                subtext("todo");
            }
        }
        fun choose_starting_item() {
            question("Starting Item:[CHOICE]Chocobo Egg[CHOICE]Nectar[CHOICE]Wings[CHOICE]Queen's Key", 0d05);

            if(MEMORY.QUESTION_ANSWER == 0d0) { // chocobo egg
                set(FLAG.CHOCOBO_EGG);
            } else if(MEMORY.QUESTION_ANSWER == 0d1) { // nectar
                MEMORY.NECTAR++;
            } else if(MEMORY.QUESTION_ANSWER == 0d2) { // wings
                MEMORY.WINGS++;
            } else if(MEMORY.QUESTION_ANSWER == 0d3) {// queens key
                set(FLAG.QUEENS_KEY);
            }
        }

        fun add_frippo_switch(x, y, trigger) {
            add_enemy(FRIPPO, x, y, INACTIVE);
            <LAST_ENTITY>[HP] = 0d1;

            attach_script(LAST_ENTITY, DEATH, trigger);
        }

        fun add_bee(x, y, collected_trigger) {
            add_enemy(BEE, x, y);
            attach_script(LAST_ENTITY, B, collected_trigger);
        }
        fun bee_collected(flag) {
            if(<ACTIVE>[Z_LEVEL] != <SCRIPT_OWNER>[Z_LEVEL]) {
                end();
            }

            if(
                (!SOULS_MEMORY.BUG_CATCHER)
                || (MEMORY.CURRENT_WEAPON != WEAPON_INDEX.SWORD_1)
                || (<ACTIVE> == <DOG>)
            ) {
                damage(ACTIVE, 0d5, True);

                end();
            }

            set(flag);

            control(SCRIPT_OWNER, True);

            fake_b();
            wait(BOY);
            fake_loot();

            SOULS_MEMORY.PROGRESS_COUNTER++;
            SOULS_MEMORY.BEES++;
            
            destroy(SCRIPT_OWNER);

            MEMORY.STRING_PARAMETER_1 = SOULS_MEMORY.BEES;
            subtext("Bees: [MEM1]");
        }

        fun collectible_collected() {
            fake_loot();

            SOULS_MEMORY.PROGRESS_COUNTER++;
            SOULS_MEMORY.COLLECTIBLE_COUNTER++;

            destroy(SCRIPT_OWNER);

            MEMORY.STRING_PARAMETER_1 = SOULS_MEMORY.COLLECTIBLE_COUNTER;
            subtext("Collectibles: [MEM1]");
        }
        fun add_collectible(type, x, y, collected_trigger) {
            if(type == 0d0) {
                add_placeholder(SCEPTER, x, y);
            } else if(type == 0d1) {
                add_placeholder(CROWN, x, y);
            }
            attach_script(LAST_ENTITY, B, collected_trigger);
        }

        fun player_message(x, y, trigger) {
            add_placeholder(LEAVES_FALLING_2, x, y, ONCE_FREEZE);

            attach_script(LAST_ENTITY, B, trigger);
        }

        fun player_message_triggered() {
            fake_loot();

            // destroy(SCRIPT_OWNER);
        }

        group player_messages() {
            @install()
            fun message_try_rolling() {
                player_message_triggered();

                subtext("try rolling");
            }
        };

        fun add_debug_entity(x, y, debug_triggered) {
            if(SOULS_MEMORY.WITH_DEBUG_ENTITIES) {
                if(FLAG.DEBUG) {
                    add_placeholder(DOVES_1, x, y);
                    attach_script(LAST_ENTITY, B, debug_triggered);
                }
            }
        }

        fun init_weather(night, rain) {
            if(SOULS_MEMORY.WITH_WEATHER) {
                if(SOULS_MEMORY.WITH_COLOR_FILTER) {
                    if(night) {
                        sfx_effect(NIGHT, True);
                    }
                }
                if(rain) {
                    sfx_effect(RAIN, True);
                }
            }
        }

        @install()
        fun start_feature_selected(index) {
            if(index == 0d1) { // TODO: "&& (FLAG.ENERGY_CORE)" doesn't work anymore
                if(FLAG.ENERGY_CORE) {
                    drop_bomb(False);
                } else {
                    drop_bomb(True);
                }
            } else if(index == 0d2) {
                _isaac_tear(True);
            } else if(index == 0d3) {
                if(FLAG.ENERGY_CORE) {
                    mario_yump(False);
                } else {
                    mario_yump(True);
                }
            } else if(index == 0d4) {
                MEMORY.DOG_WRITE = DOG.PUPPER;
            } else if(index == 0d5) {
                rocket_jump();
            } else if(index == 0d6) {
                quantum_jump();
            }
        }

        @install()
        @async()
        fun gourd_trap(object_id, entity, x, y) {
            object[object_id] = 0x01;

            // add_placeholder(SANDPIT_OUT, 0d96, 0d95);
            // add_placeholder(0x7e, 0d96, 0d95);

            x = x * 0x08;
            y = y * 0x08;

            sleep(0x10);

            while(True) {
                arg[0x10] = entity[X];
                arg[0x12] = entity[Y];
                arg[0x14] = x;
                arg[0x16] = y;

                if(arg[0x10] < arg[0x14]) {
                    arg[0x18] = arg[0x14] - arg[0x10];
                } else {
                    arg[0x18] = arg[0x10] - arg[0x14];
                }

                if(arg[0x12] < arg[0x16]) {
                    arg[0x1a] = arg[0x16] - arg[0x12];
                } else {
                    arg[0x1a] = arg[0x12] - arg[0x16];
                }

                if(arg[0x18] < arg[0x1a]) {
                    arg[0x1c] = arg[0x1a] - arg[0x18];
                } else {
                    arg[0x1c] = arg[0x18] - arg[0x1a];
                }

                if((arg[0x18] > 0d70) || (arg[0x1a] > 0d70)) {
                    object[object_id] = 0x00;
                    end();
                } else if((arg[0x18] < 0d5) && (arg[0x1a] < 0d5)) {
                    control(NONE);
                    unset(SOULS_MEMORY.WINGS_BLOCKED);

                    if(entity == <BOY>) {
                        animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SWIRL_ENTER);
                    } else {
                        animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_SWIRL_ENTER);
                    }

                    // subtext("todo");
                    sleep(0d30);
                    entity[GENERAL_PURPOSE] = 0x01;
                    end();
                }

                if(arg[0x1c] <= 0d5) {
                    if((arg[0x18] > 0x02) && (entity[X] > x)) {
                        entity[X] -= 0x02;
                    } else if((arg[0x18] > 0x02) && (entity[X] < x)) {
                        entity[X] += 0x02;
                    }

                    if((arg[0x1a] > 0x02) && (entity[Y] < y)) {
                        entity[Y] += 0x02;
                    } else if((arg[0x1a] > 0x02) && (entity[Y] > y)) {
                        entity[Y] -= 0x02;
                    }
                } else if(arg[0x18] > arg[0x1a]) {
                    if((arg[0x18] > 0x02) && (entity[X] > x)) {
                        entity[X] -= 0x02;
                    } else if((arg[0x18] > 0x02) && (entity[X] < x)) {
                        entity[X] += 0x02;
                    }
                } else {
                    if((arg[0x1a] > 0x02) && (entity[Y] < y)) {
                        entity[Y] += 0x02;
                    } else if((arg[0x1a] > 0x02) && (entity[Y] > y)) {
                        entity[Y] -= 0x02;
                    }
                }

                yield();
            }
        }

        @install()
        @async()
        fun add_palette_donor(entity, mode) {
            if(mode == 0d0) {
                add_enemy(BOY_BLACK, 0d0, 0d0, INVISBLE_INVINCIBLE_INACTIVE);
                attach_to_script(LAST_ENTITY);
            } else if(mode == 0d1) {
                attach_to_script(DOG);
            }

            arg[0x10] = entity[PALETTE];

            while(entity[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                entity[PALETTE] = <SCRIPT_OWNER>[PALETTE];
                
                sleep(0d5);
            }

            entity[PALETTE] = arg[0x10];

            if(mode == 0d0) {
                destroy(SCRIPT_OWNER);
            } 
        }
        fun guard_branch_lady(flag) {
            if(<SCRIPT_OWNER>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                if(MEMORY.SPOON > 0d0) {
                    conversation({
                        conversation_question("[SLOW]Use Spoon[CHOICE]yes…[CHOICE]no…");

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            MEMORY.SPOON--;

                            control(SCRIPT_OWNER, False);
                            attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
                        }
                    }, NONE);
                } else {
                    conversation({
                        dialog("[SLOW]…[B]");
                    }, NONE);
                }

                if!(<SCRIPT_OWNER>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                    flag = True;
                }

                end();
            }
        }
        fun branch_lady(enemy:ENEMY, x, y, direction:DIRECTION, id) {
            add_enemy(enemy, x, y, INACTIVE);
            attribute(LAST_ENTITY, INVINCIBLE_TEMP, True);

            add_palette_donor(<LAST_ENTITY>, 0d1);

            face(LAST_ENTITY, direction);
            attach_script(LAST_ENTITY, B, id);
        }

        fun guard_levitate_stone(required_strength, callback_error) {
            if(CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_2_3) {
                arg[0x0e] = 0d1;
            } else if(CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_2_2) {
                arg[0x0e] = 0d2;
            }
            
            if(<BOY>[BOOST_ATTACK] > 0d0) {
                arg[0x0e]++;
            }

            if(SYSTEM.WITH_DEBUG_START) {
                debug_memory(arg[0x0e], required_strength, <BOY>[BOOST_ATTACK]);
            }

            if(arg[0x0e] < required_strength) {
                if((MEMORY.GLOVE_2_2 > 0d0) || (MEMORY.GLOVE_2_3 > 0d0) || (FLAG.ATLAS)) {
                    subtext("(Too heavy)");
                }

                if(callback_error !is None) {
                    callback_error();
                } else {
                    fake_b();
                }
                end();
            }

            zelda_power_glove(arg[0x0e]);

            attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);
        }
        fun add_levitate_stone(x, y, trigger) {
            add_enemy(STONE, x, y, STONE_LEVITATE);
            <LAST_ENTITY>[GENERAL_PURPOSE] = 0x0000;
            
            attach_script(LAST_ENTITY, B, trigger);
        }

        fun add_heavy_stone(x, y) {
            add_enemy(STONE_ROUND, x, y);
            <LAST_ENTITY>[GENERAL_PURPOSE] = 0x0000;
            
            attach_script(LAST_ENTITY, B, reference(@install() {
                guard_levitate_stone(0d2);
            }));
        }

        group transforming_owls() {
            fun transform_owls(entity_1, entity_2) {
                control(entity_1, True);
                control(entity_2, True);

                destroy(entity_1);

                attribute(entity_2, INVINCIBLE, True);

                animate(entity_2, ONCE_FREEZE, ANIMATION_ENEMY.BLACK_OWL_FUSION);

                wait(entity_2);

                destroy(entity_2);
            }

            fun add_transforming_owl(x, y, active) {
                add_enemy(OWL_BLACK, x, y);
                attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                    heal(SCRIPT_OWNER, 0d00, False);
                    yield();
                    damage(SCRIPT_OWNER, 0d00, True);

                    if(<SCRIPT_OWNER>[GENERAL_PURPOSE]) {
                        sleep(0d50);
                        animate(SCRIPT_OWNER, ONCE_FREEZE, SLASH_2);
                    }
                }));

                if!(active) {
                    control(LAST_ENTITY, True);
                    <LAST_ENTITY>[GENERAL_PURPOSE] = True;
                    animate(LAST_ENTITY, ONCE_FREEZE, SLASH_2);
                    face(LAST_ENTITY, SOUTH);
                }
            }
            fun add_transforming_owls(x_1, y_1, active_1, x_2, y_2, active_2, callback2) {
                add_transforming_owl(x_1, y_1, active_1);
                arg[0x0e] = <LAST_ENTITY>;

                add_transforming_owl(x_2, y_2, active_2);
                arg[0x0c] = <LAST_ENTITY>;

                while(alive(arg[0x0e])) {
                    check_range_old(arg[0x0e], arg[0x0c], 0d20, 0d20, callback2);
                    yield();
                }
            }
        };

        group dog_arena() {
            fun prepare_dog_arena(dog:DOG) {
                CUSTOM_FLAG.NO_BOY = True;
                CUSTOM_FLAG.WITH_DOG = True;

                attach_script(DOG, DEATH, reference(boy_death));
                
                if(dog !is None) {
                    CUSTOM_MEMORY.CURRENT_DOG = dog;
                }
            }
        };

        group helper_market() {
            enum MARKET {
                DEBUG = False,

                START = 0x7fff,
                END = 0xffff,
            }

            @install()
            fun chicken_triggered() {
                CUSTOM_MEMORY.CHICKEN_TAUNT_COUNTER++;

                if(CUSTOM_MEMORY.CHICKEN_TAUNT_COUNTER == 0d100) {
                    chickens_taunted();
                }

                // TODO: sound
            }

            @install()
            fun goat_triggered() {
                nop();

                // TODO: sound
            }

            @install()
            fun guard_triggered() {
                MEMORY.STRING_PARAMETER_1 = time[0d0];

                if(time[0d0] < MARKET.START) {
                    MEMORY.STRING_PARAMETER_2 = ((MARKET.START - time[0d0]) / 0d60) / 0d60;

                    if(MEMORY.STRING_PARAMETER_2 > 0d1) {
                        dialog("[SLOW]Next market will be in [MEM2] minutes.[B]");
                    } else {
                        dialog("[SLOW]Next market will be soon.[B]");
                    }
                } else {
                    MEMORY.STRING_PARAMETER_2 = ((MARKET.END - time[0d0]) / 0d60) / 0d60;

                    if(MEMORY.STRING_PARAMETER_2 > 0d1) {
                        dialog("[SLOW]Next break will be in [MEM2] minutes.[B]");
                    } else {
                        dialog("[SLOW]Next break will be soon.[B]");
                    }
                }
            }

            fun guard_market_break(inverted) {
                if(inverted is None) {
                    if(time[0d0] < MARKET.START) {
                        dialog("[SLOW]See me after my break.[B]");

                        end();
                    }
                } else {
                    if(time[0d0] >= MARKET.START) {
                        dialog("[SLOW]See me after my break.[B]");

                        end();
                    }
                }
            }
            fun prepare_market_trade() {
                guard_market_break();

                if(False) {
                    set_camera(COORDINATE_CENTER, <ACTIVE>[X], <ACTIVE>[Y] - 0d30, 0x18);
                    wait(CAMERA_PAN_X);
                    wait(CAMERA_PAN_Y);

                    free_camera();
                }
            }
        };

        group helper_metro_entrance() {
            fun pit_fall_callback(callback_reduced, callback_unreduced) {
                if(CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_3_2) {
                    callback_reduced();
                } else {
                    callback_unreduced();
                }
            }

            fun pit_fall_damage_callback(fall_damage, fall_damage_reduced, callback_success, callback_death) {
                control(NONE);
                
                if(CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_3_2) {
                    damage(BOTH, fall_damage_reduced, True);
                } else {
                    damage(BOTH, fall_damage, True);
                }

                yield();

                if(<BOY>[HP] > 0d0) {
                    sleep(0d60);

                    callback_success();
                } else {
                    callback_death();
                }
            }

            @install()
            @async()
            fun swirl_entrance() {
                generic_a1_desert_sandpit_out(EAST);
            }
        };

        group code() {
            enum CODE_RIDDLE {
                DEBUG = False,
                DEBUG_LEVERS = True,

                SECRET_CODE = memory(BYTE, SRAM), // 5433_2211 = 5<<6 + 4<<5 + 33<<4 + 22<<2 + 11<<0

                CODE_RED = 0d0,
                CODE_BLUE = 0d1,
                CODE_GREEN = 0d2,
            }

            fun plot_code() {
                arg[0x10] = (CODE_RIDDLE.SECRET_CODE >> 0d0) & 0x3; // rgb_1
                arg[0x12] = (CODE_RIDDLE.SECRET_CODE >> 0d2) & 0x3; // rgb_2
                arg[0x14] = (CODE_RIDDLE.SECRET_CODE >> 0d4) & 0x3; // rgb_3
                arg[0x16] = (CODE_RIDDLE.SECRET_CODE >> 0d6) & 0x1; // right
                arg[0x18] = (CODE_RIDDLE.SECRET_CODE >> 0d7) & 0x1; // left

                if(CODE_RIDDLE.DEBUG) {
                    debug_memory(arg[0x18], arg[0x16]);
                    sleep(0d120);
                    debug_memory(arg[0x10], arg[0x12], arg[0x14]);
                    sleep(0d120);
                    debug_memory(CODE_RIDDLE.SECRET_CODE);
                }
            }
            fun create_code() {
                // 5433_2211 = 5<<6 + 4<<5 + 33<<4 + 22<<2 + 11<<0
                
                arg[0x10] = randrange(0d3); // rgb_1
                arg[0x12] = randrange(0d3); // rgb_2
                arg[0x14] = randrange(0d3); // rgb_3
                arg[0x16] = randrange(0d2); // right
                arg[0x18] = randrange(0d2); // left
                
                CODE_RIDDLE.SECRET_CODE = (arg[0x18] << 0d7) + (arg[0x16] << 0d6) + (arg[0x14] << 0d4) + (arg[0x12] << 0d2) + (arg[0x10] << 0d0);

                if(CODE_RIDDLE.DEBUG) {
                    plot_code();
                }
            }

            fun safe_create_code() {
                while!(CUSTOM_MEMORY.INPUT_P1) {
                    sleep(randrange(0d60));
                }
                sleep(randrange(0d60));
                while!(CUSTOM_MEMORY.INPUT_P1) {
                    sleep(randrange(0d60));
                }
                sleep(randrange(0d60));
                while!(CUSTOM_MEMORY.INPUT_P1) {
                    sleep(randrange(0d60));
                }

                while!(CODE_RIDDLE.SECRET_CODE) {
                    create_code();
                }
            }
        };

        @install()
        @async()
        fun sterling_rats_scanner(x, y) {
            <BOY>[GENERAL_PURPOSE] = 0d0;
            while(True) {
                if(<BOY>[GENERAL_PURPOSE] > 0d0) {
                    dust_unreachable(x, y);

                    end();
                }

                sleep(0d10);
            }
        }

        fun add_sterling_rat(x, y, x_drop, y_drop, cutoff_drop, x_dust, y_dust) {
            add_enemy(RAT_RED, x, y);
            attach_sterling_script(<LAST_ENTITY>, False, 0d20, x_drop, y_drop, cutoff_drop, 0d999);

            if((x_dust !is None) && (y_dust !is None)) {
                sterling_rats_scanner(x_dust, y_dust);
            }
        }
    };

    group fallout_mechanics() {
        enum RADIATION {
            DEBUG = False,

            RADIATION_LEVEL = memory(WORD, TEMP_RESERVED),

            RADIATION_CURRENT = memory(BYTE, SRAM),

            RADIATION_MAX = 0d255,
            RADIATION_DECAY = 0d1,
            RADIATION_DAMAGE = 0d1,

            RADIATION_BUMP_PROXIMITY = 0d3,
            RADIATION_BUMP_TOUCH = 0d10,

            THRESHOLD_DAMAGE = 0d20,
        }

        @install()
        fun prepare_radiating_entity(entity) {
            if!(SOULS_MEMORY.RADIATION_SOURCE_1) {
                SOULS_MEMORY.RADIATION_SOURCE_1 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_2) {
                SOULS_MEMORY.RADIATION_SOURCE_2 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_3) {
                SOULS_MEMORY.RADIATION_SOURCE_3 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_4) {
                SOULS_MEMORY.RADIATION_SOURCE_4 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_5) {
                SOULS_MEMORY.RADIATION_SOURCE_5 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_6) {
                SOULS_MEMORY.RADIATION_SOURCE_6 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_7) {
                SOULS_MEMORY.RADIATION_SOURCE_7 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_8) {
                SOULS_MEMORY.RADIATION_SOURCE_8 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_9) {
                SOULS_MEMORY.RADIATION_SOURCE_9 = entity;
            } else if!(SOULS_MEMORY.RADIATION_SOURCE_10) {
                SOULS_MEMORY.RADIATION_SOURCE_10 = entity;
            }
        }

        @install()
        fun increase_radiation(amount) {
            if(RADIATION.RADIATION_CURRENT < (RADIATION.RADIATION_MAX - amount)) {
                RADIATION.RADIATION_CURRENT += amount;

                if(RADIATION.RADIATION_LEVEL) {
                    RADIATION.RADIATION_CURRENT += amount + amount;
                }
            }
        }


        @install()
        fun _radiation_click(force_click) {
            if(force_click || (CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_4_2)) {
                sound(CLICK_1);

                if(True) {
                    sleep(randrange(0d2));
                    sound(NONE);
                }
            }
        }
        @install()
        fun radiation_click(no_bonus_clicks, force_click) {
            _radiation_click(force_click);

            if!(no_bonus_clicks) {
                if(rand(0x1)) {
                    sleep(0d5 + randrange(0d10));

                    _radiation_click(force_click);
                }
                if(rand(0x1)) {
                    sleep(randrange(0d30));
                }
                if(rand(0x1)) {
                    sleep(0d3 + randrange(0d10));

                    _radiation_click(force_click);

                    if(rand(0x1)) {
                        sleep(0d1 + randrange(0d10));

                        _radiation_click(force_click);
                    }
                }
            }
        }

        fun _radiation_handler_range_checker(source, target, range) {
            if(target) { // alive(target)
                check_range_old(source, target, range, range, {
                    increase_radiation(RADIATION.RADIATION_BUMP_PROXIMITY);
                    // sleep(0d30 + randrange(0d30));

                    if(False) {
                        arg[0x14] = 0d5 + randrange(0d5);
                        while(arg[0x14] > 0d0) {
                            arg[0x14]--;
                            sleep(0d30 + randrange(0d30));

                            radiation_click();
                        }
                    } else {
                        radiation_click();
                    }
                });
            }

            if(True) {
                sleep(0d5 + randrange(0d5));
            } else {
                radiation_click();
            }
        }
        @install()
        @async()
        fun _radiation_handler(source, range) {
            attach_to_script(source);

            sleep(0d60);

            if(SOULS_MEMORY.RADIATION_SOURCE_1) {
                radiation_click();
            }

            arg[0x12] = 0d2 + randrange(0d3);

            while(True) {
                arg[0x10] = 0d0;
                arg[0x12]--;
                
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_1, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_2, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_3, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_4, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_5, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_6, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_7, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_8, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_9, range);
                _radiation_handler_range_checker(source, SOULS_MEMORY.RADIATION_SOURCE_10, range);

                if(arg[0x10] > 0d0) {
                    radiation_click();
                } else if(arg[0x12] == 0d0) {
                    arg[0x12] = 0d2 + randrange(0d3);

                    if(SOULS_MEMORY.RADIATION_SOURCE_1) {
                        radiation_click();
                    }

                    if!(RADIATION.RADIATION_LEVEL) {
                        if(RADIATION.RADIATION_CURRENT > RADIATION.RADIATION_DECAY) {
                            RADIATION.RADIATION_CURRENT -= RADIATION.RADIATION_DECAY;
                        } else {
                            RADIATION.RADIATION_CURRENT = 0d0;
                        }
                    }
                }

                if(RADIATION.DEBUG) {
                    debug_memory(RADIATION.RADIATION_CURRENT, arg[0x10], arg[0x12]);
                }

                if((RADIATION.RADIATION_CURRENT > RADIATION.THRESHOLD_DAMAGE) && (!randrange(0d3))) {
                    MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                    damage(BOY, RADIATION.RADIATION_DAMAGE, True);
                }
            }
        }
        fun radiation_handler() {
            _radiation_handler(<BOY>, 0d50);
        }

        fun pip_boy(callback) {
            if((<ACTIVE> == <BOY>) && (CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_4_2)) {
                callback();
            } else {
                fake_b();
            }
        }
    };

    group archaeology_helper() {
        enum ARCHAEOLOGY_DIG {
            DEBUG = False,

            DOG = 0d10,
            BOY = 0d1,
            BOY_PICKAXE = 0d30,

            WITH_BOY = False,

            // riddle: code bots
            CODE_1 = 0x00,
            CODE_2 = 0x01,
            CODE_3 = 0x02,
            CODE_4 = 0x03,
            CODE_5 = 0x04,
        }

        @install()
        @async()
        fun hacking_wakeup(offset_boy_x, offset_boy_y, offset_dog_x, offset_dog_y) {
            <BOY>[X] += signed arg[0x00];
            <BOY>[Y] += signed arg[0x02];

            <DOG>[X] += signed arg[0x04];
            <DOG>[Y] += signed arg[0x06];

            attribute(BOY, INVINCIBLE_TEMP, True);
            attribute(DOG, INVINCIBLE_TEMP, True);

            animate_boy_kneel(BOY);

            sleep(0d60);

            animate(BOY, ONCE, DEFAULT);

            attribute(BOY, INVINCIBLE_TEMP, False);
            attribute(DOG, INVINCIBLE_TEMP, False);
        }

        fun archaeology_dig(x, y, counter, digs, callback, detectable) {
            add_enemy(PLACEHOLDER, x, y);
            attach_script(LAST_ENTITY, B, callback);
            
            counter = digs;

            if(detectable !is None) {
                if(detectable) {
                    SOULS_MEMORY.ARCHAEOLOGY_TARGET = <LAST_ENTITY>;
                }
            }
        }

        fun _guard_archaeology_dig(counter) {
            if(<ACTIVE> == <DOG>) {
                sound(IMPACT);
                animate(DOG, ONCE, ANIMATION_DOG.ACT1_ANGRY); // TODO

                if(counter >= ARCHAEOLOGY_DIG.DOG) {
                    counter -= ARCHAEOLOGY_DIG.DOG;
                } else {
                    counter = 0d0;
                }
            } else {
                if((SOULS_MEMORY.PICKAXE) || (CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_3_3)) {
                    sound(IMPACT);
                    animate(BOY, ONCE, ANIMATION_BOY.LANDING);

                    if(counter >= ARCHAEOLOGY_DIG.BOY_PICKAXE) {
                        counter -= ARCHAEOLOGY_DIG.BOY_PICKAXE;
                    } else {
                        counter = 0d0;
                    }
                } else if(ARCHAEOLOGY_DIG.WITH_BOY) {
                    sound(IMPACT);
                    animate(BOY, ONCE, ANIMATION_BOY.LANDING);

                    if(counter >= ARCHAEOLOGY_DIG.BOY) {
                        counter -= ARCHAEOLOGY_DIG.BOY;
                    } else {
                        counter = 0d0;
                    }
                } else {
                    fake_b();
                }
            }
        }
        fun guard_archaeology_dig(flag, counter, no_clean_up) {
            if(ARCHAEOLOGY_DIG.DEBUG) {
                debug_memory(counter, flag);
            }

            if!(flag) {
                if(counter == 0d0) {
                    sound(WEIRD_SOUND);

                    if(flag is Memory) {
                        flag = True;
                    }

                    if!(no_clean_up !is None) {
                        destroy(SCRIPT_OWNER);
                    }
                } else {
                    _guard_archaeology_dig(counter);

                    end();
                }
            }
        }

        @install()
        fun reveal_code() {
            arg[0x10] = (CODE_RIDDLE.SECRET_CODE >> 0d7) & 0x1; // left
            arg[0x12] = (CODE_RIDDLE.SECRET_CODE >> 0d6) & 0x1; // right
            arg[0x14] = (CODE_RIDDLE.SECRET_CODE >> 0d0) & 0x3; // rgb_1
            arg[0x16] = (CODE_RIDDLE.SECRET_CODE >> 0d2) & 0x3; // rgb_2
            arg[0x18] = (CODE_RIDDLE.SECRET_CODE >> 0d4) & 0x3; // rgb_3

            if(<BOY>[GENERAL_PURPOSE] == ARCHAEOLOGY_DIG.CODE_1) {
                // dialog("[SLOW]_ _  _ _ 1[B]");

                if(False) {
                    MEMORY.STRING_PARAMETER_1 = arg[0x18];
                    dialog("[SLOW]_ _  _ _ [MEM1][B]");
                } else {
                    if(arg[0x18] == CODE_RIDDLE.CODE_RED) {
                        dialog("[SLOW]_ _  _ _ R[B]");
                    } else if(arg[0x18] == CODE_RIDDLE.CODE_GREEN) {
                        dialog("[SLOW]_ _  _ _ G[B]");
                    } else if(arg[0x18] == CODE_RIDDLE.CODE_BLUE) {
                        dialog("[SLOW]_ _  _ _ B[B]");
                    }
                }
            } else if(<BOY>[GENERAL_PURPOSE] == ARCHAEOLOGY_DIG.CODE_2) {
                // dialog("[SLOW]_ _  _ 2 _[B]");

                if(False) {
                    MEMORY.STRING_PARAMETER_1 = arg[0x16];
                    dialog("[SLOW]_ _  _ [MEM1] _[B]");
                } else {
                    if(arg[0x16] == CODE_RIDDLE.CODE_RED) {
                        dialog("[SLOW]_ _  _ R _[B]");
                    } else if(arg[0x16] == CODE_RIDDLE.CODE_GREEN) {
                        dialog("[SLOW]_ _  _ G _[B]");
                    } else if(arg[0x16] == CODE_RIDDLE.CODE_BLUE) {
                        dialog("[SLOW]_ _  _ B _[B]");
                    }
                }
            } else if(<BOY>[GENERAL_PURPOSE] == ARCHAEOLOGY_DIG.CODE_3) {
                // dialog("[SLOW]_ _  3 _ _[B]");

                if(False) {
                    MEMORY.STRING_PARAMETER_1 = arg[0x14];
                    dialog("[SLOW]_ _  [MEM1] _ _[B]");
                } else {
                    if(arg[0x14] == CODE_RIDDLE.CODE_RED) {
                        dialog("[SLOW]_ _  R _ _[B]");
                    } else if(arg[0x14] == CODE_RIDDLE.CODE_GREEN) {
                        dialog("[SLOW]_ _  G _ _[B]");
                    } else if(arg[0x14] == CODE_RIDDLE.CODE_BLUE) {
                        dialog("[SLOW]_ _  B _ _[B]");
                    }
                }
            } else if(<BOY>[GENERAL_PURPOSE] == ARCHAEOLOGY_DIG.CODE_4) {
                // dialog("[SLOW]_ 4  _ _ _[B]");

                MEMORY.STRING_PARAMETER_1 = arg[0x12];
                dialog("[SLOW]_ [MEM1]  _ _ _[B]");
            } else if(<BOY>[GENERAL_PURPOSE] == ARCHAEOLOGY_DIG.CODE_5) {
                // dialog("[SLOW]5 _  _ _ _[B]");

                MEMORY.STRING_PARAMETER_1 = arg[0x10];
                dialog("[SLOW][MEM1] _  _ _ _[B]");
            } else {
                dialog("[SLOW]…[B]");
            }
        }

        fun add_code_bot(x, y, index, dig_counter, hacked) {
            add_enemy(DUSTER_BOT, x, y, INACTIVE_IMORTAL);
            if!(hacked) {
                attribute(LAST_ENTITY, INVISIBLE, True);
            }
            <LAST_ENTITY>[GENERAL_PURPOSE] = dig_counter;
            SOULS_MEMORY.ARCHAEOLOGY_TARGET = <LAST_ENTITY>;
            face_target(LAST_ENTITY, ACTIVE);
            prepare_radiating_entity(<LAST_ENTITY>);

            <BOY>[GENERAL_PURPOSE] = index;

            if!(hacked) {
                attach_script(LAST_ENTITY, B, reference(@install() {
                    guard_archaeology_dig(False, <SCRIPT_OWNER>[GENERAL_PURPOSE], True);

                    attribute(SCRIPT_OWNER, INVISIBLE, False);

                    if(<ACTIVE> == <DOG>) {
                        dialog("…[B]");
                        end();
                    }

                    animate_boy_kneel(BOY);

                    if((CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_4_1) || (CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_4_2)) {
                        question("[SLOW]Access robot?[CHOICE]hack…[CHOICE]leave…");

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // hack
                            if(CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_4_1) {
                                reveal_code();
                            } else {
                                map_transition(mini_game_hacking, center, NONE);
                            }
                        }
                    } else {
                        question("[SLOW]Touch robot?[CHOICE]touch…[CHOICE]leave…");

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // touch
                            increase_radiation(RADIATION.RADIATION_BUMP_TOUCH);

                            dialog("[SLOW]Even though the robot has been buried for an eternity it is still faintly buzzing inside.[B]");
                        }
                    }

                    animate(BOY, ONCE, DEFAULT);
                }));
            } else {
                attach_script(LAST_ENTITY, B, reference(reveal_code));
            }
        }

        fun archaeology_dig_code_bot(x, y, index, dig_counter, flag) {
            if!(flag) {
                add_code_bot(x, y, index, dig_counter, False);
            } else {
                add_code_bot(x, y, index, dig_counter, True);
            }
        }
    };

    group souls_game_state() {
        @install()
        @async()
        fun _init_souls() {
            if(True) { // TODO: the hit% bonus is being calculated during fade_in() and the temp-copies aren't ready at that point
                while(<ACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                    yield();
                }
                yield();
            } else {
                sleep(0d120);
            }

            if(True) {
                update_armor_effects();
            }
        }
        @install()
        fun init_souls() {
            if(SOULS_MEMORY.DEBUG) {
                FLAG.DEBUG = True;
            }

            if!(SOULS_MEMORY.INIT_SESSION) {
                update_debug_menu();
            }

            if!(SOULS_MEMORY.INIT) {
                SOULS_MEMORY.INIT = True;

                SOULS_MEMORY.ESTUS_CHARGES = SOULS_MEMORY.ESTUS_CHARGES_INIT;
                refresh_flask();

                SOULS_MEMORY.DUST_DROP_MAP = 0xffff;
                SOULS_MEMORY.DUST_DROP_VARIANT = 0xffff;

                // MEMORY.ALCHEMY_LEVEL_ATLAS = 0d10;
                // MEMORY.ALCHEMY_LEVEL_DEFEND = 0d3;
                // MEMORY.ALCHEMY_LEVEL_SPEED = 0d1;

                SOULS_MEMORY.MENU_CHOICE = 0xffff;

                // CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.BOMBS;

                if(SOULS_MEMORY.DEBUG && SOULS_MEMORY.WITH_CHEATS && SOULS_MEMORY.WITH_CHEATS_FULL_INGREDIENTS) {
                    unlock(INGREDIENTS);
                }

                if(SOULS_MEMORY.DEBUG && SOULS_MEMORY.WITH_CHEATS && SOULS_MEMORY.WITH_CHEATS_MARIO_YUMP) {
                    if(FLAG.DEBUG) {
                        SOULS_MEMORY.MENU_CHOICE = 0x01;
                        
                        SOULS_MEMORY.MARIO_YUMP_ENABLED = True;
                        // SOULS_MEMORY.BUTTON_MAP = BUTTON_MAP.MARIO;

                        update_debug_menu();
                    }
                }

                if(SOULS_MEMORY.DEBUG && SOULS_MEMORY.WITH_CHEATS && SOULS_MEMORY.WITH_CHEATS_ALL_BONFIRES) {
                    // center
                    SOULS_MEMORY.BONFIRE_INBETWIXX = True;

                    // east
                    SOULS_MEMORY.BONFIRE_EAST_CROSSING = True;
                    SOULS_MEMORY.BONFIRE_PIPES = True;
                    SOULS_MEMORY.BONFIRE_TOWN_CENTER = True;
                    SOULS_MEMORY.BONFIRE_TEMPLE_PIT = True;

                    // west
                    SOULS_MEMORY.BONFIRE_ISAAC_DUNGEON = True;
                    SOULS_MEMORY.BONFIRE_VOLCANO_TOWER = True;

                    // south
                    SOULS_MEMORY.BONFIRE_JUNGLE_PIT = True;
                    SOULS_MEMORY.BONFIRE_BUG = True;
                    SOULS_MEMORY.BONFIRE_DESERT = True;

                    // altus
                    SOULS_MEMORY.BONFIRE_ALTUS_WELL = True;
                    SOULS_MEMORY.BONFIRE_ALTUS_STAIRS = True;
                    SOULS_MEMORY.BONFIRE_CASTLE_PIT = True;
                }
            }

            if((SOULS_MEMORY.DUST_DROP_MAP == MEMORY.CURRENT_MAP) && (SOULS_MEMORY.DUST_DROP_VARIANT == MEMORY.CURRENT_MAP_VARIANT)) {
                _add_enemy(BEE, SOULS_MEMORY.DUST_DROP_X, SOULS_MEMORY.DUST_DROP_Y);
                SOULS_MEMORY.DUST_ENTITY = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DEATH, reference(dust_drop));
                
                attribute(LAST_ENTITY, MUTE, True);
                damage(LAST_ENTITY, 0d999, False);
            }

            if((<ACTIVE>[X] == 0x00) && (<ACTIVE>[Y] == 0x00)) {
                set(SOULS_MEMORY.BONFIRE_TELEPORT_REQUIRED); // TODO
            }

            // debug_memory(SOULS_MEMORY.BONFIRE_TELEPORT_REQUIRED, SOULS_MEMORY.BONFIRE_X, SOULS_MEMORY.BONFIRE_Y);

            if(SOULS_MEMORY.BONFIRE_TELEPORT_REQUIRED) {
                if(
                    // (SOULS_MEMORY.BONFIRE_MAP == 0x00) ||
                    // (SOULS_MEMORY.BONFIRE_VARIANT == 0x00) ||
                    (SOULS_MEMORY.BONFIRE_X == 0x00) ||
                    (SOULS_MEMORY.BONFIRE_Y == 0x00)
                ) {
                    if(False) {
                        _fade_in();
                        debug_subtext("Failed to teleport player to bonfire");
                        sleep(0d200);
                    }
                } else {
                    _teleport(BOY, SOULS_MEMORY.BONFIRE_X, SOULS_MEMORY.BONFIRE_Y);
                    _teleport(DOG, SOULS_MEMORY.BONFIRE_X, SOULS_MEMORY.BONFIRE_Y);
                }
                

                unset(SOULS_MEMORY.BONFIRE_TELEPORT_REQUIRED);
            }

            // cure();
            // cast(BOY, BOTH, CURE, 0x01);

            if(SOULS_MEMORY.WITH_RETURN_TO_BONFIRE_ON_DEATH) {
                attach_script(BOY, DAMAGE_DEATH, reference(boy_death));
            }

            if!(SOULS_MEMORY.WINGS_BLOCKED) {
                special_script(WINGS, reference(wings_used));
            }

            MEMORY.BOY_XP_REQUIRED = SYSTEM.HP_MAX;
            MEMORY.DOG_XP_REQUIRED = SYSTEM.HP_MAX;

            if!(SOULS_MEMORY.WITH_CHEATS) {
                attribute(BOY, NO_CLIP, False);
                attribute(DOG, NO_CLIP, False);
            }

            _init_souls();

            radiation_handler();
        }

        fun init_hack() {
            init_souls();
        }

        @install()
        fun default_init_room(night, rain) {
            init_hack();

            if((!FLAG.BAZOOKA) && (MEMORY.CURRENT_WEAPON == WEAPON_INDEX.BAZOOKA_TEMP)) {
                MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_1;
            }

            if(SOULS_MEMORY.DOG_SHIP || SOULS_MEMORY.DOG_SHIP_STAIRS) {
                CUSTOM_FLAG.NO_DOG = True;
            }
            
            if(CUSTOM_MEMORY.CURRENT_DOG) {
                MEMORY.DOG_WRITE = CUSTOM_MEMORY.CURRENT_DOG;
            } else if(SOULS_MEMORY.DOG_PREFERENCE != 0d0) {
                MEMORY.DOG_WRITE = SOULS_MEMORY.DOG_PREFERENCE;
            } else {
                MEMORY.DOG_WRITE = DOG.WOLF;
            }

            init_weather(night, rain);

            MEMORY.PACIFIED = False;

            show_currency(False);

            fade_in();
        }

        fun isaac_mode() {
            CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.ISAAC;
            MEMORY.PACIFIED = True;
        }

        fun isaac_init(night, rain) {
            init_hack();

            CUSTOM_FLAG.NO_DOG = True;
            init_weather(night, rain);

            isaac_mode();

            fade_in();
        }

        fun fallout_init(night, rain) {
            init_hack();

            RADIATION.RADIATION_LEVEL = 0d1;

            default_init_room(night, rain);
        }

        fun mario_mode() {
            CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
            MEMORY.PACIFIED = True;
        }

        fun mario_init(night, rain) {
            init_hack();

            CUSTOM_FLAG.NO_DOG = True;
            init_weather(night, rain);

            mario_mode();

            fade_in();
        }
    };

    group hotkeys() {
        @install()
        @inject(ADDRESS.HOTKEY_START)
        @count_limit(0x20)
        fun hotkey_start() {
            // if(FLAG.DEBUG) {
            //     debug_subtext("Start");
            // }

            if(CUSTOM_FLAG.START_COOLDOWN) {
                if(SYSTEM.WITH_DEBUG_START) {
                    debug_subtext("start = cooldown");
                }

                end();
            }

            if(CUSTOM_FLAG.NO_START) {
                subtext("suppressed…");

                CUSTOM_FLAG.START_COOLDOWN = True;
                sleep(0d300);
                CUSTOM_FLAG.START_COOLDOWN = False;

                end();
            }

            sleep(0d5);
            if(CUSTOM_MEMORY.INPUT_P1 != 0x1000) {
                if(SYSTEM.WITH_DEBUG_START) {
                    debug_subtext("start < 5frames");
                }

                end();
            }

            CUSTOM_FLAG.START_COOLDOWN = True;

            if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.AIRSHIP) {
                windwalker_rocket();
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.SPACESHIP) {
                if(False) {
                    spaceship_rocket();
                }
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.ISAAC) {
                isaac_tear(False);
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.BOMBS) {
                drop_bomb(False);
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.MARIO) {
                mario_yump(False);
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.PUPPER) {
                MEMORY.DOG_WRITE = DOG.PUPPER; // TODO
            } else {
                if(False) {
                    debug_memory(SOULS_MEMORY.MENU_CHOICE, SOULS_MEMORY.DEBUG_MENU_BUTTON_1);
                }

                if(SOULS_MEMORY.MENU_CHOICE == 0d1) {
                    start_feature_selected(SOULS_MEMORY.DEBUG_MENU_BUTTON_1);
                } else if(SOULS_MEMORY.MENU_CHOICE == 0d2) {
                    start_feature_selected(SOULS_MEMORY.DEBUG_MENU_BUTTON_2);
                } else if(SOULS_MEMORY.MENU_CHOICE == 0d3) {
                    start_feature_selected(SOULS_MEMORY.DEBUG_MENU_BUTTON_3);
                } else if(SOULS_MEMORY.MENU_CHOICE == 0d4) {
                    start_feature_selected(SOULS_MEMORY.DEBUG_MENU_BUTTON_4);
                } else if(SOULS_MEMORY.MENU_CHOICE == 0d5) {
                    start_feature_selected(SOULS_MEMORY.DEBUG_MENU_BUTTON_5);
                } else if(SOULS_MEMORY.MENU_CHOICE == 0d6) {
                    start_feature_selected(SOULS_MEMORY.DEBUG_MENU_BUTTON_6);
                }
            }

            if(CUSTOM_FLAG.START_COOLDOWN) {
                while(CUSTOM_MEMORY.INPUT_P1 & 0x1000) {
                    yield();
                }

                CUSTOM_FLAG.START_COOLDOWN = False;
            }
        }
        @install()
        @inject(ADDRESS.HOTKEY_START_L)
        @count_limit(0x20)
        fun hotkey_start_l() {
            sleep(0d5);
            if(CUSTOM_MEMORY.INPUT_P1 != 0x1020) {
                end();
            }

            if(CUSTOM_MEMORY.CURRENT_ARMOR_HELM == ARMOR_STATS.HELM_4_3) {
                if(False) {
                    debug_memory(SOULS_MEMORY.ARCHAEOLOGY_TARGET, _dead(SOULS_MEMORY.ARCHAEOLOGY_TARGET), dead(SOULS_MEMORY.ARCHAEOLOGY_TARGET));
                    sleep(0d30);
                }

                wow_archaeology(SOULS_MEMORY.ARCHAEOLOGY_TARGET);
            } else if(SOULS_MEMORY.MARIO_YUMP_ENABLED && (CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT > 0d0)) {
                rocket_jump();
            } else if(SOULS_MEMORY.DEBUG && SOULS_MEMORY.WITH_CHEATS && SOULS_MEMORY.WITH_CHEATS_HOTKEYS) {
                debug_subtext("Start+L");

                // return_to_bonfire();
                
                // map_transition(hidden_castle_entry, stairs, NONE);
                // map_transition(mansion_modern, west, NONE);
                map_transition(desert, south, NONE);
                
                // MEMORY.MAP_PALETTE--;
            } else {
                if(SOULS_MEMORY.CHARACTER_SWITCH_ENABLED) {
                    swap_characters();
                }
            }
        }
        @install()
        @inject(ADDRESS.HOTKEY_START_R)
        @count_limit(0x20)
        fun hotkey_start_r() {
            sleep(0d5);
            if(CUSTOM_MEMORY.INPUT_P1 != 0x1010) {
                end();
            }

            if(SOULS_MEMORY.MARIO_YUMP_ENABLED && (CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT > 0d0)) {
                if(FLAG.ENERGY_CORE) {
                    mario_yump(False);
                } else {
                    mario_yump(True);
                }
            } else if(SOULS_MEMORY.ROCKET_JUMP_ENABLED && CUSTOM_FLAG.START_MARIO_YUMP) {
                rocket_jump();
            } else if(SOULS_MEMORY.DEBUG && SOULS_MEMORY.WITH_CHEATS && SOULS_MEMORY.WITH_CHEATS_HOTKEYS) {
                debug_subtext("Start+R");
                
                if(SOULS_MEMORY.WITH_CHEATS) {
                    if(True) {
                        if((<ACTIVE>[FLAGS_2] & ATTRIBUTE_FLAGS.NO_CLIP) == 0d0) {
                            attribute(ACTIVE, NO_CLIP, True);
                        } else {
                            attribute(ACTIVE, NO_CLIP, False);
                        }
                    }
                    if(False) {
                        attribute(ACTIVE, INVINCIBLE_TEMP, True);
                    }
                    <ACTIVE>[HP] = SYSTEM.HP_MAX;
                }
                
                debug_boy();

                // MEMORY.MAP_PALETTE++;

                if(False) {
                    <0x2834>++;
                }

                // debug_tile();
            } else {
                if(SOULS_MEMORY.WEAPON_CYCLE_ENABLED) {
                    cycle_weapon();
                }
            }
        }
        @install()
        @inject(ADDRESS.HOTKEY_L)
        @count_limit(0x20)
        fun hotkey_l() {
            if(False) {
                debug_subtext("L");
            }

            if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.SPACESHIP) {
                spaceship_rocket(0d1);
            }
        }
        @install()
        @inject(ADDRESS.HOTKEY_R)
        @count_limit(0x20)
        fun hotkey_r() {
            if(False) {
                debug_subtext("R");
            }

            if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.SPACESHIP) {
                spaceship_rocket(0d2);
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.MARIO) {
                if(CUSTOM_FLAG.START_MARIO_FIREFLOWER) {
                    mario_fireflower();
                }
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.ISAAC) {
                // if(SOULS_MEMORY.ISAAC_BOMBS > 0d0) {
                //     SOULS_MEMORY.ISAAC_BOMBS--;
                // 
                //     drop_bomb(False);
                // }
                nop();
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.SPEAR_TOSS) {
                spear_toss();
            }
        }
        @install()
        @inject(ADDRESS.HOTKEY_B)
        @count_limit(0x20)
        fun hotkey_b() {
            if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.AIRSHIP) {
                windwalker_rocket();
            } else if(CUSTOM_MEMORY.HOTKEY_START == BUTTON_MAP.ISAAC) {
                isaac_tear(False);
            }
        }
        @install()
        @inject(ADDRESS.HOOK_MENU_CLOSE)
        @count_limit(0x20)
        fun hook_menu_close() {
            if(False) {
                sfx_effect(NIGHT, True);
            }

            update_armor_effects();
        }

        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_1)
        fun menu_0() {
            if(FLAG.DEBUG) {
                debug_subtext("M=1");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x01;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_2)
        fun menu_1() {
            if(FLAG.DEBUG) {
                debug_subtext("M=2");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x02;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_3)
        fun menu_2() {
            if(FLAG.DEBUG) {
                debug_subtext("M=3");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x03;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_4)
        fun menu_3() {
            if(FLAG.DEBUG) {
                debug_subtext("M=4");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x04;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_5)
        fun menu_4() {
            if(FLAG.DEBUG) {
                debug_subtext("M=5");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x05;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_6)
        fun menu_5() {
            if(FLAG.DEBUG) {
                debug_subtext("M=6");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x06;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_7)
        fun menu_6() {
            if(FLAG.DEBUG) {
                debug_subtext("M=7");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x07;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_8)
        fun menu_7() {
            if(FLAG.DEBUG) {
                debug_subtext("M=8");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x08;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_9)
        fun menu_8() {
            if(FLAG.DEBUG) {
                debug_subtext("M=9");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x09;
        }
        @install(ADDRESS.DEBUG_MENU_BUTTON_10)
        fun debug_9() {
            if(FLAG.DEBUG) {
                debug_subtext("M=10");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x0a;
        }
        @install()
        @inject(ADDRESS.DEBUG_MENU_BUTTON_11)
        fun menu_10() {
            if(FLAG.DEBUG) {
                debug_subtext("M=11");
            }
            SOULS_MEMORY.MENU_CHOICE = 0x0b;
        }
    };

    group statue_riddle() {
        enum STATUE_RIDDLE {
            PROGRESS = memory(BYTE, SRAM),

            CARRY_LEFT_EYE = memory(FLAG, SRAM),
            CARRY_RIGHT_EYE = memory(FLAG, SRAM),
        }

        enum STATUE_RIDDLE_STATUES { // order = actual activation order
            DOG = 0d0,
            HORACE = 0d1,
            VIGOR = 0d2,
            GOMI = 0d3,
            AEGIS = 0d4,
            
            BOSS = 0d5,
        }

        fun place_statue(index:STATUE_RIDDLE_STATUES, x, y) {
            if(index == STATUE_RIDDLE_STATUES.DOG) {
                if(STATUE_RIDDLE.PROGRESS >= STATUE_RIDDLE_STATUES.DOG) {
                    add_enemy(PLACEHOLDER, x, y);
                    // <LAST_ENTITY>[GENERAL_PURPOSE] = STATUE_RIDDLE_STATUES.DOG;
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        STATUE_RIDDLE.PROGRESS = STATUE_RIDDLE_STATUES.HORACE;

                        dialog("[SLOW]He was the first to wittness a dog walking on water.[B]");
                    }));
                }
            } else if(index == STATUE_RIDDLE_STATUES.HORACE) {
                if(STATUE_RIDDLE.PROGRESS >= STATUE_RIDDLE_STATUES.HORACE) {
                    add_enemy(PLACEHOLDER, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        STATUE_RIDDLE.PROGRESS = STATUE_RIDDLE_STATUES.VIGOR;

                        dialog("[SLOW]He once wittnessed a street boy outsmarting a strong man, twice.[B]");
                    }));
                }
            } else if(index == STATUE_RIDDLE_STATUES.VIGOR) {
                if(STATUE_RIDDLE.PROGRESS >= STATUE_RIDDLE_STATUES.VIGOR) {
                    add_enemy(PLACEHOLDER, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        STATUE_RIDDLE.PROGRESS = STATUE_RIDDLE_STATUES.GOMI;

                        dialog("[SLOW]He watched a street boy repeatedly falling to the ground.[B]");
                    }));
                }
            } else if(index == STATUE_RIDDLE_STATUES.GOMI) {
                if(STATUE_RIDDLE.PROGRESS >= STATUE_RIDDLE_STATUES.GOMI) {
                    add_enemy(PLACEHOLDER, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        STATUE_RIDDLE.PROGRESS = STATUE_RIDDLE_STATUES.AEGIS;

                        dialog("[SLOW]He watched an empire raise and tried to end civilization.[B]");
                    }));
                }
            } else if(index == STATUE_RIDDLE_STATUES.AEGIS) {
                if(STATUE_RIDDLE.PROGRESS >= STATUE_RIDDLE_STATUES.AEGIS) {
                    add_enemy(PLACEHOLDER, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        STATUE_RIDDLE.PROGRESS = STATUE_RIDDLE_STATUES.BOSS;

                        dialog("todo[B]");
                    }));
                }
            }
        }
    };

    group souls_npcs() {
        enum NPC_SHARED {
            STORY_PICKAXE = memory(FLAG, SRAM), // crafter -> smith (unlocks: PICKAXE_HEAD)
        }

        group npc_shrine_maiden() {
            enum NPC_SHRINE_MAIDEN {
                PROGRESS = memory(BYTE, SRAM),
                SUB_PROGRESS = memory(BYTE, SRAM),

                PRICE_LEVEL_UP = 0d100,

                // ID = memory(WORD, SRAM),
                BODY = ENEMY.FIRE_EYES,
            }

            group talk_ai() {
                fun greeting_default() {
                    dialog("[SLOW]Bearer of the curse…[LF]Seek souls. Larger, more powerful souls.[LF]Seek the King, that is the only way.[LF]Lest this land swallow you whole… As it has so many others.[B]");
                }

                fun greeting_estus_shard() {
                    dialog("[SLOW]Is that a shard you've found?[LF]Here, let me see it. So that I may help you.[LF]To see light, to see hope…[LF]However faint it might be…[B]");
                }

                fun story_estus_shard() {
                    dialog("[SLOW]If you find an Estus Shard, bring it to me.[LF]So that I may ease your burden.[B]");
                }

                fun upgrade_boy() {
                    full_heal(BOTH, True);
                    yield();
                    
                    _level_up(MEMORY.STRING_PARAMETER_1, 0d3, NPC_SHRINE_MAIDEN.PRICE_LEVEL_UP);
                    question("[SLOW]Level up for [MEM1] Souls?[CHOICE]yes…[CHOICE]no…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        level_up(BOY, 0d3, NPC_SHRINE_MAIDEN.PRICE_LEVEL_UP);

                        yield();
                        MEMORY.BOY_XP_REQUIRED = SYSTEM.HP_MAX;
                    }
                }

                fun upgrade_estus() {
                    if(SOULS_MEMORY.ESTUS_SHARDS > 0x00) {
                        question("[SLOW]estus upgrade?[CHOICE]yes[CHOICE]no");

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            SOULS_MEMORY.ESTUS_SHARDS--;

                            SOULS_MEMORY.ESTUS_CHARGES++;
                        }
                    }
                }

                @install()
                fun shrine_maiden_triggered__first_bonfire() {
                    if(NPC_SHRINE_MAIDEN.PROGRESS == 0d0) {
                        if(NPC_SHRINE_MAIDEN.SUB_PROGRESS == 0d0) {
                            NPC_SHRINE_MAIDEN.SUB_PROGRESS++;
                        
                            dialog("[SLOW]Welcome to the bonfire, Unkindled One.[LF]I am a Fire Keeper.[LF]I tend to the flame, and tend to thee.[LF]The Lords have left their thrones, and must be deliver'd to them.[LF]To this end, I am at thy side.[B]");
                        } else if(NPC_SHRINE_MAIDEN.SUB_PROGRESS == 0d1) {
                            NPC_SHRINE_MAIDEN.SUB_PROGRESS++;
                        
                            dialog("[SLOW]Produce the coiled sword at the bonfire.[LF]The mark of ash will guide thee to the land of the Lords.[LF]To Lothric, where the homes of the Lords converge.[B]");
                        } else if(NPC_SHRINE_MAIDEN.SUB_PROGRESS == 0d2) {
                            NPC_SHRINE_MAIDEN.SUB_PROGRESS++;
                        
                            dialog("[SLOW]Understood.[LF]Then touch the darkness inside me.[LF]With your power, let us make the 'soul without a master.'[LF]Farewell, ashen one.[B]");
                        } else {
                            dialog("[SLOW]Ignite the first bonfire.[B]");
                        }
                    } else if(NPC_SHRINE_MAIDEN.PROGRESS >= 0d1) {
                        NPC_SHRINE_MAIDEN.PROGRESS = 0d2;
                        NPC_SHRINE_MAIDEN.SUB_PROGRESS = 0d0;

                        dialog("[SLOW]Bearer of the curse, seek misery.[LF]For misery will lead you to greater, stronger souls.[LF]You will never meet the King with a soul so frail and pallid.[B]");
                    }
                }
                @install()
                fun shrine_maiden_triggered() {
                    if(NPC_SHRINE_MAIDEN.PROGRESS == 0d2) {
                        if(SOULS_MEMORY.ESTUS_SHARDS > 0d00) {
                            greeting_estus_shard();
                        } else {
                            greeting_default();
                        }

                        if(SOULS_MEMORY.ESTUS_SHARDS > 0x00) {
                            question("[SLOW]How can I help you?[CHOICE]talk…[CHOICE]level up…[CHOICE]upgrade…");
                        } else {
                            question("[SLOW]How can I help you?[CHOICE]talk…[CHOICE]level up…");
                        }

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                            story_estus_shard();
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) { // level up
                            upgrade_boy();
                        } else if(MEMORY.QUESTION_ANSWER == 0d2) { // upgrade
                            upgrade_estus();
                        }
                    }
                }
            };

            fun add_souls_npc_shrine_maiden(x, y) {
                add_enemy(NPC_SHRINE_MAIDEN.BODY, x, y, INACTIVE);

                if(NPC_SHRINE_MAIDEN.PROGRESS < 0d2) {
                    attach_script(LAST_ENTITY, B, reference(shrine_maiden_triggered__first_bonfire));
                } else {
                    attach_script(LAST_ENTITY, B, reference(shrine_maiden_triggered));
                }
            }
        };

        group npc_mario() {
            enum NPC_MARIO {
                PROGRESS = memory(BYTE, SRAM),
                SUB_PROGRESS = memory(BYTE, SRAM),

                MARIO_TEASED = memory(FLAG, SRAM),

                // ID = memory(WORD, SRAM),
                BODY = ENEMY.VILLAGER_2_1,
            }

            @install()
            fun npc_mario_dialog_0() {
                conversation({
                    if(NPC_MARIO.PROGRESS == 0d0) {
                        if(NPC_MARIO.SUB_PROGRESS == 0d0) {
                            dialog("[SLOW]Hey, you.[B]");

                            NPC_MARIO.SUB_PROGRESS++;
                        } else if(NPC_MARIO.SUB_PROGRESS == 0d1) {
                            dialog("[SLOW]Have you seen my brother? I seem to have taken a wrong turn down there.[B]");

                            NPC_MARIO.SUB_PROGRESS++;
                        } else if(NPC_MARIO.SUB_PROGRESS == 0d2) {
                            dialog("[SLOW]The three of us were traveling eastwards to the Sewers, before we were separated.[B]");

                            NPC_MARIO.SUB_PROGRESS++;
                        } else if(NPC_MARIO.SUB_PROGRESS == 0d3) {
                            dialog("[SLOW]Please look for my brother. He might be injured.[B]");

                            NPC_MARIO.PROGRESS++;
                            NPC_MARIO.SUB_PROGRESS = 0d0;
                        }
                    } else {
                        dialog("[SLOW]Please hurry![B]");
                    }
                });
            }
            @install()
            fun npc_mario_dialog_1() {
                if(NPC_MARIO.PROGRESS == 0d1) {
                    if(NPC_MARIO.SUB_PROGRESS == 0d0) {
                        if(MEMORY.MUSHROOM <= 0d0) {
                            subtext("…");
                        } else {
                            NPC_MARIO.SUB_PROGRESS++;

                            add_enemy(NPC_MARIO.BODY, 0xe5, 0x27, INACTIVE);
                            face(LAST_ENTITY, WEST);
                            init_map(0xb4, 0x04, 0xfc, 0x36); // room_alchemist

                            
                            subtext("Is that… a… Mushroom?");
                        }
                    } else if(NPC_MARIO.SUB_PROGRESS == 0d1) {
                        conversation({
                            question("[SLOW]Mushroom… please…[CHOICE]give…[CHOICE]leave…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                item_pay(MUSHROOM, 0d1, 0d0);
                                if(CUSTOM_MEMORY.RETURN) {
                                    if(False) {
                                        sound(PURCHASE);
                                    }

                                    dialog("[SLOW]…[B]");

                                    NPC_MARIO.SUB_PROGRESS++;
                                }
                            }
                        });
                    } else if(NPC_MARIO.SUB_PROGRESS == 0d2) {
                        conversation({
                            question("[SLOW]more…[CHOICE]give…[CHOICE]leave…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                item_pay(MUSHROOM, 0d1, 0d0);
                                if(CUSTOM_MEMORY.RETURN) {
                                    if(False) {
                                        sound(PURCHASE);
                                    }

                                    dialog("[SLOW]you saved me…[B]");

                                    NPC_MARIO.PROGRESS++;
                                    NPC_MARIO.SUB_PROGRESS = 0d0;
                                }
                            }
                        });
                    }
                } else {
                    dialog("[SLOW]you saved me…[B]");
                }
            }
            @install()
            fun npc_mario_dialog_2() {
                conversation({
                    if(NPC_MARIO.PROGRESS == 0d2) {
                        if(NPC_MARIO.SUB_PROGRESS == 0d0) {
                            dialog("[SLOW]I followed them to the Sewers all the way from the Kingdom of Mushrooms.[B]");

                            NPC_MARIO.SUB_PROGRESS++;
                        } else if(NPC_MARIO.SUB_PROGRESS == 0d1) {
                            dialog("[SLOW]This should help you navigate within the Sewers.[B]");

                            custom_reward(BIG_MUSHROOM, True);
                            CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;

                            dialog("[SLOW]Press `Start´ to use the Big Mushroom within the Sewers.[B]");

                            NPC_MARIO.PROGRESS++;
                            NPC_MARIO.SUB_PROGRESS = 0d0;
                        }
                    } else {
                        dialog("[SLOW]Use it to help me clear this place from the infestation.[B]");
                    }
                });
            }

            fun add_souls_npc_mario(x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    add_enemy(NPC_MARIO.BODY, x, y, flags);
                } else {
                    add_enemy(NPC_MARIO.BODY, x, y, 0d0);
                }

                if(NPC_MARIO.PROGRESS == 0d0) {
                    attach_script(LAST_ENTITY, B, reference(npc_mario_dialog_0));
                } else if(NPC_MARIO.PROGRESS == 0d1) {
                    attach_script(LAST_ENTITY, B, reference(npc_mario_dialog_1));
                } else {
                    attach_script(LAST_ENTITY, B, reference(npc_mario_dialog_2));
                }
            }
        };

        group npc_isaac() {
            enum NPC_ISAAC {
                FOUND = memory(FLAG, SRAM),
            }
        };
        group npc_maggy() {
            enum NPC_MAGGY {
                FOUND = memory(FLAG, SRAM),

                BODY = ENEMY.VILLAGER_3_4,

                REWARD = ITEM.CHOCOBO_EGG,
            }

            group maggy_ai() {
                @install()
                fun maggy_dialog() {
                    if!(NPC_MAGGY.FOUND) {
                        NPC_MAGGY.FOUND = True;

                        conversation({
                            conversation_dialog("[SLOW]I did not expect any visitors.[B]");
                        });
                    } else {
                        if!(NPC_ISAAC.FOUND && SOULS_MEMORY.ISAAC_WANTED_POSTER) {
                            conversation({
                                conversation_dialog("[SLOW]What do you want from me?[B]");
                            });
                        } else {
                            conversation({
                                conversation_question("[SLOW]What do you want from me?[CHOICE]procecute Magdalena…[CHOICE]leave…");

                                if(MEMORY.QUESTION_ANSWER == 0d0) { // procecute
                                    attribute(SCRIPT_OWNER, INVINCIBLE, False);

                                    conversation_dialog("[SLOW]I knew this day would come…[B]");

                                    attach_script(SCRIPT_OWNER, DEATH, reference(@install() {
                                        souls_quest_progress();

                                        reward(NPC_MAGGY.REWARD);
                                    }));
                                } else { // leave
                                    conversation_dialog("[SLOW]You wasted your chance.[B]");

                                    fade_out();
                                    sleep(0d120);

                                    destroy(SCRIPT_OWNER);

                                    _fade_in();
                                }
                            });
                        }
                    }
                }
            };

            fun add_souls_npc_maggy(x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    add_enemy(NPC_MAGGY.BODY, x, y, flags);
                } else {
                    add_enemy(NPC_MAGGY.BODY, x, y);
                }

                attach_script(LAST_ENTITY, B, reference(maggy_dialog));
            }
        };

        group npc_cat() {
            enum NPC_CAT {
                PRICE_RING_CAT = 0d100,
            }

            group cat_ai() {
                fun response_positive() {
                    if(randrange(0x02) == 0x00) {
                        dialog("[SLOW]Satisfied?[B]");
                    } else {
                        dialog("[SLOW]I'll be around if you ever come back.[B]");
                    }
                }
                fun response_negative() {
                    if(randrange(0x02) == 0x00) {
                        dialog("[SLOW]Nothing suited you, I presume?[B]");
                    } else {
                        dialog("[SLOW]Well, that's dismaying. Hee hee hee…[B]");
                    }
                }
                fun response_cancel() {
                    dialog("[SLOW]Oh my, haste makes waste. Hee hee hee…[B]");
                }

                fun story_radahn_arena() {
                    dialog("[SLOW]You've seen that gaping hole here?[B]Well, there's nasty little vermin down there.[B]Although who you seek is even further below.[B]And has been down there for a very, very long time.[B]He's plumb Rotten by now, I'm sure! Hee hee hee…[B]");
                }

                fun purchase_ring(price) {
                    MEMORY.STRING_PARAMETER_1 = price;

                    show_currency(True);
                    question("[SLOW]Silvercat Ring?[B]`Silver ring depicting a leaping feline. Reduces damage from falling. Legend has it that when cats grow old, a force brews within them, and they are reborn as something new.´[B]Are you interested?[CHOICE][MEM1] Souls[CHOICE]no.");

                    sleep(0x10);
                    
                    if(MEMORY.QUESTION_ANSWER == 0d0) { // yes
                        if_currency(MEMORY.CURRENCY_CURRENT < price) {
                            dialog("[SLOW]…[B]");
                        } else {
                            sound(PURCHASE);
                            currency_take(TALONS, price);
                            show_currency(True);

                            reward(GLOVE_3_2);

                            response_positive();
                        }
                    } else { // no
                        response_negative();
                    }

                    show_currency(False);
                }

                @install()
                fun cat_triggered() {
                    dialog("[SLOW]Oh, yes. You can call me Shalquoir. Enchante.[B]");

                    if!(MEMORY.GLOVE_3_2) {
                        question("[SLOW]How can I help you?[CHOICE]talk…[CHOICE]buy…");
                    } else {
                        question("[SLOW]How can I help you?[CHOICE]talk…");
                    }

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                        story_radahn_arena();
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // purchase
                        purchase_ring(NPC_CAT.PRICE_RING_CAT);
                    } else {
                        response_negative();
                    }
                }
            };

            enum CAT_VARIANT {
                LOOKING = 0x00,
                CLEANING = 0x01,
            }

            fun add_souls_npc_cat(variant:CAT_VARIANT, x, y) {
                if(variant == CAT_VARIANT.LOOKING) {
                    add_placeholder(CAT_LOOKING, x, y);
                } else {
                    add_placeholder(CAT_CLEANING_1, x, y);
                }

                attach_script(LAST_ENTITY, B, reference(cat_triggered));
            }
        };

        group npc_smith() {
            enum NPC_SMITH {
                PROGRESS = memory(BYTE, SRAM),

                BODY = ENEMY.TINY,
            }
            
            group smith_ai() {
                fun response_greeting() {
                    arg[0x00] = randrange(0x04);

                    if(arg[0x00] == 0x00) {
                        dialog("[SLOW]What? You again?[B]");
                    } else if(arg[0x00] == 0x01) {
                        dialog("[SLOW]You again? Can't you see that I'm busy?[B]");
                    } else if(arg[0x00] == 0x02) {
                        dialog("[SLOW]Hmph, I'd given you up for dead. Almost had me worried, really…[B]");
                    } else {
                        dialog("[SLOW]I knew you'd be around soon. Go on, show me what you've got.[B]");
                    }
                }

                fun response_positive() {
                    arg[0x00] = randrange(0x03);

                    if(arg[0x00] == 0x00) {
                        dialog("[SLOW]I'll be around, if you make it back.[B]");
                    } else if(arg[0x00] == 0x01) {
                        dialog("[SLOW]How goes your journey?[B]");
                    } else {
                        dialog("[SLOW]Take these. They should help a bit.[B]");
                    }
                }
                fun response_negative() {
                    dialog("[SLOW]Hmph. Don't waste my time.[B]");
                }

                group progress_0() {
                    @install()
                    fun smith_0_triggered() {
                        conversation({
                            if(NPC_SMITH.PROGRESS == 0d1) {
                                dialog("[SLOW]Thanks.[B]");

                                conversation_end(True);
                                end();
                            }

                            if(False) {
                                response_greeting();
                            }

                            if!(SOULS_MEMORY.SMITH_KEY) {
                                dialog("[SLOW]I can't find my key, I must have left it in my shop in the town.[B]");
                            } else {
                                question("[SLOW]I can't find my key, I must have left it in my shop in the town.[CHOICE]give…[CHOICE]leave…", 0d5);

                                if(MEMORY.QUESTION_ANSWER == 0d0) { // give key
                                    NPC_SMITH.PROGRESS = 0d1;

                                    SOULS_MEMORY.SMITH_KEY = False;

                                    dialog("[SLOW]Thanks.[B]");
                                } else { // leave
                                    response_negative();
                                }   
                            }
                        });
                    }
                };

                group progress_1() {
                    enum WEAPON_UPGRADE {
                        UPGRADE_1_TYPE_1 = ITEM.MONEY,
                        UPGRADE_1_AMOUNT_1 = 0d50,
                        UPGRADE_1_TYPE_2 = ITEM.NO_ITEM,
                        UPGRADE_1_AMOUNT_2 = 0d0,

                        UPGRADE_2_TYPE_1 = ITEM.IRON,
                        UPGRADE_2_AMOUNT_1 = 0d2,
                        UPGRADE_2_TYPE_2 = ITEM.NO_ITEM,
                        UPGRADE_2_AMOUNT_2 = 0d0,

                        UPGRADE_3_TYPE_1 = ITEM.IRON,
                        UPGRADE_3_AMOUNT_1 = 0d4,
                        UPGRADE_3_TYPE_2 = ITEM.NO_ITEM,
                        UPGRADE_3_AMOUNT_2 = 0d0,

                        UPGRADE_4_TYPE_1 = ITEM.METEORITE,
                        UPGRADE_4_AMOUNT_1 = 0d1,
                        UPGRADE_4_TYPE_2 = ITEM.IRON,
                        UPGRADE_4_AMOUNT_2 = 0d2,
                    }

                    fun upgrade_weapon(type_1, amount_1, type_2, amount_2) {
                        text_start();

                        MEMORY.STRING_PARAMETER_1 = amount_1;
                        text("This costs [MEM1] ");
                        item_to_string(type_1);

                        if(type_2 != ITEM.NO_ITEM) {
                            MEMORY.STRING_PARAMETER_1 = amount_2;
                            text(" and [MEM1] ");
                            item_to_string(type_2);
                        }

                        text("[CHOICE]yes…[CHOICE]no…");
                        await_answer();
                        text_end();

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            trade_custom_items(NO_ITEM, 0d0, type_1, amount_1, type_2, amount_2);
                        } else {
                            CUSTOM_MEMORY.RETURN = False;
                        }
                    }

                    @install()
                    fun upgrade_act_1_weapon() {
                        upgrade_weapon(WEAPON_UPGRADE.UPGRADE_1_TYPE_1, WEAPON_UPGRADE.UPGRADE_1_AMOUNT_1, WEAPON_UPGRADE.UPGRADE_1_TYPE_2, WEAPON_UPGRADE.UPGRADE_1_AMOUNT_2);
                    }
                    @install()
                    fun upgrade_act_2_weapon() {
                        upgrade_weapon(WEAPON_UPGRADE.UPGRADE_2_TYPE_1, WEAPON_UPGRADE.UPGRADE_2_AMOUNT_1, WEAPON_UPGRADE.UPGRADE_2_TYPE_2, WEAPON_UPGRADE.UPGRADE_2_AMOUNT_2);
                    }
                    @install()
                    fun upgrade_act_3_weapon() {
                        upgrade_weapon(WEAPON_UPGRADE.UPGRADE_3_TYPE_1, WEAPON_UPGRADE.UPGRADE_3_AMOUNT_1, WEAPON_UPGRADE.UPGRADE_3_TYPE_2, WEAPON_UPGRADE.UPGRADE_3_AMOUNT_2);
                    }
                    @install()
                    fun upgrade_act_4_weapon() {
                        upgrade_weapon(WEAPON_UPGRADE.UPGRADE_4_TYPE_1, WEAPON_UPGRADE.UPGRADE_4_AMOUNT_1, WEAPON_UPGRADE.UPGRADE_4_TYPE_2, WEAPON_UPGRADE.UPGRADE_4_AMOUNT_2);
                    }

                    fun reward_upgrade(orb:SOULS_MEMORY, weapon:ITEM) {
                        if(CUSTOM_MEMORY.RETURN) {
                            orb--;
                            reward(weapon, True);
                            SOULS_MEMORY.ORB_USED = True;

                            response_positive();
                        } else {
                            response_negative();
                        }
                    }

                    fun response_upgrade_weapon() {
                        if(
                            ((SOULS_MEMORY.ORB_SWORD > 0x00) && !(FLAG.SWORD_4)) ||
                            ((SOULS_MEMORY.ORB_AXE > 0x00) && !(FLAG.AXE_4)) ||
                            ((SOULS_MEMORY.ORB_SPEAR > 0x00) && !(FLAG.SPEAR_4))
                        ) {
                            text_start();
                            text("[SLOW]Which weapon?");

                            if((SOULS_MEMORY.ORB_SWORD > 0x00) && !(FLAG.SWORD_4)) {
                                text("[CHOICE]Sword…");
                            } else {
                                text("[CHOICE]…");
                            }

                            if((SOULS_MEMORY.ORB_AXE > 0x00) && !(FLAG.AXE_4)) {
                                text("[CHOICE]Axe…");
                            } else {
                                text("[CHOICE]…");
                            }

                            if((SOULS_MEMORY.ORB_SPEAR > 0x00) && !(FLAG.SPEAR_4)) {
                                text("[CHOICE]Spear…");
                            } else {
                                text("[CHOICE]…");
                            }

                            await_answer();
                            text_end();
                            control(BOTH);

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                if!((SOULS_MEMORY.ORB_SWORD > 0x00) && !(FLAG.SWORD_4)) {
                                    response_negative();
                                    end();
                                }

                                if!(FLAG.SWORD_1) {
                                    upgrade_act_1_weapon();

                                    reward_upgrade(ORB_SWORD, SWORD_1);
                                } else if!(FLAG.SWORD_2) {
                                    if(SOULS_MEMORY.WITH_CHEAP_SWORD2) {
                                        upgrade_act_1_weapon();
                                    } else {
                                        upgrade_act_2_weapon();
                                    }

                                    reward_upgrade(ORB_SWORD, SWORD_2);
                                } else if!(FLAG.SWORD_3) {
                                    upgrade_act_3_weapon();

                                    reward_upgrade(ORB_SWORD, SWORD_3);
                                } else if!(FLAG.SWORD_4) {
                                    upgrade_act_4_weapon();

                                    reward_upgrade(ORB_SWORD, SWORD_4);
                                } else {
                                    response_negative();
                                }
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                                if!((SOULS_MEMORY.ORB_AXE > 0x00) && !(FLAG.AXE_4)) {
                                    response_negative();
                                    end();
                                }

                                if!(FLAG.AXE_1) {
                                    upgrade_act_1_weapon();

                                    reward_upgrade(ORB_AXE, AXE_1);
                                } else if!(FLAG.AXE_2) {
                                    upgrade_act_2_weapon();

                                    reward_upgrade(ORB_AXE, AXE_2);
                                } else if!(FLAG.AXE_3) {
                                    upgrade_act_3_weapon();

                                    reward_upgrade(ORB_AXE, AXE_3);
                                } else if!(FLAG.AXE_4) {
                                    upgrade_act_4_weapon();

                                    reward_upgrade(ORB_AXE, AXE_4);
                                } else {
                                    response_negative();
                                }
                            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                                if!((SOULS_MEMORY.ORB_SPEAR > 0x00) && !(FLAG.SPEAR_4)) {
                                    response_negative();
                                    end();
                                }

                                if!(FLAG.SPEAR_1) {
                                    upgrade_act_1_weapon();

                                    reward_upgrade(ORB_SPEAR, SPEAR_1);
                                } else if!(FLAG.SPEAR_2) {
                                    upgrade_act_2_weapon();

                                    reward_upgrade(ORB_SPEAR, SPEAR_2);
                                } else if!(FLAG.SPEAR_3) {
                                    upgrade_act_3_weapon();

                                    reward_upgrade(ORB_SPEAR, SPEAR_3);
                                } else if!(FLAG.SPEAR_4) {
                                    upgrade_act_4_weapon();

                                    reward_upgrade(ORB_SPEAR, SPEAR_4);
                                } else {
                                    response_negative();
                                }
                            } else {
                                response_negative();
                            }
                        } else {
                            dialog("[SLOW]Bring me a weapon orb, and I'll forge you a better weapon.[B]");
                        }
                    }

                    fun story_pickaxe() {
                        question("[SLOW]Something to dig? Bring me 5 Iron.[CHOICE]yes…[CHOICE]no…");

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            item_pay(IRON, 0d5);
                            if(CUSTOM_MEMORY.RETURN) {
                                custom_reward(PICKAXE_HEAD, True);

                                conversation_dialog("[SLOW]I can't help you with the handle, though.[B]");
                            } else {
                                response_negative();
                            }
                        } else {
                            response_negative();
                        }
                    }

                    @install()
                    fun smith_1_triggered() {
                        conversation({
                            response_greeting();

                            question("[SLOW]How can I help you?[CHOICE]talk…[CHOICE]upgrade…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                                if(NPC_SHARED.STORY_PICKAXE && (!SOULS_MEMORY.PICKAXE_HEAD) && (!SOULS_MEMORY.PICKAXE)) {
                                    story_pickaxe();
                                } else {
                                    subtext("todo");
                                }
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) { // purchase
                                response_upgrade_weapon();
                            } else {
                                response_negative();
                            }
                        });
                    }
                };
            };
            
            fun add_souls_npc_smith(x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    add_enemy(NPC_SMITH.BODY, x, y, flags);
                } else {
                    add_enemy(NPC_SMITH.BODY, x, y, 0d0);
                }

                if(NPC_SMITH.PROGRESS == 0d0) {
                    attach_script(LAST_ENTITY, B, reference(smith_0_triggered));
                } else {
                    attach_script(LAST_ENTITY, B, reference(smith_1_triggered));
                }
            }
        };

        group npc_crafter() {
            enum NPC_CRAFTER {
                PROGRESS = memory(BYTE, SRAM),

                BODY = ENEMY.VILLAGER_1_4,

                PRICE_MUSHROM_HELMET = 0d5,
                PRICE_MUSHROM_CHEST = 0d8,
                PRICE_MUSHROM_GLOVE = 0d5,

                STORY_HELM_ARCHAEOLOGY = memory(FLAG, SRAM),
            }

            group crafter_ai() {
                group crafting() {
                    fun _craft_armor(armor:ITEM, price) {
                        trade_items(NO_ITEM, 0d0, TAPESTRY, 0d1, MUSHROOM, price);
                        
                        if(CUSTOM_MEMORY.RETURN) {
                            reward(armor);
                        }

                        control(BOTH);
                    }
                    
                    fun craft_armor() {
                        MEMORY.STRING_PARAMETER_1 = NPC_CRAFTER.PRICE_MUSHROM_HELMET;
                        MEMORY.STRING_PARAMETER_2 = NPC_CRAFTER.PRICE_MUSHROM_CHEST;
                        MEMORY.STRING_PARAMETER_3 = NPC_CRAFTER.PRICE_MUSHROM_GLOVE;
                        question("[SLOW]This is what I can offer for a tapestry and some mushrooms…[CHOICE]Helm ([MEM1])[CHOICE]Chest ([MEM2])[CHOICE]Glove ([MEM3])", 0d6);

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            _craft_armor(HELM_1_1, MEMORY.STRING_PARAMETER_1);
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                            _craft_armor(CHEST_1_1, MEMORY.STRING_PARAMETER_2);
                        } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                            _craft_armor(GLOVE_1_1, MEMORY.STRING_PARAMETER_3);
                        }

                        if(SOULS_MEMORY.DEAD_STOMPY_RADAHN && (MEMORY.GLOVE_3_3 == 0d0)) {
                            question("[SLOW]Are those actual dragon claws? With two tapestry I can craft you the perfect gloves…[CHOICE]yes…[CHOICE]no…", 0d5);

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                trade_items(NO_ITEM, 0d0, TAPESTRY, 0d2);
                                
                                if(CUSTOM_MEMORY.RETURN) {
                                    reward(GLOVE_3_3);
                                }

                                control(BOTH);
                            }
                        }
                    }
                };

                fun response_greeting() {
                    arg[0x00] = randrange(0x04);

                    if(arg[0x00] == 0d0) {
                        dialog("[SLOW]If you bring me the right material I can craft you almost anything. Preferably mushrooms based armor, though.[B]");
                    } else if(arg[0x00] == 0d1) {
                        dialog("[SLOW]Do you have spare mushrooms? I can make them more useful for you.[B]");
                    } else if(arg[0x00] == 0d2) {
                        dialog("[SLOW]Are you in the need of some crafting?[B]");
                    } else {
                        dialog("[SLOW]People usually underestimate the usefulness of agility items.[B]");
                    }
                }

                fun response_positive() {
                    arg[0x00] = randrange(0x03);

                    if(arg[0x00] == 0x00) {
                        dialog("[SLOW]Go and slay some big game with that armor.[B]");
                    } else if(arg[0x00] == 0x01) {
                        dialog("[SLOW]Go and hunt some monster with that armor.[B]");
                    } else {
                        dialog("[SLOW]That armor really suits you.[B]");
                    }
                }
                fun response_negative() {
                    dialog("[SLOW]I assume you're not into crafting.[B]");
                }

                @install()
                fun crafter_market_triggered() {
                    conversation({
                        if(NPC_CRAFTER.PROGRESS == 0d0) {
                            NPC_CRAFTER.PROGRESS++;

                            conversation({
                                conversation_dialog("[SLOW]How can the market be out of all exotic crafting materials so early?[B]");
                            });
                        } else if(NPC_CRAFTER.PROGRESS == 0d1) {
                            NPC_CRAFTER.PROGRESS = 0x10;

                            conversation({
                                conversation_dialog("[SLOW]After some trading I managed to find the source of the Limestone Tablets. Apparently they can be found in the temple, just lying on the floor.[B]");
                            });
                        } else {
                            dialog("[SLOW]I really need one of those for a craft…[B]");
                        }
                    });
                }
                @install()
                fun crafter_temple_triggered() {
                    conversation({
                        if(NPC_CRAFTER.PROGRESS == 0x10) {
                            conversation({
                                conversation_question("[SLOW]I don't think I'll get out of here alive…[CHOICE]invite…[CHOICE]leave…");
                                    
                                if(MEMORY.QUESTION_ANSWER == 0d0) { // invite
                                    NPC_CRAFTER.PROGRESS = 0x30;

                                    conversation_dialog("[SLOW]Let me know when you need some crafting…[B]");
                                } else {
                                    conversation_dialog("[SLOW]I fear I'm stuck…[B]");
                                }
                            });
                        } else {
                            dialog("[SLOW]I'm glad you ran into me…[B]");
                        }
                    });
                }
                @install()
                fun crafter_shrine_triggered() {
                    conversation({
                        response_greeting();

                        question("[SLOW]How can I help you?[CHOICE]talk…[CHOICE]craft…");

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                            if((SOULS_MEMORY.PICKAXE_HEAD) && (SOULS_MEMORY.PICKAXE_SHAFT) && (!SOULS_MEMORY.PICKAXE)) {
                                    conversation_dialog("[SLOW]Let me attach that for you…[B]");

                                    custom_reward(PICKAXE, True);

                                    conversation_dialog("[SLOW]Now you are ready for your first archaeology adventure![B]");
                            } else if((MEMORY.HELM_4_3 > 0d0) && (!NPC_CRAFTER.STORY_HELM_ARCHAEOLOGY)) {
                                NPC_CRAFTER.STORY_HELM_ARCHAEOLOGY = True;

                                conversation_dialog("[SLOW]How did you get that ancient helmet in your possession?![B]I only heard stories about this technology so far.[B]Press [Start]+[L] to use it.[B]It should be able to locate ancient hidden treasures with ease.[B]");

                                if((!SOULS_MEMORY.PICKAXE_HEAD) && (!SOULS_MEMORY.PICKAXE)) {
                                    conversation_dialog("[SLOW]You'll need something to dig, though.[B]Maybe the smith can help you.[B]");

                                    NPC_SHARED.STORY_PICKAXE = True;
                                }
                            } else if(SOULS_MEMORY.DEAD_WALL && (!NPC_SHARED.STORY_PICKAXE)) {
                                    conversation_dialog("[SLOW]You actually went back and defused the trap, and that sparked your interest in archaeology?[B]First step would be to dig something up.[B]Maybe the smith can help you with that.[B]");

                                    NPC_SHARED.STORY_PICKAXE = True;
                            } else {
                                subtext("todo");
                            }
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) { // craft
                            craft_armor();
                        } else {
                            response_negative();
                        }
                    });
                }
            };
            
            fun add_souls_npc_crafter(x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    add_enemy(NPC_CRAFTER.BODY, x, y, flags);
                } else {
                    add_enemy(NPC_CRAFTER.BODY, x, y, 0d0);
                }

                if(NPC_CRAFTER.PROGRESS < 0x10) {
                    attach_script(LAST_ENTITY, B, reference(crafter_market_triggered));
                } else if(NPC_CRAFTER.PROGRESS < 0x20) {
                    attach_script(LAST_ENTITY, B, reference(crafter_temple_triggered));
                } else if(NPC_CRAFTER.PROGRESS >= 0x20) {
                    attach_script(LAST_ENTITY, B, reference(crafter_shrine_triggered));
                }
            }
        };

        group npc_archaeologist() {
            enum NPC_ARCHAEOLOGIST {
                PROGRESS = memory(BYTE, SRAM),

                BODY = ENEMY.HORACE,
            }

            group archaeologist_ai() {
                fun response_positive() {
                    arg[0x00] = randrange(0x03);

                    if(arg[0x00] == 0x00) {
                        dialog("[SLOW]Go and slay some big game with that armor.[B]");
                    } else if(arg[0x00] == 0x01) {
                        dialog("[SLOW]Go and hunt some monster with that armor.[B]");
                    } else {
                        dialog("[SLOW]That armor really suits you.[B]");
                    }
                }
                fun response_negative() {
                    dialog("[SLOW]I assume you're not into crafting.[B]");
                }
            };

            fun add_souls_npc_archaeologist(x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    add_enemy(NPC_ARCHAEOLOGIST.BODY, x, y, flags);
                } else {
                    add_enemy(NPC_ARCHAEOLOGIST.BODY, x, y, 0d0);
                }

                // #0 volcano path, empty level?, subtle whispers ("The entrance to a forgotten culture must be here. I'm glad I brought my excavation gear all the way up this mountain.")
                // #1 volcano tower, bottom U ("A tower made of trash? That can't be the product of the culture I'm looking for. Maybe I can find a clue further East.")
                // #2 western inbetwixx/western waterfall (if open), ("Apparently I missed bringing the heavy gear." || "Apparently I missed bringing my climbing gear.", "My sources told me about a second lead. An abandond excavation site South of this dead end.")
                // #3 eastern crossing, small island (requires stone), ("Those pesky raptors. Once the coast is clear I'll descent and make the final dash to the excavation site.")
                // #4 horace camp, after acid rain

                if(NPC_ARCHAEOLOGIST.PROGRESS == 0d0) {
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d0) {
                                NPC_ARCHAEOLOGIST.PROGRESS++;

                                conversation_dialog("[SLOW]The entrance to a forgotten culture must be here. I'm glad I carried my excavation gear all the way up this mountain.[B]");
                            } else {
                                response_positive();
                            }
                        });
                    }));
                } else if(NPC_ARCHAEOLOGIST.PROGRESS == 0d1) {
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d1) {
                                NPC_ARCHAEOLOGIST.PROGRESS++;

                                conversation_dialog("[SLOW]A tower made of trash? That can't be the product of the culture I'm looking for. Maybe I can find a clue further East.[B]");
                            } else {
                                response_positive();
                            }
                        });
                    }));
                } else if(NPC_ARCHAEOLOGIST.PROGRESS == 0d2) {
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d2) {
                                NPC_ARCHAEOLOGIST.PROGRESS++;

                                if(MEMORY.CURRENT_MAP == MAP.RIVER) {
                                    conversation_dialog("[SLOW]Apparently I missed bringing the heavy gear.[B]");
                                } else {
                                    conversation_dialog("[SLOW]Apparently I missed bringing my climbing gear.");
                                }

                                conversation_dialog("My sources told me about a second lead. An abandond excavation site South of this dead end.[B]");
                            } else {
                                response_positive();
                            }
                        });
                    }));
                } else if(NPC_ARCHAEOLOGIST.PROGRESS == 0d3) {
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d3) {
                                NPC_ARCHAEOLOGIST.PROGRESS = 0x10;

                                conversation_dialog("[SLOW]Those pesky raptors. Once the coast is clear I'll descent and make the final dash to the excavation site.[B]");
                            } else {
                                response_negative();
                            }
                        });
                    }));
                } else if(NPC_ARCHAEOLOGIST.PROGRESS >= 0x10) {
                    NPC_ARCHAEOLOGIST.PROGRESS++;

                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if(NPC_ARCHAEOLOGIST.PROGRESS >= 0x10) {
                                if(NPC_ARCHAEOLOGIST.PROGRESS < 0x13) {
                                    conversation_question("[SLOW]Did you already inspect the excavated relics?[B]This place raises so many questions.[CHOICE]talk…[CHOICE]leave…");
                                } else {
                                    conversation_question("[SLOW]I don't feel so well…[CHOICE]talk…[CHOICE]leave…");
                                }
                                    
                                if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                                    conversation_dialog("[SLOW]It's like armor from a dead world. Bronze wouldn't rot like this. And it's far too heavy. This wasn't made for battle… It was made for survival. Against what?[B]");
                                } else {
                                    conversation_dialog("[SLOW]This seems like something big…[B]");
                                }
                            } else {
                                dialog("[SLOW]I'm glad you ran into me…[B]");
                            }
                        });
                    }));
                }
            }
        };

        group npc_smith_key_lady() {
            group smith_ai() {
                fun response_greeting() {
                    arg[0x00] = randrange(0d3);

                    if(arg[0x00] == 0d0) {
                        dialog("[SLOW]Buy something, anything… Come, now… help an old woman… Keh heh heh…[B]");
                    } else if(arg[0x00] == 0d1) {
                        dialog("[SLOW]Oh, you again. Go on… it's on the cheap for you… Keh heh heh…[B]");
                    } else {
                        dialog("[SLOW]Buy something, anything… Don't abandon a poor old woman… I knew you'd be back.[B]");
                    }
                }

                fun response_positive() {
                    arg[0x00] = randrange(0d2);

                    if(arg[0x00] == 0d0) {
                        dialog("[SLOW]Thank you kindly. Keh heh heh…[B]");
                    } else if(arg[0x00] == 0d1) {
                        dialog("[SLOW]It's high time that I pick up and move. I've a bargain for you, next time we meet, my love.[B]");
                    }
                }
                fun response_negative() {
                    dialog("[SLOW]Lowly times, these are…[B]");
                }

                @install()
                fun smith_key_triggered() {
                    response_greeting();

                    question("[SLOW]How can I help you?[CHOICE]talk…[CHOICE]upgrade…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                        subtext("todo");
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // purchase
                        subtext("todo");
                    } else {
                        response_negative();
                    }
                }
            };
            
            fun add_souls_npc_smith_key(x, y) {
                add_enemy(VILLAGER_2_6, x, y, INACTIVE);
                attach_script(LAST_ENTITY, B, reference(smith_key_triggered));
            }
        };

        group npc_bee_boy() {
            enum NPC_BEE_BOY {
                PROGRESS = memory(BYTE, SRAM),

                REWARD_1_COLLECTED = memory(FLAG, SRAM),
                REWARD_2_COLLECTED = memory(FLAG, SRAM),
                REWARD_3_COLLECTED = memory(FLAG, SRAM),
                REWARD_4_COLLECTED = memory(FLAG, SRAM),
            }

            group bee_boy_ai() {
                fun response_positive() {
                    dialog("[SLOW]If you bring me enough bees I'll reward you with some treasures I found…[B]");
                }
                fun response_negative() {
                    dialog("[SLOW]Bring me more bees…[B]");
                }

                @install()
                fun add_following_bee(entity) {
                    while(entity[GENERAL_PURPOSE] != 0x0000) {
                        entity = entity[GENERAL_PURPOSE];
                    }

                    MEMORY.NEXT_ENEMY_FOLLOWS_ENTITY = entity;
                    _add_enemy(BEE, entity[X], entity[Y]);
                    <LAST_ENTITY>[GENERAL_PURPOSE] = 0x0000;

                    entity[GENERAL_PURPOSE] = <LAST_ENTITY>;
                }

                fun bee_reward(flag, item) {
                    flag = True;

                    custom_reward(item, True);

                    add_following_bee(<SCRIPT_OWNER>);
                    arg[0x10] = True;
                }

                fun request_reward() {
                    if((!NPC_BEE_BOY.REWARD_1_COLLECTED) && (NPC_BEE_BOY.PROGRESS >= SOULS_MEMORY.COST_BEE_BOY_QUEST_1)) {
                        bee_reward(NPC_BEE_BOY.REWARD_1_COLLECTED, SOULS_MEMORY.REWARD_BEE_BOY_QUEST_1);
                    }
                    if((!NPC_BEE_BOY.REWARD_2_COLLECTED) && (NPC_BEE_BOY.PROGRESS >= SOULS_MEMORY.COST_BEE_BOY_QUEST_2)) {
                        bee_reward(NPC_BEE_BOY.REWARD_2_COLLECTED, SOULS_MEMORY.REWARD_BEE_BOY_QUEST_2);
                    }
                    if((!NPC_BEE_BOY.REWARD_3_COLLECTED) && (NPC_BEE_BOY.PROGRESS >= SOULS_MEMORY.COST_BEE_BOY_QUEST_3)) {
                        bee_reward(NPC_BEE_BOY.REWARD_3_COLLECTED, SOULS_MEMORY.REWARD_BEE_BOY_QUEST_3);
                    }
                    if((!NPC_BEE_BOY.REWARD_4_COLLECTED) && (NPC_BEE_BOY.PROGRESS >= SOULS_MEMORY.COST_BEE_BOY_QUEST_4)) {
                        bee_reward(NPC_BEE_BOY.REWARD_4_COLLECTED, SOULS_MEMORY.REWARD_BEE_BOY_QUEST_4);
                    }
                    
                    if(NPC_BEE_BOY.PROGRESS >= SOULS_MEMORY.COST_BEE_BOY_QUEST_4) {
                        dialog("[SLOW]That was my last treasure…[B]");
                    } else if(arg[0x10]) {
                        response_positive();
                    } else {
                        response_negative();
                    }
                }

                @install()
                fun bee_boy_triggered_initial() {
                    conversation({
                        if!(SOULS_MEMORY.BUG_CATCHER_BROKEN) {
                            conversation_dialog("[SLOW]Something is missing in my life…[B]");
                        } else if!(SOULS_MEMORY.BUG_CATCHER) {
                            conversation_question("[SLOW]Can you help me to find more bees?[CHOICE]help…[CHOICE]leave…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) { // help
                                custom_reward(BUG_CATCHER, True);

                                conversation_dialog("[SLOW]I attached it to your bone, so use it to collect them![B]");
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) { // leave
                                response_negative();
                            } else {
                                response_negative();
                            }   
                        } else {
                            response_negative();
                        }
                    });
                }
                @install()
                fun bee_boy_triggered() {
                    conversation({
                        if(NPC_BEE_BOY.PROGRESS < SOULS_MEMORY.COST_BEE_BOY_QUEST_4) {
                            arg[0x10] = SOULS_MEMORY.BEES - NPC_BEE_BOY.PROGRESS;

                            if(arg[0x10] > 0d0) {
                                if(arg[0x10] == 0d1) {
                                    question("[SLOW]You brought me only 1 bee?[CHOICE]give…[CHOICE]leave…");
                                } else {
                                    MEMORY.STRING_PARAMETER_1 = arg[0x10];
                                    question("[SLOW]You brought me [MEM1] bees?[CHOICE]give…[CHOICE]leave…");
                                }

                                if(MEMORY.QUESTION_ANSWER == 0d0) { // give
                                    NPC_BEE_BOY.PROGRESS = SOULS_MEMORY.BEES;
                                    request_reward();
                                } else if(MEMORY.QUESTION_ANSWER == 0d1) { // leave
                                    response_negative();
                                } else {
                                    response_negative();
                                }
                            } else {
                                response_negative();
                            }
                        } else {
                            dialog("[SLOW]I hope they aren't extinct now…[B]");
                        }
                    });
                }
            };
            
            fun add_souls_npc_bee_boy(x, y) {
                add_enemy(VILLAGER_1_2, x, y);
                arg[0x10] = <LAST_ENTITY>;
                <LAST_ENTITY>[GENERAL_PURPOSE] = 0x0000;

                if!(SOULS_MEMORY.BUG_CATCHER) {
                    attach_script(LAST_ENTITY, B, reference(bee_boy_triggered_initial));
                } else {
                    attach_script(LAST_ENTITY, B, reference(bee_boy_triggered));
                }

                if(NPC_BEE_BOY.REWARD_1_COLLECTED) {
                    add_following_bee(arg[0x10]);
                }
                if(NPC_BEE_BOY.REWARD_2_COLLECTED) {
                    add_following_bee(arg[0x10]);
                }
                if(NPC_BEE_BOY.REWARD_3_COLLECTED) {
                    add_following_bee(arg[0x10]);
                }
                if(NPC_BEE_BOY.REWARD_4_COLLECTED) {
                    add_following_bee(arg[0x10]);
                }
            }
        };

        group npc_dog_lady() {
            enum NPC_DOG_LADY {
                PROGRESS = memory(BYTE, SRAM),

                BODY = ENEMY.VILLAGER_2_4,

                STORY_CHICKEN = memory(FLAG, SRAM),
            }

            group dog_lady_ai() {
                fun response_greeting() {
                    arg[0x00] = randrange(0d2);

                    if(arg[0x00] == 0d0) {
                        dialog("[SLOW]What a sweet dog you have.[B]");
                    } else {
                        dialog("[SLOW]Great to see you both.[B]");
                    }
                }

                fun response_positive() {
                    arg[0x00] = randrange(0d2);

                    if(arg[0x00] == 0d0) {
                        dialog("[SLOW]Treats can do wonders on a moody day.[B]");
                    } else {
                        dialog("[SLOW]Let me know if you want to talk dog nutritions.[B]");
                    }
                }
                fun response_negative() {
                    dialog("[SLOW]You should treat your partner more often.[B]");
                }

                @install()
                fun dog_lady_dialog_0() {
                    conversation({
                        if(NPC_DOG_LADY.PROGRESS == 0d0) {
                            if(SOULS_MEMORY.BONFIRE_FIRST_TRIGGER) {
                                conversation_question("[SLOW]What a lovely dog… Do you need help training?[CHOICE]invite…[CHOICE]leave…");
                                
                                if(MEMORY.QUESTION_ANSWER == 0d0) { // help
                                    NPC_DOG_LADY.PROGRESS++;

                                    conversation_dialog("[SLOW]I'll be on my way.[B]");
                                }
                            } else {
                                conversation_dialog("[SLOW]I… I don't know where to go now…[B]");
                            }
                        } else {
                            conversation_dialog("[SLOW]I'll be on my way.[B]");
                        }
                    });
                }

                fun choose_dog() {
                    control(NONE);
                    text_box(0d10, 0d5);

                    text("[SLOW]What is you favorite dog?");
                    if(SOULS_MEMORY.CLEARED_TRAP_WOLF) {
                        text("[CHOICE]Wolf");
                    } else {
                        text("[CHOICE]…");
                    }
                    if(SOULS_MEMORY.CLEARED_TRAP_GREYHOUND) {
                        text("[CHOICE]Greyhound");
                    } else {
                        text("[CHOICE]…");
                    }
                    if(SOULS_MEMORY.CLEARED_TRAP_POODLE) {
                        text("[CHOICE]Poodle");
                    } else {
                        text("[CHOICE]…");
                    }
                    await_answer();
                    text_end();
                    control(BOTH);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // wolf
                        if(SOULS_MEMORY.CLEARED_TRAP_WOLF) {
                            SOULS_MEMORY.DOG_PREFERENCE = DOG.WOLF;
                            MEMORY.DOG_WRITE = DOG.WOLF;

                            response_positive();
                        } else {
                            response_negative();
                        }
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // greyhound
                        if(SOULS_MEMORY.CLEARED_TRAP_GREYHOUND) {
                            SOULS_MEMORY.DOG_PREFERENCE = DOG.GREYHOUND;
                            MEMORY.DOG_WRITE = DOG.GREYHOUND;

                            response_positive();
                        } else {
                            response_negative();
                        }
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) { // poodle
                        if(SOULS_MEMORY.CLEARED_TRAP_POODLE) {
                            SOULS_MEMORY.DOG_PREFERENCE = DOG.POODLE;
                            MEMORY.DOG_WRITE = DOG.POODLE;

                            response_positive();
                        } else {
                            response_negative();
                        }
                    } else {
                        response_negative();
                    }
                }

                fun nurse_chicken() {
                    question("[SLOW]That is one angry looking chicken.[B]Can I nurse it back up[CHOICE]yes…[CHOICE]no…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // yes
                        item_pay(CHICKEN, 0d1);

                        custom_reward(PUPPER_MODE, True);
                        
                        dialog("[SLOW]I wonder what startled that poor little fellow.[B]");
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // no
                        dialog("[SLOW]Poor soul.[B]");
                    } else {
                        response_negative();
                    }
                }

                fun reward_formula() {
                    dialog("todo: reward(revive)[B]");

                    reward(REVIVE);
                    select_alchemy(REVIVE);

                    // music(BUGMUCK_AMBIENT_MELODY);

                    dialog("todo: explain(revive)[B]");
                }
                
                @install()
                fun dog_lady_dialog_1() {
                    conversation({
                        // conversation_dialog("[SLOW]TODO.[B]");

                        response_greeting();

                        question("[SLOW]What do you want to talk about?[CHOICE]talk…[CHOICE]favorite dog…");

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                            if((!FLAG.REVIVE) && (SOULS_MEMORY.CLEARED_TRAP_WOLF) && (SOULS_MEMORY.CLEARED_TRAP_GREYHOUND) && (SOULS_MEMORY.CLEARED_TRAP_POODLE) && (SOULS_MEMORY.DEAD_TOASTER_ARENA)) {
                                reward_formula();
                            } else if((!SOULS_MEMORY.PUPPER_ENABLED) && (MEMORY.CHICKEN > 0d0)) {
                                nurse_chicken();
                            } else if!(NPC_DOG_LADY.STORY_CHICKEN) {
                                NPC_DOG_LADY.STORY_CHICKEN = True;

                                dialog("[SLOW]Most of my life I spent taking care of animals.[B]Sometimes they only need someone close to them.[B]Sometimes they are just hungry.[B]");
                            } else {
                                response_positive();
                            }
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) { // change dog
                            choose_dog();
                        } else {
                            response_negative();
                        }
                    });
                }
            };
            
            fun add_souls_npc_dog_lady(x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    add_enemy(NPC_DOG_LADY.BODY, x, y, flags);
                } else {
                    add_enemy(NPC_DOG_LADY.BODY, x, y);
                }

                if(NPC_DOG_LADY.PROGRESS == 0d0) {
                    attach_script(LAST_ENTITY, B, reference(dog_lady_dialog_0));
                } else if(NPC_DOG_LADY.PROGRESS == 0d1) {
                    attach_script(LAST_ENTITY, B, reference(dog_lady_dialog_1));
                }
            }
        };

        group npc_squidmar() {
            enum NPC_SQUIDMAR {
                DEBUG = True,
                DEBUG_SANITY = True,

                DIALOG_GREETING = memory(FLAG, SRAM),

                AQUAGOTH_SEEN = memory(FLAG, SRAM),
                DIALOG_AQUAGOTH_SEEN = memory(FLAG, SRAM),
                AQUAGOTH_DAMAGED = memory(FLAG, SRAM),
                DIALOG_AQUAGOTH_DAMAGED = memory(FLAG, SRAM),
                AQUAGOTH_RESCUED = memory(FLAG, SRAM),
                AQUAGOTH_REWARD = ITEM.ORACLE_BONE,

                INSANITY = memory(BYTE, SRAM),
                INSANITY_LIMIT = 0d100,
                INSANITY_ANGRY = 0d50,

                REPUTATION = memory(BYTE, SRAM),
                REPUTATION_LIMIT = 0d8, // available tablets: 4 (3 town + 1 desert), scarabs: 4 (4 thraxx), jackals 0 (0 pyramid)
                REPUTATION_REWARD = ITEM.CHOCOBO_EGG,
            }

            group squidmar_ai() {
                @install()
                fun reduce_sanity(amount, external_entity) {
                    NPC_SQUIDMAR.INSANITY += amount;

                    if(NPC_SQUIDMAR.DEBUG) {
                        debug_memory(NPC_SQUIDMAR.INSANITY);
                    }

                    if(NPC_SQUIDMAR.INSANITY >= NPC_SQUIDMAR.INSANITY_ANGRY) {
                        sfx_effect(SHAKING, True);
                    }

                    if!(external_entity) {
                        if(NPC_SQUIDMAR.INSANITY >= NPC_SQUIDMAR.INSANITY_LIMIT) {
                            destroy(SCRIPT_OWNER);

                            text_end();

                            conversation_end(True);
                            end();
                        }
                    }
                }

                fun response_reaction() {
                    arg[0x10] = randrange(0d3);

                    if(arg[0x10] == 0d0) {
                        subtext("Tentacles curl in curiosity");
                    } else if(arg[0x10] == 0d1) {
                        subtext("Tendrils curl in anticipation of you");
                    } else {
                        subtext("You awaken the abyss itself");
                    }
                }

                fun response_buffled() {
                    subtext("…");
                }

                fun response_sad() {
                    dialog("[SLOW]Poor soul… Please look after him…[B]");
                }

                fun response_lie_detected() {
                    arg[0x10] = randrange(0d3);

                    if(arg[0x10] == 0d0) {
                        dialog("[SLOW]…lies…[B]");
                    } else if(arg[0x10] == 0d1) {
                        dialog("[SLOW]…the smell of lies…[B]");
                    } else {
                        dialog("[SLOW]…I'll squeeze the truth out of you…[B]");
                    }
                }

                fun response_lie() {
                    if(False) {
                        reduce_sanity(0d50);

                        arg[0x10] = randrange(0d3);

                        if(arg[0x10] == 0d0) {
                            dialog("[SLOW]…you want to investige his silence?…[B]");
                        } else if(arg[0x10] == 0d1) {
                            dialog("[SLOW]…you saw someone in his cave?…[B]");
                        } else {
                            dialog("[SLOW]…he attacked you?…[B]");
                        }
                    } else {
                        question("[SLOW][CHOICE_INLINE]investigate silence…[CHOICE]saw someone…[CHOICE]attacked you…");

                        response_lie_detected();

                        reduce_sanity(0d50);
                    }
                }

                fun dialog_aquagoth() {
                    dialog("[SLOW]What happened to Aquagoth? I can't feel him anymore.[B]");

                    while(NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT) {
                        reduce_sanity(0d10);

                        if(NPC_SQUIDMAR.INSANITY < 0d50) {
                            question("[SLOW]What happened to my brother?![CHOICE]tell…[CHOICE]lie…");
                        } else {
                            question("[SLOW]WHAT HAPPENED TO MY BROTHER?![CHOICE]tell…[CHOICE]lie…[CHOICE]run…", 0d5);
                        }

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // tell
                            sfx_effect(SHAKING, False);

                            dialog("[SLOW]Puny mortal. My prison will be your grave.[B]");

                            reduce_sanity(0d100);
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) { // lie
                            response_lie();
                        } else if(MEMORY.QUESTION_ANSWER == 0d2) { // run
                            arg[0x10] = randrange(0d3);

                            if(arg[0x10] == 0d0) {
                                dialog("[SLOW]The smell of guilt…[B]");
                            } else if(arg[0x10] == 0d1) {
                                dialog("[SLOW]You can't outrun your destiny…[B]");
                            } else {
                                dialog("[SLOW]…I see…[B]");
                            }

                            reduce_sanity(0d100);
                        } else {
                            reduce_sanity(0d20);
                            
                            if(NPC_SQUIDMAR.INSANITY <= 0d50) {
                                arg[0x10] = randrange(0d3);

                                if(arg[0x10] == 0d0) {
                                    dialog("[SLOW]…mortal… tell me…[B]");
                                } else if(arg[0x10] == 0d1) {
                                    dialog("[SLOW]…tell me…[B]");
                                } else {
                                    dialog("[SLOW]…don't make me break your tiny bones…[B]");
                                }
                            } else {
                                arg[0x10] = randrange(0d4);

                                if(arg[0x10] == 0d0) {
                                    dialog("[SLOW]TELL ME![B]");
                                } else if(arg[0x10] == 0d1) {
                                    dialog("[SLOW]Tell me![B]");
                                } else {
                                    dialog("[SLOW]TELL ME?![B]");
                                }
                            }
                        }
                    }
                }

                fun dialog_aquagoth_seen() {
                    NPC_SQUIDMAR.DIALOG_AQUAGOTH_SEEN = True;

                    reduce_sanity(0d20);

                    if(NPC_SQUIDMAR.INSANITY < 0d50) {
                        dialog("[SLOW]Mortal, I have not seen my brother in millenia. Please look after him.[B]");
                    } else {
                        dialog("[SLOW]You saw my brother?! Tell me more![B]");
                    }

                    if(NPC_SQUIDMAR.INSANITY < 0d50) {
                        question("[SLOW][CHOICE_INLINE]tell…[CHOICE]lie…");
                    } else {
                        question("[SLOW][CHOICE_INLINE]tell…[CHOICE]lie…[CHOICE]run…");
                    }

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // tell
                        if!(NPC_SQUIDMAR.AQUAGOTH_RESCUED) {
                            if((NPC_SQUIDMAR.INSANITY >= 0d50) && (NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT) && !FLAG.HEAL) {
                                dialog("[SLOW]…[B]Here - go and help him.[B]");

                                reward(HEAL);
                            }

                            dialog("[SLOW]Leave now! Help my brother.[B]");

                            NPC_SQUIDMAR.AQUAGOTH_SEEN = False;
                            attach_script(SCRIPT_OWNER, B, reference(@install() {
                                reduce_sanity(0d20);

                                if(NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT) {
                                    conversation({
                                        dialog("LEAVE! QUICKLY![B]");
                                    }, NONE);
                                }

                                if(NPC_SQUIDMAR.DEBUG) {
                                    debug_memory(NPC_SQUIDMAR.INSANITY);
                                }
                            }));
                        } else {
                            if(SOULS_MEMORY.DEAD_AQUAGOTH) {
                                reduce_sanity(0d100);
                            } else {
                                dialog("[SLOW]You saved him…[B]");

                                dialog("[SLOW]This sea shell washed up in my cave recently. It shall be reward.[B]");

                                reward(NPC_SQUIDMAR.AQUAGOTH_REWARD);
                            }
                        }
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // lie
                        response_buffled();
                        reduce_sanity(0d30);
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) { // run
                        response_buffled();
                        reduce_sanity(0d10);

                        conversation_end();
                        end();
                    } else { // cancel
                        response_lie_detected();
                        reduce_sanity(0d30);
                    }
                }

                @install()
                fun donate_relic(item:ITEM) {
                    item_pay(item, 0d1, False);

                    if(CUSTOM_MEMORY.RETURN) {
                        smart_sound(PURCHASE);

                        NPC_SQUIDMAR.REPUTATION++;

                        if(NPC_SQUIDMAR.REPUTATION == NPC_SQUIDMAR.REPUTATION_LIMIT) {
                            dialog("[SLOW]This pearl washed up in my cave recently. It shall be reward.[B]");

                            reward(NPC_SQUIDMAR.REPUTATION_REWARD);
                        }

                        reduce_sanity(0d10);
                    } else {
                        response_buffled();
                        reduce_sanity(0d30);
                    }
                }

                fun response_greeting() {
                    conversation_dialog("[SLOW]I am Squidmar.[PAUSE:40] The ancient dread that slumbered in the abyss long before your mortal kind arose.[B]I have watched civilizations rise and fall, my presence whispered only in legends and nightmares.[B]Now, I awaken once more, bound by the currents of time and the secrets of this flooded dark.[B]Approach if you dare, mortal, but beware the depths conceal horrors beyond your comprehension.[B]", 0d5);
                }

                fun dialog_worship() {
                    MEMORY.QUESTION_ANSWER = 0d0;
                    while((MEMORY.QUESTION_ANSWER != 0xffff) && (NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT)) {
                        question("[SLOW]Worship me, mortal. Bring me relics from all across the lands…[CHOICE]Jeweled Scarab…[CHOICE]Limestone Tablet…[CHOICE]Golden Jackal…", 0d7);

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // scarab
                            donate_relic(JEWELED_SCARAB);
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) { // tablet
                            donate_relic(LIMESTONE_TABLET);
                        } else if(MEMORY.QUESTION_ANSWER == 0d2) { // jackal
                            donate_relic(GOLDEN_JACKAL);
                        } else {
                            response_buffled();
                            reduce_sanity(0d20);
                        }
                    }
                }
            };

            @install()
            fun npc_squidmar_triggered() {
                if(NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT) {
                    reduce_sanity(0d50, True);
                }
            }

            fun aquagoth_seen() {
                NPC_SQUIDMAR.AQUAGOTH_SEEN = True;
                NPC_SQUIDMAR.DIALOG_AQUAGOTH_SEEN = False;
            }

            fun add_souls_npc_squidmar(x, y) {
                add_enemy(PLACEHOLDER, x, y);
                
                attach_script(LAST_ENTITY, B, reference(@install() {
                    conversation({
                        reduce_sanity(0d10);

                        if(SOULS_MEMORY.DEAD_AQUAGOTH) {
                            NPC_SQUIDMAR.DIALOG_GREETING = True;
                            dialog_aquagoth();
                        } else if(NPC_SQUIDMAR.AQUAGOTH_SEEN) {
                            dialog_aquagoth_seen();
                        } else if!(NPC_SQUIDMAR.DIALOG_GREETING) {
                            NPC_SQUIDMAR.DIALOG_GREETING = True;

                            response_greeting();
                        } else {
                            question("[SLOW]Your presence disturbs my slumber.[CHOICE]talk…[CHOICE]worship…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) { // talk
                                if(NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_ANGRY) {
                                    arg[0x10] = randrange(0d3);

                                    if(arg[0x10] == 0d0) {
                                        conversation_dialog("[SLOW]The relics of this world are the keys to our salvation.[B]Offer them to me, and I will reward you with otherworldly treasures.[B]", 0d5);
                                    } else {
                                        conversation_dialog("[SLOW]I was once a guardian of the abyss[PAUSE:40], but humans summoned me in their greed[PAUSE:40], and in their ignorance[PAUSE:40], sealed me away[PAUSE:40] beneath these waves.[B]", 0d7);

                                        conversation_dialog("[SLOW]My brother Aquagoth must have suffered the same fate.[B]Our blood ties still pulse through the dark waters of this forsaken tomb.[B]", 0d5);
                                    }
                                } else {
                                    arg[0x10] = randrange(0d5);

                                    if(arg[0x10] == 0d0) {
                                        conversation_dialog("[SLOW]Time is a treasure I do not possess for idle chatter.[B]");
                                    } else if(arg[0x10] == 0d1) {
                                        conversation_dialog("[SLOW]Waste my moments, and you'll regret it.[B]");
                                    } else if(arg[0x10] == 0d2) {
                                        conversation_dialog("[SLOW]Time is my prison… Waste it, and I will break free.[B]");
                                    } else if(arg[0x10] == 0d3) {
                                        conversation_dialog("[SLOW]Your words are as shallow as this flooded abyss.[B]");
                                    } else {
                                        conversation_dialog("[SLOW]Your hesitation feeds my rage.[B]");
                                    }
                                }
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) { // worship
                                dialog_worship();
                            } else {
                                response_buffled();
                            }
                        }
                    }, NONE);

                    if(NPC_SQUIDMAR.DEBUG) {
                        debug_memory(NPC_SQUIDMAR.INSANITY);
                    }
                }));
            }
        };

        group npc_alchemists() {
            // "A"
            group npc_alchemist_acid_rain() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(acid rain)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        pop_music();

                        dialog("todo: explain(acid rain)[B]");
                    }
                }

                fun add_souls_npc_alchemist_acid_rain(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if(<SCRIPT_OWNER>[GENERAL_PURPOSE] > 0d0) {
                                dialog("[SLOW]How can you be so calm with all those raptors around you?![B]");
                            } else {
                                dialog("todo: hi2[B]");
                                reward_formula(ACID_RAIN, ACID_RAIN, ACID_RAIN);
                            }
                        });
                    }));
                }
            };

            // "C"
            group npc_alchemist_corrosion() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(corrosion)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        pop_music();

                        dialog("todo: explain(corrosion)[B]");
                    }
                }

                fun add_souls_npc_alchemist_corrosion(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi2[B]");
                            reward_formula(CORROSION, CORROSION, CORROSION);
                        });
                    }));
                }
            };

            // "D"
            group npc_alchemist_defend() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(defend)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(defend)[B]");
                    }
                }

                fun add_souls_npc_alchemist_defend(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi2[B]");
                            reward_formula(DEFEND, DEFEND, DEFEND);
                        });
                    }));
                }
            };
            group npc_alchemist_drain() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(drain)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(drain)[B]");
                    }
                }

                fun add_souls_npc_alchemist_drain(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(MONK, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(MONK, x, y);
                    }
                    attribute(LAST_ENTITY, INVINCIBLE, True);
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi2[B]");
                            reward_formula(DRAIN, DRAIN, DRAIN);
                        });
                    }));
                }
            };

            // "E"
            group npc_alchemist_escape() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(escape)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(escape)[B]");
                    }
                }

                fun add_souls_npc_alchemist_escape(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi2[B]");
                            reward_formula(ESCAPE, ESCAPE, ESCAPE);
                        });
                    }));
                }
            };

            // "F"
            group npc_alchemist_firepower() {
                enum NPC_ALCHEMIST_FIREPOWER {
                    BRANCH_USED = memory(FLAG, SRAM),
                }

                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(firepower)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(firepower)[B]");
                    }
                }
                
                @install()
                fun dialog_alchemist_firepower() {
                    conversation({
                        dialog("todo: hi3[B]");
                        reward_formula(FIRE_POWER, FIRE_POWER, FIRE_POWER);
                    });
                }
                fun add_souls_npc_alchemist_firepower(x, y, direction:DIRECTION) {
                    if!(NPC_ALCHEMIST_FIREPOWER.BRANCH_USED) {
                        branch_lady(VILLAGER_2_8, x, y, direction, reference(@install() {
                            guard_branch_lady(NPC_ALCHEMIST_FIREPOWER.BRANCH_USED);

                            dialog_alchemist_firepower();
                        }));
                    } else {
                        if(direction is Word) {
                            add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                            face(LAST_ENTITY, direction);
                        } else {
                            add_enemy(VILLAGER_2_8, x, y);
                        }

                        attach_script(LAST_ENTITY, B, reference(dialog_alchemist_firepower));
                    }
                }
            };
            group npc_alchemist_forcefield() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(forcefield)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(forcefield)[B]");
                    }
                }

                fun add_souls_npc_alchemist_forefield(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi3[B]");
                            reward_formula(FORCE_FIELD, FORCE_FIELD, FORCE_FIELD);
                        });
                    }));
                }
            };

            // "H"
            group npc_alchemist_heal() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(heal)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(heal)[B]");
                    }
                }

                fun add_souls_npc_alchemist_heal(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi3[B]");
                            reward_formula(HEAL, HEAL, HEAL);
                        });
                    }));
                }
            };

            // "R"
            group npc_alchemist_revive() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(revive)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(revive)[B]");
                    }
                }

                fun add_souls_npc_alchemist_revive(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi3[B]");
                            reward_formula(REVIVE, REVIVE, REVIVE);
                        });
                    }));
                }
            };

            // "S"
            group npc_alchemist_speed() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(speed)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(speed)[B]");
                    }
                }

                fun add_souls_npc_alchemist_speed(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            if((<ACTIVE>[FACE_DIRECTION] >= FACE_DIRECTION.NORTH_EAST) && (<ACTIVE>[FACE_DIRECTION] <= FACE_DIRECTION.SOUTH_WEST)) {
                                dialog("[SLOW]Can you please speak up, I can't understand you on that ear![B]");
                            } else {
                                dialog("todo: hi3[B]");
                                reward_formula(SPEED, SPEED, SPEED);
                            }
                        });
                    }));
                }
            };
            group npc_alchemist_stop() {
                fun reward_formula(flag:FLAG, formula:ITEM, alchemy_index:ALCHEMY_INDEX) {
                    if!(flag) {
                        dialog("todo: reward(stop)[B]");

                        reward(formula);
                        select_alchemy(alchemy_index);

                        // music(BUGMUCK_AMBIENT_MELODY);

                        dialog("todo: explain(stop)[B]");
                    }
                }

                fun add_souls_npc_alchemist_stop(x, y, direction:DIRECTION) {
                    if(direction is Word) {
                        add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                        face(LAST_ENTITY, direction);
                    } else {
                        add_enemy(VILLAGER_2_8, x, y);
                    }
                    
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            dialog("todo: hi3[B]");
                            reward_formula(STOP, STOP, STOP);
                        });
                    }));
                }
            };
        };

        group npc_dealer() {
            enum NPC_DEALER {
                PRICE_ATLAS = 0d100,
            }

            group dealer_ai() {
                fun response_positive() {
                    if(MEMORY.ATLAS_MEDALLION == 0d1) {
                        dialog("[SLOW]The first one is free they say… I don't think they mean that literally.[B]");
                    } else {
                        dialog("[SLOW]He he he…[B]");
                    }
                }
                fun response_negative() {
                    if(randrange(0x02) == 0x00) {
                        dialog("[SLOW]Sooner or later you'll need me…[B]");
                    } else {
                        dialog("[SLOW]Sooner or later you'll need me… They all do…[B]");
                    }
                }
                fun response_cancel() {
                    dialog("[SLOW]Oh my, haste makes waste. Hee hee hee…[B]");
                }

                @install()
                fun dealer_triggered() {
                    dialog("[SLOW]Sorry, you ran into my ellbow…[B]");

                    question("[SLOW]Are you with the guards? I heard they have to answer that truthfully![CHOICE]yes…[CHOICE]no…", 0d6);
                    if(MEMORY.QUESTION_ANSWER == 0d0) { // yes
                        dialog("[SLOW]There's nothing to see here… Keep moving…[B]");
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // no
                        arg[0x10] = (NPC_DEALER.PRICE_ATLAS * (MEMORY.ATLAS_MEDALLION + 0d1)) - 0d1;

                        CUSTOM_MEMORY.RETURN = False;
                        MEMORY.STRING_PARAMETER_1 = arg[0x10];
                        question("[SLOW]Do you need something… Performance enhancing…?[CHOICE][MEM1] Souls…");
                        if(MEMORY.QUESTION_ANSWER == 0d0) { // Souls
                            trade_items(ATLAS_MEDALLION, 0d1, MONEY, arg[0x10]);
                        }

                        if(CUSTOM_MEMORY.RETURN) {
                            response_positive();
                        } else {
                            response_negative();
                        }
                    } else {
                        response_cancel();
                    }
                }
            };
        };
    };

    group cheat_menu() {

        fun cheat_menu() {
            hide_non_dialog_layers();

            <0x2850> = 0x0000; // TODO

            MEMORY.QUESTION_ANSWER = 0d0;
            while(MEMORY.QUESTION_ANSWER != 0xffff) {
                // text_start();
                open_message_box(TRANSPARENT_CENTERED, 0x04, 0x04, 0x18, 0x14);

                font(OUTRO);
                text("Debug Menu:");

                font(DEFAULT);
                MEMORY.STRING_PARAMETER_1 = <0x2850, 0x01>;
                text("[CHOICE][MEM1] - Fast Travel - [MEM1]");

                MEMORY.STRING_PARAMETER_1 = <0x2850, 0x02>;
                text("[CHOICE][MEM1] - Souls on Death - [MEM1]");

                MEMORY.STRING_PARAMETER_1 = <0x2850, 0x04>;
                text("[CHOICE][MEM1] - Cheat in Weapons - [MEM1]");

                MEMORY.STRING_PARAMETER_1 = <0x2850, 0x08>;
                text("[CHOICE][MEM1] - Cheat in Armor - [MEM1]");

                debug_marker();
                await_answer(MEMORY.QUESTION_ANSWER);

                if(MEMORY.QUESTION_ANSWER == 0d0) {
                    <0x2850, 0x01> = !<0x2850, 0x01>;
                } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                    <0x2850, 0x02> = !<0x2850, 0x02>;
                } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                    <0x2850, 0x04> = !<0x2850, 0x04>;
                } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                    <0x2850, 0x08> = !<0x2850, 0x08>;
                }

                text_end();
                control(BOTH);

                if(MEMORY.QUESTION_ANSWER == 0d2) {
                    arg[0x10] = MEMORY.QUESTION_ANSWER;
                    MEMORY.QUESTION_ANSWER = 0d0;
                    while(MEMORY.QUESTION_ANSWER != 0xffff) {
                        // text_start();
                        open_message_box(TRANSPARENT_CENTERED, 0x04, 0x04, 0x18, 0x14 + 0d2);
                        // open_message_box(TRANSPARENT_CENTERED, 0x03, 0x00, 0x18 + 0d4, 0x14 + 0d4);

                        font(OUTRO);
                        text("Debug Menu: Weapons");

                        font(DEFAULT);
                        MEMORY.STRING_PARAMETER_1 = FLAG.SWORD_1;
                        text("[CHOICE][MEM1] - Sword 1 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SWORD_2;
                        text("[CHOICE][MEM1] - Sword 2 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SWORD_3;
                        text("[CHOICE][MEM1] - Sword 3 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SWORD_4;
                        text("[CHOICE][MEM1] - Sword 4 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SPEAR_1;
                        text("[CHOICE][MEM1] - Spear 1 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SPEAR_2;
                        text("[CHOICE][MEM1] - Spear 2 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SPEAR_3;
                        text("[CHOICE][MEM1] - Spear 3 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.SPEAR_4;
                        text("[CHOICE][MEM1] - Spear 4 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.AXE_1;
                        text("[CHOICE][MEM1] - Axe 1 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.AXE_2;
                        text("[CHOICE][MEM1] - Axe 2 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.AXE_3;
                        text("[CHOICE][MEM1] - Axe 3 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.AXE_4;
                        text("[CHOICE][MEM1] - Axe 4 - [MEM1]");

                        MEMORY.STRING_PARAMETER_1 = FLAG.BAZOOKA;
                        text("[CHOICE][MEM1] - Bazooka - [MEM1]");

                        await_answer(MEMORY.QUESTION_ANSWER);

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            FLAG.SWORD_1 = !FLAG.SWORD_1;
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                            FLAG.SWORD_2 = !FLAG.SWORD_2;
                        } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                            FLAG.SWORD_3 = !FLAG.SWORD_3;
                        } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                            FLAG.SWORD_4 = !FLAG.SWORD_4;
                        } else if(MEMORY.QUESTION_ANSWER == 0d4) {
                            FLAG.SPEAR_1 = !FLAG.SPEAR_1;
                        } else if(MEMORY.QUESTION_ANSWER == 0d5) {
                            FLAG.SPEAR_2 = !FLAG.SPEAR_2;
                        } else if(MEMORY.QUESTION_ANSWER == 0d6) {
                            FLAG.SPEAR_3 = !FLAG.SPEAR_3;
                        } else if(MEMORY.QUESTION_ANSWER == 0d7) {
                            FLAG.SPEAR_4 = !FLAG.SPEAR_4;
                        } else if(MEMORY.QUESTION_ANSWER == 0d8) {
                            FLAG.AXE_1 = !FLAG.AXE_1;
                        } else if(MEMORY.QUESTION_ANSWER == 0d9) {
                            FLAG.AXE_2 = !FLAG.AXE_2;
                        } else if(MEMORY.QUESTION_ANSWER == 0d10) {
                            FLAG.AXE_3 = !FLAG.AXE_3;
                        } else if(MEMORY.QUESTION_ANSWER == 0d11) {
                            FLAG.AXE_4 = !FLAG.AXE_4;
                        } else if(MEMORY.QUESTION_ANSWER == 0d12) {
                            FLAG.BAZOOKA = !FLAG.BAZOOKA;
                        }

                        text_end();
                        control(BOTH);
                    }
                    MEMORY.QUESTION_ANSWER = arg[0x10];
                } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                    <0x2850, 0x08> = !<0x2850, 0x08>;
                    arg[0x10] = 0d3;
                } else {
                    arg[0x12] = True;
                }
            }

            fade_in();
        }
    };
};

group custom_bosses() {
    area custom_boss_gideon() {
        enum BOSS {
            DEBUG = False,

            RANDOM_CAST_COOLDOWN = randrange(0d600),

            ESTUS_CHARGES = 0d2,
            HEAL_THRESHOLD = 0d20,
            ESTUS_HEAL = 0d20,

            LEVEL_FLASH = 0d5,
        }

        group random_cast_helper() {
            @install()
            fun prepare_casting() {
                animate(<SCRIPT_OWNER>, ONCE, DEFAULT);
                sleep(0d10);
                animate(<SCRIPT_OWNER>, ONCE, CAST);
                sleep(0d30);
            }

            @install()
            fun cast_alchemy() { // unused
                if(BOSS.DEBUG) {
                    debug_subtext("cast small");
                }

                animate(<SCRIPT_OWNER>, ONCE, DEFAULT);
                sleep(0d10);
                animate(<SCRIPT_OWNER>, ONCE, CAST);

                val rng = arg[0x10];
                val spell_id = arg[0x12];
                val spell_target = arg[0x14];

                rng = randrange(0d10);

                if(rng == 0d0) {
                    spell_id = CAST.CRUSH;
                } else if(rng == 0d1) {
                    spell_id = CAST.STING;
                } else {
                    spell_id = CAST.FLASH;
                }

                cast_team(<SCRIPT_OWNER>, spell_id, 0d1);

                sleep(0d30);
            }

            @install()
            @async()
            fun place_spark() {
                _add_enemy(SPARK, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y]);
                attach_to_script(LAST_ENTITY);

                sleep(0d600);

                if(alive(<SCRIPT_OWNER>)) {
                    attribute(SCRIPT_OWNER, ROOT, True);

                    if(True) {
                        sound(TESLA);
                        shoot_entity_entity(SCRIPT_OWNER, LIGHTNING, <SCRIPT_OWNER>, 0d30, 0d0);

                        sleep(0d30);
                    }

                    sleep(0d30);

                    if(alive(<SCRIPT_OWNER>)) {
                        ai_move_tesla(<SCRIPT_OWNER>, <BOY>);
                    }
                }

                destroy(SCRIPT_OWNER);
            }
            @install()
            @async()
            fun place_mosquito() {
                _add_enemy(MOSQUITO, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y]);
                <LAST_ENTITY>[GENERAL_PURPOSE] = <SCRIPT_OWNER>;
                attach_to_script(LAST_ENTITY);

                attach_script(LAST_ENTITY, DEATH, reference(@install() {
                    arg[0x10] = <SCRIPT_OWNER>[GENERAL_PURPOSE];

                    if((arg[0x10][X] >= MEMORY.CAMERA_X_MIN) && ((arg[0x10][X] <= MEMORY.CAMERA_X_MAX)) && (arg[0x10][Y] >= MEMORY.CAMERA_Y_MIN) && ((arg[0x10][Y] <= MEMORY.CAMERA_Y_MAX))) {
                        cast(SCRIPT_OWNER, arg[0x10], FIREBALL, 0d20);
                    } else {
                        cast(SCRIPT_OWNER, BOY, FIREBALL, 0d10);
                    }
                }));

                sleep(0d600);

                if(alive(<SCRIPT_OWNER>)) {
                    cast(SCRIPT_OWNER, BOY, FIREBALL, 0d10);
                }

                destroy(SCRIPT_OWNER);
            }

            @install()
            fun cast_beam() {
                if(BOSS.DEBUG) {
                    debug_subtext("cast: beam");
                }

                prepare_casting();

                control(<SCRIPT_OWNER>, True);
                attribute(<SCRIPT_OWNER>, ROOT, True);

                projectile_beam(<ACTIVE>, 0d5);
                
                control(<SCRIPT_OWNER>, False);
                attribute(<SCRIPT_OWNER>, ROOT, False);
            }

            @install()
            fun choose_move_set() {

                while(True) {
                    arg[0x0e] = randrange(0d9);
                    arg[0x10] = randrange(0d3);

                    if(BOSS.DEBUG) {
                        MEMORY.STRING_PARAMETER_1 = arg[0x0e];
                        MEMORY.STRING_PARAMETER_2 = arg[0x10];
                        debug_subtext("cast: random([MEM1], [MEM2])");
                    }

                    if((arg[0x0e] == 0d0) && (SOULS_MEMORY.DEAD_MONSTRO)) {
                        prepare_casting();

                        arg[0x10] = randrange(0d2);

                        if(arg[0x10] == 0d0) {
                            animate(<SCRIPT_OWNER>, ONCE, ANIMATION_ENEMY.MAGMAR_ENTER);
                            ai_move_projectile_splash(<SCRIPT_OWNER>, ONION);
                        } else {
                            ai_move_projectile_puke(<SCRIPT_OWNER>, ONION, <BOY>, 0d4);
                        }

                        end();
                    } else if((arg[0x0e] == 0d1) && (SOULS_MEMORY.DEAD_DARK_ONE)) {
                        prepare_casting();

                        arg[0x10] = randrange(0d4);

                        if(arg[0x10] == 0d0) {
                            animate(<SCRIPT_OWNER>, ONCE, ANIMATION_ENEMY.MAGMAR_ENTER);
                            ai_move_charge_right(<SCRIPT_OWNER>, <BOY>, 0d8, 0d2);
                        } else if(arg[0x10] == 0d1) {
                            ai_move_projectile_star(<SCRIPT_OWNER>, ONION, 0d70);
                        } else {
                            control(<SCRIPT_OWNER>, True);
                            face(<SCRIPT_OWNER>, SOUTH);
                            ai_move_projectile_x(<SCRIPT_OWNER>, ONION, 0d70);
                            sleep(0d40);
                            ai_move_projectile_plus(<SCRIPT_OWNER>, ONION, 0d70);
                            control(<SCRIPT_OWNER>, False);
                        }

                        end();
                    } else if((arg[0x0e] == 0d2) && (SOULS_MEMORY.DEAD_SIDESCROLLER)) {
                        prepare_casting();

                        arg[0x10] = randrange(0d3);

                        if(arg[0x10] == 0d0) {
                            ai_move_projectile_ring(<SCRIPT_OWNER>, CITRON, 0d75, 0x40, 0d5, 0d1, False, True);
                        } else {
                            sound(PROJECTILE_SHOOTING);
                            shoot_entity_entity(<SCRIPT_OWNER>, CITRON, BOY, 0x10, 0xff);
                        }

                        end();
                    } else if((arg[0x0e] == 0d3) && (SOULS_MEMORY.DEAD_BOWSER)) {
                        prepare_casting();

                        arg[0x10] = 0d1 + randrange(0d8);

                        ai_move_projectile_toss(<SCRIPT_OWNER>, SPEAR, <BOY>, arg[0x10]);

                        end();
                    } else if((arg[0x0e] == 0d4) && (SOULS_MEMORY.DEAD_SQUIDMAR)) {
                        prepare_casting();

                        animate(<SCRIPT_OWNER>, ONCE, ANIMATION_BOY.KNEEL);
                        place_spark();

                        end();
                    } else if((arg[0x0e] == 0d5) && (SOULS_MEMORY.DEAD_ARENA_MOSQUITO)) {
                        prepare_casting();

                        animate(<SCRIPT_OWNER>, ONCE, ANIMATION_BOY.KNEEL);
                        place_mosquito();

                        end();
                    } else if((arg[0x0e] == 0d6) && (SOULS_MEMORY.DEAD_HEART)) {
                        prepare_casting();
                        
                        sound(GORE_MOSQUITO);
                        sleep(0d10);
                        sound(GORE_MOSQUITO);
                        
                        ai_move_projectile_puke(<SCRIPT_OWNER>, ONION, <BOY>, 0d4); // TODO: same as monstro

                        end();
                    } else if((arg[0x0e] == 0d7) && (SOULS_MEMORY.DEAD_PIT_EGG)) {
                        prepare_casting();

                        if(CUSTOM_FLAG.NO_DOG || CUSTOM_FLAG.NO_BOY) {
                            pit_projectile(<SCRIPT_OWNER>, <ACTIVE>);
                        } else if(randrange(0d2)) {
                            pit_projectile(<SCRIPT_OWNER>, <ACTIVE>);
                        } else {
                            pit_projectile(<SCRIPT_OWNER>, <INACTIVE>);
                        }

                        end();
                    } else if((arg[0x0e] == 0d8) && (FLAG.FLASH) && (arg[0x10] == 0d0)) {
                        prepare_casting();

                        cast(<SCRIPT_OWNER>, <ACTIVE>, FLASH, BOSS.LEVEL_FLASH);

                        end();
                    } else {
                        if(BOSS.DEBUG) {
                            // debug_memory(arg[0x0e], 0d0);
                            // debug_subtext("reroll");
                            nop();
                        }

                        arg[0x12]++;

                        if(arg[0x12] > 0d20) {
                            if(BOSS.DEBUG) {
                                // debug_memory(arg[0x0e], 0d0);
                                // debug_subtext("reroll");
                                nop();
                            }

                            end();
                        }

                        yield();
                    }
                }
            }

            fun use_estus() {
                if(BOSS.DEBUG) {
                    debug_subtext("estus");
                }

                control(<SCRIPT_OWNER>, True);
                face(<SCRIPT_OWNER>, SOUTH);

                animate(<SCRIPT_OWNER>, ONCE, CAST);

                if((arg[0x20] > 0d0) && (arg[0x20] != 0xffff)) {
                    arg[0x20]--;

                    cast(<SCRIPT_OWNER>, <SCRIPT_OWNER>, HEAL, BOSS.ESTUS_HEAL);
                } else {
                    arg[0x20] = 0xffff;

                    cast(<SCRIPT_OWNER>, <SCRIPT_OWNER>, HEAL, 0d0);
                }

                wait(<SCRIPT_OWNER>);

                control(<SCRIPT_OWNER>, False);
            }
        };

        fun random_cast() {
            if(BOSS.DEBUG) {
                debug_subtext("start cast");
            }

            if(arg[0x20] != 0xffff) {
                arg[0x0e] = randrange(0d8);

                if((arg[0x0e] == 0d0) && (<SCRIPT_OWNER>[HP] < (arg[0x1e] - BOSS.HEAL_THRESHOLD))) {
                    use_estus();
                }
            }

            if(randrange(0d5) == 0d0) {
                cast_beam();
            } else {
                arg[0x22] = True;
                while(arg[0x22] || rand(0x1)) {
                    arg[0x22] = False;

                    choose_move_set();
                }
            }
        }

        fun add_boss(x, y, hp, poise, poise_decay, poise_decay_time, trigger_boss_music, freeze_during_start) {
            add_enemy(BOY_BLACK, x, y);
            attach_to_script(LAST_ENTITY);

            <SCRIPT_OWNER>[HP] = hp;
            arg[0x1e] = hp;
            arg[0x20] = BOSS.ESTUS_CHARGES;

            if(SOULS_MEMORY.DEAD_OWL_BOY) {
                poise_break_decay(<LAST_ENTITY>, poise, poise_decay, poise_decay_time);
            } else {
                <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0d0;
            }
            attach_script(<SCRIPT_OWNER>, DAMAGE, reference(@install() {
                if(dead(<SCRIPT_OWNER>)) {
                    nop();
                } else if(SOULS_MEMORY.DEAD_OWL_BOY) {
                    poise_break();
                }
            }));

            if(freeze_during_start) {
                animate(LAST_ENTITY, ONCE_FREEZE, DEFAULT);
                yield();
                
                while(<SCRIPT_OWNER>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) {
                    yield();
                }
            } else {
                yield();
            }

            if(trigger_boss_music) {
                push_music(BOSS);
            }

            while(alive(<SCRIPT_OWNER>)) {
                while((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) || (<SCRIPT_OWNER>[GENERAL_PURPOSE] == 0xffff)) {
                    yield();
                }

                while!((<SCRIPT_OWNER>[X] >= MEMORY.CAMERA_X_MIN) && ((<SCRIPT_OWNER>[X] <= MEMORY.CAMERA_X_MAX)) && (<SCRIPT_OWNER>[Y] >= MEMORY.CAMERA_Y_MIN) && ((<SCRIPT_OWNER>[Y] <= MEMORY.CAMERA_Y_MAX))) {
                    sleep(0d10);

                    if(BOSS.DEBUG) {
                        debug_subtext("not on screen");
                    }
                }
                
                random_cast();

                sleep(BOSS.RANDOM_CAST_COOLDOWN);
            }
        }

        @install()
        @async()
        fun gideon_speech() {
            sleep(0d30);
            dialog("I knew you'd come.[B]");
        }

        @install()
        @async()
        fun _add_custom_boss_gideon(x, y, hp, poise, poise_decay, poise_decay_time, trigger_boss_music, freeze_during_start) {
            add_boss(x, y, hp, poise, poise_decay, poise_decay_time, trigger_boss_music, freeze_during_start);
        }
        fun add_custom_boss_gideon(x, y, flag_dead, callback_dead, hp, poise, poise_decay, poise_decay_time, trigger_boss_music, freeze_during_start, with_speech) {
            if!(flag_dead) {
                _add_custom_boss_gideon(x, y, hp, poise, poise_decay, poise_decay_time, trigger_boss_music, freeze_during_start);
                yield();

                if(with_speech) {
                    gideon_speech();
                }

                if(callback_dead is Function) {
                    attach_to_script(LAST_ENTITY);

                    while!(dead(<SCRIPT_OWNER>)) {
                        yield();
                    }

                    callback_dead();
                }
            }
        }
    };

    area custom_boss_pudge() {
        enum BOSS {
            DEBUG = False,

            MOVE_COOLDOWN = 0d300,
        }

        @install()
        fun _roar(scream) {
            if(scream) {
                sound(THRAXX_DAMAGE);
            }

            animate(<0x2834>, ONCE, ANIMATION_ENEMY.MINITAUR_STOMP);
            yield();
            wait(<0x2834>);

            sfx_effect(SHAKING, True);
            sleep(0d20);
            sfx_effect(SHAKING, False);
        }
        fun roar(scream) {
            if(scream !is None) {
                _roar(scream);
            } else {
                _roar();
            }

            yield();
        }

        group ai_moves() {
            @install()
            fun ai_move_fresh_meat(mount, rider) {
                if(BOSS.DEBUG) {
                    debug_subtext("eat");
                }

                guard_dead(mount);

                control(mount, True);
                animate(mount, ONCE, ANIMATION_ENEMY.MINITAUR_STOMP);
                subtext("FRESH MEAT");

                while(arg[0x10] < 0d30) {
                    arg[0x10]++;

                    guard_dead(mount);

                    walk(mount, COORDINATE_ABSOLUTE, <BOY>[X], <BOY>[Y], False, False);

                    sleep(0d10);

                    // debug_memory(arg[0x10]);
                }

                animate(mount, ONCE, ANIMATION_ENEMY.MINITAUR_STOMP);

                control(mount, False);
            }
            
            @install()
            fun ai_move_charge(mount, rider) {
                if(BOSS.DEBUG) {
                    debug_subtext("charge");
                }

                guard_dead(mount);

                control(mount, True);

                roar(True);
                face_target(mount, ACTIVE);
                sleep(0d30);

                guard_dead(mount);

                animate(mount, ONCE, DEFAULT);
                animate(mount, ONCE, ANIMATION_ENEMY.MINITAUR_STOMP);
                face_target(mount, ACTIVE);
                sleep(0d10);
                animate(mount, ONCE, DEFAULT);
                animate(mount, ONCE, ANIMATION_ENEMY.MINITAUR_STOMP);
                face_target(mount, ACTIVE);

                animate(mount, LOOP, RUN_FORWARD);
                attribute(mount, ROOT, True);

                if(<BOY>[X] < mount[X]) {
                    arg[0x18] = DIRECTION.WEST;
                    arg[0x14] = mount[X] - <BOY>[X];
                } else {
                    arg[0x18] = DIRECTION.EAST;
                    arg[0x14] = <BOY>[X] - mount[X];
                }

                if(<BOY>[Y] < mount[Y]) {
                    arg[0x1a] = DIRECTION.NORTH;
                    arg[0x16] = mount[Y] - <BOY>[Y];
                } else {
                    arg[0x1a] = DIRECTION.SOUTH;
                    arg[0x16] = <BOY>[Y] - mount[Y];
                }

                if(arg[0x14] > arg[0x16]) {
                    if(arg[0x14] > 0d200) {
                        while(arg[0x14] > (arg[0x16] + arg[0x16] + arg[0x16] + arg[0x16])) {
                            arg[0x14] >>= 0d1;
                        }
                    }
                    
                    while(arg[0x14] < 0d100) {
                        arg[0x14] <<= 0d1;
                        arg[0x16] <<= 0d1;
                    }
                } else {
                    if(arg[0x16] > 0d200) {
                        while(arg[0x16] > (arg[0x14] + arg[0x14] + arg[0x14] + arg[0x14])) {
                            arg[0x16] >>= 0d1;
                        }
                    }
                    
                    while(arg[0x16] < 0d100) {
                        arg[0x14] <<= 0d1;
                        arg[0x16] <<= 0d1;
                    }
                }

                // debug_memory(arg[0x18], arg[0x1a], 0d1);

                while(True) {
                    guard_dead(mount);

                    arg[0x10] = arg[0x14] >> 0d5;
                    arg[0x12] = arg[0x16] >> 0d5;

                    arg[0x20] = mount[X];
                    arg[0x22] = mount[Y];

                    if((arg[0x1a] == DIRECTION.NORTH) && (arg[0x18] == DIRECTION.EAST)) { // q1
                        teleport_relative(mount, arg[0x10], -(arg[0x12]));
                    } else if((arg[0x1a] == DIRECTION.SOUTH) && (arg[0x18] == DIRECTION.EAST)) { // q2
                        teleport_relative(mount, arg[0x10], arg[0x12]);
                    } else if((arg[0x1a] == DIRECTION.SOUTH) && (arg[0x18] == DIRECTION.WEST)) { // q3
                        teleport_relative(mount, -(arg[0x10]), arg[0x12]);
                    } else { // q4
                        teleport_relative(mount, -(arg[0x10]), -(arg[0x12]));
                    }

                    if((mount[X] == arg[0x20]) && (mount[Y] == arg[0x22])) {
                        subtext("?");

                        sfx_effect(SHAKING, True);

                        bomb_entity(mount, 0d150);

                        animate(mount, ONCE, ANIMATION_ENEMY.MINITAUR_STOMP);
                        attribute(mount, ROOT, False);

                        control(mount, False);

                        sleep(0d40);

                        sfx_effect(SHAKING, False);

                        end();
                    }

                    sleep(0d2);
                }
            }
            
            @install()
            @async()
            fun tesla_line(mount, rider) {
                while(_alive(rider) && (rider[GENERAL_PURPOSE] > 0d0)) {
                    sleep(0d10);

                    shoot_entity_offset_entity_offset(mount, LIGHTNING, rider, 0d0, -0d30, 0d0, -(rider[Z] >> 0d4), 0d1, 0d0);

                    // debug_memory(rider[Z]);

                    face_target(rider, <ACTIVE>);
                    face_target(mount, rider);
                }
            }
            @install()
            fun ai_move_hook(mount, rider) {
                if(BOSS.DEBUG) {
                    debug_subtext("hook");
                }

                guard_dead(mount);

                control(mount, True);

                if(rand(0x01)) {
                    subtext("Get over here!");
                } else {
                    subtext("Come here!");
                }

                roar(True);
                attribute(mount, ROOT, True);

                rider[GENERAL_PURPOSE] = 0d1;

                sleep(0d30);

                guard_dead(mount);

                tesla_line(mount, rider);

                sleep(0d30);

                rider[GENERAL_PURPOSE] = 0d2;

                animate(rider, ONCE, SLASH_1);

                if(<BOY>[X] < mount[X]) {
                    arg[0x18] = DIRECTION.WEST;
                    arg[0x14] = mount[X] - <BOY>[X];
                } else {
                    arg[0x18] = DIRECTION.EAST;
                    arg[0x14] = <BOY>[X] - mount[X];
                }

                if(<BOY>[Y] < mount[Y]) {
                    arg[0x1a] = DIRECTION.NORTH;
                    arg[0x16] = mount[Y] - <BOY>[Y];
                } else {
                    arg[0x1a] = DIRECTION.SOUTH;
                    arg[0x16] = <BOY>[Y] - mount[Y];
                }

                if(arg[0x14] > arg[0x16]) {
                    if(arg[0x14] > 0d200) {
                        while(arg[0x14] > (arg[0x16] + arg[0x16] + arg[0x16] + arg[0x16])) {
                            arg[0x14] >>= 0d1;
                        }
                    }
                    
                    while(arg[0x14] < 0d100) {
                        arg[0x14] <<= 0d1;
                        arg[0x16] <<= 0d1;
                    }
                } else {
                    if(arg[0x16] > 0d200) {
                        while(arg[0x16] > (arg[0x14] + arg[0x14] + arg[0x14] + arg[0x14])) {
                            arg[0x16] >>= 0d1;
                        }
                    }
                    
                    while(arg[0x16] < 0d100) {
                        arg[0x14] <<= 0d1;
                        arg[0x16] <<= 0d1;
                    }
                }

                // debug_memory(arg[0x18], arg[0x1a], 0d1);

                while(True) {
                    guard_dead(mount);

                    arg[0x10] = arg[0x14] >> 0d5;
                    arg[0x12] = arg[0x16] >> 0d5;

                    arg[0x20] = rider[X];
                    arg[0x22] = rider[Y];

                    if((arg[0x1a] == DIRECTION.NORTH) && (arg[0x18] == DIRECTION.EAST)) { // q1
                        teleport_relative(rider, arg[0x10], -(arg[0x12]));
                    } else if((arg[0x1a] == DIRECTION.SOUTH) && (arg[0x18] == DIRECTION.EAST)) { // q2
                        teleport_relative(rider, arg[0x10], arg[0x12]);
                    } else if((arg[0x1a] == DIRECTION.SOUTH) && (arg[0x18] == DIRECTION.WEST)) { // q3
                        teleport_relative(rider, -(arg[0x10]), arg[0x12]);
                    } else { // q4
                        teleport_relative(rider, -(arg[0x10]), -(arg[0x12]));
                    }

                    if((rider[X] == arg[0x20]) && (rider[Y] == arg[0x22])) {
                        subtext("?");

                        sleep(0d30);

                        _drag(rider, mount[X], mount[Y]);

                        subtext("!");

                        sleep(0d30);

                        rider[GENERAL_PURPOSE] = 0d0;

                        roar();
                        attribute(mount, ROOT, False);

                        control(mount, False);

                        end();
                    }

                    sleep(0d2);
                }
            }
        };

        @install()
        @async()
        fun holding_spider(mount, rider) {
            while!(dead(mount)) {
                if(rider[GENERAL_PURPOSE] == 0d0) {
                    if(mount[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                        _teleport(rider, mount[X], mount[Y] + 0d1);
                    } else if(mount[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                        _teleport(rider, mount[X] - 0d10, mount[Y] - 0d20);
                    } else if(mount[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                        _teleport(rider, mount[X] + 0d10, mount[Y] - 0d20);
                    } else {
                        _teleport(rider, mount[X], mount[Y] - 0d20);
                    }

                    _face(rider, NORTH);
                } else if(rider[GENERAL_PURPOSE] == 0d1) {
                    _teleport(rider, mount[X], mount[Y] + 0d5);
                }

                sleep(0d2);
            }
        }

        @install()
        @async()
        fun _add_custom_boss_pudge(x, y, force_phase, hp) {
            add_enemy(MINITAUR, x, y);
            <LAST_ENTITY>[HP] = hp;
            arg[0x10] = <LAST_ENTITY>;
            attach_to_script(LAST_ENTITY);

            yield();

            _add_enemy(SPIDER, <LAST_ENTITY>[X], <LAST_ENTITY>[Y] + 0d5, INACTIVE);
            <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
            arg[0x12] = <LAST_ENTITY>;

            holding_spider(arg[0x10], arg[0x12]);

            smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(arg[0x10]));

            while!(dead(arg[0x10])) {
                if((force_phase == 0d1) || (<SCRIPT_OWNER>[HP] < (hp / 0d2))) {
                    arg[0x0e] = randrange(0d3);
                } else {
                    arg[0x0e] = randrange(0d3);
                }

                if(arg[0x0e] == 0d0) {
                    ai_move_fresh_meat(arg[0x10], arg[0x12]);
                } else if(arg[0x0e] == 0d1) {
                    ai_move_charge(arg[0x10], arg[0x12]);
                } else {
                    ai_move_hook(arg[0x10], arg[0x12]);
                }

                smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(arg[0x10]));
            }

            destroy(arg[0x12]); // TODO: delayed
        }
        fun add_custom_boss_pudge(x, y, flag_dead, callback_dead, force_phase, hp) {
            _add_custom_boss_pudge(x, y, force_phase, hp);
            yield();

            if(callback_dead is Function) {
                attach_to_script(LAST_ENTITY);

                while((!_dead(<SCRIPT_OWNER>)) && (!flag_dead)) {
                    yield();
                }

                if(flag_dead) {
                    destroy(<SCRIPT_OWNER>);
                }

                callback_dead();
            }
        }
    };

    area custom_boss_rat_boy() {
        enum BOSS {
            DEBUG = False,

            MOVE_COOLDOWN = 0d300,
        }

        @install()
        fun _roar(scream) {
            if(scream) {
                sound(THRAXX_DAMAGE);
            }

            sfx_effect(SHAKING, True);
            sleep(0d20);
            sfx_effect(SHAKING, False);
        }
        fun roar(scream) {
            if(scream !is None) {
                _roar(scream);
            } else {
                _roar();
            }

            yield();
        }

        group ai_moves() {    
            @install()
            @async()
            fun add_rat() {
                arg[0x10] = <SCRIPT_OWNER>;

                _add_enemy(RAT, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y]);
                attach_to_script(LAST_ENTITY);
                attach_script(SCRIPT_OWNER, DEATH, reference(@install() {
                    arg[0x10] = <SCRIPT_OWNER>[GENERAL_PURPOSE];

                    destroy(SCRIPT_OWNER);

                    arg[0x10][GENERAL_PURPOSE]--;
                }));
                <SCRIPT_OWNER>[GENERAL_PURPOSE] = arg[0x10];
                arg[0x10][GENERAL_PURPOSE]++;

                while(<SCRIPT_OWNER>[GENERAL_PURPOSE] != 0xffff) {
                    sleep(0d10);
                    if(dead(<SCRIPT_OWNER>)) {
                        end();
                    }
                }

                attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);
                yield();

                if(dead(<SCRIPT_OWNER>)) {
                    end();
                }

                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE_DIRECT, arg[0x10][X], arg[0x10][Y], SCRIPT_OWNER, False);

                destroy(SCRIPT_OWNER);
                arg[0x10][GENERAL_PURPOSE]--;
            }
            fun rat_split() {
                if(BOSS.DEBUG) {
                    debug_subtext("+split");
                }

                while(_alive(<SCRIPT_OWNER>) && <BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                    sleep(0d10);
                }

                control(SCRIPT_OWNER, True);

                animate_boy_kneel(SCRIPT_OWNER);

                sleep(0d20);

                animate(SCRIPT_OWNER, ONCE, DEFAULT);
                <SCRIPT_OWNER>[TYPE] = CHARACTER_TYPE.RAT_RED;
                control(SCRIPT_OWNER, False);

                add_rat();
                add_rat();
                while(rand(0x01) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] < 0d5)) {
                    add_rat();
                    yield();
                }

                yield();

                arg[0x14] = 0d0;
                while(_alive(<SCRIPT_OWNER>) && (arg[0x14] < 0d600) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] > 0d0)) {
                    arg[0x14]++;
                    yield();
                }

                while(_alive(<SCRIPT_OWNER>) && <BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                    sleep(0d10);
                }

                control(SCRIPT_OWNER, True);

                if(_alive(<SCRIPT_OWNER>) && <SCRIPT_OWNER>[GENERAL_PURPOSE] > 0d0) {
                    attribute(SCRIPT_OWNER, ROOT, True);

                    find_all(RAT, {
                        // walk(arg[0x12], COORDINATE_ABSOLUTE_DIRECT, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y], False, False)
                        // destroy();
                        arg[0x10][GENERAL_PURPOSE] = 0xffff;
                    });

                    while(<SCRIPT_OWNER>[GENERAL_PURPOSE] > 0d0) {
                        yield();
                    }

                    attribute(SCRIPT_OWNER, ROOT, False);
                }

                if(False) {
                    <SCRIPT_OWNER>[TYPE] = CHARACTER_TYPE.OWL_BLACK;
                    animate(SCRIPT_OWNER, ONCE, ANIMATION_ENEMY.BLACK_OWL_FUSION);
                    <SCRIPT_OWNER>[TYPE] = CHARACTER_TYPE.BOY_BLACK;

                    sleep(0d10);

                    animate(SCRIPT_OWNER, ONCE, DEFAULT);
                } else {
                    animate(SCRIPT_OWNER, ONCE_FREEZE, ANIMATION_BOY.LANDING);
                    <SCRIPT_OWNER>[TYPE] = CHARACTER_TYPE.BOY_BLACK;

                    sleep(0d10);

                    animate(SCRIPT_OWNER, ONCE, DEFAULT);
                }

                control(SCRIPT_OWNER, False);

                if(BOSS.DEBUG) {
                    debug_subtext("-split");
                }
            }
            @install()
            fun rat_boy_rocket_jump() {
                if(BOSS.DEBUG) {
                    debug_subtext("+jump");
                }

                guard_dead(<SCRIPT_OWNER>);

                roar(True);

                control(SCRIPT_OWNER, True);

                face_target(<SCRIPT_OWNER>, <BOY>);

                animate(SCRIPT_OWNER, ONCE_FREEZE, ANIMATION_BOY.LANDING);
                sleep(0d20);
                animate(SCRIPT_OWNER, ONCE, DEFAULT);
                sleep(0d1);

                if(False) {
                    face_target(<SCRIPT_OWNER>, <BOY>);
                } else {
                    walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE, <BOY>[X], <BOY>[Y], False, False);
                    sleep(0d10);
                    control(SCRIPT_OWNER, False);

                    if(False) {
                        yield();
                        control(SCRIPT_OWNER, True);
                    }
                }

                guard_dead(<SCRIPT_OWNER>);
                
                _rocket_jump(<SCRIPT_OWNER>, False, {
                    if(False) {
                        control(SCRIPT_OWNER, False);
                    }

                    sfx_effect(SHAKING, True);

                    bomb_entity(<SCRIPT_OWNER>, 0d150);

                    sleep(0d40);

                    sfx_effect(SHAKING, False);

                    if(BOSS.DEBUG) {
                        debug_subtext("-jump");
                    }
                });
            }
        };

        @install()
        @async()
        fun _add_custom_boss_rat_boy(x, y, force_phase, hp) {
            add_enemy(BOY_BLACK, 0d35, 0d40);
            <LAST_ENTITY>[HP] = hp;
            attach_to_script(LAST_ENTITY);

            attach_sterling_script(<SCRIPT_OWNER>, True, 0d10, 0d32, 0d40, 0d400, 0d15);

            smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(<SCRIPT_OWNER>));

            while!(dead(<SCRIPT_OWNER>)) {
                if(BOSS.DEBUG) {
                    debug_subtext("+rng");
                }

                while(alive(<SCRIPT_OWNER>) && (<SCRIPT_OWNER>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) || (<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED)  || (<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK)) {
                    yield();
                }

                if((force_phase == 0d1) || (<SCRIPT_OWNER>[HP] < (hp / 0d2))) {
                    arg[0x0e] = randrange(0d3);
                } else {
                    arg[0x0e] = randrange(0d4);
                }
                debug_memory(arg[0x0e]);

                if(arg[0x0e]) {
                    rat_split();
                } else {
                    rat_boy_rocket_jump();
                }

                if(BOSS.DEBUG) {
                    debug_subtext("-rng");
                }

                smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(<SCRIPT_OWNER>));
            }

            find_all(RAT, {
                destroy(arg[0x10]);
            });
        }
        fun add_custom_boss_rat_boy(x, y, flag_dead, callback_dead, force_phase, hp) {
            _add_custom_boss_rat_boy(x, y, force_phase, hp);
            yield();

            if(callback_dead is Function) {
                attach_to_script(LAST_ENTITY);

                while((!_dead(<SCRIPT_OWNER>)) && (!flag_dead)) {
                    yield();
                }

                if(flag_dead) {
                    destroy(<SCRIPT_OWNER>);
                }

                callback_dead();
            }
        }
    };

    area custom_boss_diablo() {
        enum BOSS {
            DEBUG = False,

            MOVE_COOLDOWN = 0d300,

            WITH_CHANNEL_PROTECTION = False,
        }

        @install()
        fun _roar(scream) {
            if(scream) {
                sound(THRAXX_DAMAGE);
            }

            sfx_effect(SHAKING, True);
            sleep(0d20);
            sfx_effect(SHAKING, False);
        }
        fun roar(scream) {
            if(scream !is None) {
                _roar(scream);
            } else {
                _roar();
            }

            yield();
        }

        group ai_moves() {
            @install()
            @async()
            fun add_shadow() {
                <SCRIPT_OWNER>[GENERAL_PURPOSE]++;

                arg[0x10] = <SCRIPT_OWNER>[X];
                arg[0x12] = <SCRIPT_OWNER>[Y];

                while((arg[0x10] == <SCRIPT_OWNER>[X]) && (arg[0x12] == <SCRIPT_OWNER>[Y])) {
                    guard_dead(<SCRIPT_OWNER>);

                    sleep(0d10);
                }

                sleep(0d60);

                guard_dead(<SCRIPT_OWNER>);

                _add_enemy(LIZARD, arg[0x10], arg[0x12]);
                <LAST_ENTITY>[HP] = 0d1;
                <LAST_ENTITY>[GENERAL_PURPOSE] = <SCRIPT_OWNER>;
                attach_to_script(<LAST_ENTITY>);
                attach_script(LAST_ENTITY, DEATH, reference(@install() {
                    arg[0x10] = <SCRIPT_OWNER>[GENERAL_PURPOSE];

                    arg[0x10][GENERAL_PURPOSE]--;

                    wait(SCRIPT_OWNER);
                    destroy(SCRIPT_OWNER);
                }));

                animate(SCRIPT_OWNER, ONCE, ANIMATION_ENEMY.LIZARD_DUCK_1);

                yield();

                smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(<SCRIPT_OWNER>));

                while!(dead(<SCRIPT_OWNER>)) {
                    arg[0x0e] = randrange(0d2);

                    if(arg[0x0e] == 0d0) {
                        animate(SCRIPT_OWNER, ONCE, ANIMATION_ENEMY.LIZARD_TALK);

                        // ai_move_projectile_ring(<SCRIPT_OWNER>, BOOMERANG, 0d75, 0x40, 0d5, 0d1, False, True);
                        ai_move_projectile_plus(<SCRIPT_OWNER>, ONION, 0d70);
                    } else {
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.LIZARD_TALK);
                        attribute(SCRIPT_OWNER, ROOT, True);
                        if(BOSS.WITH_CHANNEL_PROTECTION) {
                            attribute(SCRIPT_OWNER, INVINCIBLE, True);
                        }

                        projectile_beam(<ACTIVE>, 0d5);

                        if(BOSS.WITH_CHANNEL_PROTECTION) {
                            attribute(SCRIPT_OWNER, INVINCIBLE, False);
                        }
                        attribute(SCRIPT_OWNER, ROOT, False);
                        animate(SCRIPT_OWNER, ONCE, DEFAULT);
                    }

                    smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(<SCRIPT_OWNER>));
                }
            }
        };

        @install()
        @async()
        fun _add_custom_boss_diablo(x, y, force_phase, hp) {
            add_enemy(LIZARD, x, y);
            <LAST_ENTITY>[HP] = hp;
            attach_to_script(<LAST_ENTITY>);
            <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0d0;

            yield();

            smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(<SCRIPT_OWNER>));

            arg[0x10] = True;

            while!(dead(<SCRIPT_OWNER>)) {
                if((force_phase == 0d1) || (<SCRIPT_OWNER>[HP] < (hp / 0d2))) {
                    arg[0x0e] = randrange(0d2);
                } else {
                    arg[0x0e] = randrange(0d3);
                }

                debug_memory(arg[0x0e]);

                if(arg[0x0e] == 0d0) {
                    animate(SCRIPT_OWNER, ONCE, ANIMATION_ENEMY.LIZARD_TALK);

                    if!(<SCRIPT_OWNER>[GENERAL_PURPOSE]) {
                        ai_move_projectile_star(<SCRIPT_OWNER>, ONION, 0d70);
                    } else {
                        ai_move_projectile_x(<SCRIPT_OWNER>, ONION, 0d70);
                    }
                } else if(arg[0x0e] == 0d1) {
                    animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.LIZARD_TALK);
                    attribute(SCRIPT_OWNER, ROOT, True);
                    if(BOSS.WITH_CHANNEL_PROTECTION) {
                        attribute(SCRIPT_OWNER, INVINCIBLE, True);
                    }

                    projectile_beam(<ACTIVE>, 0d5);

                    if(BOSS.WITH_CHANNEL_PROTECTION) {
                        attribute(SCRIPT_OWNER, INVINCIBLE, False);
                    }
                    attribute(SCRIPT_OWNER, ROOT, False);
                    animate(SCRIPT_OWNER, ONCE, DEFAULT);
                } else {
                    if!(<SCRIPT_OWNER>[GENERAL_PURPOSE]) {
                        add_shadow();
                    } else {
                        arg[0x10] = True;
                    }
                }

                if!(arg[0x10]) {
                    smart_timer(arg[0x16], BOSS.MOVE_COOLDOWN, !_dead(<SCRIPT_OWNER>));
                } else {
                    arg[0x10] = False;
                }
            }
        }
        fun add_custom_boss_diablo(x, y, flag_dead, callback_dead, force_phase, hp) {
            _add_custom_boss_diablo(x, y, force_phase, hp);
            yield();

            if(callback_dead is Function) {
                attach_to_script(LAST_ENTITY);

                while((!_dead(<SCRIPT_OWNER>)) && (!flag_dead)) {
                    yield();
                }

                if(flag_dead) {
                    destroy(<SCRIPT_OWNER>);
                }

                callback_dead();
            }
        }
    };

    area custom_boss_aegis() {
        enum BOSS {
            DEBUG = False,

            MASKLESS_DURATION = 0d600,
        }

        enum MASK {
            SUN = 0d0,
            MOON = 0d1,
            CAT = 0d2,

            NONE = 0xffff,
        }
        
        @install()
        fun randomize_mask(entity, mask) {
            arg[0x10] = 0d5 + randrange(0d100);

            arg[0x14] = 0d100;
            while(arg[0x10] > 0d0) {
                guard_dead(entity);

                arg[0x10]--;
                arg[0x12]++;

                if(arg[0x12] > MASK.CAT) {
                    arg[0x12] = MASK.SUN;
                }

                if(arg[0x12] == MASK.SUN) {
                    animate(mask, LOOP, ANIMATION_PLACEHOLDER.AEGIS_MASK_1);
                } else if(arg[0x12] == MASK.MOON) {
                    animate(mask, LOOP, ANIMATION_PLACEHOLDER.AEGIS_MASK_2);
                } else {
                    animate(mask, LOOP, ANIMATION_PLACEHOLDER.AEGIS_MASK_3);
                }

                arg[0x14] = (arg[0x14] + arg[0x14] + arg[0x14]) >> 0d2;

                sleep(0d2 + arg[0x14]);
                sound(CLICK_1);
            }

            mask[GENERAL_PURPOSE] = arg[0x12];

            entity[GENERAL_PURPOSE] = True;
            if(BOSS.DEBUG) {
                debug_memory(entity, entity[GENERAL_PURPOSE]);
            }
        }
        @install()
        fun remove_mask(entity, mask) {
            guard_dead(entity);

            sleep(0d60);

            guard_dead(entity);

            animate(mask, ONCE_FREEZE, INVISIBLE_FADE);
            wait(mask);

            guard_dead(entity);

            mask[GENERAL_PURPOSE] = MASK.NONE;

            entity[GENERAL_PURPOSE] = False;
            if(BOSS.DEBUG) {
                debug_memory(entity, entity[GENERAL_PURPOSE]);
            }
        }

        @install()
        @async()
        fun _add_custom_boss_aegis(x, y, x_mask, y_mask, x_spawn, y_spawn, hp) {
            add_enemy(AEGIS_ENTITY, x, y);
            <LAST_ENTITY>[HP] = hp;
            arg[0x10] = <LAST_ENTITY>;
            <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
            attach_to_script(LAST_ENTITY);
            attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(@install() {
                if(<SCRIPT_OWNER>[GENERAL_PURPOSE]) {
                    sound(WEIRD_SOUND);

                    heal(SCRIPT_OWNER, 0d0, False);
                }

                if(dead(<SCRIPT_OWNER>)) {
                    end();
                }

                if(<ACTIVE>[Y] >= 0d275) {
                    if(BOSS.DEBUG) {
                        debug_subtext("center");
                    }

                    beam_wall(SOUTH, <BOY>, 0d150, 0d170, 0d360, 0d550, 0d20);
                } else if(<ACTIVE>[X] < 0d260) {
                    if(BOSS.DEBUG) {
                        debug_subtext("left");
                    }

                    beam_wall(SOUTH, <BOY>, 0d150, 0d170, 0d270, 0d550, 0d20);
                } else {
                    if(BOSS.DEBUG) {
                        debug_subtext("right");
                    }

                    beam_wall(SOUTH, <BOY>, 0d240, 0d170, 0d360, 0d550, 0d20);
                }

                if(BOSS.DEBUG) {
                    debug_memory(<SCRIPT_OWNER>, <SCRIPT_OWNER>[GENERAL_PURPOSE]);
                }
            }));

            yield();

            add_enemy(PLACEHOLDER, x_mask, y_mask);
            arg[0x12] = <LAST_ENTITY>;

            while(alive(arg[0x10])) {
                randomize_mask(arg[0x10], arg[0x12]);

                if(arg[0x10][HP] > 0d300) {
                    arg[0x14] = 0d1;
                } else {
                    arg[0x14] = 0d2;
                }

                if(BOSS.DEBUG) {
                    MEMORY.STRING_PARAMETER_1 = arg[0x12][GENERAL_PURPOSE];
                    debug_subtext("mask = [MEM1]");
                }

                if(arg[0x12][GENERAL_PURPOSE] == MASK.SUN) {
                    if(BOSS.DEBUG) {
                        debug_subtext("+rat boy");
                    }
                    add_custom_boss_rat_boy(x_spawn, y_spawn, _dead(arg[0x10]), {
                        if(BOSS.DEBUG) {
                            debug_subtext("-rat boy");
                        }
                    }, arg[0x14], 0d100);
                } else if(arg[0x12][GENERAL_PURPOSE] == MASK.MOON) {
                    if(BOSS.DEBUG) {
                        debug_subtext("+diablo");
                    }
                    add_custom_boss_diablo(0d35, 0d40, _dead(arg[0x10]), {
                        if(BOSS.DEBUG) {
                            debug_subtext("-diablo");
                        }
                    }, arg[0x14], 0d100);
                } else if(arg[0x12][GENERAL_PURPOSE] == MASK.CAT) {
                    if(BOSS.DEBUG) {
                        debug_subtext("+pudge");
                    }
                    add_custom_boss_pudge(x_spawn, y_spawn, _dead(arg[0x10]), {
                        if(BOSS.DEBUG) {
                            debug_subtext("-pudge");
                        }
                    }, arg[0x14], 0d100);
                }

                // debug_memory(dead(arg[0x10]), _dead(arg[0x10]));

                remove_mask(arg[0x10], arg[0x12]);

                smart_timer(arg[0x16], BOSS.MASKLESS_DURATION, !_dead(arg[0x10]));
            }

            destroy(arg[0x12]);
        }
        
        fun add_custom_boss_aegis(x, y, flag_dead, callback_dead, x_mask, y_mask, x_spawn, y_spawn, hp) {
            if!(flag_dead) {
                play_music(BOSS_DRUMS, False, True);

                _add_custom_boss_aegis(x, y, x_mask, y_mask, x_spawn, y_spawn, hp);
                yield();

                if(callback_dead is Function) {
                    attach_to_script(LAST_ENTITY);

                    while!(dead(<SCRIPT_OWNER>)) {
                        yield();
                    }

                    callback_dead();
                }
            }
        }
    };
};

// MAPS

group helper_global() {
    enum AREA_GLOBAL {
        ROCK_MOVED_SHIP = memory(FLAG, SRAM),
        ROCK_MOVED_SHIP_OFFSET = 0d8 * 0d5,
    }

    @install()
    fun add_levitate_stone_ship(x, y) {
        add_levitate_stone(x, y, reference(@install() {
            guard_levitate_stone(0d1);

            AREA_GLOBAL.ROCK_MOVED_SHIP = True;
        }));
        if(AREA_GLOBAL.ROCK_MOVED_SHIP) {
            <LAST_ENTITY>[Y] += AREA_GLOBAL.ROCK_MOVED_SHIP_OFFSET;
        }
        special_script(LEVITATE, reference(@install() {
            if(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.INVINCIBLE_TEMP) {
                end();
            }

            attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

            if!(AREA_GLOBAL.ROCK_MOVED_SHIP) {
                sleep(0d60);

                AREA_GLOBAL.ROCK_MOVED_SHIP = True;
                object[0x03] = 0x01; // open door_NW

                sleep(0d60);

                while(arg[0x10] < AREA_GLOBAL.ROCK_MOVED_SHIP_OFFSET) {
                    arg[0x10]++;

                    <SCRIPT_OWNER>[Y]++;

                    sleep(0d3);
                }

                sleep(0d360 - 0d3 * AREA_GLOBAL.ROCK_MOVED_SHIP_OFFSET);
            } else {
                sleep(0d120);

                while(arg[0x10] < AREA_GLOBAL.ROCK_MOVED_SHIP_OFFSET) {
                    arg[0x10]++;

                    <SCRIPT_OWNER>[Y]--;

                    sleep(0d3);
                }

                sleep(0d360 - 0d3 * AREA_GLOBAL.ROCK_MOVED_SHIP_OFFSET);

                AREA_GLOBAL.ROCK_MOVED_SHIP = False;
            }

            attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
        }));
    }
};

area intro_screens() {
    fun intro_skip() {
        init_souls();

        map_transition(inbetwixx, start, NONE);
    }

    map intro_1(OPENING) {
        enum entrance {
            test = entrance(0x10, 0x10, NONE),
        }

        fun trigger_enter() {
            if(False) {
                fade_in();
            }

            if(SOULS_MEMORY.WITH_OPENING) {
                if(SOULS_MEMORY.WITH_SAVESTATE_SAVE) {
                    if(False) {
                        call(0x92e0ca);
                    } else {
                        // unset(<0x22ea, 0x04>);
                        set(<0x22ea, 0x08>);
                        unset(<0x22ea, 0x20>);

                        fade_in();

                        if(False) {
                            while!(<0x22eb, 0x20>) {
                                debug_subtext("nope");
                                debug_memory(<0x22eb>, <0x22eb, 0x02>);
                                sleep(0d60);
                                // eval("26");
                            }
                        }
                        // fade_out();

                        // show_hud(True);
                        set(<0x22ea, 0x10>);
                        set(<0x22ea, 0x20>);
                    }
                } else {
                    call(0x92e0ca);
                }
            } else {
                if(SOULS_MEMORY.DEBUG && !SOULS_MEMORY.WITH_SAVESTATE_LOAD) {
                    intro_skip();
                } else {
                    boot_into_loading_screen();
                }
            }
        }
    };
    map intro_2(PODUNK_65) {
        enum entrance {
            north = entrance(0d09, 0d00, SOUTH),
            west = entrance(0d00, 0d19, EAST),

            cinema_left = entrance(0d64, 0d15, SOUTH),
            cinema_right = entrance(0d75, 0d15, SOUTH),
        }

        fun trigger_enter() {
            intro_skip();
        }
    };
};

area mini_games() {
    map mini_game_hacking(OMNITOPIA_ALARM) {
        enum soundtrack {
            default = soundtrack(SPACE, 0xff),
        }

        enum ROOM {
            DEBUG = False,
            DEBUG_INPUT = False,
            DEBUG_POINTS_GOAL = False,

            COLUMN_LEFT = 0d34,
            COLUMN_RIGHT = 0d58,

            ROW_1 = 0d60,
            ROW_2 = 0d68,
            ROW_3 = 0d76,
            ROW_4 = 0d84,

            DEBOUNCE = 0d3,

            CURSOR_X = memory(WORD, TEMP),
            CURSOR_Y = memory(WORD, TEMP),

            TESLA_ID_LEFT_1 = memory(WORD, TEMP),
            TESLA_ID_LEFT_2 = memory(WORD, TEMP),
            TESLA_ID_LEFT_3 = memory(WORD, TEMP),
            TESLA_ID_LEFT_4 = memory(WORD, TEMP),
            TESLA_ID_RIGHT_1 = memory(WORD, TEMP),
            TESLA_ID_RIGHT_2 = memory(WORD, TEMP),
            TESLA_ID_RIGHT_3 = memory(WORD, TEMP),
            TESLA_ID_RIGHT_4 = memory(WORD, TEMP),

            TESLA_ID_RIGHT = memory(WORD, TEMP),

            CHAIN_1 = memory(WORD, TEMP),
            CHAIN_2 = memory(WORD, TEMP),
            CHAIN_3 = memory(WORD, TEMP),
            CHAIN_4 = memory(WORD, TEMP),
            CHAIN_5 = memory(WORD, TEMP),
            CHAIN_6 = memory(WORD, TEMP),
            CHAIN_7 = memory(WORD, TEMP),
            CHAIN_8 = memory(WORD, TEMP),

            CHAIN_COOLDOWN = 0d10,

            POINTS = memory(WORD, TEMP),
            POINTS_GOAL = memory(WORD, TEMP),
            TILT = memory(FLAG, TEMP),

            WITH_ENEMY = True,
        }

        enum entrance {
            north = entrance(0x0e, 0x68, NONE),
            south = entrance(0x4c, 0x15, NONE),

            pod_left_1 = entrance(ROOM.COLUMN_LEFT, ROOM.ROW_1, NONE),
            pod_left_2 = entrance(ROOM.COLUMN_LEFT, ROOM.ROW_2, NONE),
            pod_left_3 = entrance(ROOM.COLUMN_LEFT, ROOM.ROW_3, NONE),
            pod_left_4 = entrance(ROOM.COLUMN_LEFT, ROOM.ROW_4, NONE),

            pod_right_1 = entrance(ROOM.COLUMN_RIGHT, ROOM.ROW_1, NONE),
            pod_right_2 = entrance(ROOM.COLUMN_RIGHT, ROOM.ROW_2, NONE),
            pod_right_3 = entrance(ROOM.COLUMN_RIGHT, ROOM.ROW_3, NONE),
            pod_right_4 = entrance(ROOM.COLUMN_RIGHT, ROOM.ROW_4, NONE),

            center = entrance(0d45, 0d72, NONE),
        }

        enum stepon_trigger {
            exit_north = @install() {
                debug_subtext("S=0");
            },
            exit_south = @install() {
                debug_subtext("S=1");
            },
            exit_south = @install() {
                debug_subtext("S=2");
            },
            exit_south = @install() {
                debug_subtext("S=3");
            },
            alarm_row_4 = @install() {
                if(False) {
                    debug_subtext("S=4");
                }
            },
            alarm_row_3 = @install() {
                if(False) {
                    debug_subtext("S=5");
                }
            },
            alarm_row_2 = @install() {
                if(False) {
                    debug_subtext("S=6");
                }
            },
            alarm_row_1 = @install() {
                if(False) {
                    debug_subtext("S=7");
                }
            },
        }

        enum b_trigger {
            gourd = @install() {
                debug_subtext("B=0");
            },
        }

        group game_logic() {
            fun room_hacked() {
                control(NONE);
                <BOY>[GENERAL_PURPOSE] = <BOY>[GENERAL_PURPOSE] + (True << 0x08);
            }

            fun exit_room() {
                if(ROOM.DEBUG) {
                    subtext("exit");
                }

                if(ROOM.TILT) {
                    dialog("[SLOW]You have been caught.[B]");
                }

                if((<BOY>[GENERAL_PURPOSE] & 0xff) == ARCHAEOLOGY_DIG.CODE_1) {
                    map_transition(west_inbetwixx, code_bot, NONE);
                } else if((<BOY>[GENERAL_PURPOSE] & 0xff) == ARCHAEOLOGY_DIG.CODE_2) {
                    map_transition(cave_left_south_east, code_bot, NONE);
                } else if((<BOY>[GENERAL_PURPOSE] & 0xff) == ARCHAEOLOGY_DIG.CODE_3) {
                    map_transition(volcano_tower, code_bot, NONE);
                } else if((<BOY>[GENERAL_PURPOSE] & 0xff) == ARCHAEOLOGY_DIG.CODE_4) {
                    map_transition(bugmuck, code_bot, NONE);
                } else if((<BOY>[GENERAL_PURPOSE] & 0xff) == ARCHAEOLOGY_DIG.CODE_5) {
                    map_transition(desert, code_bot, NONE);
                }
            }

            fun tilt() {
                ROOM.TILT = True;
                music(ALARM);
            }

            fun cursor_init(x, y) {
                teleport(BOY, x, y);
                control(NONE);

                ROOM.CURSOR_X = x;
                ROOM.CURSOR_Y = y;
            }
            fun cursor_x(x) {
                teleport(BOY, x, ROOM.CURSOR_Y);

                ROOM.CURSOR_X = x;
            }
            fun cursor_y(y) {
                teleport(BOY, ROOM.CURSOR_X, y);

                ROOM.CURSOR_Y = y;
            }

            fun cursor_up() {
                sound(CLICK_1);

                if(ROOM.CURSOR_Y == ROOM.ROW_2) {
                    cursor_y(ROOM.ROW_1);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("north 2");
                    }
                } else if(ROOM.CURSOR_Y == ROOM.ROW_3) {
                    cursor_y(ROOM.ROW_2);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("north 3");
                    }
                } else if(ROOM.CURSOR_Y == ROOM.ROW_4) {
                    cursor_y(ROOM.ROW_3);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("north 4");
                    }
                } else {
                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("north ?");
                    }
                }
            }
            fun cursor_right() {
                sound(CLICK_1);

                if(ROOM.CURSOR_X == ROOM.COLUMN_LEFT) {
                    cursor_x(ROOM.COLUMN_RIGHT);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("east");
                    }
                } else {
                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("east ?");
                    }
                }
            }
            fun cursor_down() {
                sound(CLICK_2);

                if(ROOM.CURSOR_Y == ROOM.ROW_1) {
                    cursor_y(ROOM.ROW_2);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("south 1");
                    }
                } else if(ROOM.CURSOR_Y == ROOM.ROW_2) {
                    cursor_y(ROOM.ROW_3);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("south 2");
                    }
                } else if(ROOM.CURSOR_Y == ROOM.ROW_3) {
                    cursor_y(ROOM.ROW_4);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("south 3");
                    }
                } else {
                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("south ?");
                    }
                }
            }
            fun cursor_left() {
                sound(CLICK_2);

                if(ROOM.CURSOR_X == ROOM.COLUMN_RIGHT) {
                    cursor_x(ROOM.COLUMN_LEFT);

                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("west");
                    }
                } else {
                    if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                        debug_subtext("west ?");
                    }
                }
            }
            @install()
            fun cursor(direction:DIRECTION) {
                control(BOY);

                if(direction == DIRECTION.NORTH) {
                    cursor_up();
                } else if(direction == DIRECTION.EAST) {
                    cursor_right();
                } else if(direction == DIRECTION.SOUTH) {
                    cursor_down();
                } else if(direction == DIRECTION.WEST) {
                    cursor_left();
                }
            }

            fun store_pod(x, y) {
                if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_1)) {
                    arg[0x0e] = ROOM.TESLA_ID_LEFT_1;
                } else if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_2)) {
                    arg[0x0e] = ROOM.TESLA_ID_LEFT_2;
                } else if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_3)) {
                    arg[0x0e] = ROOM.TESLA_ID_LEFT_3;
                } else if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_4)) {
                    arg[0x0e] = ROOM.TESLA_ID_LEFT_4;
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_1)) {
                    arg[0x0e] = ROOM.TESLA_ID_RIGHT_1;
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_2)) {
                    arg[0x0e] = ROOM.TESLA_ID_RIGHT_2;
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_3)) {
                    arg[0x0e] = ROOM.TESLA_ID_RIGHT_3;
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_4)) {
                    arg[0x0e] = ROOM.TESLA_ID_RIGHT_4;
                } else {
                    arg[0x0e] = 0x0000;
                }
            }

            fun _check_hacked(entity) {
                if(entity) {
                    if(ROOM.DEBUG && ROOM.DEBUG_POINTS_GOAL) {
                        debug_memory(entity, entity[GENERAL_PURPOSE], arg[0x12]);
                        sleep(0d60);
                    }

                    arg[0x12] += entity[GENERAL_PURPOSE];
                }
            }
            @install()
            fun check_hacked() {
                arg[0x12] = 0d0;

                _check_hacked(ROOM.CHAIN_1);
                _check_hacked(ROOM.CHAIN_2);
                _check_hacked(ROOM.CHAIN_3);
                _check_hacked(ROOM.CHAIN_4);
                _check_hacked(ROOM.CHAIN_5);
                _check_hacked(ROOM.CHAIN_6);
                _check_hacked(ROOM.CHAIN_7);
                _check_hacked(ROOM.CHAIN_8);

                if(ROOM.DEBUG) {
                    debug_memory(arg[0x12], ROOM.POINTS_GOAL);
                }

                ROOM.POINTS = arg[0x12];
            }

            @install()
            fun cursor_enter() {
                sound(CLICK_3);

                store_pod(ROOM.CURSOR_X, ROOM.CURSOR_Y);
                
                if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                    debug_subtext("B");
                }

                if((ROOM.CHAIN_1 == arg[0x0e]) || (ROOM.CHAIN_2 == arg[0x0e]) || (ROOM.CHAIN_3 == arg[0x0e]) || (ROOM.CHAIN_4 == arg[0x0e])) {
                    end();
                }

                if!(ROOM.CHAIN_1) {
                    ROOM.CHAIN_1 = arg[0x0e];
                } else if!(ROOM.CHAIN_2) {
                    if((ROOM.CHAIN_1[X] == arg[0x0e][X]) || ROOM.CHAIN_1[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_2 = arg[0x0e];
                    }
                } else if!(ROOM.CHAIN_3) {
                    if((ROOM.CHAIN_2[X] == arg[0x0e][X]) || ROOM.CHAIN_2[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_3 = arg[0x0e];
                    }
                } else if!(ROOM.CHAIN_4) {
                    if((ROOM.CHAIN_3[X] == arg[0x0e][X]) || ROOM.CHAIN_3[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_4 = arg[0x0e];
                    }
                } else if!(ROOM.CHAIN_5) {
                    if((ROOM.CHAIN_4[X] == arg[0x0e][X]) || ROOM.CHAIN_4[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_5 = arg[0x0e];
                    }
                } else if!(ROOM.CHAIN_6) {
                    if((ROOM.CHAIN_5[X] == arg[0x0e][X]) || ROOM.CHAIN_5[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_6 = arg[0x0e];
                    }
                } else if!(ROOM.CHAIN_7) {
                    if((ROOM.CHAIN_6[X] == arg[0x0e][X]) || ROOM.CHAIN_6[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_7 = arg[0x0e];
                    }
                } else if!(ROOM.CHAIN_8) {
                    if((ROOM.CHAIN_7[X] == arg[0x0e][X]) || ROOM.CHAIN_7[Y] == arg[0x0e][Y]) {
                        ROOM.CHAIN_8 = arg[0x0e];
                    }
                }

                check_hacked();
            }

            fun cursor_back() {
                sound(CLICK_3);

                if(ROOM.DEBUG && ROOM.DEBUG_INPUT) {
                    debug_subtext("A");
                }

                if(ROOM.CHAIN_8) {
                    ROOM.CHAIN_8 = 0x0000;
                } else if(ROOM.CHAIN_7) {
                    ROOM.CHAIN_7 = 0x0000;
                } else if(ROOM.CHAIN_6) {
                    ROOM.CHAIN_6 = 0x0000;
                } else if(ROOM.CHAIN_5) {
                    ROOM.CHAIN_5 = 0x0000;
                } else if(ROOM.CHAIN_4) {
                    ROOM.CHAIN_4 = 0x0000;
                } else if(ROOM.CHAIN_3) {
                    ROOM.CHAIN_3 = 0x0000;
                } else if(ROOM.CHAIN_2) {
                    ROOM.CHAIN_2 = 0x0000;
                } else if(ROOM.CHAIN_1) {
                    question("[SLOW]Exit?[CHOICE]exit…[CHOICE]cancel…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // exit
                        exit_room();
                    }
                }
            }

            fun pod(x, y, state) {
                ROOM.POINTS_GOAL += state;

                store_pod(x, y);
                arg[0x0e][GENERAL_PURPOSE] = state;

                if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_1)) {
                    debug_subtext("pod left 1");

                    object[0x02] = state; // open pod_left_1
                } else if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_2)) {
                    debug_subtext("pod left 2");

                    object[0x03] = state; // open pod_left_2
                } else if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_3)) {
                    debug_subtext("pod left 3");

                    object[0x04] = state; // open pod_left_3
                } else if((x == ROOM.COLUMN_LEFT) && (y == ROOM.ROW_4)) {
                    debug_subtext("pod left 4");

                    object[0x05] = state; // open pod_left_4
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_1)) {
                    debug_subtext("pod right 1");

                    object[0x06] = state; // open pod_right_1
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_2)) {
                    debug_subtext("pod right 2");

                    object[0x07] = state; // open pod_right_2
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_3)) {
                    debug_subtext("pod right 3");

                    object[0x08] = state; // open pod_right_3
                } else if((x == ROOM.COLUMN_RIGHT) && (y == ROOM.ROW_4)) {
                    debug_subtext("pod right 4");

                    object[0x09] = state; // open pod_right_4
                } else {
                    debug_subtext("pod unknown");
                }
            }

            @install()
            @async()
            fun tesla_chain_watcher() {
                while(True) {
                    if(ROOM.CHAIN_1) {
                        if(ROOM.CHAIN_2) {
                            shoot_entity_entity(ROOM.CHAIN_1, LIGHTNING, ROOM.CHAIN_2, 0d1, 0d0);
                        } else if((ROOM.CHAIN_1[X] == <BOY>[X]) || ROOM.CHAIN_1[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_1, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_2) {
                        if(ROOM.CHAIN_3) {
                            shoot_entity_entity(ROOM.CHAIN_2, LIGHTNING, ROOM.CHAIN_3, 0d1, 0d0);
                        } else if((ROOM.CHAIN_2[X] == <BOY>[X]) || ROOM.CHAIN_2[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_2, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_3) {
                        if(ROOM.CHAIN_4) {
                            shoot_entity_entity(ROOM.CHAIN_3, LIGHTNING, ROOM.CHAIN_4, 0d1, 0d0);
                        } else if((ROOM.CHAIN_3[X] == <BOY>[X]) || ROOM.CHAIN_3[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_3, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_4) {
                        if(ROOM.CHAIN_5) {
                            shoot_entity_entity(ROOM.CHAIN_4, LIGHTNING, ROOM.CHAIN_5, 0d1, 0d0);
                        } else if((ROOM.CHAIN_4[X] == <BOY>[X]) || ROOM.CHAIN_4[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_4, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_5) {
                        if(ROOM.CHAIN_6) {
                            shoot_entity_entity(ROOM.CHAIN_5, LIGHTNING, ROOM.CHAIN_6, 0d1, 0d0);
                        } else if((ROOM.CHAIN_5[X] == <BOY>[X]) || ROOM.CHAIN_5[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_5, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_6) {
                        if(ROOM.CHAIN_7) {
                            shoot_entity_entity(ROOM.CHAIN_6, LIGHTNING, ROOM.CHAIN_7, 0d1, 0d0);
                        } else if((ROOM.CHAIN_6[X] == <BOY>[X]) || ROOM.CHAIN_6[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_6, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_7) {
                        if(ROOM.CHAIN_8) {
                            shoot_entity_entity(ROOM.CHAIN_7, LIGHTNING, ROOM.CHAIN_8, 0d1, 0d0);
                        } else if((ROOM.CHAIN_7[X] == <BOY>[X]) || ROOM.CHAIN_7[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_7, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    if(ROOM.CHAIN_8) {
                        if((ROOM.CHAIN_8[X] == <BOY>[X]) || ROOM.CHAIN_8[Y] == <BOY>[Y]) {
                            shoot_entity_entity(ROOM.CHAIN_8, LIGHTNING, <BOY>, 0d1, 0d0);
                        }

                        sleep(ROOM.CHAIN_COOLDOWN);
                    }

                    sleep(ROOM.CHAIN_COOLDOWN);
                    sound(TESLA);
                }
            }

            fun add_player_sprite(enemy:ENEMY) {
                add_enemy(enemy, 0d0, 0d0);

                stack_sprite(<BOY>, <LAST_ENTITY>);
            }

            fun prepare_enemy(enemy:ENEMY, x, y) {
                add_enemy(enemy, x, y);

                attribute(LAST_ENTITY, ROOT, True);
            }

            fun prepare_pod(entity, x, y) {
                add_enemy(PLACEHOLDER, x, y);
                <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
                entity = <LAST_ENTITY>;

                if(arg[0x18] == arg[0x10]) { // start
                    ROOM.CHAIN_1 = <LAST_ENTITY>;

                    cursor_init(x, y);
                    pod(x, y, 0x03);
                } else if(arg[0x18] == arg[0x12]) { // end
                    pod(x, y, 0x03);
                } else if(arg[0x18] == arg[0x14]) { // node
                    pod(x, y, 0x01);
                } else if(arg[0x18] == arg[0x16]) { // node
                    pod(x, y, 0x01);
                }

                arg[0x18]++;
            }
        };

        fun trigger_enter() {
            // object[0x00] = 0x06; // open gate_north
            // object[0x01] = 0x06; // gate_south
            // object[0x02] = 0x03; // open pod_left_1
            // object[0x03] = 0x03; // open pod_left_2
            // object[0x04] = 0x03; // open pod_left_3
            // object[0x05] = 0x03; // open pod_left_4
            // object[0x06] = 0x03; // open pod_right_1
            // object[0x07] = 0x03; // open pod_right_2
            // object[0x08] = 0x03; // open pod_right_3
            // object[0x09] = 0x03; // open pod_right_4
            // object[0x0a] = 0x02; // open gourd

            if(False) {
                set_camera(TILE_CENTER, 0d45, 0d72, 0x80);
                wait(CAMERA_PAN_X);
                wait(CAMERA_PAN_Y);
                free_camera();
            }
            

            CUSTOM_FLAG.NO_DOG = True;
            fade_in();
            attach_script(BOY, DAMAGE_DEATH, reference(@install() {
                heal(SCRIPT_OWNER, 0d0, False);
                
                tilt();
            }));

            // control(NONE);
            attribute(BOY, INVISIBLE, True);
            add_player_sprite(DUSTER_BOT);
            attribute(BOY, ROOT, True);
            MEMORY.PACIFIED = True;

            arg[0x10] = randrange(0d8); // start
            while((arg[0x12] == 0d0) || (arg[0x12] == arg[0x10])) { // end
                arg[0x12] = randrange(0d8);
            }
            while((arg[0x14] == 0d0) || (arg[0x14] == arg[0x10]) || (arg[0x14] == arg[0x12])) { // node
                arg[0x14] = randrange(0d8);
            }
            while((arg[0x16] == 0d0) || (arg[0x16] == arg[0x10]) || (arg[0x16] == arg[0x12]) || (arg[0x16] == arg[0x14])) { // node
                arg[0x16] = randrange(0d8);
            }

            prepare_pod(ROOM.TESLA_ID_LEFT_1, ROOM.COLUMN_LEFT, ROOM.ROW_1);
            prepare_pod(ROOM.TESLA_ID_LEFT_2, ROOM.COLUMN_LEFT, ROOM.ROW_2);
            prepare_pod(ROOM.TESLA_ID_LEFT_3, ROOM.COLUMN_LEFT, ROOM.ROW_3);
            prepare_pod(ROOM.TESLA_ID_LEFT_4, ROOM.COLUMN_LEFT, ROOM.ROW_4);
            prepare_pod(ROOM.TESLA_ID_RIGHT_1, ROOM.COLUMN_RIGHT, ROOM.ROW_1);
            prepare_pod(ROOM.TESLA_ID_RIGHT_2, ROOM.COLUMN_RIGHT, ROOM.ROW_2);
            prepare_pod(ROOM.TESLA_ID_RIGHT_3, ROOM.COLUMN_RIGHT, ROOM.ROW_3);
            prepare_pod(ROOM.TESLA_ID_RIGHT_4, ROOM.COLUMN_RIGHT, ROOM.ROW_4);

            if(False) {
                cursor_init(ROOM.COLUMN_LEFT, ROOM.ROW_1);
                pod(ROOM.CURSOR_X, ROOM.CURSOR_Y, 0x03);
                pod(ROOM.COLUMN_RIGHT, ROOM.ROW_4, 0x03);
                pod(ROOM.COLUMN_LEFT, ROOM.ROW_3, 0x01);
                
                ROOM.CHAIN_1 = ROOM.TESLA_ID_LEFT_1;
            }
            tesla_chain_watcher();

            if(ROOM.WITH_ENEMY) {
                if(randrange(0d2)) {
                    prepare_enemy(GATE_BOT, 0d45, 0d72);
                } else {
                    prepare_enemy(GUARD_BOT, 0d45, 0d72);
                }
            }

            while((ROOM.POINTS < ROOM.POINTS_GOAL) && (!ROOM.TILT)) {
                // debug_memory(CUSTOM_MEMORY.INPUT_P1, CUSTOM_MEMORY.INPUT_P1 & 0x0400);

                if(CUSTOM_MEMORY.INPUT_P1 & 0x0800) { // north
                    sleep(ROOM.DEBOUNCE);
                    if(CUSTOM_MEMORY.INPUT_P1 & 0x0800) {
                        cursor(NORTH);

                        while(CUSTOM_MEMORY.INPUT_P1 & 0x0800) {
                            sleep(ROOM.DEBOUNCE);
                        }
                    }
                } else if(CUSTOM_MEMORY.INPUT_P1 & 0x0100) { // east
                    sleep(ROOM.DEBOUNCE);
                    if(CUSTOM_MEMORY.INPUT_P1 & 0x0100) {
                        cursor(EAST);

                        while(CUSTOM_MEMORY.INPUT_P1 & 0x0100) {
                            sleep(ROOM.DEBOUNCE);
                        }
                    }
                } else if(CUSTOM_MEMORY.INPUT_P1 & 0x0400) { // south
                    sleep(ROOM.DEBOUNCE);
                    if(CUSTOM_MEMORY.INPUT_P1 & 0x0400) {
                        cursor(SOUTH);

                        while(CUSTOM_MEMORY.INPUT_P1 & 0x0400) {
                            sleep(ROOM.DEBOUNCE);
                        }
                    }
                } else if(CUSTOM_MEMORY.INPUT_P1 & 0x0200) { // west
                    sleep(ROOM.DEBOUNCE);
                    if(CUSTOM_MEMORY.INPUT_P1 & 0x0200) {
                        cursor(WEST);

                        while(CUSTOM_MEMORY.INPUT_P1 & 0x0200) {
                            sleep(ROOM.DEBOUNCE);
                        }
                    }
                } else if(CUSTOM_MEMORY.INPUT_P1 & 0x8000) { // b
                    sleep(ROOM.DEBOUNCE);
                    if(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                        cursor_enter();

                        while(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                            sleep(ROOM.DEBOUNCE);
                        }
                    }
                } else if(CUSTOM_MEMORY.INPUT_P1 & 0x0080) { // a
                    sleep(ROOM.DEBOUNCE);
                    if(CUSTOM_MEMORY.INPUT_P1 & 0x0080) {
                        cursor_back();

                        while(CUSTOM_MEMORY.INPUT_P1 & 0x0080) {
                            sleep(ROOM.DEBOUNCE);
                        }
                    }
                }

                sleep(ROOM.DEBOUNCE);
            }

            if(ROOM.DEBUG) {
                subtext("yatta");
            }

            if!(ROOM.TILT) {
                room_hacked();
            }

            exit_room();
        }
    };
};

area shrine_area() {
    map shrine(VILLAGE) {
        // sniff=vanilla

        enum entrance {
            north = entrance(0x59, 0x0d, SOUTH),
            east = entrance(0x7d, 0x65, WEST),
            south = entrance(0x59, 0x73, NORTH),
            west = entrance(0x01, 0x2f, EAST),

            hut_1 = entrance(0x0f, 0x1b, SOUTH),
            hut_2 = entrance(0x33, 0x2d, SOUTH),
            hut_3 = entrance(0x53, 0x2f, SOUTH),
            hut_4 = entrance(0x65, 0x35, SOUTH),
            hut_5 = entrance(0x6f, 0x49, SOUTH),
            hut_6 = entrance(0x45, 0x53, SOUTH),
            hut_7 = entrance(0x25, 0x5b, SOUTH),
            hut_8 = entrance(0x21, 0x3b, SOUTH),

            crash = entrance(0d75, 0d95, NONE, { crash_both(); }),
        }

        enum soundtrack {
            default = soundtrack(MYSTERY, 0xff)
        }

        enum ROOM {
            SHRINE_BONFIRE_LIT = memory(FLAG, SRAM),

            SMITH_UNLOCKED = memory(FLAG, SRAM),
        }

        @install()
        fun bonfire_triggered_first_bonfire() {
            fake_b();

            question("[SLOW]Return to the beginning?[CHOICE]Yes.[CHOICE]No.");

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                map_transition(inbetwixx, center, NONE);
            }
        }

        @install()
        fun bonfire_triggered_inbetwixx() {
            guard_boy_damage();
            
            text_start();
            text("[SLOW]Return to Inbetwixx?");
            if(SOULS_MEMORY.BONFIRE_INBETWIXX) {
                text("[CHOICE]Inbetwixx…");
            } else {
                text("[CHOICE]…");
            }
            await_answer();
            text_end();
            control(BOTH);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                if(SOULS_MEMORY.BONFIRE_INBETWIXX) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.CROSSING;
                    map_transition(inbetwixx, bonfire, NONE);
                }
            }
        }
        @install()
        fun bonfire_triggered_east() {
            guard_boy_damage();

            text_start();
            text("[SLOW]Return to East Inbetwixx?");
            if(SOULS_MEMORY.BONFIRE_EAST_CROSSING) {
                text("[CHOICE]Eastern Cave");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_PIPES) {
                text("[CHOICE]Pipe maze");
            } else {
                text("[CHOICE]…");
            }
            await_answer();
            text_end();
            control(BOTH);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                if(SOULS_MEMORY.BONFIRE_EAST_CROSSING) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.BLIMP_EXTERIOR;
                    map_transition(east_crossing, bonfire, NONE);
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                if(SOULS_MEMORY.BONFIRE_PIPES) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.PIPEMAZE_ROOMS;
                    map_transition(pipe_entrance, bonfire, NONE);
                }
            }
        }
        @install()
        fun bonfire_triggered_west() {
            guard_boy_damage();

            text_start();
            text("[SLOW]Return to West Inbetwixx?");
            if(SOULS_MEMORY.BONFIRE_VOLCANO_TOWER) {
                text("[CHOICE]Volcano Tower…");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_ISAAC_DUNGEON) {
                text("[CHOICE]Basement Lvl1…");
            } else {
                text("[CHOICE]…");
            }
            await_answer();
            text_end();
            control(BOTH);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                if(SOULS_MEMORY.BONFIRE_VOLCANO_TOWER) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.STERLING;
                    map_transition(volcano_tower, bonfire, NONE);
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                if(SOULS_MEMORY.BONFIRE_ISAAC_DUNGEON) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.DARK_FOREST;
                    map_transition(basement_0_start, bonfire, NONE);
                }
            }
        }
        @install()
        fun bonfire_triggered_town() {
            guard_boy_damage();

            text_start();
            text("[SLOW]Return to Town?");
            if(SOULS_MEMORY.BONFIRE_TOWN_CENTER) {
                text("[CHOICE]Town Center…");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_TEMPLE_PIT) {
                text("[CHOICE]Temple Lvl.2…");
            } else {
                text("[CHOICE]…");
            }
            await_answer();
            text_end();
            control(BOTH);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                if(SOULS_MEMORY.BONFIRE_TOWN_CENTER) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.NOBILIA_SQUARE;
                    map_transition(town_center, bonfire, NONE); // TODO
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                if(SOULS_MEMORY.BONFIRE_TEMPLE_PIT) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.FIREPIT_NOBILIA;
                    SOULS_MEMORY.BONFIRE_VARIANT = 0d1;
                    map_transition(temple_underground_firepit, bonfire, NONE); // TODO
                }
            }
        }
        @install()
        fun bonfire_triggered_jungle() {
            guard_boy_damage();

            control(NONE);
            text_box(0x0a, 0d5); // text_start();
            text("[SLOW]Return to Southern Jungle?");
            if(SOULS_MEMORY.BONFIRE_JUNGLE_PIT) {
                text("[CHOICE]Jungle Pit…");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_BUG) {
                text("[CHOICE]Bug…");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_DESERT) {
                text("[CHOICE]Desert…");
            } else {
                text("[CHOICE]…");
            }
            await_answer();
            text_end();
            control(BOTH);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                if(SOULS_MEMORY.BONFIRE_JUNGLE_PIT) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.FIREPIT_JUNGLE;
                    map_transition(jungle_firepit, bonfire, NONE);
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                if(SOULS_MEMORY.BONFIRE_BUG) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.VOLCANO_ROOMS;
                    SOULS_MEMORY.BONFIRE_VARIANT = 0d2;
                    map_transition(bugmuck_cave_1, bonfire, NONE);
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                if(SOULS_MEMORY.BONFIRE_DESERT) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.HALLS_NE;
                    SOULS_MEMORY.BONFIRE_VARIANT = 0d1;
                    map_transition(desert_temple_main, bonfire, NONE);
                }
            }
        }
        @install()
        fun bonfire_triggered_altus() {
            guard_boy_damage();

            text_start();
            text("[SLOW]Return to Altus Plateu?");
            if(SOULS_MEMORY.BONFIRE_ALTUS_WELL) {
                text("[CHOICE]Well…");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_ALTUS_STAIRS) {
                text("[CHOICE]Stairs…");
            } else {
                text("[CHOICE]…");
            }
            if(SOULS_MEMORY.BONFIRE_CASTLE_PIT) {
                text("[CHOICE]Castle Pit…");
            } else {
                text("[CHOICE]…");
            }
            await_answer();
            text_end();
            control(BOTH);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                if(SOULS_MEMORY.BONFIRE_ALTUS_WELL) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.WELL;
                    map_transition(well, bonfire, NONE);
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                if(SOULS_MEMORY.BONFIRE_ALTUS_STAIRS) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.CHESSBOARD_STAIRS;
                    map_transition(stairs, bonfire, NONE);
                }
            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                if(SOULS_MEMORY.BONFIRE_CASTLE_PIT) {
                    SOULS_MEMORY.BONFIRE_MAP = MAP.FIREPIT_NOBILIA;
                    SOULS_MEMORY.BONFIRE_VARIANT = 0d0;
                    map_transition(castle_fire_pit, bonfire, NONE);
                }
            }
        }

        fun bonfire_portal(x, y, flag, active, trigger) {
            if(flag) {
                if!(active) {
                    add_enemy(LANTERN_LIGHT, x, y, INACTIVE);
                } else {
                    add_enemy(LANTERN_LIGHT_RED, x, y, INACTIVE);
                }
                attach_script(LAST_ENTITY, DAMAGE, trigger);
                attribute(LAST_ENTITY, ROOT, True);
                <LAST_ENTITY>[HP] = SYSTEM.HP_MAX;
                // <LAST_ENTITY>[PALETTE] = 0x0000;
            }
        }

        @install()
        fun add_bonfire() {
            bonfire_portal(0d77, 0d92, SOULS_MEMORY.BONFIRE_INBETWIXX, (SOULS_MEMORY.BONFIRE_MAP == MAP.CROSSING), reference(bonfire_triggered_inbetwixx)); // inbetwixx

            bonfire_portal(0d77, 0d100, (SOULS_MEMORY.BONFIRE_EAST_CROSSING || SOULS_MEMORY.BONFIRE_PIPES), ((SOULS_MEMORY.BONFIRE_MAP == MAP.BLIMP_EXTERIOR) || (SOULS_MEMORY.BONFIRE_MAP == MAP.PIPEMAZE_ROOMS)), reference(bonfire_triggered_east)); // east inbetwixx

            bonfire_portal(0d69, 0d104, (SOULS_MEMORY.BONFIRE_TOWN_CENTER || SOULS_MEMORY.BONFIRE_TEMPLE_PIT), ((SOULS_MEMORY.BONFIRE_MAP == MAP.NOBILIA_SQUARE) || ((SOULS_MEMORY.BONFIRE_MAP == MAP.FIREPIT_NOBILIA) && (SOULS_MEMORY.BONFIRE_VARIANT == 0d1))), reference(bonfire_triggered_town)); // town

            bonfire_portal(0d61, 0d104, (SOULS_MEMORY.BONFIRE_ISAAC_DUNGEON || SOULS_MEMORY.BONFIRE_VOLCANO_TOWER), ((SOULS_MEMORY.BONFIRE_MAP == MAP.DARK_FOREST) || (SOULS_MEMORY.BONFIRE_MAP == MAP.STERLING)), reference(bonfire_triggered_west)); // west inbetwixx

            bonfire_portal(0d53, 0d100, (SOULS_MEMORY.BONFIRE_JUNGLE_PIT || SOULS_MEMORY.BONFIRE_BUG || SOULS_MEMORY.BONFIRE_DESERT), ((SOULS_MEMORY.BONFIRE_MAP == MAP.FIREPIT_JUNGLE) || (SOULS_MEMORY.BONFIRE_MAP == MAP.VOLCANO_ROOMS) || (SOULS_MEMORY.BONFIRE_MAP == MAP.HALLS_NE)), reference(bonfire_triggered_jungle)); // southern jungle

            bonfire_portal(0d51, 0d92, (SOULS_MEMORY.BONFIRE_ALTUS_WELL || SOULS_MEMORY.BONFIRE_ALTUS_STAIRS || SOULS_MEMORY.BONFIRE_CASTLE_PIT), ((SOULS_MEMORY.BONFIRE_MAP == MAP.WELL) || (SOULS_MEMORY.BONFIRE_MAP == MAP.CHESSBOARD_STAIRS) || ((SOULS_MEMORY.BONFIRE_MAP == MAP.FIREPIT_NOBILIA) && (SOULS_MEMORY.BONFIRE_VARIANT == 0d0))), reference(bonfire_triggered_altus)); // altus plateau 

            // bonfire_portal(0d59, 0d88, …); // omnitopia
        }

        @install()
        fun locked_door() {
            subtext("Locked.");
        }

        enum stepon_trigger {
            exit_hut_1 = @install() {
                map_transition(hut_dog_lady, door, NORTH);
            },
            exit_hut_2 = @install() {
                map_transition(hut_2, door, NORTH);
            },
            exit_hut_3 = @install() {
                map_transition(hut_3, door, NORTH);
            },
            exit_hut_4 = @install() {
                map_transition(hut_crafter, door, NORTH);
            },
            exit_hut_5 = @install() {
                map_transition(hut_5, door, NORTH);
            },
            exit_hut_6 = @install() {
                map_transition(hut_6, door, NORTH);
            },
            exit_hut_7 = @install() {
                map_transition(hut_smith, door, NORTH);
            },
            exit_hut8 = @install() {
                map_transition(hut_cat, door, NORTH);
            },
            guard_east = @install() {
                debug_subtext("S=8");
            },
            exit_north = @install() {
                map_transition(shrine, south, NORTH);
            },

            exit_south = @install() {
                map_transition(shrine, north, SOUTH);
            },
            exit_east = @install() {
                map_transition(shrine, west, EAST);
            },
            exit_west = @install() {
                map_transition(shrine, east, WEST);
            },
        }

        @install()
        fun first_bonfire_triggered() {
            if(SOULS_MEMORY.DEBUG && !(SOULS_MEMORY.WITH_SHRINE_INTRO)) {
                bonfire_triggered_first_bonfire();
            } else {
                if(
                    (NPC_SHRINE_MAIDEN.PROGRESS == 0d0) && (NPC_SHRINE_MAIDEN.SUB_PROGRESS == 0d3) &&
                    !(ROOM.SHRINE_BONFIRE_LIT)
                ) {
                    ROOM.SHRINE_BONFIRE_LIT = True;
                    
                    NPC_SHRINE_MAIDEN.PROGRESS++;
                    NPC_SHRINE_MAIDEN.SUB_PROGRESS = 0x00;

                    object[0x11] = 0x1; // ignite fire

                    add_bonfire();
                } else if(ROOM.SHRINE_BONFIRE_LIT) {
                    bonfire_triggered_first_bonfire();
                }
            }
        }

        enum b_trigger {
            sniff__1_ash = first_bonfire_triggered(), // object[0x12]=0x01; object[0x13]=0x01; ?
            sniff__1_ash = first_bonfire_triggered(), // object[0x12]=0x01; object[0x14]=0x01; ?
            sniff__1_ash = first_bonfire_triggered(), // object[0x13]=0x01; object[0x14]=0x01; ?
            gourd__2_wax = @install() {
                debug_subtext("B=3");
                _loot_chest(0x00, WAX, 0d02);
            },
            sniff__1_water = @install() {
                debug_subtext("B=4");
                _loot(0x0c, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=5");
                _loot(0x0b, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=6");
                _loot(0x0a, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=7");
                _loot(0x09, ROOTS, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=8");
                _loot(0x08, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=9");
                _loot(0x07, OIL, 0d01, 0d00);
            },

            sniff__1_water = @install() {
                debug_subtext("B=10");
                _loot(0x06, WATER, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=11");
                _loot(0x05, OIL, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=12");
                _loot(0x04, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=13");
                _loot(0x03, ROOTS, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=14");
                _loot(0x02, OIL, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=15");
                _loot(0x0d, WATER, 0d01, 0d00); // object[0x0d]=0x01; ?
            },
            sniff__1_ash = @install() {
                debug_subtext("B=16");
                _loot(0x0e, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=17");
                _loot(0x0f, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=18");
                _loot(0x10, ASH, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=19");
                _loot(0x01, ROOTS, 0d01, 0d00);
            },
        }

        fun show_bonfires() {
            object[0x11] = 0x01; // ignite fire

            add_bonfire();
        }

        fun add_door(x, y, locked) {
            if(locked) {
                add_enemy(STONE_ROUND, x, y);
                attach_script(LAST_ENTITY, B, reference(@install() { error_message(DOOR_LOCKED); }));
            } else {
                add_enemy(STONE_ROUND, x - 0d4, y);
            }
        }

        fun trigger_enter() {
            if!(FLAG.IN_ANIMATION) {
                crash_both();
            }

            add_souls_npc_bee_boy(0d60, 0d60);

            add_door(0d15, 0d29, NPC_DOG_LADY.PROGRESS < 0d1); // dog lady
            add_door(0d51, 0d47, True);
            add_door(0d83, 0d49, True);
            add_door(0d101, 0d57, NPC_CRAFTER.PROGRESS < 0x20); // crafter
            add_door(0d111, 0d75, True);


            add_door(0d33, 0d62, False); // cat
            add_door(0d69, 0d85, True); // shrine maiden

            if(ROOM.SHRINE_BONFIRE_LIT) {
                show_bonfires();
            } else if(SOULS_MEMORY.DEBUG && !(SOULS_MEMORY.WITH_SHRINE_INTRO)) {
                show_bonfires();
            }

            add_souls_npc_shrine_maiden(0d71, 0d88);
            if(NPC_SMITH.PROGRESS == 0d0) {
                add_door(0d37, 0d93, True); // smith
                add_souls_npc_smith(0d42, 0d93);
            } else {
                add_door(0d37, 0d93, False); // smith
                ROOM.SMITH_UNLOCKED = True;
            }

            // object[0x00] = 0x01; // open gourd
            // … sniff spots?
            // object[0x11] = 0x01; // ignite fire

            default_init_room(False, False);

            add_debug_entity(0d54, 0d84, reference(@install() {
                SOULS_MEMORY.CLEARED_TRAP_WOLF = True;
                SOULS_MEMORY.CLEARED_TRAP_GREYHOUND = True;
                SOULS_MEMORY.CLEARED_TRAP_POODLE = True;

                SOULS_MEMORY.SMITH_KEY = True;
                ROOM.SMITH_UNLOCKED = True;
                NPC_SMITH.PROGRESS = 0d1;

                MEMORY.IRON = 0d5;
                MEMORY.METEORITE = 0d5;

                MEMORY.CHICKEN = 0d1;

                SOULS_MEMORY.ORB_SWORD = 0d99;
                SOULS_MEMORY.ORB_AXE = 0d99;
                SOULS_MEMORY.ORB_SPEAR = 0d99;

                SOULS_MEMORY.ESTUS_SHARDS = 0d99;

                SOULS_MEMORY.BEES = 0d99;

                currency_get(TALONS, 0d1000);

                destroy(SCRIPT_OWNER);
            }));
        }
    };

    map hut_dog_lady(VILLAGE_HUTS) { // variant 1_1
        enum entrance {
            door = entrance(0x10, 0x23, NORTH),
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door_1_2 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_1, SOUTH);
            },
        }

        enum b_trigger {
            gourd_3_3_3__1_water = nop(),
            gourd_3_3_2__1_water = nop(),
            gourd_3_3_1__1_water = nop(),
            gourd_3_2_4__1_water = nop(),
            gourd_3_2_3__4_water = nop(),
            gourd_3_2_1__1_petal = nop(),
            gourd_3_2_2__2_clay = nop(),
            gourd_3_1_2__1_call_beads = nop(),
            gourd_3_1_1__1_water = nop(),
            gourd_2_3_2__2_water = nop(),

            gourd_2_3_1__1_roots = nop(),
            gourd_2_2_3__4_water = nop(),
            gourd_2_2_2__2_roots = nop(),
            gourd_2_2_1__1_water = nop(),
            gourd_2_1_3__3_clay = nop(),
            gourd_2_1_2__18_money = nop(),
            gourd_2_1_1__1_clay = nop(),
            gourd_1_3_3__2_roots = nop(),
            gourd_1_3_2__1_water = nop(),
            gourd_1_3_1__1_nectar = nop(),

            gourd_1_2_3__30_money = nop(),
            gourd_1_2_2__1_water = nop(),
            gourd_1_2_1__4_water = nop(),
            gourd_2 = @install() {
                debug_subtext("B=23");
                _loot_chest(0x01, WATER, 0d01);
            },
            gourd_1_1_1 = @install() {
                debug_subtext("B=24");
                _loot_chest(0x00, ROOTS, 0d01);
            },
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x01);

            // object[0x00] = 0x01; // open gourd_1_1_1
            // object[0x01] = 0x01; // open gourd_1_1_2

            if(NPC_DOG_LADY.PROGRESS >= 0d1) {
                add_souls_npc_dog_lady(0d15, 0d16);
            }

            default_init_room(False, False);
        }
    };

    map hut_2(VILLAGE_HUTS) { // variant 2_3
        enum entrance {
            door = entrance(0x54, 0x49, NORTH),
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_2, SOUTH);
            },
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door_1_2 = nop(),
            exit_door_1_1 = nop(),
        }

        enum b_trigger {
            gourd_3_3_3__1_water = nop(),
            gourd_3_3_2__1_water = nop(),
            gourd_3_3_1__1_water = nop(),
            gourd_3_2_4__1_water = nop(),
            gourd_3_2_3__4_water = nop(),
            gourd_3_2_1__1_petal = nop(),
            gourd_3_2_2__2_clay = nop(),
            gourd_3_1_2__1_call_beads = nop(),
            gourd_3_1_1__1_water = nop(),
            gourd_2__2_water = @install() {
                debug_subtext("B=9");
                _loot_chest(0x0f, WATER, 0d02);
            },

            gourd_1__1_roots = @install() {
                debug_subtext("B=10");
                _loot_chest(0x0e, ROOTS, 0d01);
            },
            gourd_2_2_3__4_water = nop(),
            gourd_2_2_2__2_roots = nop(),
            gourd_2_2_1__1_water = nop(),
            gourd_2_1_3__3_clay = nop(),
            gourd_2_1_2__18_money = nop(),
            gourd_2_1_1__1_clay = nop(),
            gourd_1_3_3__2_roots = nop(),
            gourd_1_3_2__1_water = nop(),
            gourd_1_3_1__1_nectar = nop(),

            gourd_1_2_3__30_money = nop(),
            gourd_1_2_2__1_water = nop(),
            gourd_1_2_1__4_water = nop(),
            gourd_1_1_2__1_water = nop(),
            gourd_1_1_1__2_roots = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x06);

            // object[0x0e] = 0x01; // open gourd_2_3_1
            // object[0x0f] = 0x01; // open gourd_2_3_2

            default_init_room(False, False);
        }
    };

    map hut_3(VILLAGE_HUTS) { // variant 1_2
        enum entrance {
            door = entrance(0x32, 0x23, NORTH),
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_3, SOUTH);
            },
            exit_door_1_1 = nop(),
        }

        enum b_trigger {
            gourd_3_3_3__1_water = nop(),
            gourd_3_3_2__1_water = nop(),
            gourd_3_3_1__1_water = nop(),
            gourd_3_2_4__1_water = nop(),
            gourd_3_2_3__4_water = nop(),
            gourd_3_2_1__1_petal = nop(),
            gourd_3_2_2__2_clay = nop(),
            gourd_3_1_2__1_call_beads = nop(),
            gourd_3_1_1__1_water = nop(),
            gourd_2_3_2__2_water = nop(),

            gourd_2_3_1__1_roots = nop(),
            gourd_2_2_3__4_water = nop(),
            gourd_2_2_2__2_roots = nop(),
            gourd_2_2_1__1_water = nop(),
            gourd_2_1_3__3_clay = nop(),
            gourd_2_1_2__18_money = nop(),
            gourd_2_1_1__1_clay = nop(),
            gourd_1_3_3__2_roots = nop(),
            gourd_1_3_2__1_water = nop(),
            gourd_1_3_1__1_nectar = nop(),

            gourd_3__30_money = @install() {
                debug_subtext("B=20");
                _loot_chest(0x04, MONEY, 0d30);
            },
            gourd_2__1_water = @install() {
                debug_subtext("B=21");
                _loot_chest(0x03, WATER, 0d01);
            },
            gourd_1__4_water = @install() {
                debug_subtext("B=22");
                _loot_chest(0x02, WATER, 0d03);
            },
            gourd_1_1_2__1_water = nop(),
            gourd_1_1_1__2_roots = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x02);

            // object[0x02] = 0x01; // open gourd_1_2_1
            // object[0x03] = 0x01; // open gourd_1_2_2
            // object[0x04] = 0x01; // open gourd_1_2_3

            default_init_room(False, False);
        }
    };

    map hut_crafter(VILLAGE_HUTS) { // variant 1_3
        enum entrance {
            door = entrance(0x32, 0x23, NORTH),
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_4, SOUTH);
            },
            exit_door_1_1 = nop(),
        }

        enum b_trigger {
            gourd_3_3_3__1_water = nop(),
            gourd_3_3_2__1_water = nop(),
            gourd_3_3_1__1_water = nop(),
            gourd_3_2_4__1_water = nop(),
            gourd_3_2_3__4_water = nop(),
            gourd_3_2_1__1_petal = nop(),
            gourd_3_2_2__2_clay = nop(),
            gourd_3_1_2__1_call_beads = nop(),
            gourd_3_1_1__1_water = nop(),
            gourd_2_3_2__2_water = nop(),

            gourd_2_3_1__1_roots = nop(),
            gourd_2_2_3__4_water = nop(),
            gourd_2_2_2__2_roots = nop(),
            gourd_2_2_1__1_water = nop(),
            gourd_2_1_3__3_clay = nop(),
            gourd_2_1_2__18_money = nop(),
            gourd_2_1_1__1_clay = nop(),
            gourd_1_3_3__2_roots = nop(),
            gourd_1_3_2__1_water = nop(),
            gourd_1_3_1__1_nectar = nop(),

            gourd_3__30_money = @install() {
                debug_subtext("B=20");
                _loot_chest(0x04, MONEY, 0d30);
            },
            gourd_2__1_water = @install() {
                debug_subtext("B=21");
                _loot_chest(0x03, WATER, 0d01);
            },
            gourd_1__4_water = @install() {
                debug_subtext("B=22");
                _loot_chest(0x02, WATER, 0d03);
            },
            gourd_1_1_2__1_water = nop(),
            gourd_1_1_1__2_roots = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x02);

            // object[0x02] = 0x01; // open gourd_1_2_1
            // object[0x03] = 0x01; // open gourd_1_2_2
            // object[0x04] = 0x01; // open gourd_1_2_3

            if(NPC_CRAFTER.PROGRESS >= 0x20) {
                add_souls_npc_crafter(0d57, 0d23);
            }

            default_init_room(False, False);
        }
    };

    map hut_5(VILLAGE_HUTS) { // variant 2_1
        enum entrance {
            door = entrance(0x10, 0x49, NORTH),
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_5, SOUTH);
            },
            exit_door_1_3 = nop(),
            exit_door_1_2 = nop(),
            exit_door_1_1 = nop(),
        }

        enum b_trigger {
            gourd_3_3_3__1_water = nop(),
            gourd_3_3_2__1_water = nop(),
            gourd_3_3_1__1_water = nop(),
            gourd_3_2_4__1_water = nop(),
            gourd_3_2_3__4_water = nop(),
            gourd_3_2_1__1_petal = nop(),
            gourd_3_2_2__2_clay = nop(),
            gourd_3_1_2__1_call_beads = nop(),
            gourd_3_1_1__1_water = nop(),
            gourd_2_3_2__2_water = nop(),

            gourd_2_3_1__1_roots = nop(),
            gourd_2_2_3__4_water = nop(),
            gourd_2_2_2__2_roots = nop(),
            gourd_2_2_1__1_water = nop(),
            gourd_3__3_clay = @install() {
                debug_subtext("B=14");
                _loot_chest(0x0a, CLAY, 0d03);
            },
            gourd_2__18_money = @install() {
                debug_subtext("B=15");
                _loot_chest(0x09, MONEY, 0d18);
            },
            gourd_1__1_clay = @install() {
                debug_subtext("B=16");
                _loot_chest(0x08, CLAY, 0d01);
            },
            gourd_1_3_3__2_roots = nop(),
            gourd_1_3_2__1_water = nop(),
            gourd_1_3_1__1_nectar = nop(),

            gourd_1_2_3__30_money = nop(),
            gourd_1_2_2__1_water = nop(),
            gourd_1_2_1__4_water = nop(),
            gourd_1_1_2__1_water = nop(),
            gourd_1_1_1__2_roots = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x04);

            // object[0x08] = 0x01; // open gourd_2_1_1
            // object[0x09] = 0x01; // open gourd_2_1_2
            // object[0x0a] = 0x01; // open gourd_2_1_3

            default_init_room(False, False);
        }
    };

    map hut_6(VILLAGE_HUTS) { // variant 3_1 (fire eyes)
        enum entrance {
            door = entrance(0x10, 0x6f, NORTH),
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_6, SOUTH);
            },
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door_1_2 = nop(),
            exit_door_1_1 = nop(),
        }

        enum b_trigger {
            gourd_3_3_3__1_water = nop(),
            gourd_3_3_2__1_water = nop(),
            gourd_3_3_1__1_water = nop(),
            gourd_3_2_4__1_water = nop(),
            gourd_3_2_3__4_water = nop(),
            gourd_3_2_1__1_petal = nop(),
            gourd_3_2_2__2_clay = nop(),
            gourd_2__1_call_beads = @install() {
                debug_subtext("B=7");
                // _loot_chest(0x11, BISCUIT, 0d01);
                _loot_chest(0x11, CALL_BEADS, 0d01);
            },
            gourd_1__1_water = @install() {
                debug_subtext("B=8");
                _loot_chest(0x10, WATER, 0d01);
            },
            gourd_2_3_2__2_water = nop(),

            gourd_2_3_1__1_roots = nop(),
            gourd_2_2_3__4_water = nop(),
            gourd_2_2_2__2_roots = nop(),
            gourd_2_2_1__1_water = nop(),
            gourd_2_1_3__3_clay = nop(),
            gourd_2_1_2__18_money = nop(),
            gourd_2_1_1__1_clay = nop(),
            gourd_1_3_3__2_roots = nop(),
            gourd_1_3_2__1_water = nop(),
            gourd_1_3_1__1_nectar = nop(),

            gourd_1_2_3__30_money = nop(),
            gourd_1_2_2__1_water = nop(),
            gourd_1_2_1__4_water = nop(),
            gourd_1_1_2__1_water = nop(),
            gourd_1_1_1__2_roots = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x07);

            // object[0x10] = 0x01; // open gourd_3_1_1
            // object[0x11] = 0x01; // open gourd_3_1_2

            default_init_room(False, False);
        }
    };

    map hut_smith(VILLAGE_HUTS) {
        enum entrance {
            door = entrance(0x32, 0x23, NORTH),
        }

        enum soundtrack {
            default = soundtrack(MYSTERY, 0xff)
        }

        enum stepon_trigger {
            exit_door_3_3 = nop(),
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door = @install() {
                map_transition(shrine, hut_7, SOUTH);
            },
            exit_door_1_1 = nop(),
        }

        enum b_trigger {
            gourd_3_3_3 = nop(),
            gourd_3_3_2 = nop(),
            gourd_3_3_1 = nop(),
            gourd_3_2_4 = nop(),
            gourd_3_2_3 = nop(),
            gourd_3_2_1 = nop(),
            gourd_3_2_2 = nop(),
            gourd_3_1_2 = nop(),
            gourd_3_1_1 = nop(),
            gourd_2_3_2 = nop(),

            gourd_2_3_1 = nop(),
            gourd_2_2_3 = nop(),
            gourd_2_2_2 = nop(),
            gourd_2_2_1 = nop(),
            gourd_2_1_3 = nop(),
            gourd_2_1_2 = nop(),
            gourd_2_1_1 = nop(),
            gourd_1_3_3 = nop(),
            gourd_1_3_2 = nop(),
            gourd_1_3_1 = nop(),

            gourd_3__30_money = @install() {
                debug_subtext("B=20");
                _loot_chest(0x04, MONEY, 0d30);
            },
            gourd_2__1_water = @install() {
                debug_subtext("B=21");
                _loot_chest(0x03, WATER, 0d01);
            },
            gourd_1__4_water = @install() {
                debug_subtext("B=22");
                _loot_chest(0x02, WATER, 0d03);
            },
            gourd_1_1_2 = nop(),
            gourd_1_1_1 = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2 ?
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x02);

            // object[0x02] = 0x01; // open gourd_1_2_1
            // object[0x03] = 0x01; // open gourd_1_2_2
            // object[0x04] = 0x01; // open gourd_1_2_3

            if(NPC_SMITH.PROGRESS >= 0d1) {
                add_souls_npc_smith(0d49, 0d18);
            }

            default_init_room(False, False);
        }
    };

    map hut_cat(VILLAGE_HUTS) {
        enum entrance {
            door = entrance(0x54, 0x6f, NORTH),
        }

        enum soundtrack {
            default = soundtrack(INN_GUITAR, 0xff)
        }

        enum stepon_trigger {
            exit_door = @install() {
                map_transition(shrine, hut_8, SOUTH);
            },
            exit_door_3_2 = nop(),
            exit_door_3_1 = nop(),
            exit_door_2_3 = nop(),
            exit_door_2_2 = nop(),
            exit_door_2_1 = nop(),
            exit_door_1_3 = nop(),
            exit_door_1_2 = nop(),
            exit_door_1_1 = nop(),
        }

        @install()
        @async()
        fun entity_general_purpose_check(entity) {
            while(entity[GENERAL_PURPOSE] == 0x00) {
                yield();
            }

            map_transition(gourd_trap_wolf, right, NONE);
        }

        enum b_trigger {
            gourd_3 = @install() {
                <ACTIVE>[GENERAL_PURPOSE] = 0x00;
                gourd_trap(0x18, <ACTIVE>, 0d96, 0d95);
                entity_general_purpose_check(<ACTIVE>);
                // _loot_chest(0x18, WATER, 0x03);
            },
            gourd_2 = @install() {
                _loot_chest(0x17, WATER, 0x02);
            },
            gourd_1 = @install() {
                _loot_chest(0x16, WATER, 0x01);
            },
            gourd_3_2_4 = nop(),
            gourd_3_2_3 = nop(),
            gourd_3_2_1 = nop(),
            gourd_3_2_2 = nop(),
            gourd_3_1_2 = nop(),
            gourd_3_1_1 = nop(),
            gourd_2_3_2 = nop(),

            gourd_2_3_1 = nop(),
            gourd_2_2_3 = nop(),
            gourd_2_2_2 = nop(),
            gourd_2_2_1 = nop(),
            gourd_2_1_3 = nop(),
            gourd_2_1_2 = nop(),
            gourd_2_1_1 = nop(),
            gourd_1_3_3 = nop(),
            gourd_1_3_2 = nop(),
            gourd_1_3_1 = nop(),

            gourd_1_2_3 = nop(),
            gourd_1_2_2 = nop(),
            gourd_1_2_1 = nop(),
            gourd_1_1_2 = nop(),
            gourd_1_1_1 = nop(),
        }

        fun init_map(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x20, 0x24); // hut_1_1
            } else if(index == 0x02) {
                init_map(0x22, 0x00, 0x42, 0x24); // hut_1_2
            } else if(index == 0x03) {
                init_map(0x44, 0x00, 0x64, 0x24); // hut_1_3
            } else if(index == 0x04) {
                init_map(0x00, 0x26, 0x20, 0x4a); // hut_2_1
            } else if(index == 0x05) {
                init_map(0x22, 0x26, 0x42, 0x4a); // hut_2_2
            } else if(index == 0x06) {
                init_map(0x44, 0x26, 0x64, 0x4a); // hut_2_3
            } else if(index == 0x07) {
                init_map(0x00, 0x4c, 0x20, 0x70); // hut_3_1
            } else if(index == 0x08) {
                init_map(0x22, 0x4c, 0x42, 0x70); // hut_3_2
            } else if(index == 0x09) {
                init_map(0x44, 0x4c, 0x64, 0x70); // hut_3_3
            }
        }

        fun trigger_enter() {
            init_map(0x09);

            // object[0x16] = 0x01; // open gourd_3_3_1
            // object[0x17] = 0x01; // open gourd_3_3_2
            // object[0x18] = 0x01; // open gourd_3_3_3

            arg[0x00] = randrange(0x05);

            if(arg[0x00] == 0x00) {
                add_souls_npc_cat(CLEANING, 0d89, 0d103); // fish cleaning
            } else if(arg[0x00] == 0x01) {
                add_souls_npc_cat(LOOKING, 0d78, 0d100); // desk looking
            } else if(arg[0x00] == 0x02) {
                add_souls_npc_cat(CLEANING, 0d76, 0d92); // food cleaning
    
            } else {
                add_souls_npc_cat(CLEANING, 0d78, 0d100); // desk cleaning
            }

            if(SOULS_MEMORY.CLEARED_TRAP_WOLF) {
                object[0x18] = 0x01; // open gourd_3_3_3
            }

            default_init_room(False, False);
        }
    };
};

area inbetwixx_center() {
    map inbetwixx(CROSSING) {
        // chests=vanilla
        // sniff=vanilla

        enum entrance {
            north = entrance(0x2d, 0x01, SOUTH),
            east = entrance(0x5f, 0x4d, WEST),
            west_1 = entrance(0x04, 0x71, EAST),
            west_2 = entrance(0x04, 0x2f, EAST),

            start = entrance(0x0f, 0x47, NONE),
            center = entrance(0x0f, 0x47, NONE, { bonfire_wakeup(0d0, -0d16, -0d24, 0d0); }),
            bonfire = entrance(0d49, 0d53, NONE, { bonfire_wakeup(0d0, -0d16, -0d24, 0d0); }),
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum ROOM {
            DEBUG = False,

            WALL_1 = retained_object(0x01),
            WALL_2 = retained_object(0x00),
            
            BRIDGE_REVEALED = memory(FLAG, SRAM),
            BRIDGE_REVEALER_ENTITY = memory(WORD, TEMP),

            FLOWER_GATE = memory(WORD, TEMP),

            WITH_FLOWER_TRIGGER = False,

            WITH_ILLUSORY_WALL = True,

            WITH_CUSTOM_GOURD = True,
            CUSTOM_GOURD_LOOTED = memory(FLAG, SRAM),
        }

        @install()
        fun ravine_triggered() {
            guard_z();

            generic_fall(0d100, 0d300);

            dust_unreachable(0d45, 0d35);
            damage(BOTH, 0d999, True);
            sleep(0d30);
            damage(BOTH, SYSTEM.HP_MAX, False);
        }

        enum stepon_trigger {
            stepon_0 = @install() {
                debug_subtext("S=0");
            },
            stepon_1 = ravine_triggered(),
            stepon_2 = ravine_triggered(),
            stepon_3 = ravine_triggered(),
            stepon_4 = ravine_triggered(),
            stepon_5 = ravine_triggered(),
            stepon_6 = ravine_triggered(),
            diamon_eyes = @install() {
                if(ROOM.WITH_FLOWER_TRIGGER) {
                    face(ROOM.FLOWER_GATE, SOUTH);
                    animate(ROOM.FLOWER_GATE, ONCE, SLASH_1);
                }
            },
            exit_east = @install() {
                map_transition(east_inbetwixx, west_2, EAST);
            },
            exit_north = @install() {
                fog_wall_outside(!SOULS_MEMORY.DEAD_GIDEON, SOUTH);

                map_transition(north_inbetwixx, south, NORTH);
            },
            exit_west_2_east = @install() {
                map_transition(northwest_inbetwixx, east, WEST);
            },
            exit_west_1_exit = @install() {
                map_transition(west_inbetwixx, east_2, WEST);
            },
            stepon_12 = @install() {
                debug_subtext("S=12");
            },
            stepon_13 = @install() {
                debug_subtext("S=13");
            },
            stepon_14 = @install() {
                debug_subtext("S=14");
            },
            stepon_15 = @install() {
                debug_subtext("S=15");
            },

            stepon_16 = @install() {
                debug_subtext("S=16");
            },
            stepon_17 = @install() {
                debug_subtext("S=17");
            },
            stepon_18 = @install() {
                debug_subtext("S=18");
            },
            stepon_19 = @install() {
                debug_subtext("S=19");
            }
        }

        enum b_trigger {
            wall_2 = @install() fun trigger_wall_2() {
                if!(ROOM.WITH_ILLUSORY_WALL) {
                    bombable_object(WALL_AXE2, True, ROOM.WALL_2, 0x00, 0x01);
                } else {
                    bombable_object(ILLUSION, True, ROOM.WALL_2, 0x00, 0x01);
                }
            },
            wall_1 = @install() fun trigger_wall_1() {
                bombable_object(WALL_AXE2, True, ROOM.WALL_1, 0x01, 0x01);
            },
            gourd_2_1__3_water = @install() {
                debug_subtext("B=2");

                if!(ROOM.WITH_CUSTOM_GOURD) {
                    _loot_chest(0x06, WATER, 0d03);
                } else {
                    ROOM.CUSTOM_GOURD_LOOTED = True;
                    object[0x06] = 0x01; // block gourd_2_1

                    custom_reward(BUG_CATCHER_BROKEN, True);
                }
            },
            gourd_1_1__2_water = @install() {
                debug_subtext("B=3");
                _loot_chest(0x05, WATER, 0d02);
            },
            gourd_1_2__3_limestone = @install() {
                debug_subtext("B=4");
                _loot_chest(0x07, LIMESTONE, 0d03);
            },
            gourd_1_3__4_wax = @install() {
                debug_subtext("B=5");
                _loot_chest(0x08, WAX, 0d04);
            },
            sniff__1_ethanol_3 = @install() {
                debug_subtext("B=6");
                _loot(0x09, ETHANOL, 0d01, 0d03);
            },
            sniff__1_ethanol_2 = @install() {
                debug_subtext("B=7");
                _loot(0x0a, ETHANOL, 0d01, 0d02);
            },
            sniff__1_roots_1 = @install() {
                debug_subtext("B=8");
                _loot(0x0b, ROOTS, 0d01, 0d01);
            },
            sniff__1_roots_3 = @install() {
                debug_subtext("B=9");
                _loot(0x0c, ROOTS, 0d01, 0d03);
            },

            sniff__1_roots = @install() {
                debug_subtext("B=10");
                _loot(0x0d, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots_2 = @install() {
                debug_subtext("B=11");
                _loot(0x0e, ROOTS, 0d01, 0d02);
            },
            sniff__1_limestone_2 = @install() {
                debug_subtext("B=12");
                _loot(0x0f, LIMESTONE, 0d01, 0d02);
            },
            sniff__1_limestone_1 = @install() {
                debug_subtext("B=13");
                _loot(0x10, LIMESTONE, 0d01, 0d01);
            },
            sniff__1_wax_2 = @install() {
                debug_subtext("B=14");
                _loot(0x11, WAX, 0d01, 0d02);
            },
            sniff__1_wax_2 = @install() {
                debug_subtext("B=15");
                _loot(0x12, WAX, 0d01, 0d02);
            },
            sniff__1_water_1 = @install() {
                debug_subtext("B=16");
                _loot(0x13, WATER, 0d01, 0d01);
            },
            sniff__1_vinegar_1 = @install() {
                debug_subtext("B=17");
                _loot(0x14, VINEGAR, 0d01, 0d01);
            },
            sniff__1_vinegar_1 = @install() {
                debug_subtext("B=18");
                _loot(0x15, VINEGAR, 0d01, 0d01);
            },
            sniff__1_bone_1 = @install() {
                debug_subtext("B=19");
                _loot(0x16, BONE, 0d01, 0d01);
            },
        }

        fun init_room() {
            default_init_room(True, True);

            if(SOULS_MEMORY.WITH_AREA_NAMES) {
                subtext("Inbetwixx");
            }
        }

        fun intro() {
            // teleport(BOY, 0x0f, 0x47);
            teleport(DOG, 0x13, 0x49);

            if(SOULS_MEMORY.WITH_INTRO) {
                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_SLEEP);

                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);

                sleep(0x50);
            }

            if(SOULS_MEMORY.WITH_STARTING_CLASS) {
                choose_starting_class();

                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_SLEEP);

                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);

                choose_starting_item();
            }

            if(SOULS_MEMORY.WITH_INTRO) {
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);
                sleep(0x30);
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);
                sleep(0x40);
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);
                sleep(0x15);
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);

                animate(BOY, ONCE, ANIMATION_BOY.KNEEL);

                sleep(0x20);
                animate(DOG, ONCE, DEFAULT);
            }
        }

        @install()
        fun energy_core_triggered() {
            if(<ACTIVE> == <BOY>) {
                animate(BOY, ONCE, ANIMATION_BOY.LOOT);
                sleep(0x10);

                unlock(ENERGY_CORE);

                destroy(SCRIPT_OWNER);
            }
        }

        @install()
        @async()
        fun revealer_approached() {
            range_checker(ROOM.BRIDGE_REVEALER_ENTITY, <ACTIVE>, 0x20, 0x20, { ravine_triggered(); });
        }

        @install()
        fun revealer_triggered() {
            set(ROOM.BRIDGE_REVEALED);
            object[0x02] = 0x7e;
            sleep(0x29);
            destroy(ROOM.BRIDGE_REVEALER_ENTITY);
        }

        @install()
        fun debug_triggered() {
            if(False) {
                unlock(ALL);
            } else {
                unlock(WEAPONS);
                unlock(ARMOR);
                unlock(JAGUAR_RING);
                if(False) {
                    unlock(CHARMS);
                }
                unlock(CONSUMABLES);
                unlock(INGREDIENTS);
                unlock(TRADING_GOODS);
                unlock(MONEY);
                unlock(ALCHEMY);
                
                // unlock(SPEAR_1);
                unlock(AXE_2);

                set(FLAG.REVEALER);
                MEMORY.SELECTED_ALCHEMY_0 = ALCHEMY_INDEX.REVEALER;
                set(FLAG.LEVITATE);
                MEMORY.SELECTED_ALCHEMY_1 = ALCHEMY_INDEX.LEVITATE;
                set(FLAG.HARD_BALL);
                MEMORY.SELECTED_ALCHEMY_2 = ALCHEMY_INDEX.HARD_BALL;

                set(FLAG.ATLAS);
                MEMORY.SELECTED_ALCHEMY_3 = ALCHEMY_INDEX.ATLAS;
                set(FLAG.DEFEND);
                MEMORY.SELECTED_ALCHEMY_4 = ALCHEMY_INDEX.DEFEND;
                set(FLAG.FLASH);
                MEMORY.SELECTED_ALCHEMY_5 = ALCHEMY_INDEX.FLASH;
                set(FLAG.SPEED);
                MEMORY.SELECTED_ALCHEMY_6 = ALCHEMY_INDEX.SPEED;

                SOULS_MEMORY.BOMB_ENABLED = True;
                SOULS_MEMORY.MARIO_YUMP_ENABLED = True;
                SOULS_MEMORY.ISAAC_TEARS_ENABLED = True;
                SOULS_MEMORY.PUPPER_ENABLED = True;
                SOULS_MEMORY.ROCKET_JUMP_ENABLED = True;
                SOULS_MEMORY.QUANTUM_JUMP_ENABLED = True;
                update_debug_menu();
            }

            if(SOULS_MEMORY.WITH_DEBUG_ENTITY_ALCHEMY_SELECTION) {
                select_alchemy();
            }
            
            destroy(SCRIPT_OWNER);
        }
        
        @install()
        fun trigger_enter() {
            add_debug_entity(0d16, 0d63, reference(debug_triggered));

            if(False) {
                add_enemy(PLACEHOLDER, 0d22, 0d68);
                attach_script(LAST_ENTITY, B, reference(@install() {
                    arg[0x10] = <SCRIPT_OWNER>[X];
                    arg[0x12] = <SCRIPT_OWNER>[Y];

                    wow_archaeology_guard();

                    if(False) {
                        subtext("!");
                    }

                    _add_enemy(GUARD_BOT, arg[0x10], arg[0x12], INACTIVE);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        subtext("!");
                    }));
                }));
                SOULS_MEMORY.ARCHAEOLOGY_TARGET = <LAST_ENTITY>;
            }

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // center
                add_enemy(FLOWER_PURPLE, 0d52, 0d79);

                // north
                add_enemy(BUZZARD_1, 0d29, 0d35);

                // east
                // add_enemy(FLOWER_PURPLE, 0x59, 0x4f);
                add_enemy(FLOWER_PURPLE, 0x4d, 0x4a);
                ROOM.FLOWER_GATE = <LAST_ENTITY>;

                // south
                add_enemy(FLOWER_PURPLE, 0d28, 0d109);

                add_enemy(FLOWER_PURPLE, 0d36, 0d96);

                add_enemy(FLOWER_PURPLE, 0x2a, 0x56);
            }

            if!(ROOM.BRIDGE_REVEALED) {
                add_enemy(REVEALER_TARGET_ENTITY, 0x24, 0x1a);
                ROOM.BRIDGE_REVEALER_ENTITY = <LAST_ENTITY>;

                special_script(REVEALER, reference(revealer_triggered));
                revealer_approached();
            } else {
                revealer_triggered();
            }

            init_room();

            if!(FLAG.IN_ANIMATION) {
                if!(SOULS_MEMORY.INTRO_WATCHED) {
                    set(SOULS_MEMORY.INTRO_WATCHED);

                    subtext("`The Missadventures of Vex´");

                    intro();

                    subtext("v0.9.0 - by r.bin");
                }
                
                // code(0xa3, 0x18, "// (a3) CALL 'Prepare room change? North exit/south entrance outdoor-indoor?' (0x26)"); // TODO: 4x4 combinations, not 4
                // 19=ww, 1a=Ww, 1b=wn, 1c=ws, 1d=ee, 1e=Ee, 1f=EN
                // 20=ES, 21=SS, 22=Ss, 23=sW, 24=SW, 25=SE, 26=NN, 27=NN, 28=NE, 29=NW, 2a=NS, 2b=Ns, 2c=ns, 2d=ss

                // load_map(0x05, 0x0f, 0x47);
            }

            bonfire(0d49, 0d53, SOULS_MEMORY.BONFIRE_INBETWIXX);

            add_bombable(0d63, 0d63, ROOM.WALL_1, reference(trigger_wall_1));
            add_bombable(0d64, 0d99, ROOM.WALL_2, reference(trigger_wall_2));

            // object[0x02] = 0x01; // show bridge
            // object[0x01] = 0x01; // open wall_1
            // object[0x00] = 0x01; // open wall_2
            // object[0x04] = 0x01; // block exit_east_left
            // object[0x03] = 0x01; // block exit_east_right
            // object[0x05] = 0x01; // block gourd_1_1
            // object[0x07] = 0x01; // block gourd_1_2
            // object[0x08] = 0x01; // block gourd_1_3
            // object[0x06] = 0x01; // block gourd_2_1
            // sniff spots

            if(ROOM.WITH_CUSTOM_GOURD) {
                if(ROOM.CUSTOM_GOURD_LOOTED) {
                    object[0x06] = 0x01; // block gourd_2_1
                }
            }

            player_message(0d30, 0d75, reference(@install() {
                player_message_triggered();

                subtext("try rolling");
            }));

            if(False) {
                destroy(DOG);
                add_enemy(BOXER_1, 0x13, 0x47);
                // attach_script(LAST_ENTITY, 0x100, reference(@install() { if(dead(<SCRIPT_OWNER>)) { subtext("true"); } else { subtext("false"); } }));
            }

            safe_create_code();
        }
    };
};

area north_inbetwixx() {
    map north_inbetwixx(HALLS_EXTERIOR) {
        // sniff=vanilla
        
        enum entrance {
            north = entrance(0x41, 0x03, SOUTH),
            south = entrance(0x45, 0x41, NORTH),
        }

        enum soundtrack {
            default = soundtrack(WIND_AMBIENT_BIRDS_2, 0xff),
        }

        fun outro_triggered() {
            question("[SLOW]I'm afraid there is no final boss, yet.[B]After starting the credits you can't return back to the game.[B]Exit the games and roll the credits?[CHOICE]credits…[CHOICE]leave…");

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                show_credits();
            } else {
                map_transition(inbetwixx, north, SOUTH);
            }

            end();
        }

        enum stepon_trigger {
            exit_south = @install() {
                debug_subtext("S=0");

                fog_wall_inside(True, NORTH);

                map_transition(inbetwixx, north, SOUTH);
            },
            exit_north = @install() {
                debug_subtext("S=1");

                fog_wall_inside(!SOULS_MEMORY.DEAD_GIDEON, SOUTH);

                show_credits();
            },
        }

        enum b_trigger {
            sniff__1_ash = @install() {
                debug_subtext("B=0");
                _loot(0x0f, ASH, 0d01, 0d00);
            },
            sniff__1_ash_2 = @install() {
                debug_subtext("B=1");
                _loot(0x0e, ASH, 0d01, 0d02);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=2");
                _loot(0x0d, ASH, 0d01, 0d00);
            },
            sniff__1_ethanol_3 = @install() {
                debug_subtext("B=3");
                _loot(0x0c, ETHANOL, 0d01, 0d03);
            },
            sniff__1_ethanol = @install() {
                debug_subtext("B=4");
                _loot(0x0b, ETHANOL, 0d01, 0d00);
            },
            sniff__1_ethanol_1 = @install() {
                debug_subtext("B=5");
                _loot(0x0a, ETHANOL, 0d01, 0d01);
            },
            sniff__1_bone_1 = @install() {
                debug_subtext("B=6");
                _loot(0x09, BONE, 0d01, 0d01);
            },
            sniff__1_bone_1 = @install() {
                debug_subtext("B=7");
                _loot(0x08, BONE, 0d01, 0d01);
            },
            sniff__1_bone_1 = @install() {
                debug_subtext("B=8");
                _loot(0x07, BONE, 0d01, 0d01);
            },
            sniff__1_limestone_2 = @install() {
                debug_subtext("B=9");
                _loot(0x06, LIMESTONE, 0d01, 0d02);
            },

            sniff__1_limestone_1 = @install() {
                debug_subtext("B=10");
                _loot(0x05, LIMESTONE, 0d01, 0d01);
            },
            sniff__1_limestone = @install() {
                debug_subtext("B=11");
                _loot(0x04, LIMESTONE, 0d01, 0d00);
            },
            sniff__1_brimstone_1 = @install() {
                debug_subtext("B=12");
                _loot(0x03, BRIMSTONE, 0d01, 0d01);
            },
            sniff__1_brimstone_2 = @install() {
                debug_subtext("B=13");
                _loot(0x02, BRIMSTONE, 0d01, 0d02);
            },
            sniff__1_brimstone = @install() {
                debug_subtext("B=14");
                _loot(0x01, BRIMSTONE, 0d01, 0d00); // same as B=15
            },
            sniff__1_brimstone = @install() {
                debug_subtext("B=15");
                _loot(0x01, BRIMSTONE, 0d01, 0d00); // same as B=14
            },
            sniff__1_brimstone_1 = @install() {
                debug_subtext("B=16");
                _loot(0x00, BRIMSTONE, 0d01, 0d01);
            },
        }

        fun place_masks(position) {
            if(position == 0x01) {
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_1, 0x3d, 0x04);
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_2, 0x46, 0x04);

                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_3, 0x42, 0x0b);
            } else if(position == 0x02) {
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_1, 0x38, 0x04);
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_2, 0x4c, 0x04);
            } else if(position == 0x03) {
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_1, 0x32, 0x14);
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_2, 0x32, 0x24);

                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_3, 0x52, 0x14);
                add_placeholder(ANIMATION_PLACEHOLDER.AEGIS_MASK_1, 0x52, 0x24);
            }
        }

        fun trigger_enter() {
            if!(SOULS_MEMORY.WITH_ENDBOSS) {
                fade_in();
                outro_triggered();
            }

            // place_masks(0x01);

            if(False) {
                <BOY>[HP] = SYSTEM.HP_MAX;
                
                // SOULS_MEMORY.DEAD_MONSTRO = True;
                // SOULS_MEMORY.DEAD_DARK_ONE = True;
                // SOULS_MEMORY.DEAD_BOWSER = True;
                // SOULS_MEMORY.DEAD_SQUIDMAR = True;
                // SOULS_MEMORY.DEAD_ARENA_MOSQUITO = True;
                SOULS_MEMORY.DEAD_OWL_BOY = True;
                SOULS_MEMORY.DEAD_HEART = True;
                SOULS_MEMORY.DEAD_PIT_EGG = True;
                FLAG.FLASH = True;
            }

            default_init_room(True, True);

            add_custom_boss_gideon(0d66, 0d35, SOULS_MEMORY.DEAD_GIDEON, {
                souls_boss_defeated(DEAD_GIDEON, REWARD_GIDEON);

                CUSTOM_FLAG.NO_RUNNING = True;
            }, 0d200, 0d20, 0d1, 0d120, True, True, True);
        }
    };
};

area west_inbetwixx() {
    map west_inbetwixx(EAST_JUNGLE) {
        // sniff=vanilla

        enum ROOM {
            BRANCH_USED = memory(FLAG, SRAM),

            FAKE_SLASH_GRASS_X = memory(WORD, TEMP),
            FAKE_SLASH_GRASS_Y = memory(WORD, TEMP),

            CODE_BOT_HACKED = memory(FLAG, TEMP),
            CODE_BOT_DIG_COUNT = 0d100,
            CODE_BOT_X = 0d45,
            CODE_BOT_Y = 0d78,
        }

        enum entrance {
            north = entrance(0x12, 0x09, SOUTH),
            east_1 = entrance(0x6d, 0x11, WEST),
            east_2 = entrance(0x6d, 0x23, WEST),
            east_3 = entrance(0x6d, 0x35, WEST),
            west = entrance(0x01, 0x37, EAST),

            code_bot = entrance(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, NONE, {
                ROOM.CODE_BOT_HACKED = <BOY>[GENERAL_PURPOSE] >> 0x08;

                hacking_wakeup(0d32, -0d8, 0d24, -0d24);
            }),
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum BOSS {
            DEBUG = False,

            PROGRESS = memory(FLAG, TEMP),

            ID_OWL_1 = memory(WORD, TEMP),
            ID_OWL_2 = memory(WORD, TEMP),

            TRANSFORM_DISTANCE = 0d16,

            POISE_DECAY = 0d1,
            POISE = 0d20,
        }

        fun fog_wall(exit_direction:DIRECTION) {
            if(BOSS.PROGRESS) {
                fog_wall_inside(!SOULS_MEMORY.DEAD_OWL_BOY, exit_direction);
            }
        }

        enum stepon_trigger {
            exit_east_1 = @install() {
                fog_wall(NONE); // WEST

                map_transition(west_inbetwixx, east_3, EAST);
            },
            exit_east_3 = @install() {
                fog_wall(NONE); // WEST

                map_transition(west_inbetwixx, east_1, EAST);
            },
            exit_east_2 = @install() {
                fog_wall(NONE); // WEST

                map_transition(inbetwixx, west_1, EAST);
            },
            exit_west = @install() {
                fog_wall(NONE); // EAST

                map_transition(west_hut_outside, east, WEST);
            },
            exit_north = @install() {
                fog_wall(SOUTH);

                map_transition(volcano, south, NORTH);
            }
        }

        enum b_trigger {
            sniff__1_clay = @install() {
                debug_subtext("B=0");
                _loot(0x0a, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=1");
                _loot(0x09, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=2");
                _loot(0x08, CLAY, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=3");
                _loot(0x07, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=4");
                _loot(0x06, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=5");
                _loot(0x05, ROOTS, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=6");
                _loot(0x04, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=7");
                _loot(0x03, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=8");
                _loot(0x0c, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=9");
                _loot(0x0b, WATER, 0d01, 0d00);
            },

            sniff__1_roots = @install() {
                debug_subtext("B=10");
                _loot(0x02, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=11");
                _loot(0x01, ROOTS, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=12");
                _loot(0x00, WATER, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=13");
                _loot(0x0d, CLAY, 0d01, 0d00); // same as B=16
            },
            sniff__1_water = @install() {
                debug_subtext("B=14");
                _loot(0x0c, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=15");
                _loot(0x0b, WATER, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=16");
                _loot(0x0d, CLAY, 0d01, 0d00); // same as B=13
            },
        }

        fun boss_defeated() {
            souls_boss_defeated(DEAD_OWL_BOY, REWARD_OWL_BOY);

            BOSS.PROGRESS = False;
        }

        @install()
        @async()
        fun grabby_owls() {
            add_transforming_owls(0x2d, 0x21, True, 0x47, 0x42, False, {
                transform_owls(arg[0x0e], arg[0x0c]);

                _add_enemy(BOY_BLACK, arg[0x0c][X], arg[0x0c][Y]);
                poise_break_decay(<LAST_ENTITY>, BOSS.POISE, BOSS.POISE_DECAY, 0d120);
                attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                    if(dead(<SCRIPT_OWNER>)) {
                        boss_defeated();
                    } else {
                        poise_break();
                    }
                }));

                BOSS.PROGRESS = True;
                push_music(BOSS);

                end();
            });
        }

        fun trigger_enter() {
            add_souls_npc_alchemist_speed(0d91, 0d65);
            
            if!(ROOM.BRANCH_USED) {
                branch_lady(VILLAGER_2_4, 0x58, 0x0f, WEST, reference(@install() {
                    guard_branch_lady(ROOM.BRANCH_USED);

                    dog_lady_dialog_0();
                }));
            } else if(NPC_DOG_LADY.PROGRESS == 0d0) {
                add_souls_npc_dog_lady(0x58, 0x0f);
            }

            if!(SOULS_MEMORY.DEAD_OWL_BOY) {
                grabby_owls();
            }

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // inside
                add_enemy(FLOWER_PURPLE, 0x1e, 0x2c);

                // add_enemy(RAT, 0d51, 0d43); // backup

                // east
                add_enemy(TUMBLING_WEED, 0d77, 0d36);

                // west
                add_enemy(FLOWER_PURPLE, 0d20, 0d61);

                // cliff
                // add_enemy(OWL_BLACK, 0d97, 0d55, INACTIVE);
            }

            init_map(0x00, 0x06, 0x6e, 0x52);
            default_init_room(True, True);
            if(SOULS_MEMORY.WITH_AREA_NAMES) {
                subtext("West Inbetwixx");
            }

            player_message(0d23, 0d66, reference(@install() {
                player_message_triggered();

                subtext("prisoner ahead and then bonfire!");
            }));

            archaeology_dig_code_bot(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, ARCHAEOLOGY_DIG.CODE_1, ROOM.CODE_BOT_DIG_COUNT, ROOM.CODE_BOT_HACKED);
        }
    };

    map west_hut_outside(STRONGHEART_EXTERIOR) {
        enum entrance {
            hut = entrance(0x13, 0x13, SOUTH), // TODO: 13/15
            east = entrance(0x25, 0x12, WEST),

            backdoor = entrance(0d15, 0d16, WEST),
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum stepon_trigger {
            stepon_0 = @install() {
                map_transition(west_hut_inside, door, NORTH);
            },
            stepon_1 = @install() {
                map_transition(west_inbetwixx, west, EAST);
            }
        }

        fun trigger_enter() {
            default_init_room(True, True);

            add_enemy(PLACEHOLDER, 0d13, 0d18);
            attach_script(LAST_ENTITY, B, reference(@install() {
                sound(WEIRD_SOUND);

                map_transition(potato_room, stairs, NONE);
            }));
        }
    };

    map potato_room(EBON_CELLAR) {
        // chests=vanilla

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum entrance {
            stairs = entrance(0x29, 0x0d, WEST),

            floor = entrance(0d29, 0d27, NONE, { bonfire_wakeup(0d0, 0d0, -0d24, 0d0); }),
        }

        enum stepon_trigger {
            exit_stairs = @install() {
                map_transition(west_hut_outside, backdoor, EAST);
            },
        }

        enum b_trigger {
            chest_1__3_feather = @install() {
                debug_subtext("B=0");
                _loot_chest(0x00, FEATHER, 0d03);
            },
            chest_2__4_brimstone = @install() {
                debug_subtext("B=1");
                _loot_chest(0x01, BRIMSTONE, 0d04);
            },
            chest_3__2_acorns = @install() {
                debug_subtext("B=2");
                _loot_chest(0x02, SPOON, 0d01);
            },
        }

        fun trigger_enter() {
            if!(NPC_ISAAC.FOUND) {
                eternal_dust(0d8, 0d24, reference(@install() {
                    NPC_ISAAC.FOUND = True;

                    subtext("Cruel fate…");
                }));
            }

            default_init_room(True, False);
        }
    };

    map west_hut_inside(STRONGHEART) {
        enum entrance {
            door = entrance(0x12, 0x23, NORTH)
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum ROOM {
            CLUE_1 = memory(FLAG, SRAM),
            CLUE_2 = memory(FLAG, SRAM),
        }

        enum stepon_trigger {
            stepon_0 = @install() {
                map_transition(west_hut_outside, hut, SOUTH);
            }
        }

        enum b_trigger {
            gourd_1__1_oil = @install() {
                fake_loot_gourd();

                object[0x00] = 0x01; // unload gourd_1
                custom_reward(ISAAC_LETTER, True);

                dialog("[SLOW]The letter seems to be old, it's barely readable.[B]But it clearly states the phrases `To Maggy´, `child´ and something about leaving.[B]Based on the coat of arms the origin seems to be a town.[B]Maybe I can find more clues there.[B]");
            },
            gourd_2__1_wax = @install() {
                fake_loot_gourd();

                object[0x02] = 0x01; // unload gourd_2
                subtext("Locked away childrens toys.");
                set(ROOM.CLUE_1);
            },
            gourd_3__1_wax = @install() {
                fake_loot_gourd();

                object[0x01] = 0x01; // unload gourd_3
                subtext("Cheap religious artifacts.");
                set(ROOM.CLUE_2);
            },
        }

        @install()
        fun trap_door() {
            if!(SOULS_MEMORY.WITH_SIDE_QUESTS) {
                error_message();
                end();
            }
            if((!ROOM.CLUE_1) || (!ROOM.CLUE_2)) {
                fake_b();
                end();
            }

            sound(WEIRD_SOUND);

            animate_boy_kneel(BOY);
            
            question("[SLOW]A trap door under the rug.[CHOICE]Enter…[CHOICE]Leave…");

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                face(BOY, SOUTH);
                animate(BOY, LOOP, ANIMATION_BOY.FALL_2);
                sleep(0d20);

                map_transition(basement_0_start, center, NONE);
            } else {
                animate(BOY, ONCE, DEFAULT);
            }
        }
        
        fun trigger_enter() {
            if(SOULS_MEMORY.ISAAC_LETTER) {
                object[0x00] = 0x01; // unload gourd_1
            }
            if(ROOM.CLUE_1) {
                object[0x02] = 0x01; // unload gourd_2
            }
            if(ROOM.CLUE_2) {
                object[0x01] = 0x01; // unload gourd_3
            }

            add_enemy(PLACEHOLDER, 0x0f, 0x12);
            attach_script(LAST_ENTITY, B, reference(trap_door));

            default_init_room(True, False);
        }
    };
};

area altus_plateau_entry() {
    enum AREA_ALTUS_PLATEAU {
        DEFAULT_MUSIC = MUSIC.JUNGLE_AMBIENT_BIRDS,

        ENTRANCE_UNLOCKED = memory(FLAG, SRAM),

        BRANCH_USED = memory(FLAG, SRAM),
    }

    map volcano(VOLCANO_PATH) {
        // gourd=vanilla
        // sniff=vanilla

        enum entrance {
            cutscene_north_1 = entrance(0x4a, 0x38, NONE),
            cutscene_north_2 = entrance(0x5f, 0x1b, NONE),
            east = entrance(0x6d, 0x83, WEST), // 0x6b, 0x83
            south = entrance(0x1b, 0x9d, NORTH),

            cave_west = entrance(0x0b, 0x70, SOUTH),
            cave_center = entrance(0x3f, 0x4a, SOUTH),
            cave_east = entrance(0x4d, 0x6a, SOUTH),

            cave_gauge = entrance(0x5f, 0x16, SOUTH),

            cave_2_2 = entrance(0x44, 0x23, SOUTH),
        }

        enum soundtrack {
            default = soundtrack(AREA_ALTUS_PLATEAU.DEFAULT_MUSIC, 0xff)
        }

        enum ROOM {
            STONE_MOVED = memory(FLAG, SRAM),
            STONE_OFFSET = 0d8 * 0d2,

            VOLCANO_TOWER_BACKDOOR_DIG = 0d20,
            VOLCANO_TOWER_BACKDOOR_DIG_COUNTER = memory(WORD, TEMP),
            VOLCANO_TOWER_BACKDOOR_OPEN = memory(FLAG, SRAM),
        }

        fun pressure_plate_0_1() {
            generic_act1_volcano_pressure_plate(0x3c, 0x3f, 0x05, 0x02, 0d93, 0d59, 0d2);
        }
        fun pressure_plate_0_2() {
            if(ROOM.STONE_MOVED) {
                generic_act1_volcano_pressure_plate(0x44, 0x41, 0x06, 0x01, 0d61, 0d30, 0d4);
            }
        }
        @install()
        @async()
        fun exit_north() {
            sleep(0d75);
            map_transition(well, crash, NONE);
        }
        fun pressure_plate_1_1() {
            exit_north();
            generic_act1_volcano_pressure_plate(0x30, 0x39, 0x04, 0x01, 0d145, 0d00, 0d0);
        }
        fun pressure_plate_1_2() {
            generic_act1_volcano_pressure_plate(0x4e, 0x31, 0x03, 0x01, 0d74, 0d52, 0d0);
        }
        fun pressure_plate_2_1() {
            generic_act1_volcano_pressure_plate(0x3c, 0x27, 0x01, 0x01, 0d68, 0d27, 0d3);
        }
        fun pressure_plate_2_2() {
            generic_act1_volcano_pressure_plate(0x52, 0x25, 0x02, 0x01, 0d71, 0d49, 0d0);
        }
        fun pressure_plate_3_1() {
            generic_act1_volcano_pressure_plate(0x36, 0x1d, 0x07, 0x01, 0d59, 0d39, 0d3);
        }
        fun pressure_plate_3_2() {
            generic_act1_volcano_pressure_plate(0x52, 0x19, 0x00, 0x01, 0d66, 0d37, 0d1);
        }

        @install()
        fun volcano_tower_backdoor_triggered() {
            map_transition(pipe_pit, south, NORTH);
        }

        enum stepon_trigger {
            tunnel_gauge = @install() {
                debug_subtext("S=0");

                if(False) {
                    generic_tunnel_enter(CAVE_IN);
                    generic_tunnel(DEFAULT, 0d48, 0d69);
                    generic_tunnel_exit(SLIDE_OUT, EAST);
                } else {
                    map_transition(cave_gauge, south, NORTH);
                }
            },
            pressure_plate_1_2_right = @install() {
                debug_subtext("S=1");

                pressure_plate_1_2();
            },
            pressure_plate_1_2_left = @install() {
                debug_subtext("S=2");
                
                pressure_plate_1_2();
            },
            door_1_2_hole_0_2 = @install() {
                debug_subtext("S=3");

                generic_act1_volcano_cave_hole(0x46, 0x31, 0d74, 0d56);
            },
            pressure_plate_3_1_left = @install() {
                debug_subtext("S=4");
                
                pressure_plate_3_1();
            },
            cave_2_1_hole_0_1 = @install() {
                debug_subtext("S=5");

                generic_act1_volcano_cave_hole(0x2a, 0x35, 0d48, 0d60);
            },
            cave_2_1_hole_1_1 = @install() {
                debug_subtext("S=6");

                generic_act1_volcano_cave_hole(0d52, 0d36, 0d52, 0d48);
            },
            cave_4_hole_0_2 = @install() {
                debug_subtext("S=7");

                generic_act1_volcano_cave_hole(0d62, 0d18, 0d74, 0d56, True);
            },
            cave_5_hole_3 = @install() {
                debug_subtext("S=8");

                generic_act1_volcano_cave_hole(0x4a, 0x09, 0d72, 0d16);
            },
            cave_4_hole_1_2 = @install() {
                debug_subtext("S=9");

                generic_act1_volcano_cave_hole(0d76, 0d23, 0d82, 0d42, True);
            },

            cave_2_2_hole_1_2 = @install() {
                debug_subtext("S=10");

                if(ROOM.VOLCANO_TOWER_BACKDOOR_OPEN) {
                    volcano_tower_backdoor_triggered();
                } else {
                    error_message(DOOR_REQUIRES_DIG);
                }
                // generic_act1_volcano_cave_hole(0x44, 0x23, 0d82, 0d42);
            },
            exit_south = @install() {
                debug_subtext("S=11");

                map_transition(west_inbetwixx, north, SOUTH);
            },
            cave_east = @install() {
                debug_subtext("S=12");

                map_transition(cave_shop, south, NORTH);
            },
            cave_west = @install() {
                debug_subtext("S=13");

                if(AREA_ALTUS_PLATEAU.ENTRANCE_UNLOCKED) {
                    map_transition(stairs, stairs_west_bottom, NORTH);
                } else {
                    error_message(DOOR_WRONG_SIDE, SOUTH);
                }
            },
            cave_center = @install() {
                debug_subtext("S=14");

                map_transition(volcano_tower, south, NORTH);
            },
            exit_east = @install() {
                debug_subtext("S=15");

                map_transition(northwest_inbetwixx, west, EAST);
            },
            pressure_plate_2_2_right = @install() {
                debug_subtext("S=16");
                
                pressure_plate_2_2();
            },
            pressure_plate_3_2 = @install() {
                debug_subtext("S=17");
                
                pressure_plate_3_2();
            },
            pressure_plate_1_1 = @install() {
                debug_subtext("S=8");
                
                pressure_plate_1_1();
            },
            stepon_19 = @install() {
                debug_subtext("S=19");
            },

            pressure_plate_0_1_right = @install() {
                debug_subtext("S=20");
                
                pressure_plate_0_1();
            },
            pressure_plate_0_2_right = @install() {
                debug_subtext("S=21");
                
                pressure_plate_0_2();
            },
            pressure_plate_0_2_left = @install() {
                debug_subtext("S=22");
                
                pressure_plate_0_2();
            },
            stepon_23 = @install() {
                debug_subtext("S=23");
            },
            stepon_24 = @install() {
                debug_subtext("S=24");
            },
            pressure_plate_3_1_right = @install() {
                debug_subtext("S=25");
                
                pressure_plate_3_1();
            },
            stepon_26 = @install() {
                debug_subtext("S=26");
            },
            pressure_plate_2_2_left = @install() {
                debug_subtext("S=27");
                
                pressure_plate_2_2();
            },
            stepon_28 = @install() {
                debug_subtext("S=28");
            },
            pressure_plate_0_1_left = @install() {
                debug_subtext("S=29");

                pressure_plate_0_1();
            },

            pressure_plate_2_1 = @install() {
                debug_subtext("S=30");
                
                pressure_plate_2_1();
            },
        }

        enum b_trigger {
            guord_gauge = @install() {
                debug_subtext("B=0");
                _loot_chest(0x27, DRY_ICE, 0d01); // gauge
            },
            gourd_2__1_CLAY = @install() {
                debug_subtext("B=1");
                _loot_chest(0x0b, WINGS, 0d01);
            },
            gourd_3__1_PETAL = @install() {
                debug_subtext("B=2");
                _loot_chest(0x08, BISCUIT, 0d01);
            },
            gourd_5__1_WATER = @install() {
                debug_subtext("B=3");
                _loot_chest(0x09, PIXIE_DUST, 0d01);
            },
            gourd_1__1_ROOTS = @install() {
                debug_subtext("B=4");
                _loot_chest(0x0a, ROOTS, 0d01);
            },
            sniff__1_water = @install() {
                debug_subtext("B=5");
                _loot(0x0c, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=6");
                _loot(0x0d, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=7");
                _loot(0x0e, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=8");
                _loot(0x0f, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=9");
                _loot(0x10, WATER, 0d01, 0d00);
            },

            sniff__1_water = @install() {
                debug_subtext("B=10");
                _loot(0x11, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=11");
                _loot(0x12, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=12");
                _loot(0x13, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=13");
                _loot(0x14, WATER, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=14");
                _loot(0x15, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=15");
                _loot(0x16, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=16");
                _loot(0x17, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=17");
                _loot(0x18, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=18");
                _loot(0x19, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=19");
                _loot(0x1a, CLAY, 0d01, 0d00);
            },

            sniff__1_clay = @install() {
                debug_subtext("B=20");
                _loot(0x1b, CLAY, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=21");
                _loot(0x1d, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=22");
                _loot(0x1d, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=23");
                _loot(0x1e, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=24");
                _loot(0x1f, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=25");
                _loot(0x20, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=26");
                _loot(0x21, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=27");
                _loot(0x22, ROOTS, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=28");
                _loot(0x23, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=29");
                _loot(0x24, OIL, 0d01, 0d00);
            },

            sniff__1_ash = @install() {
                debug_subtext("B=30");
                _loot(0x25, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=31");
                _loot(0x26, ASH, 0d01, 0d00);
            },
            grass_non_sword = @install() {
                debug_subtext("B=32");

                vanilla_grass_cutter(0x05);
            },
        }

        @install()
        fun debug_triggered() {
            set(AREA_ALTUS_PLATEAU.ENTRANCE_UNLOCKED);

            destroy(SCRIPT_OWNER);
        }

        fun trigger_enter() {
            if(FLAG.DEBUG) {
                if!(AREA_ALTUS_PLATEAU.ENTRANCE_UNLOCKED) {
                    add_debug_entity(0x06, 0x78, reference(debug_triggered));
                }
            }

            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d0) {
                add_souls_npc_archaeologist(0d77, 0d38);
            }

            if!(ROOM.VOLCANO_TOWER_BACKDOOR_OPEN) {
                archaeology_dig(0d67, 0d34, ROOM.VOLCANO_TOWER_BACKDOOR_DIG_COUNTER, ROOM.VOLCANO_TOWER_BACKDOOR_DIG, reference(@install() {
                    guard_archaeology_dig(ROOM.VOLCANO_TOWER_BACKDOOR_OPEN, ROOM.VOLCANO_TOWER_BACKDOOR_DIG_COUNTER);

                    volcano_tower_backdoor_triggered();
                }));
            }

            if!(AREA_ALTUS_PLATEAU.BRANCH_USED) {
                branch_lady(MONK, 0d63, 0d77, SOUTH, reference(@install() {
                    guard_branch_lady(AREA_ALTUS_PLATEAU.BRANCH_USED);
                }));
            }

            add_levitate_stone(0d68, 0d65, reference(@install() {
                guard_levitate_stone(0d1);

                ROOM.STONE_MOVED = True;
            }));
            if(ROOM.STONE_MOVED) {
                <LAST_ENTITY>[X] += ROOM.STONE_OFFSET;
            }

            special_script(LEVITATE, reference(@install() {
                if(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.INVINCIBLE_TEMP) {
                    end();
                }

                attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

                if!(ROOM.STONE_MOVED) {
                    sleep(0d60);

                    ROOM.STONE_MOVED = True;

                    sleep(0d60);

                    while(arg[0x10] < ROOM.STONE_OFFSET) {
                        arg[0x10]++;

                        <SCRIPT_OWNER>[X]++;

                        sleep(0d3);
                    }

                    sleep(0d360 - 0d3 * ROOM.STONE_OFFSET);
                } else {
                    sleep(0d120);

                    while(arg[0x10] < ROOM.STONE_OFFSET) {
                        arg[0x10]++;

                        <SCRIPT_OWNER>[X]--;

                        sleep(0d3);
                    }

                    sleep(0d360 - 0d3 * ROOM.STONE_OFFSET);

                    ROOM.STONE_MOVED = False;
                    object[0x03] = 0x00; // open door_NW
                }

                attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
            }));

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // path
                add_enemy(FLOWER_PURPLE, 0d31, 0d103);

                add_enemy(MONK, 0d79, 0d84);

                add_enemy(HEDGEHOG, 0d58, 0d67);

                // east
                add_enemy(FLOWER_PURPLE, 0d85, 0d115);

                // west
                add_enemy(HEDGEHOG, 0d19, 0d125);
                add_enemy(FLOWER_PURPLE, 0d17, 0d126);
            }

            default_init_room(True, True);

            if!(AREA_ALTUS_PLATEAU.ENTRANCE_UNLOCKED) {
                add_enemy(STONE_ROUND, 0d11, 0d114);
                attach_script(LAST_ENTITY, B, reference(@install() {
                    error_message(DOOR_WRONG_SIDE, SOUTH);
                }));
            }
        }
    };

    area behind_volcano() {
        map volcano_tower(STERLING) {
            // gourd=vanilla
            // sniff=vannilla

            enum ROOM {
                COLLECTIBLE_LOOTED = memory(FLAG, SRAM),

                DIAMOND_EYE_LOOTED = memory(FLAG, SRAM),

                WITH_WIND = True,
                WIND_ACTIVE = memory(FLAG, TEMP),

                CODE_BOT_HACKED = memory(FLAG, TEMP),
                CODE_BOT_DIG_COUNT = 0d100,
                CODE_BOT_X = 0d39,
                CODE_BOT_Y = 0d233,
            }

            enum entrance {
                south = entrance(0x55, 0xf9, NORTH),
                platform = entrance(0x51, 0x2f, NORTH),

                bonfire = entrance(0d67, 0d159, NONE, { bonfire_wakeup(0d0, 0d8, -0d24, 0d0); }),

                crash = entrance(0d23, 0d249, NONE, { crash_both(); }),

                code_bot = entrance(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, NONE, {
                    ROOM.CODE_BOT_HACKED = True;

                    hacking_wakeup(-0d8, 0d24, 0d24, 0d24);
                }),
            }

            enum soundtrack {
                default = soundtrack(WIND_AMBIENT_BIRDS, 0xff),
            }

            @install()
            fun trapdoor_3() {
                debug_subtext("S=10/11");

                object[0x05] = 0x03; // activate trapdoor_3

                pit_fall_callback({
                    generic_fall_gomi(0d91, 0d191, 0d1640);
                }, {
                    generic_fall_gomi(0d91, 0d191, 0d1640, 0d5);
                });
            }
            @install()
            fun trapdoor_4() {
                debug_subtext("S=3/7");

                object[0x03] = 0x03; // activate trapdoor_4

                pit_fall_callback({
                    generic_fall_gomi(0d43, 0d96, 0d1280);
                }, {
                    generic_fall_gomi(0d43, 0d96, 0d1280, 0d5);
                });
            }

            enum stepon_trigger {
                elevator_bottom = @install() {
                    debug_subtext("S=0");

                    generic_elevator_gomi(0x3e, 0xcf, 0x01, 0x01, 0d62, 0d76, 0x04, 0x01);
                },
                elevator_top = @install() {
                    debug_subtext("S=1");

                    generic_elevator_gomi(0x3e, 0x4e, 0x04, 0x01, 0d62, 0d205, 0x01, 0x01);
                },
                spawn_boss = @install() {
                    debug_subtext("S=2");
                },
                trapdoor_4 = @install() {
                    debug_subtext("S=3");

                    trapdoor_4();
                },
                exit_south = @install() {
                    if!(AREA_ALTUS_PLATEAU.BRANCH_USED) {
                        error_message(DOOR_WRONG_SIDE);
                    } else {
                        map_transition(volcano, cave_center, SOUTH);
                    }
                },
                trapdoor_1 = nop(),
                stepon_6 = @install() {
                    debug_subtext("S=6");
                },
                trapdoor_4_open = @install() {
                    debug_subtext("S=7");

                    trapdoor_4();
                },
                trapdoor_2 = @install() {
                    debug_subtext("S=8");
                    
                    object[0x06] = 0x03; // activate trapdoor_2

                    pit_fall_callback({
                        generic_fall_gomi(0d61, 0d160, 0d1408);
                    }, {
                        generic_fall_gomi(0d61, 0d160, 0d1408, 0d5);
                    });
                },
                stepon_9 = @install() {
                    debug_subtext("S=9");
                },

                trapdoor_3_left = trapdoor_3(),
                trapdoor_3_right = trapdoor_3()
            }

            enum b_trigger {
                sniff__1_water_2 = @install() {
                    debug_subtext("B=0");
                    _loot(0x1c, WATER, 0d01, 0d02);
                },
                sniff__1_water_4 = @install() {
                    debug_subtext("B=1");
                    _loot(0x1b, WATER, 0d01, 0d04);
                },
                sniff__1_acorns_2 = @install() {
                    debug_subtext("B=2");
                    _loot(0x1a, ACORNS, 0d01, 0d02);
                },
                sniff__1_acorns_1 = @install() {
                    debug_subtext("B=3");
                    _loot(0x19, ACORNS, 0d01, 0d01);
                },
                sniff__1_mushroom_3 = @install() {
                    debug_subtext("B=4");
                    _loot(0x18, MUSHROOM, 0d01, 0d03);
                },
                sniff__1_mushroom_1 = @install() {
                    debug_subtext("B=5");
                    _loot(0x17, MUSHROOM, 0d01, 0d01);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=6");
                    _loot(0x16, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots_2 = @install() {
                    debug_subtext("B=7");
                    _loot(0x15, ROOTS, 0d01, 0d02);
                },
                sniff__1_feather_2 = @install() {
                    debug_subtext("B=8");
                    _loot(0x14, FEATHER, 0d01, 0d02);
                },
                sniff__1_feather_3 = @install() {
                    debug_subtext("B=9");
                    _loot(0x13, FEATHER, 0d01, 0d03);
                },

                sniff__1_feather_1 = @install() {
                    debug_subtext("B=10");
                    _loot(0x12, FEATHER, 0d01, 0d01);
                },
                sniff__1_iron = @install() {
                    debug_subtext("B=11");
                    _loot(0x11, IRON, 0d01, 0d00);
                },
                sniff__1_iron_2 = @install() {
                    debug_subtext("B=12");
                    _loot(0x10, IRON, 0d01, 0d02);
                },
                sniff__1_ash_2 = @install() {
                    debug_subtext("B=13");
                    _loot(0x0f, ASH, 0d01, 0d02);
                },
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=14");
                    _loot(0x0e, ASH, 0d01, 0d01);
                },
                sniff__1_ethanol_2 = @install() {
                    debug_subtext("B=15");
                    _loot(0x0d, ETHANOL, 0d01, 0d02);
                },
                sniff__1_ethanol_2 = @install() {
                    debug_subtext("B=16");
                    _loot(0x0c, ETHANOL, 0d01, 0d02);
                },
                sniff__1_ethanol_1 = @install() {
                    debug_subtext("B=17");
                    _loot(0x0b, ETHANOL, 0d01, 0d01);
                },
                gourd_x__1_feather = @install() {
                    debug_subtext("B=18");
                    _loot_chest(0x09, DRY_ICE, 0d01);
                },
                gourd_x__1_acorn = @install() {
                    debug_subtext("B=19");
                    _loot_chest(0x08, ACORNS, 0d01);
                },

                gourd_x__1_ash = @install() {
                    debug_subtext("B=20");
                    _loot_chest(0x02, ASH, 0d01);
                },
                gourd_x__1_ethanol = @install() {
                    debug_subtext("B=21");
                    _loot_chest(0x00, SPOON, 0d01);
                }
            }

            @install()
            fun lift_off() {
                <0x2834> = <SCRIPT_OWNER>[X];
                <0x2836> = <SCRIPT_OWNER>[Y];
                // walk(BOY, TILE_ABSOLUTE_DIRECT, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y], NONE);
                // walk(BOY, TILE_ABSOLUTE_DIRECT, <0x2834>, <0x2836>, NONE);
                control(NONE);
                walk(DOG, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X] + 0x30, <SCRIPT_OWNER>[Y] - 0x05, NONE);
                walk(BOY, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X] + 0x30, <SCRIPT_OWNER>[Y] - 0x05, BOTH);
                walk(DOG, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X] - 0x20, <SCRIPT_OWNER>[Y] - 0x05, NONE);
                walk(BOY, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X] - 0x10, <SCRIPT_OWNER>[Y] - 0x05, BOTH);
                
                face(BOY, EAST);
                face(DOG, EAST);
                sleep(0x20);

                while(arg[0x00] < 0d160) {
                    arg[0x00]++;
                    control(NONE);
                    face(BOY, EAST);
                    face(DOG, EAST);
                    <SCRIPT_OWNER>[Y]--;
                    <BOY>[Y]--;
                    <DOG>[Y]--;

                    yield();
                }

                map_transition(windwalker_sidescroller, west, NONE);
            }

            fun start_wind() {
                while(True) {
                    if(<BOY>[Y] < 0d180) {
                        arg[0x10] = 0d3;
                    } else if(<BOY>[Y] < 0d350) {
                        arg[0x10] = 0d4;
                    } else if(<BOY>[Y] < 0d400) {
                        arg[0x10] = 0d3;
                    } else if(<BOY>[Y] < 0d670) {
                        arg[0x10] = 0d1;
                    } else {
                        arg[0x10] = 0d0;
                    }

                    if(<DOG>[Y] < 0d180) {
                        arg[0x12] = 0d3;
                    } else if(<DOG>[Y] < 0d350) {
                        arg[0x12] = 0d4;
                    } else if(<DOG>[Y] < 0d400) {
                        arg[0x12] = 0d3;
                    } else if(<DOG>[Y] < 0d670) {
                        arg[0x12] = 0d1;
                    } else {
                        arg[0x12] = 0d0;
                    }

                    // if(<BOY>[STAMINA] > STAMINA.PERCENTAGE_50) {

                    if(arg[0x10] > 0d0) {
                        increment_no_running(ROOM.WIND_ACTIVE);
                    } else {
                        decrement_no_running(ROOM.WIND_ACTIVE);
                    }

                    if(CUSTOM_MEMORY.CURRENT_ARMOR_CHEST != ARMOR_STATS.CHEST_2_2) {
                        if!(<BOY>[FLAGS_1] & (ATTRIBUTE_FLAGS.DISABLED | ATTRIBUTE_FLAGS.IN_ANIMATION)) {
                            teleport_relative(BOY, 0d0, arg[0x10]);
                        }
                    }
                    if!(<DOG>[FLAGS_1] & (ATTRIBUTE_FLAGS.DISABLED | ATTRIBUTE_FLAGS.IN_ANIMATION)) {
                        teleport_relative(DOG, 0d0, arg[0x12]);
                    }

                    sleep(0d3);
                }
            }

            fun trigger_enter() {
                // object[0x00] = 0x01; // open chest_2
                // object[0x01] = 0x01; // open elevator_bottom
                // object[0x02] = 0x01; // open chest_3
                // object[0x03] = 0x01; // activate trapdoor_3
                // object[0x04] = 0x01; // open elevator_top
                // object[0x05] = 0x03; // activate trapdoor_4
                // object[0x06] = 0x03; // activate trapdoor_2
                // object[0x07] = 0x03; // activate trapdoor_1
                // object[0x08] = 0x01; // open chest_1
                // object[0x09] = 0x01; // open chest_4
                // object[0x0a] = 0x01; // block elevator_top

                if!(ROOM.COLLECTIBLE_LOOTED) {
                    add_collectible(0x00, 0d43, 0d10, reference(@install() {
                        collectible_collected();

                        set(ROOM.COLLECTIBLE_LOOTED);
                        destroy(SCRIPT_OWNER);
                    }));
                }

                if(NPC_ARCHAEOLOGIST.PROGRESS == 0d1) {
                    add_souls_npc_archaeologist(0d71, 0d238);
                }

                add_placeholder(ANIMATION_PLACEHOLDER.WINDWALKER_IDLE, 0d24, 0d109);
                attach_script(LAST_ENTITY, B, reference(lift_off));

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // level 0
                    // add_enemy(FLOWER_PURPLE, 0d81, 0d239);

                    // level 1
                    add_enemy(MONK, 0d93, 0d209);
                    add_enemy(HEDGEHOG, 0d54, 0d186);

                    // level 2
                    add_enemy(MONK, 0d25, 0d175);

                    // level 3
                    add_enemy(HEDGEHOG, 0d41, 0d160);

                    // level 5
                    // add_enemy(BUZZARD_1, 0d29, 0d123);
                    // add_enemy(RAT, 0d29, 0d123);
                    // add_enemy(RAT, 0d29, 0d123);
                }

                bonfire(0d67, 0d159, SOULS_MEMORY.BONFIRE_VOLCANO_TOWER);

                default_init_room(True, True);

                place_statue(GOMI, 0d24, 0d119);

                add_souls_npc_alchemist_drain(0d63, 0d31);

                if!(ROOM.DIAMOND_EYE_LOOTED) {
                    add_placeholder(DIAMOND_EYE_1, 0d66, 0d19);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        ROOM.DIAMOND_EYE_LOOTED = True;
                        STATUE_RIDDLE.CARRY_LEFT_EYE = True;

                        destroy(SCRIPT_OWNER);

                        reward(DIAMOND_EYE);
                    }));
                }

                archaeology_dig_code_bot(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, ARCHAEOLOGY_DIG.CODE_3, ROOM.CODE_BOT_DIG_COUNT, ROOM.CODE_BOT_HACKED);

                if(ROOM.WITH_WIND) {
                    start_wind();
                }
            }
        };

        map windwalker_sidescroller(SKY) {
            enum entrance {
                west = entrance(0x06, 0x0f, NONE),
                south = entrance(0x10, 0x19, NONE),
            }

            enum soundtrack {
                default = soundtrack(WIND_AMBIENT_PLANE, 0xff)
            }

            enum ROOM {
                DEBUG = False,

                SHIP_ID = memory(WORD, TEMP),

                PROGRESS = memory(BYTE, SRAM),

                START_HEIGHT = 0x1fff,

                ENEMIES_ALIVE = memory(BYTE, TEMP),

                LANE_1 = 0x05,
                LANE_2 = 0x0c,
                LANE_3 = 0x15,
            }

            enum BOSS {
                DEBUG = False,
                
                ID = memory(WORD, TEMP),
                PHASE = memory(WORD, TEMP),

                HP = 0d4,

                TURN_TIME = 0x30,

                P1_THRESHOLD = 0x04,

                RING_TIMER = memory(WORD, TEMP),
                RING_X = memory(WORD, TEMP),
                RING_Y = memory(WORD, TEMP),
                RING_PROJECTILE = THROWABLE.CITRON,
                RING_SLEEP = 0d5,
                RING_STEP = 0x40,
                RING_RADIUS = 0d200,

                RING_DOUBLE = False,
            }

            fun shoot_boss(x, y) {
                sound(PROJECTILE_SHOOTING);
                shoot_entity_relative(BOSS.ID, BOSS.RING_PROJECTILE, x, y, 0x14, 0x0a);
            }

            @install()
            fun enemy_killed() {
                ROOM.ENEMIES_ALIVE--;
                if(ROOM.DEBUG) {
                    debug_memory(ROOM.ENEMIES_ALIVE, 0d0);
                }
            }

            fun enemy(enemy, y) {
                ROOM.ENEMIES_ALIVE++;
                if(ROOM.DEBUG) {
                    debug_memory(ROOM.ENEMIES_ALIVE, 0d1);
                }

                add_enemy(enemy, 0x20, y);
                <LAST_ENTITY>[HP] = 0d1;
                attach_script(LAST_ENTITY, DEATH, reference(enemy_killed));
                face(LAST_ENTITY, WEST);
                
                // attach_to_script(LAST_ENTITY);
                // walk(LAST_ENTITY, TILE_ABSOLUTE_DIRECT, 0x00, y, LAST_ENTITY);
                // destroy(SCRIPT_OWNER);
            }

            fun shooting_mosquito(enemy, y) {
                ROOM.ENEMIES_ALIVE++;
                if(ROOM.DEBUG) {
                    debug_memory(ROOM.ENEMIES_ALIVE, 0d1);
                }

                add_enemy(enemy, 0x20, y);
                <LAST_ENTITY>[HP] = 0d1;
                face(LAST_ENTITY, WEST);
                attach_script(LAST_ENTITY, DEATH, reference(enemy_killed));
                
                attach_to_script(LAST_ENTITY);
                walk(LAST_ENTITY, TILE_ABSOLUTE_DIRECT, 0d0, y, NONE);

                arg[0x10] = 0x80 + randrange(0d60);

                while(alive(<SCRIPT_OWNER>)) {
                    arg[0x10]--;

                    if(<SCRIPT_OWNER>[X] <= 0d0) {
                        if(<SCRIPT_OWNER>[HP] > 0d0) {
                            attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);
                            yield();

                            destroy(SCRIPT_OWNER);
                            enemy_killed();
                            end();
                        }
                    }

                    if(arg[0x10] == 0d0) {
                        arg[0x10] = 0x80 + randrange(0d60);

                        sound(PROJECTILE_SHOOTING);
                        shoot_entity_entity(SCRIPT_OWNER, CITRON, BOY, 0x10, 0xff);
                    }

                    yield();
                }
            }

            @install()
            @async()
            fun shooting_mosquito_1() {
                shooting_mosquito(ENEMY.MOSQUITO, ROOM.LANE_1);
            }
            @install()
            @async()
            fun shooting_mosquito_2() {
                shooting_mosquito(ENEMY.MOSQUITO, ROOM.LANE_2);
            }
            @install()
            @async()
            fun shooting_mosquito_3() {
                shooting_mosquito(ENEMY.MOSQUITO, ROOM.LANE_3);
            }

            @install()
            @async()
            fun shooting_fan_2() {
                attach_to_script(BOSS.ID);

                while(alive(<SCRIPT_OWNER>)) {
                    if((BOSS.RING_TIMER == 0d0) && (<SCRIPT_OWNER>[Z] == 0d0) && !(<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK)) {
                        sound(PROJECTILE_SHOOTING);
                        shoot_entity_entity(SCRIPT_OWNER, CITRON, BOY, 0x10, 0xff);
                    }

                    sleep(0x40);
                    <SCRIPT_OWNER>[VELOCITY] = 0d5;
                    sleep(0x40);
                    <SCRIPT_OWNER>[VELOCITY] = 0d5;
                }
            }

            @install()
            fun fan_damage() {
                if(BOSS.PHASE == 0d0) {
                    if(BOSS.ID[HP] <= BOSS.P1_THRESHOLD) {
                        BOSS.PHASE = 0d1;
                    }
                }
            }

            @install()
            @async()
            fun shooting_fan() {
                add_enemy(FAN_BOT, 0x20, ROOM.LANE_2);
                control(LAST_ENTITY, True);
                BOSS.ID = <LAST_ENTITY>;
                <LAST_ENTITY>[HP] = BOSS.HP;
                face(LAST_ENTITY, WEST);
                // attribute(LAST_ENTITY, ROOT, True);
                attach_script(LAST_ENTITY, DAMAGE, reference(fan_damage));
                
                attach_to_script(LAST_ENTITY);

                attribute(LAST_ENTITY, INVINCIBLE, True);
                walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, 0x17, ROOM.LANE_2, SCRIPT_OWNER);
                attribute(LAST_ENTITY, INVINCIBLE, False);
                shooting_fan_2();

                while(alive(<SCRIPT_OWNER>)) {
                    if(BOSS.PHASE == 0d0) {
                        walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, 0x17, ROOM.LANE_1, SCRIPT_OWNER);
                    }
                    if(BOSS.PHASE == 0d0) {
                        sleep(BOSS.TURN_TIME);
                    }

                    if(BOSS.PHASE == 0d0) {
                        walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, 0x17, ROOM.LANE_3, SCRIPT_OWNER);
                    }
                    if(BOSS.PHASE == 0d0) {
                        sleep(BOSS.TURN_TIME);
                    } else {
                        attribute(BOSS.ID, INVINCIBLE, True);

                        while((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK)) {
                            yield();
                        }

                        BOSS.ID[VELOCITY] = 0d50;
                        walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, 0x10, 0x10, SCRIPT_OWNER);

                        while(BOSS.ID[Z] > 0d0) {
                            yield();
                        }

                        attribute(BOSS.ID, INVINCIBLE, False);

                        attribute(BOSS.ID, ROOT, True);
                        ai_move_projectile_ring(BOSS.ID, BOSS.RING_PROJECTILE, BOSS.RING_RADIUS, BOSS.RING_STEP, BOSS.RING_SLEEP, 0d2, False, True);
                        attribute(BOSS.ID, ROOT, False);

                        BOSS.PHASE = 0d0;
                    }
                }
            }

            fun exit_map() {
                attribute(BOY, INVINCIBLE_TEMP, True);

                souls_boss_defeated(DEAD_SIDESCROLLER, REWARD_SIDESCROLLER);

                <BOY>[VELOCITY] = 0x20;
                ROOM.SHIP_ID[VELOCITY] = 0x20;
                sleep(0x30);

                <BOY>[VELOCITY] = 0xff;
                ROOM.SHIP_ID[VELOCITY] = 0xff;
                sleep(0x50);

                map_transition(well, crash, NONE);
            }

            @install()
            fun debug_triggered() {
                destroy(SCRIPT_OWNER);

                exit_map();
            }

            fun pause() {
                sleep(0d60);

                while(ROOM.ENEMIES_ALIVE > 0d0) {
                    yield();
                }

                if(ROOM.DEBUG) {
                    debug_memory(ROOM.ENEMIES_ALIVE, 0d0);
                }

                sleep(0d120);
            }

            fun trigger_enter() {
                add_debug_entity(0d3, 0d3, reference(debug_triggered));

                CUSTOM_FLAG.NO_DOG = True;
                face(BOY, EAST);

                <BOY>[Z] = ROOM.START_HEIGHT;
                <0x0A47> = 0x0001;
                <0x4F2F> = 0x0020;

                default_init_room(False, False);
                CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.AIRSHIP;

                hint(PRESS_START);

                add_placeholder(ANIMATION_PLACEHOLDER.WINDWALKER_IDLE, 0x10, 0x10);
                ROOM.SHIP_ID = <LAST_ENTITY>;
                <LAST_ENTITY>[Z] = ROOM.START_HEIGHT;

                stack_sprite(<BOY>, ROOM.SHIP_ID, 0d0, -0d5);

                sleep(0d250);

                subtext("go!");

                if(ROOM.PROGRESS == 0d0) {
                    enemy(ENEMY.MOSQUITO, 0x10);

                    pause();

                    enemy(ENEMY.MOSQUITO, 0x05);
                    enemy(ENEMY.MOSQUITO, 0x15);

                    pause();

                    enemy(ENEMY.MOSQUITO, 0x05);
                    enemy(ENEMY.MOSQUITO, 0x15);

                    pause();

                    enemy(ENEMY.BUZZARD_1, 0x10);

                    pause();

                    ROOM.PROGRESS = 0d1;
                }

                if(ROOM.PROGRESS == 0d1) {
                    shooting_mosquito_2();

                    pause();

                    shooting_mosquito_1();
                    shooting_mosquito_3();

                    pause();

                    shooting_mosquito_1();
                    shooting_mosquito_2();
                    shooting_mosquito_3();

                    pause();

                    ROOM.PROGRESS = 0d2;
                }

                if(ROOM.PROGRESS == 0d2) {
                    shooting_fan();
                    sleep(0x60);

                    if(BOSS.DEBUG) {
                        subtext("boss start");
                    }
                    while(alive(BOSS.ID)) {
                        yield();
                    }
                    if(BOSS.DEBUG) {
                        subtext("boss end");
                    }

                    sleep(0d250);

                    ROOM.PROGRESS = 0d3;
                }

                if(True) {
                    exit_map();
                }
            }
        };
    };

    map pipe_pit(IVOR_EBON_PRISON) { // variant pit
        enum entrance {
            south = entrance(0d42, 0d140, NORTH),
            west = entrance(0d24, 0d115, EAST),
            east = entrance(0d59, 0d115, WEST),
        }

        enum soundtrack {
            default = soundtrack(SWAMP_AMBIENT, 0xff)
        }

        enum ROOM {
            ID_FAKE_EXIT = memory(WORD, TEMP),
            ID_PIT = memory(WORD, TEMP),

            ID_YOSHI = memory(WORD, TEMP),
            ID_MARIO = memory(WORD, TEMP),
        }

        enum stepon_trigger {
            switch_6 = nop(),
            switch_5 = nop(),
            switch_4 = nop(),
            switch_3 = nop(),
            switch_2 = nop(),
            switch_7 = nop(),
            switch_1 = nop(),
            exit_door = nop(),
            stepon_8 = nop(),
            stepon_9 = nop(),

            stepon_10 = nop(),
            stepon_11 = nop(),
            stepon_12 = nop(),
            stepon_13 = nop(),
            stepon_14 = nop(),
            pipe_3_1 = nop(),
            pipe_1_1 = nop(),
            pipe_2_1 = nop(),
            pipe_2_2 = nop(),
            pipe_2_3 = nop(),

            pipe_1_2 = nop(),
            pipe_1_3 = nop(),
            pipe_1_4 = nop(),
            pipe_3_2 = nop(),
            pipe_3_3 = nop(),
            pipe_3_4 = nop(),
            stepon_26 = nop(),
            stepon_27 = nop(),
            stepon_28 = nop(),
            stepon_29 = nop(),

            stepon_30 = nop(),
            stepon_31 = nop(),
        }

        enum b_trigger {
            cell_1_gourd__1_glove_3_1 = nop(),
        }

        @install()
        @async()
        fun fake_exit_scanner() {
            range_checker(ROOM.ID_FAKE_EXIT, <ACTIVE>, 0x20, 0x20, {
                map_transition(volcano, cave_2_2, SOUTH);
            });
        }
        @install()
        @async()
        fun pit_scanner() {
            range_checker(ROOM.ID_PIT, <ACTIVE>, 0d35, 0d15, {
                generic_fall(0d100, 0d1000);
                map_transition(volcano_tower, crash, NONE);
            });
        }

        fun tease_mario() {
            add_enemy(RAPTOR_GREEN, 0d24 - 0d2, 0d115, INACTIVE_IMORTAL);
            ROOM.ID_YOSHI = <LAST_ENTITY>;
            add_enemy(VILLAGER_2_1, 0d24 - 0d2, 0d115, INACTIVE_IMORTAL);
            face(LAST_ENTITY, EAST);
            ROOM.ID_MARIO = <LAST_ENTITY>;

            stack_sprite(ROOM.ID_YOSHI, ROOM.ID_MARIO, 0d0, 0d15);

            subtext("He should be in that direction.");

            walk(ROOM.ID_YOSHI, TILE_ABSOLUTE, 0d59 + 0d2, 0d115, ROOM.ID_YOSHI, NONE);
            destroy(ROOM.ID_YOSHI);
            destroy(ROOM.ID_MARIO);
        }

        fun trigger_enter() {
            init_map(0d24, 0d108, 0d60, 0d140);
            default_init_room(False, False);

            fake_walls();

            add_enemy(PLACEHOLDER, 0d42, 0d140);
            ROOM.ID_FAKE_EXIT = <LAST_ENTITY>;
            fake_exit_scanner();

            add_enemy(PLACEHOLDER, 0d42, 0d122);
            ROOM.ID_PIT = <LAST_ENTITY>;
            pit_scanner();

            if((!NPC_MARIO.MARIO_TEASED) && (NPC_MARIO.PROGRESS < 0d1)) {
                NPC_MARIO.MARIO_TEASED = True;

                tease_mario();
            }
        }
    };

    map cave_gauge(PYRAMID_CAVE) {
        enum entrance {
            south = entrance(0x15, 0x23, NORTH),

            teleporter = entrance(0d23, 0d18, NONE, { teleporter_in(SOUTH); }),
        }

        enum soundtrack {
            default = soundtrack(AREA_ALTUS_PLATEAU.DEFAULT_MUSIC, 0xff)
        }

        enum stepon_trigger {
            exit_south = @install() {
                map_transition(volcano, cave_gauge, SOUTH);
            },
            exit_teleporter = @install() {
                debug_subtext("S=1");

                teleporter_out(0d23, 0d17);
                map_transition(jaguar_cave, teleporter, NONE);
            },
        }

        fun trigger_enter() {
            default_init_room(False, False);
        }
    };

    map cave_shop(ACT1_2_CAVES) {
        enum entrance {
            south = entrance(0x40, 0x2d, NORTH),
        }

        enum soundtrack {
            default = soundtrack(AREA_ALTUS_PLATEAU.DEFAULT_MUSIC, 0xff)
        }

        enum stepon_trigger {
            exit_south_drain = nop(),
            exit_south = @install() {
                map_transition(volcano, cave_east, SOUTH);
            },
            exit_south_jaguar_ring = nop(),
            exit_south_hard_ball = nop(),
            exit_south_inn = nop(),
        }

        enum b_trigger {
            gourd_drain_2 = nop(),
            gourd_drain_1 = nop(),
            gourd_inn_2 = nop(),
            gourd_inn_1 = nop(),
            gourd_jaguar_ring_1 = nop(),
            gourd_jaguar_ring_2 = nop(),
            gourd_jaguar_ring_3 = nop(),
            gourd_hard_ball_1 = nop(),
            gourd_hard_ball_2 = nop(),
            gourd_hard_ball_3 = nop(),
        }

        fun show_furniture(show) {
            if(show) {
                object[0x08] = 0x00; // hide raptors_stoble
                object[0x09] = 0x00; // hide raptors_fire
                object[0x0a] = 0x00; // hide raptors_rug
            } else {
                object[0x08] = 0x01; // hide raptors_stoble
                object[0x09] = 0x01; // hide raptors_fire
                object[0x0a] = 0x01; // hide raptors_rug
            }
        }

        enum ROOM {
            FURNITURE_REVEALED = memory(FLAG, SRAM),
        }

        @install()
        fun alchemist_triggered() {
            dialog("[SLOW]Huh, how did you find me?[B]");
        }

        fun reveal_furniture() {
            show_furniture(True);

            sfx_effect(NIGHT, False);

            add_enemy(VILLAGER_1_6, 0d70, 0d18);
            attach_script(LAST_ENTITY, B, reference(alchemist_triggered));
        }

        @install()
        fun revealer_triggered() {
            set(ROOM.FURNITURE_REVEALED);

            reveal_furniture();
        }

        fun trigger_enter() {
            if!(ROOM.FURNITURE_REVEALED) { // TODO: soft lock while standing in fire
                show_furniture(False);

                add_enemy(REVEALER_TARGET_ENTITY, 0d70, 0d23);
                special_script(REVEALER, reference(revealer_triggered));

                default_init_room(True, False);
            } else {
                reveal_furniture(True);

                default_init_room(False, False);
            }
        }
    };
    
    area altus_plateau_entry() {
        enum ALTUS {
            MUSIC = MUSIC.ACT3,
        }

        area chessboard_caves() {
            map stairs(CHESSBOARD_STAIRS) {
                enum entrance {
                    stairs_east_top = entrance(0x43, 0x03, SOUTH),
                    stairs_west_top = entrance(0x15, 0x05, SOUTH),
                    stairs_west_bottom = entrance(0x5f, 0xa1, NORTH),

                    bonfire = entrance(0d108, 0d100, NONE, { bonfire_wakeup(0d0, -0d8, 0d32, 0d0); }),
                }

                enum soundtrack {
                    default = soundtrack(CAVE_AMBIENT_PIANO, 0xff)
                }

                enum stepon_trigger {
                    cutscene_energy_core = @install() {
                        debug_subtext("S=0");
                    },
                    exit_stairs_west_bottom = @install() {
                        map_transition(volcano, cave_west, SOUTH);
                    },
                    exit_stairs_west_top = @install() {
                        map_transition(chessboard, stairs_east, NORTH);
                    },
                    exit_stairs_east_top = @install() {
                        map_transition(hidden_castle_entry, stairs, NORTH);
                    },
                }

                enum b_trigger {
                    pickup_energy_core = @install() {
                        debug_subtext("B=0");
                    },
                }

                fun trigger_enter() {
                    object[0x00] = 0x7e; // remove energy_core_hitbox

                    bonfire(0d108, 0d100, SOULS_MEMORY.BONFIRE_ALTUS_STAIRS);

                    add_souls_npc_alchemist_defend(0d75, 0d103);

                    default_init_room(False, False);
                }
            };

            map chessboard(FOOTKNIGHT) {
                // sniff=vanilla

                enum entrance {
                    east = entrance(0x93, 0x42, WEST),
                    west = entrance(0x01, 0x42, EAST),
                    stairs_east = entrance(0x53, 0x4c, WEST),
                    stairs_west = entrance(0x40, 0x40, EAST), // 0x4c, 0x40

                    crash = entrance(0x54, 0x39, NONE),
                    boss = entrance(0d43, 0d70, EAST),
                }

                enum soundtrack {
                    default = soundtrack(ALTUS.MUSIC, 0xff)
                }

                enum ROOM {
                    STAIRS_WEST_REVEALED = memory(FLAG, SRAM),

                    PALETTE_DONOR_BOY = memory(WORD, TEMP),
                    PALETTE_DONOR_DOG = memory(WORD, TEMP),

                    BEE_COLLECTED = memory(FLAG, SRAM),
                }

                fun open_stairs_east(open) {
                    if(open) {
                        object[0x01] = 0x00; // close stairs_east
                    } else {
                        object[0x01] = 0x7e; // close stairs_east
                    }
                }

                fun close_arena(close) {
                    if(close) {
                        init_map(0x31, 0x2f, 0x65, 0x57);

                        sound(IMPACT);
                        object[0x02] = 0x01; // close wall_2
                        sleep(0d10);
                        sound(IMPACT);
                        object[0x03] = 0x01; // close wall_1

                    } else {
                        init_map(0x00, 0x00, 0xff, 0xff);

                        object[0x02] = 0x00; // close wall_2
                        object[0x03] = 0x00; // close wall_1
                    }
                }

                enum BOSS {
                    ID = memory(WORD, TEMP),
                    PROGRESS = memory(FLAG, TEMP),

                    HP = 0d200,
                }

                fun boss_defeated() {
                    souls_boss_defeated(DEAD_CHESS, REWARD_CHESS);

                    close_arena(False);
                    open_stairs_east(True);
                }

                @install()
                fun boss_triggered() {
                    // debug_memory(BOSS.ID[HP], BOSS.ID[DAMAGE_SOURCE]);

                    // if(<SCRIPT_OWNER>[GENERAL_PURPOSE] > 0x00) {
                    //     heal(SCRIPT_OWNER, 0x30, True);
                    //     end();
                    // }
                    
                    if((<SCRIPT_OWNER>[DAMAGE_SOURCE] == CHARACTER_ADDRESS.DOG) && (<DOG>[GENERAL_PURPOSE] ^ <SCRIPT_OWNER>[GENERAL_PURPOSE] == 0x00)){
                        heal(SCRIPT_OWNER, 0x30, True);
                    } else if(<BOY>[GENERAL_PURPOSE] ^ <SCRIPT_OWNER>[GENERAL_PURPOSE] == 0x00){
                        heal(SCRIPT_OWNER, 0x30, True);
                    }

                    if(<SCRIPT_OWNER>[HP] <= 0x00) {
                        boss_defeated();
                    }
                }

                @install()
                @async()
                fun oglin_parity_check(entity) {
                    attach_to_script(arg[0x00]);

                    val palette_oglin_black = arg[0x10];
                    palette_oglin_black = ROOM.PALETTE_DONOR_DOG[PALETTE];
                    val palette_oglin = arg[0x12];
                    palette_oglin = <SCRIPT_OWNER>[PALETTE];
                    
                    while(alive(<SCRIPT_OWNER>)) {
                        if((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) == 0d0) {
                            arg[0x14] = (((<SCRIPT_OWNER>[X]) / 0x50) & 0x01) ^ (((<SCRIPT_OWNER>[Y] - 0x1e) / 0x32) & 0x01);
                            yield();

                            if(<SCRIPT_OWNER>[GENERAL_PURPOSE] != arg[0x14]) {
                                // parity_check_character(<BOY>, DOG);
                                if(arg[0x14]) {
                                    // attribute(BOY, INVISIBLE, False);
                                    <SCRIPT_OWNER>[PALETTE] = palette_oglin_black;
                                    <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0x01;
                                    nop();
                                } else {
                                    // attribute(BOY, INVISIBLE, True);
                                    <SCRIPT_OWNER>[PALETTE] = palette_oglin;
                                    <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0x00;
                                    nop();
                                }
                            }
                        }
                        sleep(0d10);
                    }
                }

                fun spawn_boss(x, y) {
                    BOSS.PROGRESS = True;

                    add_enemy(MAGMAR, x, y);
                    BOSS.ID = <LAST_ENTITY>;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(boss_triggered));
                    <LAST_ENTITY>[HP] = BOSS.HP;

                    push_music(BOSS);

                    if(False) {
                        attribute(BOY, INVINCIBLE_TEMP, True);
                        attribute(DOG, INVINCIBLE_TEMP, True);
                    }
                }

                enum stepon_trigger {
                    stairs_east = @install() {
                        map_transition(stairs, stairs_west_top, EAST);
                    },
                    spawn_boss = @install() {
                        debug_subtext("S=1");

                        if!(SOULS_MEMORY.DEAD_CHESS) {
                            if!(BOSS.PROGRESS) {
                                walk(BOY, TILE_ABSOLUTE, 0x39, 0x44, NONE);
                                walk(DOG, TILE_ABSOLUTE, 0x39, 0x48, BOTH, BOTH);

                                close_arena(True);
                                spawn_boss(0d74, 0d69); // 0d84, 0d57);
                                oglin_parity_check(<LAST_ENTITY>);
                            }
                        }
                    },
                    exit_west = @install() {
                        map_transition(gate, east, WEST);
                    },
                    exit_east = @install() {
                        map_transition(well, west, EAST);
                    },
                    stairs_west = @install() {
                        map_transition(hidden_stairs, stairs, WEST);
                    }
                }

                enum b_trigger {
                    sniff__1_water_3 = @install() {
                        debug_subtext("B=0");
                        _loot(0x18, WATER, 0d01, 0d03);
                    },
                    sniff__1_water_1 = @install() {
                        debug_subtext("B=1");
                        _loot(0x17, WATER, 0d01, 0d01);
                    },
                    sniff__1_ash_2 = @install() {
                        debug_subtext("B=2");
                        _loot(0x16, ASH, 0d01, 0d02);
                    },
                    sniff__1_ash_3 = @install() {
                        debug_subtext("B=3");
                        _loot(0x15, ASH, 0d01, 0d03);
                    },
                    sniff__1_roots_2 = @install() {
                        debug_subtext("B=4");
                        _loot(0x14, ROOTS, 0d01, 0d02);
                    },
                    sniff__1_roots_4 = @install() {
                        debug_subtext("B=5");
                        _loot(0x13, ROOTS, 0d01, 0d04);
                    },
                    sniff__1_roots_3 = @install() {
                        debug_subtext("B=6");
                        _loot(0x12, ROOTS, 0d01, 0d03);
                    },
                    sniff__1_roots_4 = @install() {
                        debug_subtext("B=7");
                        _loot(0x11, ROOTS, 0d01, 0d04);
                    },
                    sniff__1_brimstone_3 = @install() {
                        debug_subtext("B=8");
                        _loot(0x10, BRIMSTONE, 0d01, 0d03);
                    },
                    sniff__1_brimstone_1 = @install() {
                        debug_subtext("B=9");
                        _loot(0x0f, BRIMSTONE, 0d01, 0d01);
                    },

                    sniff__1_brimstone_1 = @install() {
                        debug_subtext("B=10");
                        _loot(0x0e, BRIMSTONE, 0d01, 0d01);
                    },
                    sniff__1_iron_3 = @install() {
                        debug_subtext("B=11");
                        _loot(0x0d, IRON, 0d01, 0d03);
                    },
                    sniff__1_iron = @install() {
                        debug_subtext("B=12");
                        _loot(0x0c, IRON, 0d01, 0d00);
                    },
                    sniff__1_feather_2 = @install() {
                        debug_subtext("B=13");
                        _loot(0x0b, FEATHER, 0d01, 0d02);
                    },
                    sniff__1_acorns_3 = @install() {
                        debug_subtext("B=14");
                        _loot(0x0a, ACORNS, 0d01, 0d03);
                    },
                    sniff__1_acorns_2 = @install() {
                        debug_subtext("B=15");
                        _loot(0x09, ACORNS, 0d01, 0d02);
                    },
                    sniff__1_acorns_2 = @install() {
                        debug_subtext("B=16");
                        _loot(0x08, ACORNS, 0d01, 0d02);
                    },
                    sniff__1_mushroom_3 = @install() {
                        debug_subtext("B=17");
                        _loot(0x07, MUSHROOM, 0d01, 0d03);
                    },
                    sniff__1_mushroom_2 = @install() {
                        debug_subtext("B=18");
                        _loot(0x06, MUSHROOM, 0d01, 0d02);
                    }
                }

                @install()
                fun revealer_triggered() {
                    destroy(SCRIPT_OWNER);

                    set(ROOM.STAIRS_WEST_REVEALED);

                    object[0x00] = 0x02;
                    sleep(0x10);
                    object[0x00] = 0x01;
                    sleep(0x10);
                    object[0x00] = 0x00;
                }

                fun square_white(character) {
                    attribute_bit(character, INVISIBLE);
                }
                fun square_black(character) {
                    attribute_bit(character, VISIBLE);
                }

                fun parity_check_character(char, character:CHARACTER) { // buggy
                    // arg[0x00] = (character[X] - 0x1e0) / 0x50;
                    // arg[0x02] = (character[Y] - 0x1ae) / 0x32;
                    arg[0x00] = (char[X]) / 0x50;
                    arg[0x02] = (char[Y] - 0x1e) / 0x32;

                    // debug_memory(arg[0x00], arg[0x02]);
                    // sleep(0x30);

                    arg[0x04] = arg[0x00] & 0x01;
                    arg[0x06] = arg[0x02] & 0x01;

                    // debug_memory(arg[0x04], arg[0x06]);
                    // sleep(0x30);

                    arg[0x08] = arg[0x04] ^ arg[0x06];

                    // debug_memory(arg[0x08], arg[0x08]);
                    if(arg[0x08] == 0x00) {
                        // square_black(character);
                        attribute(character, INVISIBLE, False);
                    } else {
                        // square_white(character);
                        attribute(character, INVISIBLE, True);
                    }

                    // arg[0x00] = (((<BOY>[X]) / 0x50) & 0x01);
                    // arg[0x02] = (((<BOY>[Y] - 0x1e) / 0x32) & 0x01);
                }

                @install()
                @async()
                fun parity_check() {
                    sleep(0x50);

                    val palette_boy_black = arg[0x10];
                    palette_boy_black = ROOM.PALETTE_DONOR_BOY[PALETTE];
                    val palette_dog_black = arg[0x12];
                    palette_dog_black = ROOM.PALETTE_DONOR_DOG[PALETTE];
                    val palette_boy = arg[0x14];
                    palette_boy = <BOY>[PALETTE];
                    val palette_dog = arg[0x16];
                    palette_dog = <DOG>[PALETTE];
                    // arg[0x06] = 0x08cd;

                    val current_square = arg[0x18];

                    // debug_memory(palette_boy_black, palette_boy);

                    while(True) {
                        // parity_check_character(<BOY>, DOG);
                        if((<BOY>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) == 0d0) {
                            current_square = (((<BOY>[X]) / 0x50) & 0x01) ^ (((<BOY>[Y] - 0x1e) / 0x32) & 0x01);
                            yield();

                            if(<BOY>[GENERAL_PURPOSE] != current_square) {
                                if(current_square) {
                                    // attribute(BOY, INVISIBLE, False);
                                    <BOY>[PALETTE] = palette_boy_black;
                                    <BOY>[GENERAL_PURPOSE] = 0x01;
                                    nop();
                                } else {
                                    // attribute(BOY, INVISIBLE, True);
                                    <BOY>[PALETTE] = palette_boy;
                                    <BOY>[GENERAL_PURPOSE] = 0x00;
                                    nop();
                                }
                            }
                        }
                        sleep(0d10);

                        if((<DOG>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) == 0d0) {
                            current_square = (((<DOG>[X]) / 0x50) & 0x01) ^ (((<DOG>[Y] - 0x1e) / 0x32) & 0x01);
                            yield();

                            if(<DOG>[GENERAL_PURPOSE] != current_square) {
                                // parity_check_character(<DOG>, DOG);
                                if((((<DOG>[X]) / 0x50) & 0x01) ^ (((<DOG>[Y] - 0x1e) / 0x32) & 0x01)) {
                                    // attribute(DOG, INVISIBLE, False);
                                    <DOG>[GENERAL_PURPOSE] = 0x01;
                                    <DOG>[PALETTE] = palette_dog_black;
                                    nop();
                                } else {
                                    // attribute(DOG, INVISIBLE, True);
                                    <DOG>[GENERAL_PURPOSE] = 0x00;
                                    <DOG>[PALETTE] = palette_dog;
                                    nop();
                                }
                            }
                        }
                        sleep(0d10);
                    }
                }

                @install()
                fun enemy_triggered() {
                    // debug_memory(BOSS.ID[HP], BOSS.ID[DAMAGE_SOURCE]);

                    // if(<SCRIPT_OWNER>[GENERAL_PURPOSE] > 0x00) {
                    //     heal(SCRIPT_OWNER, 0x30, True);
                    //     end();
                    // }
                    
                    if((<SCRIPT_OWNER>[DAMAGE_SOURCE] == CHARACTER_ADDRESS.DOG) && (<DOG>[GENERAL_PURPOSE] ^ <SCRIPT_OWNER>[GENERAL_PURPOSE] == 0x00)){
                        heal(SCRIPT_OWNER, 0x30, True);
                        end();
                    } else if(<BOY>[GENERAL_PURPOSE] ^ <SCRIPT_OWNER>[GENERAL_PURPOSE] == 0x00){
                        heal(SCRIPT_OWNER, 0x30, True);
                        end();
                    }
                }

                @install()
                fun debug_triggered() {
                    set(ROOM.STAIRS_WEST_REVEALED);

                    object[0x00] = 0x00; // close stairs_west
                    open_stairs_east(True);

                    destroy(SCRIPT_OWNER);
                }

                fun add_chess_enemy(x, y) {
                    add_enemy(OGLIN, x, y);
                    <LAST_ENTITY>[HP] = 0x01;
                    attach_script(LAST_ENTITY, DAMAGE, reference(enemy_triggered));

                    oglin_parity_check(<LAST_ENTITY>);
                }

                fun trigger_enter() {
                    CUSTOM_FLAG.NO_CURRENCY_DISPLAY = True; // TODO: should not discolor magmar
                    
                    add_enemy(BOY_BLACK, 0d00, 0d00, INVISBLE_INVINCIBLE_INACTIVE);
                    ROOM.PALETTE_DONOR_BOY = <LAST_ENTITY>;
                    add_enemy(DOG_1_BLACK, 0d00, 0d00, INVISBLE_INVINCIBLE_INACTIVE);
                    ROOM.PALETTE_DONOR_DOG = <LAST_ENTITY>;

                    if(FLAG.DEBUG) {
                        add_debug_entity(0x59, 0x49, reference(debug_triggered));
                    }

                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // east
                        add_chess_enemy(0d113, 0d71);

                        // south
                        add_chess_enemy(0d55, 0d93);

                        // west
                        add_chess_enemy(0d68, 0d44);
                    }

                    if(SOULS_MEMORY.DEAD_CHESS) {
                        open_stairs_east(True);
                    } else {
                        open_stairs_east(False);
                    }

                    if!(ROOM.STAIRS_WEST_REVEALED) {
                        add_enemy(REVEALER_TARGET_ENTITY, 0x3e, 0x40);
                        special_script(REVEALER, reference(revealer_triggered));

                        object[0x00] = 0x7e; // close stairs_west
                    } else {
                        object[0x00] = 0x00;
                    }

                    if!(ROOM.BEE_COLLECTED) {
                        add_bee(0d143, 0d31, reference(@install() {
                            bee_collected(ROOM.BEE_COLLECTED);
                        }));
                    }

                    default_init_room(True, True);

                    parity_check();

                    // object[0x00] = 0x7e; // close stairs_west
                    // object[0x01] = 0x7e; // close stairs_east
                    // object[0x02] = 0x01; // close wall_2
                    // object[0x03] = 0x01; // close wall_1
                    // object[0x04] = 0x01; // remove bridge_east
                    // object[0x05] = 0x01; // remove bridge_west
                }
            };

            map hidden_stairs(EBON_CELLAR) {
                // chests=vanilla

                enum entrance {
                    stairs = entrance(0x29, 0x0d, WEST)
                }

                enum soundtrack {
                    default = soundtrack(CAVE_AMBIENT_PIANO, 0xff)
                }

                enum stepon_trigger {
                    stepon_0 = @install() {
                        map_transition(chessboard, stairs_west, EAST);
                    },
                }

                enum b_trigger {
                    chest_1__3_feather = @install() {
                        debug_subtext("B=0");
                        _loot_chest(0x00, SPOON, 0d01);
                    },
                    chest_2__4_brimstone = @install() {
                        debug_subtext("B=1");
                        _loot_chest(0x01, BRIMSTONE, 0d04);
                    },
                    chest_3__2_acorns = @install() {
                        debug_subtext("B=2");
                        _loot_chest(0x02, DRY_ICE, 0d02);
                    },
                }

                fun trigger_enter() {
                    default_init_room(True, False);
                }
            };

            map hidden_castle_entry(VERMINATOR) {
                enum entrance {
                    north = entrance(0x16, 0x09, SOUTH),
                    east = entrance(0x29, 0x38, WEST),
                    south = entrance(0x16, 0x65, NORTH),
                    west = entrance(0x03, 0x38, EAST),
                    stairs = entrance(0x19, 0x4d, EAST)
                }

                enum soundtrack {
                    default = soundtrack(CAVE_AMBIENT_PIANO, 0xff)
                }

                group boss_ai() {
                    enum BOSS {
                        DEBUG = False,
                        PROGRESS = memory(FLAG, TEMP),

                        HP = 0d600,

                        ID_RIDER = memory(WORD, TEMP),
                        ID_MOUNT = memory(WORD, TEMP),

                        ID_PROJECTILE = memory(WORD, TEMP),

                        PHASE = memory(WORD, TEMP), // TODO: doesn't work with BYTE
                        BOSS_RAT_KILL_COUNT = memory(WORD, TEMP), // TODO: doesn't work with BYTE
                        BOSS_RAT_KILLS_P1 = 0d3,
                        BOSS_RAT_HP = 0d50,
                        BOSS_RAT_HEALING = memory(FLAG, TEMP),

                        TIMER = memory(WORD, TEMP),
                        TIMER_T0 = 0d60,
                        TIMER_T1 = 0d300,
                        TIMER_T2 = 0d300,

                        STACKING = memory(FLAG, TEMP),
                        STACK_ROLL = memory(WORD, TEMP),
                        STACK_ROLL_COUNT = 0d4,

                        CRATES_X = 0d22,
                        CRATES_Y = 0d12,

                        CHEESE_RANGE = 0d10,
                    }

                    fun boss_killed() {
                        destroy(BOSS.ID_MOUNT);

                        souls_boss_defeated(DEAD_UNNAMED_STAIRWELL_BOSS, REWARD_UNNAMED_STAIRWELL_BOSS);

                        object[0x00] = 0x00; // close gate
                        free_map();
                    }

                    fun prepare_rat(entity) {
                        entity[HP] = 0d1;
                        attach_script(entity, DAMAGE, reference(@install() {
                            if(script[0x9] == 0x100) {
                                heal(SCRIPT_OWNER, 0d0, False);
                                yield();
                                damage(SCRIPT_OWNER, 0d0, True);

                                // walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y], NONE, NONE);
                                // animate(SCRIPT_OWNER, ONCE, DEFAULT);
                                control(SCRIPT_OWNER, True);

                                if(BOSS.DEBUG) {
                                    subtext("stunned");
                                }
                            }
                        }));
                    }

                    @install()
                    @async()
                    fun cheese_protection(entity_mount) {
                        while(alive(entity_mount)) {
                            if(entity_mount[FLAGS_7] & ATTRIBUTE_FLAGS.WALKING) {
                                arg[0x10] = entity_mount[X];
                                arg[0x12] = entity_mount[Y];

                                while(entity_mount[FLAGS_7] & ATTRIBUTE_FLAGS.WALKING) {
                                    yield();
                                }

                                if(entity_mount[X] < arg[0x10]) {
                                    arg[0x10] = arg[0x10] - entity_mount[X];
                                } else {
                                    arg[0x10] = entity_mount[X] - arg[0x10];
                                }

                                if(entity_mount[Y] < arg[0x12]) {
                                    arg[0x12] = arg[0x12] - entity_mount[Y];
                                } else {
                                    arg[0x12] = entity_mount[Y] - arg[0x12];
                                }

                                if((arg[0x10] == arg[0x14]) && (arg[0x12] == arg[0x16])) {
                                    arg[0x18]++;
                                } else {
                                    arg[0x18] = 0d0;
                                }

                                if(BOSS.DEBUG && False) {
                                    debug_memory(arg[0x10], arg[0x12], arg[0x18]);
                                }

                                BOSS.STACK_ROLL++;
                                if(BOSS.STACK_ROLL >= BOSS.STACK_ROLL_COUNT) {
                                    if(BOSS.DEBUG) {
                                        MEMORY.STRING_PARAMETER_1 = BOSS.STACK_ROLL;
                                        debug_subtext("cheese: roll=[MEM1]");
                                    }

                                    BOSS.STACKING = False;
                                    end();
                                } else if(
                                    ((arg[0x10] <= BOSS.CHEESE_RANGE) && (arg[0x12] <= BOSS.CHEESE_RANGE)) ||
                                    (arg[0x18] >= 0d2)
                                ) {
                                    if(BOSS.DEBUG) {
                                        MEMORY.STRING_PARAMETER_1 = arg[0x10];
                                        MEMORY.STRING_PARAMETER_2 = arg[0x12];
                                        debug_subtext("cheese: dx=[MEM1] dy=[MEM2]");
                                    }

                                    BOSS.STACKING = False;
                                    end();
                                }

                                arg[0x14] = arg[0x10];
                                arg[0x16] = arg[0x12];
                            }

                            yield();
                        }
                    }

                    fun bench_enemy(enemy, benched_enemy) {
                        control(enemy, True);
                        swap_enemies(enemy, benched_enemy);
                        // animate(benched_enemy, ONCE_FREEZE, INVISIBLE);
                        control(benched_enemy, False);
                    }

                    @install()
                    // @async()
                    fun ride_rat(entity_rider, entity_mount, offset_x, offset_y) {
                        BOSS.STACKING = True;
                        arg[0x10] = entity_mount[Z_LEVEL];
                        arg[0x12] = entity_rider[Z_LEVEL];

                        attribute(entity_mount, ROOT, True);
                        animate(entity_mount, ONCE_FREEZE, ANIMATION_ENEMY.MEGATAUR_ENTER);
                        entity_mount[TYPE] = CHARACTER_TYPE.MEGATAUR;

                        animate(entity_rider, ONCE, ANIMATION_ALL.CAST);
                        wait(entity_rider);

                        // entity_rider[VELOCITY] = 0d30;
                        _drag(entity_rider, entity_mount[X] + offset_x, entity_mount[Y] - offset_y);
                        entity_rider[Z_LEVEL] = arg[0x10];

                        entity_rider[VELOCITY] = 0d20;
                        guard_dead(entity_rider);
                        sleep(0d50);
                        entity_rider[Z] = 0d0;

                        animate(entity_mount, ONCE, ANIMATION_ENEMY.MEGATAUR_DUCK);
                        attribute(entity_mount, ROOT, False);
                        guard_dead(entity_rider);

                        cheese_protection(entity_mount);
                        
                        BOSS.STACK_ROLL = 0d0;
                        while(BOSS.STACKING && _alive(entity_rider) && _alive(entity_mount)) {
                            entity_rider[X] = entity_mount[X] + offset_x;
                            entity_rider[Y] = entity_mount[Y] - offset_y;

                            yield();
                        }

                        guard_dead(entity_rider);

                        animate(entity_mount, ONCE, ANIMATION_ENEMY.MEGATAUR_DUCK);
                        entity_mount[TYPE] = CHARACTER_TYPE.RAT_RED;
                        animate(entity_mount, ONCE, ANIMATION_ENEMY.MEGATAUR_EXIT);

                        drag(entity_rider, BOSS.CRATES_X, BOSS.CRATES_Y);
                        entity_rider[Z_LEVEL] = arg[0x12];

                        guard_dead(entity_mount);
                        wait(entity_mount);
                    }

                    fun toss_bomb() {
                        arg[0x10] = <ACTIVE>[X];
                        arg[0x12] = <ACTIVE>[Y];
                        if(<ACTIVE>[X] < 0d180) {
                            arg[0x14] = -0d20;
                        } else {
                            arg[0x14] = 0d20;
                        }

                        animate(BOSS.ID_RIDER, ONCE, ANIMATION_ALL.CAST);
                        sleep(0d30);
                        ai_move_bomb_toss(BOSS.ID_RIDER, BOTTLE, <ACTIVE>, arg[0x14], -0d20);
                    }
                    @install()
                    fun toss_bombs(amount) {
                        while(amount > 0d0) {
                            amount--;

                            toss_bomb();
                        }
                    }

                    fun toss_rock(x, y, overshoot) {
                        animate(BOSS.ID_RIDER, ONCE, ANIMATION_ALL.CAST);
                        sleep(0d30);
                        shoot_entity_absolute(BOSS.ID_RIDER, ROCK, arg[0x10], arg[0x12], 0d50, overshoot);
                        animate(BOSS.ID_RIDER, ONCE, DEFAULT);
                    }
                    @install()
                    fun toss_rocks(amount) {
                        arg[0x10] = <ACTIVE>[X];
                        arg[0x12] = <ACTIVE>[Y];
                        
                        while(amount > 0d0) {
                            amount--;

                            toss_rock(arg[0x10], arg[0x12], arg[0x14]);

                            arg[0x14] += 0d50;
                        }
                    }

                    @install()
                    fun toss_rat(boss_rat) {
                        animate(BOSS.ID_RIDER, ONCE, ANIMATION_ALL.CAST);
                        sleep(0d20);

                        if(boss_rat) {
                            _add_enemy(RAT_RED, BOSS.ID_RIDER[X] - 0d15, BOSS.ID_RIDER[Y] - 0d30, INVINCIBLE);
                            BOSS.ID_MOUNT = <LAST_ENTITY>;
                        } else {
                            _add_enemy(RAT, BOSS.ID_RIDER[X] - 0d15, BOSS.ID_RIDER[Y] - 0d30, INVINCIBLE);
                        }
                        arg[0x10] = <LAST_ENTITY>;
                        sleep(0d10);

                        arg[0x10][Z] = 0d100;
                        _drag(arg[0x10], <ACTIVE>[X], <ACTIVE>[Y]);

                        if(boss_rat) {
                            replace_enemy(arg[0x10], RAT_RED);
                            BOSS.ID_MOUNT = <LAST_ENTITY>;
                            <LAST_ENTITY>[HP] = BOSS.BOSS_RAT_HP;
                            attach_script(LAST_ENTITY, DEATH, reference(@install() {
                                BOSS.BOSS_RAT_KILL_COUNT++;

                                if(BOSS.PHASE == 0d0) {
                                    if(BOSS.DEBUG) {
                                        debug_memory(BOSS.BOSS_RAT_KILL_COUNT);
                                    }

                                    if(BOSS.BOSS_RAT_KILL_COUNT == BOSS.BOSS_RAT_KILLS_P1) {
                                        BOSS.PHASE++;
                                    }
                                } else if(BOSS.PHASE == 0d1) {
                                    attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);
                                    heal(SCRIPT_OWNER, 0d1, False);

                                    animate(BOSS.ID_RIDER, ONCE, ANIMATION_ALL.CAST);
                                    cast(BOSS.ID_RIDER, SCRIPT_OWNER, HEAL, BOSS.BOSS_RAT_HP);

                                    animate(SCRIPT_OWNER, ONCE_FREEZE, DEFAULT);

                                    BOSS.BOSS_RAT_HEALING = True;

                                    if!(BOSS.STACKING) {
                                        cast(BOSS.ID_RIDER, SCRIPT_OWNER, HEAL, BOSS.BOSS_RAT_HP);

                                        animate(BOSS.ID_MOUNT, ONCE_FREEZE, ANIMATION_ENEMY.MEGATAUR_ENTER);
                                    }
                                    attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
                                }
                            }));

                            if(False && BOSS.DEBUG) {
                                <LAST_ENTITY>[HP] = 0d1;
                            }
                        } else {
                            replace_enemy(arg[0x10], RAT);
                        }
                        arg[0x10] = <LAST_ENTITY>;
                        
                        if((arg[0x10][CURRENT_GROUND] & 0xff) != 0d16) {
                            bomb_entity(arg[0x10], 0d50);
                            animate(arg[0x10], ONCE, ANIMATION_PLACEHOLDER.GORE_RED);
                            wait(arg[0x10]);

                            destroy(arg[0x10]);
                        } else {
                            if!(boss_rat) {
                                hatch_enemy(arg[0x10], MINITAUR);
                            }
                        }
                    }

                    @install()
                    @async()
                    fun boss_watcher() {
                        while(<ACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                            yield();
                        }

                        if(BOSS.DEBUG) {
                            subtext("phase 0");
                        }

                        // BOSS.PHASE = 0d1;

                        while(BOSS.PHASE == 0d0) {
                            BOSS.TIMER++;

                            if(BOSS.TIMER > BOSS.TIMER_T0) {
                                arg[0x10] = randrange(0d3);

                                if(BOSS.DEBUG) {
                                    debug_memory(arg[0x10], dead(BOSS.ID_MOUNT));
                                }

                                if(dead(BOSS.ID_MOUNT)) {
                                    toss_rat(True);
                                } else if(arg[0x10] == 0d0) {
                                    toss_bombs(0d1);
                                } else {
                                    toss_rocks(0d1);
                                }

                                BOSS.TIMER = 0d0;
                            }

                            yield();
                        }

                        if(BOSS.DEBUG) {
                            subtext("phase 1");
                        }

                        BOSS.TIMER = 0d0;

                        while(BOSS.PHASE == 0d1) {
                            BOSS.TIMER++;

                            if(BOSS.TIMER > BOSS.TIMER_T1) {
                                arg[0x10] = randrange(0d5);

                                if(dead(BOSS.ID_MOUNT)) {
                                    toss_rat(True);
                                } else if(BOSS.BOSS_RAT_HEALING) {
                                    BOSS.BOSS_RAT_HEALING = False;
                                    ride_rat(BOSS.ID_RIDER, BOSS.ID_MOUNT, 0d0, 0d40);
                                } else if(arg[0x10] == 0d0) {
                                    toss_bombs(0d2);
                                } else if(arg[0x10] == 0d1) {
                                    toss_rocks(0d4);
                                } else if(arg[0x10] == 0d2) {
                                    toss_rat();
                                } else {
                                    if!(BOSS.STACKING) {
                                        ride_rat(BOSS.ID_RIDER, BOSS.ID_MOUNT, 0d0, 0d40);
                                    }
                                }

                                BOSS.TIMER = 0d0;
                            }
                            
                            yield();
                        }

                        if(BOSS.DEBUG) {
                            subtext("yatta");
                        }

                        boss_killed();
                    }

                    fun add_boss(x, y) {
                        add_enemy(VERMINATOR, x, y);
                        BOSS.ID_RIDER = <LAST_ENTITY>;
                        <LAST_ENTITY>[HP] = BOSS.HP;
                        attach_script(LAST_ENTITY, DEATH, reference(@install() {
                            if(BOSS.PHASE == 0d1) {
                                if(script[0x9] == 0x200) {
                                    BOSS.PHASE = 0d2;
                                }
                            }
                        }));

                        boss_watcher();
                    }
                };

                enum stepon_trigger {
                    exit_north = @install() {
                        debug_subtext("S=0");
                    },
                    stepon_1 = @install() {
                        debug_subtext("S=1");
                    },
                    stepon_2 = @install() {
                        debug_subtext("S=2");
                    },
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    stepon_4 = @install() {
                        debug_subtext("S=4");
                    },
                    spawn_boss = @install() {
                        debug_subtext("S=5");

                        if!(SOULS_MEMORY.DEAD_UNNAMED_STAIRWELL_BOSS) {
                            set(BOSS.PROGRESS);

                            control(NONE);

                            push_music(BOSS);
                            add_boss(BOSS.CRATES_X, BOSS.CRATES_Y);

                            set_camera(COORDINATE_CENTER, 0xb0, 0x78, 0x80 >> 0d2);
                            wait(CAMERA_PAN_Y);

                            init_map(0x00, 0x00, 0x2e, 0x1e);

                            walk(ACTIVE, TILE_ABSOLUTE, 0x14, 0x16, ACTIVE, NONE);
                            face(ACTIVE, NORTH);

                            walk(INACTIVE, TILE_ABSOLUTE, 0x18, 0x16, INACTIVE, NONE);
                            face(INACTIVE, NORTH);

                            object[0x00] = 0x7e; // close gate

                            free_camera();

                            control(BOTH);
                        }
                    },
                    exit_stairs = @install() {
                        map_transition(stairs, stairs_east_top, WEST);
                    },
                    exit_south = @install() {
                        debug_subtext("S=7");
                    },
                    exit_west = @install() {
                        debug_subtext("S=8");
                    },
                    exit_east = @install() {
                        debug_subtext("S=9");
                    }
                }

                fun trigger_enter() {
                    default_init_room(False, False);
                }
            };
        };

        map well(WELL) {
            enum entrance {
                west = entrance(0x01, 0x1c, EAST),

                crash = entrance(0x38, 0x18, NONE),
                bonfire = entrance(0d30, 0d20, NONE, { bonfire_wakeup(0d0, 0d8, 0d32, 0d0); }),
            }

            enum soundtrack {
                default = soundtrack(ALTUS.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_west = @install() {
                    map_transition(chessboard, east, WEST);
                },
            }

            enum ROOM {
                DEBUG = False,

                WELL_CRANKS = memory(WORD, TEMP),
                CRANKS_REQUIRED = 0d20,

                WELL_STATE = memory(FLAG, TEMP),

                LUIGI_ID = memory(WORD, TEMP),

                LUIGI_LIMIT_TOP = 0d433,
                LUIGI_LIMIT_BOTTOM = 0d447,
            }

            fun crank_well() {
                ROOM.WELL_STATE = !ROOM.WELL_STATE;

                sound(SQUEEK);

                if(ROOM.WELL_STATE) {
                    object[0x00] = 0x00;
                    object[0x01] = 0x00;
                    object[0x02] = 0x00;
                } else {
                    object[0x00] = 0x01;
                    object[0x01] = 0x01;
                    object[0x02] = 0x01;
                }

                if(ROOM.LUIGI_ID > 0d0) {
                    arg[0x10] = ROOM.LUIGI_LIMIT_TOP + (ROOM.CRANKS_REQUIRED - ROOM.WELL_CRANKS);

                    if(arg[0x10] < ROOM.LUIGI_LIMIT_BOTTOM) {
                        _teleport(ROOM.LUIGI_ID, 0d215, arg[0x10]);
                    } else if(arg[0x10] == ROOM.LUIGI_LIMIT_BOTTOM) {
                        teleport(ROOM.LUIGI_ID, 0d0, 0d0);
                    }
                }

                if(ROOM.DEBUG) {
                    MEMORY.STRING_PARAMETER_1 = ROOM.WELL_CRANKS;
                    MEMORY.STRING_PARAMETER_2 = ROOM.CRANKS_REQUIRED;
                    MEMORY.STRING_PARAMETER_3 = arg[0x10];

                    debug_subtext("cranks = [MEM1]/[MEM2] ([MEM3])");
                }
            }
            fun drop_bucket() {
                control(NONE);

                while(ROOM.WELL_CRANKS > 0d0) {
                    ROOM.WELL_CRANKS--;
                    crank_well();

                    sleep(0d3);
                }
                ROOM.WELL_CRANKS = 0d0;

                sound(WATER_PLOP);

                control(BOTH);
            }

            fun well_triggered() {
                nop();
            }

            enum b_trigger {
                well = @install() {
                    debug_subtext("B=0");

                    if(ROOM.WELL_CRANKS < ROOM.CRANKS_REQUIRED) {
                        ROOM.WELL_CRANKS++;
                        crank_well();
                    } else {
                        drop_bucket();

                        well_triggered();
                    }
                },
            }

            @install()
            @async()
            fun crash_windwalker() {
                // add_placeholder(ANIMATION_PLACEHOLDER.WINDWALKER_IDLE, 0x5b, 0x39);
                add_placeholder(ANIMATION_PLACEHOLDER.WINDWALKER_IDLE, 0x2a, 0x0c);
                attach_to_script(LAST_ENTITY);
                <SCRIPT_OWNER>[Z] = 0x1fff;
                sleep(0x80);
                <SCRIPT_OWNER>[VELOCITY] = 0x20;
                
                add_placeholder(ANIMATION_PLACEHOLDER.EXPLOSION_3, 0x00, 0x00);
                arg[0x00] = <LAST_ENTITY>;

                arg[0x00][X] = <SCRIPT_OWNER>[X] + 0x10;
                arg[0x00][Y] = <SCRIPT_OWNER>[Y] + 0x10;

                add_placeholder(ANIMATION_PLACEHOLDER.EXPLOSION_3, 0x00, 0x00);
                arg[0x02] = <LAST_ENTITY>;

                arg[0x02][X] = <SCRIPT_OWNER>[X] - 0x10;
                arg[0x02][Y] = <SCRIPT_OWNER>[Y] - 0x10;

                sleep(0x50);
                destroy(arg[0x02]);
                sleep(0x10);
                destroy(SCRIPT_OWNER);
                sleep(0x60);
                destroy(arg[0x00]);
            }

            fun trigger_enter() {
                if!(AREA_ALTUS_PLATEAU.ENTRANCE_UNLOCKED) {
                    set(AREA_ALTUS_PLATEAU.ENTRANCE_UNLOCKED);

                    if!(FLAG.IN_ANIMATION) {
                        crash_both();
                        crash_windwalker();
                    }
                }

                if(SOULS_MEMORY.WITH_SIDE_QUESTS) {
                    if(NPC_MARIO.PROGRESS == 0d0) {
                        add_souls_npc_mario(0d0, 0d0, INACTIVE);
                        ROOM.LUIGI_ID = <LAST_ENTITY>;
                    }
                }

                bonfire(0d30, 0d20, SOULS_MEMORY.BONFIRE_ALTUS_WELL);
                
                default_init_room(True, True);
            }
        };

        map gate(GATE) {
            // chests=vanilla
            // sniff=vanilla

            enum entrance {
                north = entrance(0x2c, 0x09, SOUTH),
                east = entrance(0x67, 0x71, WEST),
            }

            enum soundtrack {
                default = soundtrack(ALTUS.MUSIC, 0xff)
            }

            enum stepon_trigger {
                east_north = @install() {
                    map_transition(castle_center, south_2, NORTH);
                },
                exit_east = @install() {
                    map_transition(chessboard, west, EAST);
                },
            }

            enum b_trigger {
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=0");
                    _loot(0x13, ASH, 0d01, 0d01);
                },
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x12, ASH, 0d01, 0d01);
                },
                sniff__1_ethanol_1 = @install() {
                    debug_subtext("B=2");
                    _loot(0x11, ETHANOL, 0d01, 0d01);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=3");
                    _loot(0x10, ROOTS, 0d01, 0d01);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=4");
                    _loot(0x0f, ROOTS, 0d01, 0d01);
                },
                sniff__1_water_1 = @install() {
                    debug_subtext("B=5");
                    _loot(0x0e, WATER, 0d01, 0d01);
                },
                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=6");
                    _loot(0x0d, BRIMSTONE, 0d01, 0d01);
                },
                sniff__1_feather_1 = @install() {
                    debug_subtext("B=7");
                    _loot(0x0c, FEATHER, 0d01, 0d01);
                },
                sniff__1_feather_1 = @install() {
                    debug_subtext("B=8");
                    _loot(0x0b, FEATHER, 0d01, 0d01);
                },
                sniff__1_mushroom_1 = @install() {
                    debug_subtext("B=9");
                    _loot(0x0a, MUSHROOM, 0d01, 0d01);
                },

                sniff__1_mushroom_1 = @install() {
                    debug_subtext("B=10");
                    _loot(0x09, MUSHROOM, 0d01, 0d01);
                },
                sniff__1_mushroom_1 = @install() {
                    debug_subtext("B=11");
                    _loot(0x08, MUSHROOM, 0d01, 0d01);
                },
                sniff__1_acorns_1 = @install() {
                    debug_subtext("B=12");
                    _loot(0x07, ACORNS, 0d01, 0d01);
                },
                sniff__1_acorns_1 = @install() {
                    debug_subtext("B=13");
                    _loot(0x06, ACORNS, 0d01, 0d01);
                },
                sniff__1_iron_1 = @install() {
                    debug_subtext("B=14");
                    _loot(0x05, IRON, 0d01, 0d01);
                },
                sniff__1_iron_1 = @install() {
                    debug_subtext("B=15");
                    _loot(0x04, IRON, 0d01, 0d01);
                },
                gourd_x__aura_formula = @install() {
                    debug_subtext("B=16");
                    // aura formula
                    _loot_chest(0x02, ASH, 0d05); // TODO
                },
                gourd_x__1_anihilation_amulet = @install() {
                    debug_subtext("B=17");
                    _loot_chest(0x01, ANNIHILATION_AMULET, 0d01);
                },
                gourd_x__5_ash = @install() {
                    debug_subtext("B=18");
                    _loot_chest(0x02, ASH, 0d05);
                },
                gourd_x__1_atlas_medallion = @install() {
                    debug_subtext("B=19");
                    _loot_chest(0x03, ATLAS_MEDALLION, 0d01);
                },
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // north
                    add_enemy(DRAKE, 0d58, 0d28);

                    add_enemy(SLIME, 0d36, 0d27);

                    // center
                    add_enemy(DRAKE, 0d59, 0d71);

                    add_enemy(SLIME, 0d40, 0d63);

                    // south
                    add_enemy(SLIME, 0d79, 0d116);
                }

                default_init_room(True, True);
            }
        };

        area castle() {
            enum CASTLE {
                MUSIC = MUSIC.EBON_KEEP,
            }

            map castle_center(NOBILIA_NORTH) {
                // sniff=vanilla

                enum entrance {
                    north = entrance(0x40, 0x04, SOUTH),
                    south_1 = entrance(0x72, 0x38, NORTH),
                    south_2 = entrance(0x4c, 0x38, NORTH),
                    south_3 = entrance(0x08, 0x38, NORTH),

                    guard = entrance(0d63, 0d15, NONE, {
                        face(BOY, NORTH);
                        animate(BOY, ONCE, ANIMATION_ALL.KNOCKBACK);

                        subtext("[SLOW]Back on the streets with you!");
                    }),
                }

                enum soundtrack {
                    default = soundtrack(CASTLE.MUSIC, 0xff)
                }

                enum ROOM {
                    BEE_COLLECTED = memory(FLAG, SRAM),
                    BEE_TRIGGERED = memory(FLAG, TEMP),
                }

                enum stepon_trigger {
                    exit_north = @install() {
                        map_transition(castle_throne_room, south, NORTH);
                    },
                    exit_south_3 = @install() {
                        map_transition(market_west, north, SOUTH);
                    },
                    exit_south_2 = @install() {
                        map_transition(gate, north, SOUTH);
                    },
                    exit_south_1 = @install() {
                        map_transition(castle_bridges, west, SOUTH);
                    },
                    guard_right = @install() {
                        debug_subtext("S=4");
                    },
                    guard_left = @install() {
                        debug_subtext("S=5");
                    },
                }

                enum b_trigger {
                    chicken_1 = @install() {
                        debug_subtext("B=0");
                    },
                    chicken_2 = @install() {
                        debug_subtext("B=1");
                    },
                    chicken_3 = @install() {
                        debug_subtext("B=2");
                    },
                    farmer = @install() {
                        debug_subtext("B=3");
                    },
                    guard = @install() {
                        debug_subtext("B=4");

                        if(MEMORY.TICKET_FOR_EXHIBITION < 0d1) {
                            dialog("[SLOW]Bring me a ticket from the market first and you can try your luck in the arena.[B]");
                        } else {
                            question("[SLOW]Enter a ticket[CHOICE]Yes.[CHOICE]No.");

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                MEMORY.TICKET_FOR_EXHIBITION--;

                                map_transition(duel_arena_waiting_room, fall, NONE);
                            }
                        }
                    },
                    b_trigger_5 = @install() {
                        debug_subtext("B=5");
                        _loot(0x01, WATER, 0d01, 0d01);
                    },
                    b_trigger_6 = @install() {
                        debug_subtext("B=6");
                        _loot(0x02, WATER, 0d01, 0d02);
                    },
                    b_trigger_7 = @install() {
                        debug_subtext("B=7");
                        _loot(0x03, WATER, 0d01, 0d00);
                    },
                    b_trigger_8 = @install() {
                        debug_subtext("B=8");
                        _loot(0x04, OIL, 0d01, 0d02);
                    },
                    b_trigger_9 = @install() {
                        debug_subtext("B=9");
                        _loot(0x05, OIL, 0d01, 0d01);
                    },

                    b_trigger_10 = @install() {
                        debug_subtext("B=10");
                        _loot(0x06, CRYSTAL, 0d01, 0d02);
                    },
                    b_trigger_11 = @install() {
                        debug_subtext("B=11");
                        _loot(0x07, CRYSTAL, 0d01, 0d03);
                    },
                    b_trigger_12 = @install() {
                        debug_subtext("B=12");
                        _loot(0x08, CLAY, 0d01, 0d01);
                    },
                    b_trigger_13 = @install() {
                        debug_subtext("B=13");
                        _loot(0x09, CLAY, 0d01, 0d02);
                    },
                    b_trigger_14 = @install() {
                        debug_subtext("B=14");
                        _loot(0x0a, CLAY, 0d01, 0d00);
                    },
                    b_trigger_15 = @install() {
                        debug_subtext("B=15");
                        _loot(0x0b, VINEGAR, 0d01, 0d01);
                    },
                    b_trigger_16 = @install() {
                        debug_subtext("B=16");
                        _loot(0x0c, VINEGAR, 0d01, 0d00);
                    },
                    b_trigger_17 = @install() {
                        debug_subtext("B=17");
                        _loot(0x0d, VINEGAR, 0d01, 0d03); // same as B=18
                    },
                    b_trigger_18 = @install() {
                        debug_subtext("B=18");
                        _loot(0x0d, VINEGAR, 0d01, 0d03);// same as B=17
                    },
                    b_trigger_19 = @install() {
                        debug_subtext("B=19");
                        _loot(0x0e, ATLAS_MEDALLION, 0d01, 0d00);
                    },
                }

                @install()
                fun stone_lifted() {
                    if!(ROOM.BEE_TRIGGERED) {
                        ROOM.BEE_TRIGGERED = True;

                        if!(ROOM.BEE_COLLECTED) {
                            add_bee(0d86, 0d20, reference(@install() {
                                bee_collected(ROOM.BEE_COLLECTED);
                            }));
                        }
                    }
                }

                fun trigger_enter() {
                    add_levitate_stone(0d86, 0d20, reference(@install() {
                        guard_levitate_stone(0d1);

                        stone_lifted();
                    }));
                    special_script(LEVITATE, reference(stone_lifted));

                    default_init_room(False, False);

                    place_statue(VIGOR, 0d64, 0d32);
                }
            };

            map market_west(IVOR_MARKET) {
                enum entrance {
                    north = entrance(0x2a, 0x01, SOUTH),
                    east = entrance(0x39, 0xc3, WEST),
                }

                enum soundtrack {
                    default = soundtrack(CASTLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_north = @install() {
                        map_transition(castle_center, south_3, NORTH);
                    },
                    exit_east = @install() {
                        map_transition(castle_fire_pit, west, EAST);
                    },
                }

                fun trigger_enter() {
                    if(time[0d0] < MARKET.START) {
                        if(MARKET.DEBUG) {
                            debug_subtext("market not empty");
                        }

                        add_enemy(VILLAGER_3_6, 0d9, 0d31, INACTIVE);
                        face(LAST_ENTITY, EAST);
                        attach_script(LAST_ENTITY, B, reference(@install() {
                            guard_market_break(True);

                            question("[SLOW]Do you want to trade for iron?[CHOICE]5 Limestone…[CHOICE]5 Vinegar…[CHOICE]3 Bones…", 0d5);

                            if(MEMORY.QUESTION_ANSWER == 0d0) { // limestone
                                trade_items(IRON, 0d1, LIMESTONE, 0d5);
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) { // vinegar
                                trade_items(IRON, 0d1, VINEGAR, 0d5);
                            } else if(MEMORY.QUESTION_ANSWER == 0d2) { // bone
                                trade_items(IRON, 0d1, BONE, 0d3);
                            }

                            control(BOTH);
                        }));

                        add_enemy(VILLAGER_3_5, 0d9, 0d58, INACTIVE);
                        face(LAST_ENTITY, EAST);
                        attach_script(LAST_ENTITY, B, reference(@install() {
                            guard_market_break(True);

                            question("[SLOW]Do you want to trade for mushrooms?[CHOICE]1 Water…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) { // water
                                dialog("[SLOW]Sorry, I'm all out for today…[B]");
                            }

                            control(BOTH);
                        }));

                        add_enemy(VILLAGER_2_1, 0d9, 0d116, INACTIVE);
                        face(LAST_ENTITY, EAST);
                        attach_script(LAST_ENTITY, B, reference(@install() {
                            guard_market_break(True);

                            question("[SLOW]TICKETS… TICKETS…[CHOICE]100 Souls…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) { // Souls
                                trade_items(TICKET_FOR_EXHIBITION, 0d1, MONEY, 0d100);
                            }

                            control(BOTH);
                        }));
                    } else {
                        if(MARKET.DEBUG) {
                            debug_subtext("market empty");
                        }
                    }

                    init_map(0x0, 0x0, 0x3a, 0xcc);
                    default_init_room(False, False);
                }
            };

            map castle_throne_room(PALACE) {
                enum entrance {
                    south = entrance(0x31, 0x21, NORTH),

                    cinematic_enter = entrance(0x37, 0x01, NORTH),
                }

                enum soundtrack {
                    default = soundtrack(CASTLE.MUSIC, 0xff)
                }

                enum ROOM {
                    FAKE_EXIT_ID = memory(WORD, TEMP),

                    KING = memory(WORD, TEMP),
                    FACE = memory(WORD, TEMP),

                    IRON_THRONE_COUNT = memory(BYTE, SRAM),
                    IRON_THRONE_THRESHOLD = 0d4,

                    CLAIMED_SWORD_2 = memory(FLAG, SRAM),
                    CLAIMED_SWORD_3 = memory(FLAG, SRAM),
                    CLAIMED_SWORD_4 = memory(FLAG, SRAM),

                    CLAIMED_AXE_1 = memory(FLAG, SRAM),
                    CLAIMED_AXE_2 = memory(FLAG, SRAM),
                    CLAIMED_AXE_3 = memory(FLAG, SRAM),
                    CLAIMED_AXE_4 = memory(FLAG, SRAM),

                    CLAIMED_SPEAR_1 = memory(FLAG, SRAM),
                    CLAIMED_SPEAR_2 = memory(FLAG, SRAM),
                    CLAIMED_SPEAR_3 = memory(FLAG, SRAM),
                    CLAIMED_SPEAR_4 = memory(FLAG, SRAM),

                    CLAIMED_BAZOOKA = memory(FLAG, SRAM),
                }

                fun fake_exit() {
                    map_transition(castle_center, north, SOUTH);
                }

                @install()
                @async()
                fun fake_exit_scanner() {
                    attach_to_script(ROOM.FAKE_EXIT_ID);

                    while(True) {
                        arg[0x00] = <ACTIVE>[X];
                        arg[0x02] = <ACTIVE>[Y];
                        arg[0x04] = <SCRIPT_OWNER>[X];
                        arg[0x06] = <SCRIPT_OWNER>[Y];

                        if(arg[0x00] < arg[0x04]) {
                            arg[0x08] = arg[0x04] - arg[0x00];
                        } else {
                            arg[0x08] = arg[0x00] - arg[0x04];
                        }

                        if(arg[0x02] < arg[0x06]) {
                            arg[0x0a] = arg[0x06] - arg[0x02];
                        } else {
                            arg[0x0a] = arg[0x02] - arg[0x06];
                        }

                        if((arg[0x08] <= 0x20) && (arg[0x0a] <= 0x20)) {
                            fake_exit();
                            end();
                        }

                        yield();
                    }
                }

                @install()
                fun debug_triggered() {
                    set(FLAG.REVEALER);
                    subtext("Revealer learned.");
                    sleep(0x20);
                    select_alchemy(REVEALER);

                    destroy(SCRIPT_OWNER);
                }
                
                @install()
                @async()
                fun face_logic(entity) {
                    attach_to_script(entity);

                    while(alive(<SCRIPT_OWNER>)) {
                        object[0x00] = arg[0x10];
                        arg[0x10]++;
                        debug_memory(arg[0x10], 0d0);

                        sound(0x76);
                        sleep(0d180);
                    }
                }
                fun add_face(x, y) {
                    add_enemy(FACE_ENTITY, x, y);
                    ROOM.FACE = <LAST_ENTITY>;

                    face_logic(<LAST_ENTITY>);
                }

                fun check_iron_throne_reward() {
                    if(ROOM.IRON_THRONE_COUNT >= ROOM.IRON_THRONE_THRESHOLD) {
                        _dialog("[SLOW]Your contribution to the iron throne will be honored.[B]");

                        reward(REVEALER);
                        
                        control(BOTH);
                        end();
                    }
                }

                @install()
                fun update_removed_weapons() {
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SWORD_2) && !FLAG.SWORD_2) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SWORD_3) && !FLAG.SWORD_3) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SWORD_4) && !FLAG.SWORD_4) {
                        unlock(SWORD_1);
                    }

                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.AXE_1) && !FLAG.AXE_1) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.AXE_2) && !FLAG.AXE_2) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.AXE_3) && !FLAG.AXE_3) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.AXE_4) && !FLAG.AXE_4) {
                        unlock(SWORD_1);
                    }

                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SPEAR_1) && !FLAG.SPEAR_1) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SPEAR_2) && !FLAG.SPEAR_2) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SPEAR_3) && !FLAG.SPEAR_3) {
                        unlock(SWORD_1);
                    }
                    if((MEMORY.CURRENT_WEAPON == WEAPON_INDEX.SPEAR_4) && !FLAG.SPEAR_4) {
                        unlock(SWORD_1);
                    }
                }

                fun forfeit_weapon(claimed, weapon:FLAG) {
                    if((!claimed) && weapon) {
                        claimed = True;
                        weapon = False;

                        sound(PURCHASE);

                        ROOM.IRON_THRONE_COUNT++;
                        update_removed_weapons();
                    }
                }

                fun iron_throne_trade_sword() {
                    while(MEMORY.QUESTION_ANSWER != 0xffff) {
                        if(False) {
                            text_start();
                        } else {
                            control(NONE);
                            open_message_box(DEFAULT, 0x0a, 0x02, 0x14, 0d20);
                        }

                        if((!ROOM.CLAIMED_SWORD_2) && FLAG.SWORD_2) {
                            text("[CHOICE]Gladiator Sword…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_SWORD_3) && FLAG.SWORD_3) {
                            text("[CHOICE]Crusader Sword…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_SWORD_4) && FLAG.SWORD_4) {
                            text("[CHOICE]Neutron Blade…");
                        } else {
                            text("[CHOICE]…");
                        }

                        await_answer();
                        text_end();

                        if(MEMORY.QUESTION_ANSWER != 0xffff) {
                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                forfeit_weapon(ROOM.CLAIMED_SWORD_2, SWORD_2);
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                                forfeit_weapon(ROOM.CLAIMED_SWORD_3, SWORD_3);
                            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                                forfeit_weapon(ROOM.CLAIMED_SWORD_4, SWORD_4);
                            }

                            check_iron_throne_reward();
                        }
                    }
                }
                fun iron_throne_trade_axe() {
                    while(MEMORY.QUESTION_ANSWER != 0xffff) {
                        if(False) {
                            text_start();
                        } else {
                            control(NONE);
                            open_message_box(DEFAULT, 0x0a, 0x02, 0x14, 0d20);
                        }

                        if((!ROOM.CLAIMED_AXE_1) && FLAG.AXE_1) {
                            text("[CHOICE]Spider's Claw…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_AXE_2) && FLAG.AXE_2) {
                            text("[CHOICE]Bronze Axe…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_AXE_3) && FLAG.AXE_3) {
                            text("[CHOICE]Knight Basher…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_AXE_4) && FLAG.AXE_4) {
                            text("[CHOICE]Atom Smasher…");
                        } else {
                            text("[CHOICE]…");
                        }

                        await_answer();
                        text_end();

                        if(MEMORY.QUESTION_ANSWER != 0xffff) {
                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                forfeit_weapon(ROOM.CLAIMED_AXE_1, AXE_1);
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                                forfeit_weapon(ROOM.CLAIMED_AXE_2, AXE_2);
                            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                                forfeit_weapon(ROOM.CLAIMED_AXE_3, AXE_3);
                            } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                                forfeit_weapon(ROOM.CLAIMED_AXE_4, AXE_4);
                            }

                            check_iron_throne_reward();
                        }
                    }
                }
                fun iron_throne_trade_spear() {
                    while(MEMORY.QUESTION_ANSWER != 0xffff) {
                        if(False) {
                            text_start();
                        } else {
                            control(NONE);
                            open_message_box(DEFAULT, 0x0a, 0x02, 0x14, 0d20);
                        }

                        if((!ROOM.CLAIMED_SPEAR_1) && FLAG.SPEAR_1) {
                            text("[CHOICE]Horn Spear…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_SPEAR_2) && FLAG.SPEAR_2) {
                            text("[CHOICE]Bronze Spear…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_SPEAR_3) && FLAG.SPEAR_3) {
                            text("[CHOICE]Lance…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if((!ROOM.CLAIMED_SPEAR_4) && FLAG.SPEAR_4) {
                            text("[CHOICE]Laser Lance…");
                        } else {
                            text("[CHOICE]…");
                        }

                        await_answer();
                        text_end();

                        if(MEMORY.QUESTION_ANSWER != 0xffff) {
                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                forfeit_weapon(ROOM.CLAIMED_SPEAR_1, SPEAR_1);
                            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                                forfeit_weapon(ROOM.CLAIMED_SPEAR_2, SPEAR_2);
                            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                                forfeit_weapon(ROOM.CLAIMED_SPEAR_3, SPEAR_3);
                            } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                                forfeit_weapon(ROOM.CLAIMED_SPEAR_4, SPEAR_4);
                            }

                            check_iron_throne_reward();
                        }
                    }
                }
                // @install()
                fun iron_throne_trade() {
                    dialog("[SLOW]Forfeit 4 of your weapons weapons and I'll grant you a formula.[B]");

                    // MEMORY.QUESTION_ANSWER = 0xffff;
                    // while(MEMORY.QUESTION_ANSWER == 0xffff) {
                        if(False) {
                            text_start();
                        } else {
                            control(NONE);
                            open_message_box(DEFAULT, 0x0a, 0x02, 0x14, 0d20);
                        }

                        // text("[SLOW]What weapon do you want to turn in?");

                        if(FLAG.SWORD_2 || FLAG.SWORD_3 || FLAG.SWORD_4) {
                            text("[CHOICE]Sword…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if(FLAG.AXE_1 || FLAG.AXE_2 || FLAG.AXE_3 || FLAG.AXE_4) {
                            text("[CHOICE]Axe…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if(FLAG.SPEAR_1 || FLAG.SPEAR_2 || FLAG.SPEAR_3 || FLAG.SPEAR_4) {
                            text("[CHOICE]Spear…");
                        } else {
                            text("[CHOICE]…");
                        }
                        if(FLAG.BAZOOKA) {
                            text("[CHOICE]Bazooka…");
                        } else {
                            text("[CHOICE]…");
                        }
                        
                        await_answer();
                        
                        text_end();

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            if(FLAG.SWORD_2 || FLAG.SWORD_3 || FLAG.SWORD_4) {
                                iron_throne_trade_sword();
                            }
                        } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                            if(FLAG.AXE_1 || FLAG.AXE_2 || FLAG.AXE_3 || FLAG.AXE_4) {
                                iron_throne_trade_axe();
                            }
                        } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                            if(FLAG.SPEAR_1 || FLAG.SPEAR_2 || FLAG.SPEAR_3 || FLAG.SPEAR_4) {
                                iron_throne_trade_spear();
                            }
                        } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                            forfeit_weapon(ROOM.CLAIMED_BAZOOKA, BAZOOKA);

                            check_iron_throne_reward();
                        }
                    // }
                }

                @install()
                fun king_triggered() {
                    if(ROOM.IRON_THRONE_COUNT < ROOM.IRON_THRONE_THRESHOLD) {
                        iron_throne_trade();
                    } else {
                        debug_subtext("TODO");
                    }

                    control(BOTH);
                }

                fun add_king(x, y) {
                    add_enemy(BOY_BLACK, x, y, INVINCIBLE);
                    ROOM.KING = <LAST_ENTITY>;
                    attach_script(LAST_ENTITY, B, reference(king_triggered));

                    animate(LAST_ENTITY, FREEZE, ANIMATION_BOY.SWIRL_EXIT);

                    if(False) {
                        sleep(0d300);

                        while(True) {
                            teleport(ROOM.KING, 0d49, 0d17);
                            animate(ROOM.KING, FREEZE, ANIMATION_BOY.SWIRL_EXIT);
                            sleep(0d300);

                            teleport(ROOM.KING, 0d49, 0d16);
                            animate(ROOM.KING, FREEZE, ANIMATION_BOY.DRAGGED);
                            sleep(0d300);
                        }
                    }
                }

                fun trigger_enter() {
                    if(FLAG.DEBUG) {
                        if!(FLAG.REVEALER) {
                            add_debug_entity(0x27, 0x15, reference(debug_triggered));
                        }
                    }

                    if(False) {
                        add_face(0d61, 0d03);
                    }

                    add_king(0d49, 0d17);

                    default_init_room(False, False);

                    add_enemy(PLACEHOLDER, 0x31, 0x21);
                    ROOM.FAKE_EXIT_ID = <LAST_ENTITY>;
                    sleep(0x10);
                    fake_exit_scanner();
                }
            };

            map castle_fire_pit(FIREPIT_NOBILIA) {
                enum entrance {
                    west = entrance(0x05, 0x1b, EAST),

                    cutscene_landing = entrance(0x0b, 0x1b, NONE),
                    
                    bonfire = entrance(0d45, 0d17, NONE, { bonfire_wakeup(-0d40, 0d8, -0d32, 0d32); }),
                }

                enum soundtrack {
                    default = soundtrack(CASTLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    b_trigger_0 = @install() {
                        debug_subtext("S=0");
                    },
                    exit_west = @install() {
                        map_transition(market_west, east, WEST);
                    },
                }

                enum ROOM {
                    DEBUG = False,

                    PIT_IGNITED = memory(FLAG, SRAM),
                    FIRE_ORB_TRIGGER_COUNTER = memory(WORD, TEMP),
                }

                fun ignite_pit() {
                    object[0x00] = 0x01; // ignite firepit

                    bonfire(0d45, 0d17, SOULS_MEMORY.BONFIRE_CASTLE_PIT);
                    attribute(LAST_ENTITY, INVISIBLE, True);
                    <LAST_ENTITY>[Z_LEVEL] = <BOY>[Z_LEVEL];
                }

                @install()
                fun firepit_damage() {
                    check_damage_type(FIRE, ROOM.FIRE_ORB_TRIGGER_COUNTER);

                    if(ROOM.FIRE_ORB_TRIGGER_COUNTER) {
                        ROOM.FIRE_ORB_TRIGGER_COUNTER = 0x00;
                        set(ROOM.PIT_IGNITED);
                        destroy(SCRIPT_OWNER);

                        set(SOULS_MEMORY.BONFIRE_CASTLE_PIT);
                        ignite_pit();
                    } else {
                        heal(SCRIPT_OWNER, 0x00, False);
                        // damage(SCRIPT_OWNER, 0x00, True);
                    }

                    // reset_alchemy_types();
                }

                fun trigger_enter() {
                    // object[0x00] = 0x01; // ignite fire
                    // object[0x01] = 0x02; // show windwalker_collision

                    if((!ROOM.PIT_IGNITED) && (!SOULS_MEMORY.BONFIRE_CASTLE_PIT)) {
                        add_enemy(FACE_ENTITY, 0d45, 0d17);
                        attribute(LAST_ENTITY, INVISIBLE, True);
                        attach_script(LAST_ENTITY, DAMAGE, reference(firepit_damage));

                        reset_alchemy_types();
                    } else {
                        ignite_pit();
                    }

                    default_init_room(False, False);
                }
            };

            map castle_bridges(IVOR_BRIDGE) {
                enum entrance {
                    east = entrance(0x8b, 0x28, WEST),
                    west = entrance(0x01, 0x29, EAST),

                    door_east = entrance(0x5f, 0x28, EAST),
                    door_west = entrance(0x2d, 0x29, WEST),

                    balcony_east_1 = entrance(0x4f, 0x0f, EAST),
                    balcony_east_2 = entrance(0x4f, 0x19, EAST),
                    balcony_east_3 = entrance(0x4f, 0x23, EAST),

                    balcony_west_1 = entrance(0x3f, 0x23, WEST),
                    balcony_west_2 = entrance(0x3f, 0x19, WEST),
                    balcony_west_3 = entrance(0x3f, 0x0f, WEST),
                }

                enum soundtrack {
                    default = soundtrack(CASTLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_door_east = @install() {
                        debug_subtext("S=0");
                    },
                    exit_door_west = @install() {
                        map_transition(castle_balconies, stairs_west, EAST);
                    },
                    exit_east = @install() {
                        debug_subtext("S=2");
                    },
                    balcony_east_3 = @install() {
                        debug_subtext("S=3");
                    },
                    balcony_east_2 = @install() {
                        debug_subtext("S=4");
                    },
                    balcony_east_1 = @install() {
                        debug_subtext("S=5");
                    },
                    exit_west = @install() {
                        map_transition(castle_center, south_1, WEST);
                    },
                    balcony_west_1 = @install() {
                        map_transition(castle_balconies, balcony_west_1, EAST);
                    },
                    balcony_west_2 = @install() {
                        map_transition(castle_balconies, balcony_west_2, EAST);
                    },
                    balcony_west_3 = @install() {
                        map_transition(castle_balconies, balcony_west_3, EAST);
                    },
                }

                fun trigger_enter() {
                    init_map(0x00, 0x00, 0x3c, 0x74);
                    
                    default_init_room(False, False);
                }
            };

            map castle_balconies(IVOR_ROOMS_2) {
                enum entrance {
                    balcony_east_1 = entrance(0x75, 0x1a, WEST),
                    balcony_east_2 = entrance(0x75, 0x3c, WEST),
                    balcony_east_3 = entrance(0x75, 0x5e, WEST),

                    balcony_west_1 = entrance(0x05, 0x5e, EAST),
                    balcony_west_2 = entrance(0x05, 0x3c, EAST),
                    balcony_west_3 = entrance(0x05, 0x1a, EAST),

                    stairs_east = entrance(0x45, 0x39, EAST),
                    stairs_west = entrance(0x35, 0x39, WEST),

                    vent_east_1 = entrance(0x67, 0x23, NONE),
                    vent_east_2 = entrance(0x67, 0x67, NONE),

                    vent_west_1 = entrance(0x13, 0x67, NONE),
                    vent_west_2 = entrance(0x13, 0x45, NONE),
                    vent_west_3 = entrance(0x13, 0x23, NONE),
                }

                enum soundtrack {
                    default = soundtrack(CASTLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    door_3 = @install() {
                        debug_subtext("S=0");

                        error_message(DOOR_LOCKED); // TODO: should be EAST/WEST
                    },
                    door_2 = @install() {
                        debug_subtext("S=1");
                    },
                    door_1 = @install() {
                        debug_subtext("S=2");

                        error_message(DOOR_LOCKED); // TODO: should be EAST/WEST
                    },
                    door_east_3 = nop(),
                    door_east_2 = nop(),
                    door_east_1 = nop(),
                    vent_2 = @install() {
                        debug_subtext("S=6");
                    },
                    vent_1 = @install() {
                        debug_subtext("S=7");
                    },
                    vent_1 = @install() {
                        debug_subtext("S=8");
                    },
                    vent_2 = @install() {
                        debug_subtext("S=9");
                    },

                    vent_3 = @install() {
                        debug_subtext("S=10");
                    },
                    stairs_east = nop(),
                    stairs = @install() {
                        debug_subtext("S=12");

                        map_transition(castle_bridges, door_west, EAST);
                    },
                    balcony_east_3 = nop(),
                    balcony_east_2 = nop(),
                    balcony_east_1 = nop(),
                    balcony_1 = @install() {
                        debug_subtext("S=16");

                        map_transition(castle_bridges, balcony_west_1, WEST);
                    },
                    balcony_2 = @install() {
                        debug_subtext("S=17");

                        map_transition(castle_bridges, balcony_west_2, WEST);
                    },
                    balcony_3 = @install() {
                        debug_subtext("S=18");

                        map_transition(castle_bridges, balcony_west_3, WEST);
                    },
                }

                enum b_trigger {
                    sniff__1_water_1 = nop(), // east room 3
                    sniff__1_water_1 = @install() { // west room 1
                        debug_subtext("B=1");
                        _loot(0x20, WATER, 0d01, 0d01);
                    },
                    sniff__1_acorns_1 = nop(), // east room 2 (south)
                    sniff__1_acorns_1 = @install() { // west room 2
                        debug_subtext("B=3");
                        _loot(0x1d, ACORNS, 0d01, 0d01);
                    },
                    sniff__1_acorns_1 = @install() { // west room 3
                        debug_subtext("B=4");
                        _loot(0x1c, ACORNS, 0d01, 0d01);
                    },
                    sniff__1_feather_1 = @install() { // west halls (south)
                        debug_subtext("B=5");
                        _loot(0x1b, FEATHER, 0d01, 0d01);
                    },
                    sniff__1_feather_1 = nop(), // east room 2 (north)
                    sniff__1_feather_1 = @install() { // west halls (north)
                        debug_subtext("B=7");
                        _loot(0x19, FEATHER, 0d01, 0d01);
                    },
                    sniff__1_ethanol_1 = nop(), // east room 1 (north)
                    sniff__1_ethanol_1 = @install() { // west room 3 (north)
                        debug_subtext("B=9");
                        _loot(0x17, ETHANOL, 0d01, 0d01);
                    },

                    sniff__1_ash_1 = nop(),// east halls (south, window)
                    sniff__1_ash_1 = @install() { // west halls (south)
                        debug_subtext("B=11");
                        _loot(0x15, ASH, 0d01, 0d01);
                    },
                    sniff__1_iron_1 = nop(), // east room 1
                    sniff__1_iron_1 = @install() { // west room 3
                        debug_subtext("B=13");
                        _loot(0x13, IRON, 0d01, 0d01);
                    },
                    chest_east_3__1_roots = nop(), // east room 3
                    chest_west_1__1_wax = @install() { // west room 1
                        debug_subtext("B=15");
                        _loot_chest(0x07, MUD_PEPPER, 0d01);
                    },
                    chest_x__1_water = @install() { // ???
                        debug_subtext("B=16");
                        _loot_chest(0x20, WATER, 0d01); // same as B=17
                    },
                    chest_x__1_water = @install() { // ???
                        debug_subtext("B=17");
                        _loot(0x20, WATER, 0d01, 0d00); // same as B=16
                    },
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x00, 0x38, 0x74);
                    } else if(index == 0d1) {
                        init_map(0x42, 0x00, 0x78, 0x74);
                    }
                }

                fun trigger_enter() {
                    // object[0x00] = 0x7e; // door_west_1
                    object[0x01] = 0x7e; // door_west_2
                    // object[0x02] = 0x7e; // door_west_3
                    // object[0x03] = 0x7e; // door_east_3
                    // object[0x04] = 0x7e; // door_east_2
                    // object[0x05] = 0x7e; // door_east_1

                    init_room(0d0);
                    default_init_room(False, False);
                }
            };

            group duel_arena() {
                enum AREA_DUEL_ARENA {
                    DEFAULT_MUSIC = MUSIC.BOSS_ARENA,
                }

                map duel_arena_waiting_room(ARENA_ROOM) {
                    enum entrance {
                        north = entrance(0x14, 0x13, SOUTH),
                        
                        fall = entrance(0d19, 0d30, NONE, { crash_both(); }),
                    }

                    enum soundtrack {
                        default = soundtrack(AREA_DUEL_ARENA.DEFAULT_MUSIC, 0xff)
                    }

                    enum stepon_trigger {
                        exit_north = @install() {
                            debug_subtext("S=0");

                            map_transition(duel_arena, south, NORTH);
                        },
                    }

                    enum b_trigger {
                        gourd_west = @install() {
                            debug_subtext("B=0");
                            _loot_chest(0x01, CHEST_2_1, 0x01);
                            // _loot_chest(0x01, CHEST_2_2, 0x01);
                            // _loot_chest(0x01, CHEST_2_3, 0x01);
                        },
                        secret_passage = @install() { // empty
                            debug_subtext("B=1");
                        },
                        gourd_east = @install() {
                            debug_subtext("B=2");
                            _loot_chest(0x02, PETAL, 0x01);
                        },
                        gourd_hidden_1_1 = @install() {
                            debug_subtext("B=3");
                            _loot_chest(0x03, WAX, 0x01);
                        },
                        gourd_hidden_1_2 = @install() {
                            debug_subtext("B=4");
                            _loot_chest(0x04, CALL_BEADS, 0x01);
                        },
                        gourd_hidden_1_3 = @install() {
                            debug_subtext("B=5");
                            _loot_chest(0x05, GLOVE_2_1, 0x01);
                            // _loot_chest(0x02, GLOVE_2_2, 0x01);
                            // _loot_chest(0x02, GLOVE_2_3, 0x01);
                        },
                        gourd_hidden_2_1 = @install() {
                            debug_subtext("B=6");
                            _loot_chest(0x06, WAX, 0x01);
                        },
                        gourd_hidden_2_2 = @install() {
                            debug_subtext("B=7");
                            _loot_chest(0x07, CALL_BEADS, 0x01);
                        },
                        gourd_hidden_2_3 = @install() {
                            debug_subtext("B=8");
                            _loot_chest(0x08, HELM_2_1, 0x01);
                            // _loot_chest(0x02, HELM_2_2, 0x01);
                            // _loot_chest(0x02, HELM_2_3, 0x01);
                        },
                    }

                    fun trigger_enter() {
                        object[0x00] = 0x04; // open door

                        // object[0x01] = 0x01; // loot gourd_west
                        // object[0x02] = 0x01; // loot gourd_east

                        // object[0x03] = 0x01; // loot gourd_hidden_1_1
                        // object[0x04] = 0x01; // loot gourd_hidden_1_2
                        // object[0x05] = 0x01; // loot gourd_hidden_1_3

                        // object[0x06] = 0x01; // loot gourd_hidden_2_1
                        // object[0x07] = 0x01; // loot gourd_hidden_2_2
                        // object[0x08] = 0x01; // loot gourd_hidden_2_3

                        CUSTOM_FLAG.NO_DOG = True;

                        default_init_room(False, False);
                    }
                };

                map duel_arena(ARENA) {
                    enum entrance {
                        north_cinematic = entrance(0x20, 0x07, NONE),
                        south = entrance(0x22, 0x69, NORTH) // 0x22, 0x6a
                    }

                    enum soundtrack {
                        default = soundtrack(AREA_DUEL_ARENA.DEFAULT_MUSIC, 0xff)
                    }

                    enum ROOM {
                        enemy_1 = MOSQUITO,
                        enemy_2 = FLOWER_PURPLE,
                        enemy_3 = LIZARD,
                        enemy_4 = TUMBLING_WEED,

                        enemy_5 = MINITAUR,
                        enemy_6 = BOY_BLACK,
                        enemy_7 = STERLING,

                        LOCK = memory(FLAG, TEMP),

                        GUARD_LEFT = 0d8,
                        GUARD_RIGHT = 0d496,
                        GUARD_COOLDOWN = 0d180,

                        HIT_COUNT_KILL = 0d3,
                        HIT_COUNT = memory(WORD, TEMP),
                        KILL_COUNT = memory(BYTE, SRAM),

                        HIT_COUNT_BOY = memory(WORD, TEMP),

                        ID_ENEMY = memory(WORD, TEMP),
                    }

                    fun reset_camera() {
                        set_camera(TILE_CENTER, 0d32, 0d84, 0x20);
                        wait(CAMERA_PAN_Y);
                        wait(CAMERA_PAN_X);
                    }

                    @install()
                    @async()
                    fun side_guard_scanner() {
                        while(True) {
                            if(<BOY>[X] >= ROOM.GUARD_RIGHT) {
                                face(BOY, EAST);
                                animate(BOY, ONCE, ANIMATION_ALL.KNOCKBACK);

                                sleep(ROOM.GUARD_COOLDOWN);
                            } else if(<BOY>[X] <= ROOM.GUARD_LEFT) {
                                face(BOY, WEST);
                                animate(BOY, ONCE, ANIMATION_ALL.KNOCKBACK);

                                sleep(ROOM.GUARD_COOLDOWN);
                            }

                            yield();
                        }
                    }

                    @install()
                    @async()
                    fun lock_scanner() {
                        while(True) {
                            if(ROOM.LOCK != arg[0x10]) {
                                arg[0x10] = ROOM.LOCK;

                                if(arg[0x14] > 0d0) {
                                    arg[0x12] = randrange(0d3);
                                    if(arg[0x12] == 0d0) {
                                        arg[0x14] = 0d79;
                                    } else if(arg[0x12] == 0d1) {
                                        arg[0x14] = 0d84;
                                    } else {
                                        arg[0x14] = 0d89;
                                    }
                                } else {
                                    arg[0x14] = <BOY>[Y] >> 0d3;
                                }

                                while((arg[0x16] == arg[0x14]) || arg[0x16] == 0d0) {
                                    arg[0x12] = randrange(0d3);
                                    if(arg[0x12] == 0d0) {
                                        arg[0x16] = 0d79;
                                    } else if(arg[0x12] == 0d1) {
                                        arg[0x16] = 0d84;
                                    } else {
                                        arg[0x16] = 0d89;
                                    }
                                }

                                if(arg[0x10]) {
                                    attribute(ROOM.ID_ENEMY, INVINCIBLE_TEMP, True);
                                    attribute(BOY, INVINCIBLE_TEMP, True);

                                    teleport(ROOM.ID_ENEMY, 0d25, arg[0x16]);
                                    teleport(BOY, 0d38, arg[0x14]);

                                    if(True) {
                                        attribute(ROOM.ID_ENEMY, ROOT, True);
                                        attribute(BOY, ROOT, True);
                                    }

                                    while((ROOM.ID_ENEMY[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) || (<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION)) {
                                        teleport(ROOM.ID_ENEMY, 0d25, arg[0x16]);
                                        teleport(BOY, 0d38, arg[0x14]);

                                        yield();
                                    }

                                    if(True) {
                                        attribute(ROOM.ID_ENEMY, ROOT, False);
                                        attribute(BOY, ROOT, False);
                                    }

                                    animate(ROOM.ID_ENEMY, ONCE, ANIMATION_ALL.DEFAULT);
                                } else {
                                    attribute(ROOM.ID_ENEMY, INVINCIBLE_TEMP, False);
                                    attribute(BOY, INVINCIBLE_TEMP, False);

                                    free_camera();
                                }
                            }

                            if(arg[0x10]) {
                                if(False) {
                                    teleport(ROOM.ID_ENEMY, 0d25, arg[0x16]);
                                } else {
                                    if(ROOM.ID_ENEMY[X] > 0d200) {
                                        ROOM.ID_ENEMY[X] = 0d200;
                                    }
                                }

                                if(False) {
                                    teleport(BOY, 0d38, arg[0x14]);
                                } else {
                                    if(<BOY>[X] < 0d308) {
                                        <BOY>[X] = 0d308;
                                    }   
                                }
                            }

                            yield();
                        }
                    }

                    fun dialog_reward() {
                        control(NONE);

                        reward(SOULS_MEMORY.REWARD_ARENA_DUEL);
                        
                        dialog("[SLOW]…Um, you actually won…?[B]Well fought. Don't just gamble your reward away.[B]");

                        map_transition(castle_center, guard, NONE);
                    }
                    fun dialog_no_enemy() {
                        sleep(0d600);
                        control(NONE);
                        
                        dialog("[SLOW]There are no more enemies left for you.[B]");

                        map_transition(castle_center, guard, NONE);
                    }

                    fun stall() {
                        ROOM.LOCK = True;

                        reset_camera();
                        sleep(0d60);

                        ROOM.LOCK = False;
                    }

                    @install()
                    fun prepare_next_enemy() {
                        ROOM.HIT_COUNT = 0d0;
                        ROOM.HIT_COUNT_BOY = 0d0;

                        if(ROOM.ID_ENEMY[HP] > 0d0) {
                            destroy(ROOM.ID_ENEMY);
                        }

                        if(ROOM.KILL_COUNT == 0d0) {
                            add_enemy(ROOM.enemy_1, 0d32, 0d84);
                        } else if(ROOM.KILL_COUNT == 0d1) {
                            add_enemy(ROOM.enemy_2, 0d32, 0d84);
                        } else if(ROOM.KILL_COUNT == 0d2) {
                            add_enemy(ROOM.enemy_3, 0d32, 0d84);
                        } else if(ROOM.KILL_COUNT == 0d3) {
                            add_enemy(ROOM.enemy_4, 0d32, 0d84);
                        } else if(ROOM.KILL_COUNT == 0d4) {
                            add_enemy(ROOM.enemy_5, 0d32, 0d84);
                        } else if(ROOM.KILL_COUNT == 0d5) {
                            add_enemy(ROOM.enemy_6, 0d32, 0d84);
                        } else if(ROOM.KILL_COUNT == 0d6) {
                            add_enemy(ROOM.enemy_7, 0d32, 0d84);
                            attach_sterling_script(<LAST_ENTITY>, False, 0d30, 0d38, 0d60, 0d664, 0d999);
                        } else if(ROOM.KILL_COUNT == 0d7) {
                            ROOM.KILL_COUNT++;
                            dialog_reward();
                        } else {
                            dialog_no_enemy();
                        }

                        ROOM.ID_ENEMY = <LAST_ENTITY>;

                        attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(hit_enemy));
                        attach_script(BOY, DAMAGE_DEATH, reference(hit_boy));

                        teleport(ROOM.ID_ENEMY, 0d25, 0d84);
                        teleport(BOY, 0d38, 0d84);

                        face(ROOM.ID_ENEMY, EAST);
                        face(BOY, WEST);

                        stall();
                    }

                    @install()
                    fun reset() {
                        yield();
                        
                        attribute(ROOM.ID_ENEMY, INVINCIBLE_TEMP, True);
                        attribute(BOY, INVINCIBLE_TEMP, True);

                        if(False) {
                            heal(ROOM.ID_ENEMY, 0d0, False);
                            heal(BOY, 0d0, False);
                        }

                        teleport(ROOM.ID_ENEMY, 0d25, 0d84);
                        teleport(BOY, 0d38, 0d84);

                        face(ROOM.ID_ENEMY, EAST);
                        face(BOY, WEST);

                        stall();
                    }

                    fun hit() {
                        if((<BOY>[HP] <= 0d0) || (ROOM.ID_ENEMY[HP] <= 0d0)) {
                            subtext("TKO!");
                        } else {
                            MEMORY.STRING_PARAMETER_1 = ROOM.HIT_COUNT;
                            MEMORY.STRING_PARAMETER_2 = ROOM.HIT_COUNT_BOY;
                            subtext("[MEM1]:[MEM2]");
                        }
                    }

                    @install()
                    fun hit_boy() {
                        sound(ARENA_CHEER);

                        ROOM.HIT_COUNT_BOY++;

                        hit();
                        
                        if((<BOY>[HP] <= 0d0) || (ROOM.HIT_COUNT_BOY >= ROOM.HIT_COUNT_KILL)) {
                            attach_script(BOY, DAMAGE_DEATH, reference(boy_death));
                            damage(BOY, 0d999, True);
                        } else {
                            reset();
                        }
                    }
                    @install()
                    fun hit_enemy() {
                        sound(ARENA_CHEER);

                        if(ROOM.ID_ENEMY[DAMAGE_SOURCE] != CHARACTER_ADDRESS.BOY) {
                            heal(ROOM.ID_ENEMY, 0d999, True);
                            
                            damage(BOY, 0d5, True);
                            hit_boy();
                            
                            end();
                        }

                        ROOM.HIT_COUNT++;

                        hit();

                        if((ROOM.HIT_COUNT >= ROOM.HIT_COUNT_KILL) || (ROOM.ID_ENEMY[HP] <= 0d0)) {
                            ROOM.HIT_COUNT = 0d0;
                            ROOM.KILL_COUNT++;

                            prepare_next_enemy();
                        } else {
                            reset();
                        }
                    }

                    fun trigger_enter() {
                        init_map(0x00, 0x30, 0x40, 0x70);

                        CUSTOM_FLAG.NO_DOG = True;
                        CUSTOM_FLAG.NO_XP_MONEY = True;
                        default_init_room(False, False);

                        walk(BOY, TILE_ABSOLUTE, 0d38, 0d84, BOY, BOY);
                        lock_scanner();
                        side_guard_scanner();

                        if(False) {
                            ROOM.KILL_COUNT = 0d6;
                        }
                        prepare_next_enemy();
                    }
                };
            };
        };
    };
};

area northwest_inbetwixx() {
    map northwest_inbetwixx(RIVER) {
        // sniff=vanilla

        enum entrance {
            east = entrance(0x44, 0x44, WEST),
            west = entrance(0x01, 0x3d, EAST),
            cave = entrance(0x41, 0x0b, SOUTH)
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum ROOM {
            DEBUG = False,

            LIFT_ID = memory(WORD, TEMP),
            LIFT_POSITION = memory(BYTE, SRAM),
            CENTER_LINE = 0d272,

            SECRET_PASSAGE_TRIGGER = memory(WORD, TEMP),
            SECRET_PASSAGE_DISTANCE = 0x10,

            WALL = retained_object(0x00),
        }

        fun init_lift(position) {
            if(ROOM.LIFT_POSITION == 0d0) {
                ROOM.LIFT_POSITION = position;
            }

            if(ROOM.LIFT_POSITION == 0d1) {
                add_placeholder(LIFT_MOVING, 0d16, 0d15, ONCE_FREEZE);
            } else if(ROOM.LIFT_POSITION == 0d2) {
                add_placeholder(LIFT_MOVING, 0d33, 0d15, ONCE_FREEZE);
            } else if(ROOM.LIFT_POSITION == 0d3) {
                add_placeholder(LIFT_MOVING, 0d49, 0d15, ONCE_FREEZE);
            }

            ROOM.LIFT_ID = <LAST_ENTITY>;
        }

        @install()
        fun move_lift(lift_id, position, dry) {
            if(ROOM.LIFT_POSITION == position) {
                end();
            }

            if(position == 0d1) {
                arg[0x10] = 0d128;
            } else if(position == 0d2) {
                arg[0x10] = 0d264;
            } else if(position == 0d3) {
                arg[0x10] = 0d392;
            }

            if!(dry) {
                if((<BOY>[X] < ROOM.CENTER_LINE) ^ (<DOG>[X] < ROOM.CENTER_LINE)) {
                    arg[0x12] = True;
                }

                if(arg[0x12]) {
                    walk(ACTIVE, COORDINATE_ABSOLUTE, lift_id[X], lift_id[Y], ACTIVE, NONE);
                    face(ACTIVE, SOUTH);
                } else {
                    walk(ACTIVE, COORDINATE_ABSOLUTE, lift_id[X] - 0d8, lift_id[Y], NONE, NONE);
                    walk(INACTIVE, COORDINATE_ABSOLUTE, lift_id[X] + 0d8, lift_id[Y], BOTH, NONE);
                    face(ACTIVE, SOUTH);
                    face(INACTIVE, SOUTH);
                }
            }

            animate(lift_id, LOOP, ANIMATION_PLACEHOLDER.LIFT_MOVING);

            while(lift_id[X] > arg[0x10]) {
                lift_id[X]--;

                if!(dry) {
                    if(arg[0x12]) {
                        <ACTIVE>[X] = lift_id[X];
                        <ACTIVE>[Y] = lift_id[Y];
                    } else {
                        <ACTIVE>[X] = lift_id[X] - 0d8;
                        <ACTIVE>[Y] = lift_id[Y];

                        <INACTIVE>[X] = lift_id[X] + 0d8;
                        <INACTIVE>[Y] = lift_id[Y];
                    }
                }

                yield();
            }
            while(lift_id[X] < arg[0x10]) {
                lift_id[X]++;

                if!(dry) {
                    if(arg[0x12]) {
                        <ACTIVE>[X] = lift_id[X];
                        <ACTIVE>[Y] = lift_id[Y];
                    } else {
                        <ACTIVE>[X] = lift_id[X] - 0d8;
                        <ACTIVE>[Y] = lift_id[Y];

                        <INACTIVE>[X] = lift_id[X] + 0d8;
                        <INACTIVE>[Y] = lift_id[Y];
                    }
                }

                yield();
            }

            animate(lift_id, ONCE_FREEZE, ANIMATION_PLACEHOLDER.LIFT_MOVING);

            if!(dry) {
                if(arg[0x12]) {
                    walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, 0d1, ACTIVE, ACTIVE);
                } else {
                    walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, 0d1, NONE, BOTH);
                    walk(INACTIVE, TILE_RELATIVE_DIRECT, 0d0, 0d1, BOTH, BOTH);
                }
            }

            ROOM.LIFT_POSITION = position;
        }

        enum stepon_trigger {
            lift_west = @install() {
                debug_subtext("S=0");

                if(ROOM.LIFT_POSITION == 0d1) {
                    move_lift(ROOM.LIFT_ID, 0d3);
                }
            },
            lift_east = @install() {
                debug_subtext("S=1");

                if(ROOM.LIFT_POSITION == 0d3) {
                    move_lift(ROOM.LIFT_ID, 0d1);
                }
            },
            exit_west = @install() {
                map_transition(volcano, east, WEST);
            },
            bridge_east = @install() {
                // pit_act2_between(0x0250);

                debug_subtext("S=3");

                generic_act2_dog_bridge_jump(WEST, 0x29, 0x3c);
            },
            bridge_west = @install() {
                debug_subtext("S=4");

                generic_act2_dog_bridge_jump(EAST, 0x20, 0x3c);
            },
            stepon_5 = @install() {
                debug_subtext("S=5");
            },
            stepon_6 = @install() {
                map_transition(northern_waterfall, south, NORTH);
            },
            stepon_7 = @install() {
                debug_subtext("S=7");
            },
            stepon_8 = @install() {
                debug_subtext("S=8");
            },
            exit_west = @install() {
                map_transition(inbetwixx, west_2, EAST);
            }
        }

        enum b_trigger {
            sniff__1_water_1 = @install() {
                debug_subtext("B=0");
                _loot(0x0c, WATER, 0d01, 0d01);
            },
            sniff__1_water_1 = @install() {
                debug_subtext("B=1");
                _loot(0x0b, WATER, 0d01, 0d01);
            },
            sniff__1_roots_2 = @install() {
                debug_subtext("B=2");
                _loot(0x0a, ROOTS, 0d01, 0d02);
            },
            sniff__1_ash_2 = @install() {
                debug_subtext("B=3");
                _loot(0x09, ASH, 0d01, 0d02);
            },
            sniff__1_wax_1 = @install() {
                debug_subtext("B=4");
                _loot(0x08, WAX, 0d01, 0d01);
            },
            sniff__1_brimstone_2 = @install() {
                debug_subtext("B=5");
                _loot(0x07, BRIMSTONE, 0d01, 0d02);
            },
            sniff__1_brimstone = @install() {
                debug_subtext("B=6");
                _loot(0x06, BRIMSTONE, 0d01, 0d00);
            },
            sniff__1_limestone_1 = @install() {
                debug_subtext("B=7");
                _loot(0x05, LIMESTONE, 0d01, 0d01);
            },
            sniff__1_limestone_2 = @install() {
                debug_subtext("B=8");
                _loot(0x04, LIMESTONE, 0d01, 0d02);
            },
            sniff__1_ethanol_1 = @install() {
                debug_subtext("B=9");
                _loot(0x03, ETHANOL, 0d01, 0d01);
            },

            sniff__1_ethanol_2 = @install() {
                debug_subtext("B=10");
                _loot(0x02, ETHANOL, 0d01, 0d02);
            },
            sniff__1_ethanol_1 = @install() {
                debug_subtext("B=11");
                _loot(0x01, ETHANOL, 0d01, 0d01);
            },
            axe2_wall = @install() fun trigger_wall() {
                bombable_object(WALL_AXE2, True, ROOM.WALL, 0x00, 0x01);
            }
        }

        @install()
        @async()
        fun hidden_exit_check() {
            while(True) {
                arg[0x00] = <ACTIVE>[X];
                arg[0x02] = <ACTIVE>[Y];
                arg[0x04] = ROOM.SECRET_PASSAGE_TRIGGER[X];
                arg[0x06] = ROOM.SECRET_PASSAGE_TRIGGER[Y];

                if(arg[0x00] < arg[0x04]) {
                    arg[0x08] = arg[0x04] - arg[0x00];
                } else {
                    arg[0x08] = arg[0x00] - arg[0x04];
                }

                if(arg[0x02] < arg[0x06]) {
                    arg[0x0a] = arg[0x06] - arg[0x02];
                } else {
                    arg[0x0a] = arg[0x02] - arg[0x06];
                }

                if((arg[0x08] <= ROOM.SECRET_PASSAGE_DISTANCE) && (arg[0x0a] <= ROOM.SECRET_PASSAGE_DISTANCE)) {
                    map_transition(river, right, NORTH);
                    end();
                }
                yield();

                if(ROOM.DEBUG) {
                    debug_memory(arg[0x08], arg[0x0a]);
                    sleep(0x20);
                }
            }
        }
        
        fun trigger_enter() {
            init_lift(0d2);
            if(ROOM.LIFT_POSITION == 0d2) {
                add_frippo_switch(0d33, 0d15 + 0d1, reference(@install() {
                    if(<ACTIVE>[X] < ROOM.CENTER_LINE) {
                        move_lift(ROOM.LIFT_ID, 0d1, True);
                    } else {
                        move_lift(ROOM.LIFT_ID, 0d3, True);
                    }
                }));
            }

            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d2) {
                add_souls_npc_archaeologist(0d44, 0d11);
            }

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // east
                add_enemy(BUZZARD_1, 0d50, 0d26);

                // west
                add_enemy(BUZZARD_1, 0d15, 0d14);
                add_enemy(FLOWER_PURPLE, 0d12, 0d38);
            }

            default_init_room(True, True);

            if(SOULS_MEMORY.WITH_AREA_NAMES) {
                subtext("North West Inbetwixx");
            }

            add_enemy(PLACEHOLDER, 0x17, 0x00);
            ROOM.SECRET_PASSAGE_TRIGGER = <LAST_ENTITY>;

            if(SOULS_MEMORY.WITH_BOAT_RIDE) {
                hidden_exit_check();
            }

            add_bombable(0d64, 0d17, ROOM.WALL, reference(trigger_wall));
        }
    };

    map northern_waterfall(WATERFALL) {
        enum entrance {
            south = entrance(0x11, 0x3f, NORTH),

            swirl = entrance(0d19, 0d33, NONE, { swirl_entrance(); }),
        }

        enum soundtrack {
            default = soundtrack(WATERFALL_AMBIENT, 0xff)
        }

        @install()
        fun waterfall_triggered() {
            if(SOULS_MEMORY.WITH_METRO) {
                generic_yeet_waterfall(0d250, 0d200);

                pit_fall_damage_callback(0d500, 0d50, {
                    map_transition(junkyard_northwest, crash_north, NONE);
                }, {
                    dust_unreachable(0d24, 0d34);
                });
            } else {
                error_message(DLC);
            }
        }

        enum stepon_trigger {
            stepon_0 = waterfall_triggered(),
            stepon_1 = waterfall_triggered(),
            stepon_2 = waterfall_triggered(),
            stepon_3 = waterfall_triggered(),
            stepon_4 = waterfall_triggered(),
            stepon_5 = waterfall_triggered(),
            stepon_6 = @install() {
                map_transition(northwest_inbetwixx, cave, SOUTH);
            }
        }

        fun trigger_enter() {
            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d2) {
                add_souls_npc_archaeologist(0d44, 0d11);
            }

            default_init_room(True, True);
        }
    };
};

area east_inbetwixx() {
    map east_inbetwixx(SANDPITS) {
        // chests=vanilla
        // sniff=vanilla

        enum entrance {
            east = entrance(0x73, 0x22, WEST),
            cave = entrance(0x42, 0x1a, SOUTH),
            south_1 = entrance(0x44, 0x9e, NORTH),
            south_2 = entrance(0x33, 0x9e, NORTH),
            west_1 = entrance(0x01, 0x2a, EAST),
            west_2 = entrance(0x01, 0x22, EAST),
            west_3 = entrance(0x01, 0x15, EAST)
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum ROOM {
            BRANCH_USED = memory(FLAG, SRAM),
        }

        enum BOSS {
            DEBUG = False,
            PROGRESS = memory(FLAG, TEMP),

            ID = memory(WORD, TEMP),

            PIT_THRESHOLD = 0d03,

            PIT_1_TIMER = memory(WORD, TEMP),
            PIT_2_TIMER = memory(WORD, TEMP),
            PIT_3_TIMER = memory(WORD, TEMP),
            PIT_4_TIMER = memory(WORD, TEMP),

            VOLCANO_DELAY = 0d180,
            VOLCANO_TIMER = 0d300,
        }

        fun fog_wall(exit_direction:DIRECTION) {
            if(BOSS.PROGRESS) {
                fog_wall_inside(!SOULS_MEMORY.DEAD_PIT_EGG, exit_direction);
            }
        }

        enum stepon_trigger {
            center_bottleneck = nop(),
            stepon_1 = @install() {
                debug_subtext("S=1");
            },
            sandpit_5_2_west = nop(),
            sandpit_5_2_north = nop(),
            sandpit_4_1_east = nop(),
            sandpit_4_1_south = nop(),
            sandpit_4_1 = nop(),
            sandpit_2_north = nop(),
            sandpit_2 = nop(),
            sandpit_8_east = nop(),

            sandpit_6_north = nop(),
            sandpit_6_west = nop(),
            sandpit_6 = nop(),
            sandpit_9 = nop(),
            sandpit_10_3 = nop(),
            sandpit_10_2 = nop(),
            sandpit_10_1 = nop(),
            sandpit_8 = nop(),
            sandpit_7 = nop(),
            sandpit_5_1 = nop(),

            sandpit_4_2 = nop(),
            sandpit_3_2 = nop(),
            stepon_22 = @install() {
                debug_subtext("S=22");
            },
            stepon_23 = @install() {
                debug_subtext("S=23");
            },
            exit_west_1 = @install() {
                fog_wall(NONE); // EAST

                map_transition(east_inbetwixx, west_3, WEST);
            },
            exit_cave = @install() {
                fog_wall(SOUTH);
                
                if(True) {
                    map_transition(jaguar_cave, south, NORTH);
                } else {
                    map_transition(stone_room_top, crash, NORTH);
                }
            },
            exit_south_1 = @install() {
                fog_wall(NONE); // NORTH
                
                map_transition(east_crossing, crash, SOUTH);
            },
            exit_south_2 = @install() {
                fog_wall(NONE); // NORTH
                
                map_transition(east_crossing, north, SOUTH);
            },
            exit_west_2 = @install() {
                fog_wall(NONE); // EAST
                
                map_transition(inbetwixx, east, WEST);
            },
            exit_west_3 = @install() {
                fog_wall(NONE); // EAST
                
                map_transition(east_inbetwixx, west_1, WEST);
            },

            sandpit_1_1 = nop(),
            sandpit_1_1_west = nop(),
            sandpit_3_2_west = nop(),
            sandpit_4_2_south = nop(),
            sandpit_5_1_south = nop(),
            sandpit_7_north = nop(),
            sandpit_9_north = nop(),
            sandpit_10_2_north = nop(),
            sandpit_10_3_north = nop(),
            sandpit_cave_north = nop(),

            sandpit_cave = nop(),
            sandpit_5_1_north = nop(),
            sandpit_1_2_west = nop(),
            sandpit_1_2_east = nop(),
            sandpit_3_1_north = nop(),
            sandpit_2_east = nop(),
            sandpit_3_1_south = nop(),
            sandpit_4_3_west = nop(),
            sandpit_4_3_north = nop(),
            sandpit_4_3 = nop(),

            sandpit_5_2 = nop(),
            sandpit_1_2 = nop(),
            sandpit_3_1 = nop(),
            sandpit_4_1 = nop(),
            sandpit_8_west = nop(),
            sandpit_8_north = nop(),
            sandpit_10_3_east = nop(),
            sanpit_7_south = nop(),
            sanpit_7_east = nop(),
            sandpit_3_2_east = nop(),

            sandpit_4_2_north = nop(),
            sandpit_4_2_east = nop(),
            sandpit_10_1_north = nop(),
            sandpit_10_1_west = nop(),
            exit_east = @install() {
                fog_wall(NONE); // WEST
                
                map_transition(eastern_barrier, west, EAST);
            }
        }

        enum b_trigger {
            sniff__1_wax = @install() {
                debug_subtext("B=0");
                _loot(0x2c, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=1");
                _loot(0x2e, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=2");
                _loot(0x2d, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=3");
                _loot(0x16, WAX, 0d01, 0d00);
            },
            gourd_south__4_crystal = @install() {
                debug_subtext("B=4");
                _loot_chest(0x02, CRYSTAL, 0d04);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=5");
                _loot(0x17, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=6");
                _loot(0x18, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=7");
                _loot(0x19, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=8");
                _loot(0x1a, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=9");
                _loot(0x1b, ASH, 0d01, 0d00);
            },

            sniff__1_ash = @install() {
                debug_subtext("B=10");
                _loot(0x1c, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=11");
                _loot(0x1d, ASH, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=12");
                _loot(0x1e, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=13");
                _loot(0x1f, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=14");
                _loot(0x20, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=15");
                _loot(0x21, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=16");
                _loot(0x22, ROOTS, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=17");
                _loot(0x23, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=18");
                _loot(0x24, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=19");
                _loot(0x25, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=20");
                _loot(0x26, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=21");
                _loot(0x29, CLAY, 0d01, 0d00);
            },
            gourd_hidden_west__1_clay = @install() {
                debug_subtext("B=22");
                _loot_chest(0x29, CLAY, 0d01);
            },
            gourd_hidden_north_3__1_water = @install() {
                debug_subtext("B=23");
                _loot_chest(0x2a, WATER, 0d01);
            },
            gourd_hidden_north_2__1_biscuit = @install() {
                debug_subtext("B=24");
                _loot_chest(0x28, BISCUIT, 0d01);
            },
            gourd_hidden_north_1__1_clay = @install() {
                debug_subtext("B=25");
                _loot_chest(0x27, CLAY, 0d01);
            },
            gourd_west__1_petal = @install() {
                debug_subtext("B=26");
                _loot_chest(0x00, PETAL, 0d01);
            },
            gourd_north__4_wax = @install() {
                debug_subtext("B=27");
                _loot_chest(0x01, WAX, 0d04);
            }
        }

        fun open_sandpits(open) {
            if(open) {
                object[0x03] = 0x04; // open sandpit_2
                object[0x04] = 0x04; // open sandpit_1
                object[0x05] = 0x04; // open sandpit_4
                object[0x06] = 0x04; // open sandpit_5
                object[0x07] = 0x04; // open sandpit_6
                object[0x08] = 0x04; // open sandpit_7
                object[0x09] = 0x04; // open sandpit_8
                object[0x0a] = 0x04; // open sandpit_9
                object[0x0b] = 0x04; // open sandpit_10
                object[0x0c] = 0x04; // open sandpit_12_1
                object[0x0d] = 0x04; // open sandpit_12_2
                object[0x0e] = 0x04; // open sandpit_12_3
                object[0x0f] = 0x04; // open sandpit_cave
                object[0x10] = 0x04; // open sandpit_5
                object[0x11] = 0x04; // open sandpit_6
                object[0x12] = 0x04; // open sandpit_2
                object[0x13] = 0x04; // open sandpit_3
                object[0x14] = 0x04; // open sandpit_4
            }
        }

        fun init_room() {
            default_init_room(True, True);
        }

        fun pit_triggered(entity, index) {
            if(entity[GENERAL_PURPOSE] != index) {
                entity[GENERAL_PURPOSE] = index;
            } else {
                damage(entity, 0x100, True);
            }
        }
        fun pit_triggered_boy(index) {
            if(<BOY>[GENERAL_PURPOSE] != index) {
                <BOY>[GENERAL_PURPOSE] = index;
            } else {
                damage(BOY, 0x10, True);
            }
        }

        fun pit_scanner_entity(entity, threshold, trigger_damage, sleep) {
            arg[0x10] = entity[CURRENT_GROUND] & 0xff;

            if(((arg[0x10] > 0d40) && (arg[0x10] < 0d47)) || ((arg[0x10] == 0d40) && (entity[GENERAL_PURPOSE] > 0d00)) || ((arg[0x10] == 0d47) && (entity[GENERAL_PURPOSE] > 0d00))) {
                entity[GENERAL_PURPOSE] += (entity[CURRENT_GROUND] & 0xff) - 0d30;

                if(entity[GENERAL_PURPOSE] > threshold) {
                    entity[GENERAL_PURPOSE] = 0x00;
                    damage(entity, trigger_damage, True);

                    sleep(sleep);
                }
            } else {
                entity[GENERAL_PURPOSE] = 0x00;
            }

            // sleep(0d03);
            yield();
        }
        @install()
        @async()
        fun pit_scanner_boy() {
            while(True) {
                pit_scanner_entity(<BOY>, 0d300, 0d05, 0d120);
            }
        }
        @install()
        @async()
        fun pit_scanner_dog() {
            while(True) {
                pit_scanner_entity(<DOG>, 0d300, 0d05, 0d120);
            }
        }
        @install()
        @async()
        fun pit_scanner_boss() {
            while(alive(BOSS.ID)) {
                pit_scanner_entity(BOSS.ID, 0d300, 0d100, 0d60);
            }
        }

        @install()
        fun boss_defeated() {
            if(BOSS.DEBUG) {
                subtext("boss defeated");
            }
            
            souls_boss_defeated(DEAD_PIT_EGG, REWARD_PIT_EGG);

            BOSS.PROGRESS = False;
        }
        @install()
        fun boss_triggered() {
            if!(BOSS.PROGRESS) {
                BOSS.PROGRESS = True;

                if(BOSS.DEBUG) {
                    subtext("boss triggered");
                }

                push_music(BOSS);

                attach_script(BOSS.ID, DEATH, reference(boss_defeated));

                control(BOSS.ID, False);

                if(BOSS.DEBUG) {
                    debug_subtext("+pit");
                }

                sleep(BOSS.VOLCANO_DELAY);

                while(alive(BOSS.ID)) {
                    if(BOSS.DEBUG) {
                        debug_subtext("pit");
                    }

                    if(randrange(0d2)) {
                        pit_projectile(BOSS.ID, <ACTIVE>);
                    } else {
                        pit_projectile(BOSS.ID, <INACTIVE>);
                    }

                    sleep(BOSS.VOLCANO_TIMER);
                }

                if(BOSS.DEBUG) {
                    debug_subtext("-pit");
                }
            }
        }

        fun trigger_enter() {
            open_sandpits(True);

            if!(SOULS_MEMORY.DEAD_PIT_EGG) {
                add_enemy(MEGATAUR, 0d56, 0d68, INACTIVE);
                animate(LAST_ENTITY, ONCE_FREEZE, ANIMATION_ENEMY.MEGATAUR_ENTER);
                attach_script(LAST_ENTITY, DAMAGE, reference(boss_triggered));
                <LAST_ENTITY>[HP] = 0d600;
                BOSS.ID = <LAST_ENTITY>;
            }

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // north
                add_enemy(TUMBLING_WEED, 0d42, 0d42);

                // center
                add_enemy(TUMBLING_WEED, 0d18, 0d90);

                // center
                add_enemy(TUMBLING_WEED, 0d68, 0d147);

                // upstairs east
                add_enemy(SLIME, 0d11, 0d109);
                
                add_enemy(SLIME, 0d11, 0d65);

                // upstairs north
                add_enemy(SLIME, 0d57, 0d34);

                // upstairs east
                add_enemy(TUMBLING_WEED, 0d76, 0d89);
                add_enemy(SLIME, 0d76, 0d114);
            }

            init_room();

            if!(ROOM.BRANCH_USED) {
                branch_lady(VILLAGER_2_4, 0d78, 0d44, NORTH, reference(@install() {
                    guard_branch_lady(ROOM.BRANCH_USED);
                }));
            }

            pit_scanner_boy();
            yield();
            pit_scanner_dog();
            yield();
            pit_scanner_boss();
        }
    };

    map jaguar_cave(PYRAMID_CAVE) {
        enum entrance {
            south = entrance(0x15, 0x23, NORTH),

            teleporter = entrance(0d23, 0d18, NONE, { teleporter_in(SOUTH); }),
        }

        enum stepon_trigger {
            exit_south = @install() {
                map_transition(east_inbetwixx, cave, SOUTH);
            },
            exit_teleporter = @install() {
                debug_subtext("S=1");

                teleporter_out(0d23, 0d18);
                map_transition(cave_gauge, teleporter, NONE);
            },
        }

        fun trigger_enter() {
            default_init_room(False, False);
        }
    };

    map east_crossing(BLIMP_EXTERIOR) {
        // chests=vanilla
        // sniff=vanilla

        enum ROOM {
            DEBUG = False,

            STONE_TRIGGERED = memory(FLAG, SRAM),
            RADAHN_EXIT_OPENED = memory(FLAG, SRAM),
            BRIDGE_RESTORED = memory(FLAG, SRAM),

            ID_STONE = memory(WORD, TEMP),
            ID_STONE_HOLE = memory(WORD, TEMP),
        }

        enum entrance {
            north = entrance(0x27, 0x01, SOUTH),
            cave = entrance(0x15, 0x1a, SOUTH, { ROOM.RADAHN_EXIT_OPENED = True; }),
            east = entrance(0x3f, 0x4b, WEST),
            west = entrance(0x01, 0x4b, EAST),

            elevator_top = entrance(0x0d, 0x2b, SOUTH),
            elevator_bottom = entrance(0x1b, 0x47, SOUTH),

            crash = entrance(0x32, 0x1e, NONE, { crash_both(); }),
            bonfire = entrance(0d45, 0d68, NONE, { bonfire_wakeup(0d0, 0d8, 0d24, 0d0); }),
        }

        enum soundtrack {
            default = soundtrack(SEWER_AMBIENT_WATER, 0xff)
        }

        @install()
        fun ravine_triggered() {
            generic_fall(0d100, 0d170);

            pit_fall_damage_callback(0d300, 0d30, {
                map_transition(radahn_arena, center, NONE);
            }, {
                dust_unreachable(0d47, 0d6);
            });
        }

        enum stepon_trigger {
            ravine_1 = ravine_triggered(),
            ravine_2 = ravine_triggered(),
            ravine_3 = ravine_triggered(),
            ravine_4 = ravine_triggered(),
            ravine_5 = ravine_triggered(),
            ravine_6 = ravine_triggered(),
            ravine_7 = ravine_triggered(),
            ravine_8 = ravine_triggered(),
            ravine_9 = ravine_triggered(),
            ravine_10 = ravine_triggered(),

            ravine_11 = ravine_triggered(),
            ravine_12 = ravine_triggered(),
            ravine_13 = ravine_triggered(),
            ravine_14 = ravine_triggered(),
            ravine_15 = ravine_triggered(),
            ravine_16 = ravine_triggered(),
            ravine_17 = ravine_triggered(),
            ravine_18 = ravine_triggered(),
            ravine_19 = ravine_triggered(),
            exit_east = @install() {
                if(AREA_GLOBAL.ROCK_MOVED_SHIP) {
                    map_transition(ship, west, EAST);
                } else {
                    error_message(DOOR_CONTRAPTION);
                }
            },

            exit_cave = @install() {
                if(ROOM.RADAHN_EXIT_OPENED) {
                    map_transition(radahn_exit, south_1, NORTH);
                } else {
                    error_message(DOOR_WRONG_SIDE, SOUTH);
                }
            },
            exit_west = @install() {
                map_transition(eastern_river, east, WEST);
            },
            elevator_bottom = @install() {
                map_transition(dungeon_volcano, south_2, NORTH);
            },
            elevator_top = @install() {
                map_transition(dungeon_volcano, south_1, NORTH);
            },
            exit_north = @install() {
                map_transition(east_inbetwixx, south_2, NORTH);
            }
        }

        enum b_trigger {
            sniff__1_ethanol_3 = @install() {
                debug_subtext("B=0");
                _loot(0x01, ETHANOL, 0d01, 0d03);
            },
            sniff__1_ethanol_1 = @install() {
                debug_subtext("B=1");
                _loot(0x02, ETHANOL, 0d01, 0d01);
            },
            sniff__1_ethanol_2 = @install() {
                debug_subtext("B=2");
                _loot(0x03, ETHANOL, 0d01, 0d02);
            },
            sniff__1_ethanol = @install() {
                debug_subtext("B=3");
                _loot(0x04, ETHANOL, 0d01, 0d00);
            },
            sniff__1_roots_1 = @install() {
                debug_subtext("B=4");
                _loot(0x05, ROOTS, 0d01, 0d01);
            },
            sniff__1_limestone = @install() {
                debug_subtext("B=5");
                _loot(0x06, LIMESTONE, 0d01, 0d01);
            },
            sniff__1_limestone_2 = @install() {
                debug_subtext("B=6");
                _loot(0x07, LIMESTONE, 0d01, 0d02);
            },
            sniff__1_wax_1 = @install() {
                debug_subtext("B=7");
                _loot(0x08, WAX, 0d01, 0d01);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=8");
                _loot(0x09, WAX, 0d01, 0d00);
            },
            sniff__1_wax_2 = @install() {
                debug_subtext("B=9");
                _loot(0x0a, WAX, 0d01, 0d02);
            },

            sniff__1_vinegar_2 = @install() {
                debug_subtext("B=10");
                _loot(0x0b, VINEGAR, 0d01, 0d02);
            },
            sniff__1_bone_3 = @install() {
                debug_subtext("B=11");
                _loot(0x0c, BONE, 0d01, 0d03);
            },
            sniff__1_brimstone_1 = @install() {
                debug_subtext("B=12");
                _loot(0x0d, BRIMSTONE, 0d01, 0d01);
            },
            sniff__1_brimstone_2 = @install() {
                debug_subtext("B=13");
                _loot(0x0e, BRIMSTONE, 0d01, 0d02);
            },
            gourd_1__1_call_beads = @install() {
                debug_subtext("B=14");
                _loot_chest(0x0f, CALL_BEADS, 0d01);
            },
            gourd_2__200_money = @install() {
                debug_subtext("B=15");
                _loot_chest(0x10, MONEY, 0d200);
            }
        }

        @install()
        fun stone_triggered() {
            if(<ACTIVE> == <BOY>) {
                animate(BOY, ONCE, SLASH_2);

                <SCRIPT_OWNER>[VELOCITY] = 0x30;
                sleep(0x50);

                object[0x00] = 0x01;
                destroy(SCRIPT_OWNER);

                set(ROOM.STONE_TRIGGERED);
            }
        }

        fun tiny_bridge(connected) {
            if(connected) {
                object[0x11] = 0x01;
            } else {
                object[0x11] = 0x00;
            }
        }

        @install()
        fun stone_hole_triggered() {
            ROOM.BRIDGE_RESTORED = True;

            destroy(ROOM.ID_STONE);
            destroy(ROOM.ID_STONE_HOLE);

            tiny_bridge(True);
        }
        
        @install()
        @async()
        fun stone_hole_scanner() {
            range_checker(ROOM.ID_STONE_HOLE, ROOM.ID_STONE, 0d10, 0d30, {
                stone_hole_triggered();
                end();
            });
        }

        fun init_room() {
            default_init_room(True, True);
        }

        @install()
        fun debug_triggered() {
            stone_triggered();

            destroy(SCRIPT_OWNER);
        }

        fun trigger_enter() {
            if(FLAG.DEBUG) {
                if!(ROOM.STONE_TRIGGERED) {
                    add_debug_entity(0x24, 0x06, reference(debug_triggered));
                }
            }

            if(NPC_ARCHAEOLOGIST.PROGRESS == 0d3) {
                add_souls_npc_archaeologist(0d55, 0d46);
            }

            add_levitate_stone_ship(0d65, 0d75);

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // upstairs
                add_enemy(RAPTOR_GREEN, 0d26, 0d48);
                add_enemy(RAPTOR_PURPLE, 0d28, 0d25);

                // downstairs
                add_enemy(RAPTOR_GREEN, 0d39, 0d80);
                add_enemy(RAPTOR_PURPLE, 0d17, 0d71);
            }

            if!(ROOM.STONE_TRIGGERED) {
                add_enemy(STONE_ROUND, 0x24, 0x18);
                attach_script(LAST_ENTITY, B, reference(stone_triggered));
            } else {
                object[0x00] = 0x01;
            }

            bonfire(0d45, 0d68, SOULS_MEMORY.BONFIRE_EAST_CROSSING);

            if(ROOM.BRIDGE_RESTORED) {
                tiny_bridge(True);
            } else {
                add_enemy(STONE_ROUND, 0x15, 0x1b);
                ROOM.ID_STONE = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, B, reference(@install() {
                    if!(ROOM.RADAHN_EXIT_OPENED) {
                        ROOM.RADAHN_EXIT_OPENED = True;

                        guard_levitate_stone(0d2, {
                            error_message(DOOR_WRONG_SIDE, SOUTH);
                        });
                    } else {
                        guard_levitate_stone(0d2);
                    }
                }));

                if(ROOM.RADAHN_EXIT_OPENED) {
                    ROOM.ID_STONE[Y] += 0d7 * 0d8;
                }
                
                add_enemy(PLACEHOLDER, 0d49, 0d46);
                ROOM.ID_STONE_HOLE = <LAST_ENTITY>;

                stone_hole_scanner();
            }

            default_init_room(True, False);
        }
    };

    area arena_ravine() {
        map radahn_arena(RAPTORS) {
            // sniff=vanilla
            
            enum entrance {
                north = entrance(0x1b, 0x03, SOUTH),
                south = entrance(0x1d, 0x33, NORTH),

                left = entrance(0x15, 0x1c, NONE, { crash_both(); }),
                center = entrance(0x1e, 0x21, NONE, { crash_both(); }),
                right = entrance(0x2a, 0x23, NONE, { crash_both(); }),
            }

            enum soundtrack {
                default = soundtrack(BOSS_JUNGLE, 0xff)
            }

            enum stepon_trigger {
                exit_north = nop(),
                exit_south = @install() {
                    fog_wall_inside(!SOULS_MEMORY.DEAD_ARENA_RADAHN, NORTH);
                    map_transition(radahn_exit, north, SOUTH);
                },
                center = nop(),
            }

            enum b_trigger {
                sniff__1_crystal_1 = @install() {
                    debug_subtext("B=0");
                    _loot(0x09, CRYSTAL, 0d01, 0d01);
                },
                sniff__1_oil_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x08, OIL, 0d01, 0d01);
                },
                sniff__1_crystal_2 = @install() {
                    debug_subtext("B=2");
                    _loot(0x07, CRYSTAL, 0d01, 0d02);
                },
                sniff__1_water_2 = @install() {
                    debug_subtext("B=3");
                    _loot(0x06, WATER, 0d01, 0d02);
                },
            }

            fun close_exits(close) {
                if(close) {
                    object[0x04] = 0x04;
                } else {
                    object[0x05] = 0x04;
                }
            }

            enum BOSS {
                DEBUG = False,

                RIDER_ID = memory(WORD, TEMP),
                MOUNT_ID = memory(WORD, TEMP),

                PHASE = memory(WORD, TEMP),
                COOLDOWN = memory(WORD, TEMP),

                HP = 0d1000,
                HP_MOUNT = 0d600,

                COUNTDOWN = 0d03,

                // p1

                P1_THRESHOLD = 0d800,
                P1_TIME_BEFORE_SALVAGE = 0d420,

                // p2

                P2_THRESHOLD = 0d500,
                P2_TIME_BEFORE_SALVAGE = 0d420,

                RANDOM_SPELL = memory(WORD, TEMP),
                TIME_BEFORE_RANDOM_SPELL = 0d720,

                THRESHOLD_SUDDEN_DEATH = 0d50,
            }

            fun boss_killed() {
                destroy(BOSS.MOUNT_ID);

                souls_boss_defeated(DEAD_ARENA_RADAHN, REWARD_ARENA_RADAHN);

                object[0x04] = 0x00;
            }

            @install()
            fun reset_cooldown() {
                if(BOSS.PHASE == 0d0) {
                    BOSS.COOLDOWN = BOSS.P1_THRESHOLD;
                } else {
                    BOSS.COOLDOWN = BOSS.P2_THRESHOLD;
                }
            }

            fun cast_salvage(target:CHARACTER, count, level) {
                arg[0x10] = 0d0;
                while(arg[0x10] < count) {
                    arg[0x10]++;

                    animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_CAST_1); // blocks cast() for whatever reason

                    cast(BOSS.RIDER_ID, target, FLASH, level);
                    cast(BOSS.RIDER_ID, target, FLASH, level);

                    BOSS.COOLDOWN += 0d120;

                    if(arg[0x10] < count) {
                        if(False) {
                            debug_memory(arg[0x10], count);
                        }

                        sleep(0d60);
                        animate(BOSS.RIDER_ID, ONCE, DEFAULT);
                        yield();
                    }
                }
            }
            fun cast_spells(callback2) {
                animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_CAST_1); // blocks cast() for whatever reason

                BOSS.COOLDOWN += 0d120;

                if(BOSS.RIDER_ID[HP] > BOSS.THRESHOLD_SUDDEN_DEATH) {
                    callback2();
                } else {
                    cast(BOSS.RIDER_ID, ACTIVE, PLAGUE, 0d1);
                }
            }

            @install()
            fun boss_damage() {
                // animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_DAMAGE);

                reset_cooldown();

                if(BOSS.PHASE == 0d0) {
                    if(BOSS.RIDER_ID[HP] < BOSS.P1_THRESHOLD) {
                        BOSS.PHASE++;
                    }
                }
                if(BOSS.PHASE == 0d1) {
                    if(BOSS.RIDER_ID[HP] < BOSS.P2_THRESHOLD) {
                        BOSS.PHASE++;
                    }
                }
                if(BOSS.PHASE == 0d2) {
                    if(dead(BOSS.RIDER_ID)) {
                        BOSS.PHASE = 0xffff;
                    }
                }

                if(BOSS.DEBUG) {
                    MEMORY.STRING_PARAMETER_1 = BOSS.RIDER_ID[HP];
                    MEMORY.STRING_PARAMETER_2 = BOSS.HP;

                    subtext("Rider = [MEM1]/[MEM2]");
                }
            }

            fun handle_cast_cooldown(callback) {
                if(BOSS.RIDER_ID[PALETTE] == 0x0400) { // TODO: buggy, since menu resets paletts
                    nop();
                } if(BOSS.COOLDOWN == 0d0) {
                    callback();

                    reset_cooldown();
                } else {
                    BOSS.COOLDOWN--;
                }

                if(False) {
                    debug_memory(BOSS.COOLDOWN, BOSS.RIDER_ID[PALETTE]);
                    sleep(0d60);
                }
            }

            @install()
            @async()
            fun boss_watcher() {
                if(BOSS.DEBUG) {
                    subtext("phase 0");
                }

                reset_cooldown();

                while(BOSS.PHASE == 0d0) {
                    handle_cast_cooldown({
                        cast_salvage(ACTIVE, 0d1, 0d0);
                    });

                    yield();
                }

                if(BOSS.DEBUG) {
                    subtext("phase 1");
                }

                reset_cooldown();
                cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD);
                // cast(BOSS.RIDER_ID, ACTIVE, CONFOUND);

                while(BOSS.PHASE == 0d1) {
                    handle_cast_cooldown({
                        cast_salvage(ACTIVE, 0d2, 0d0);
                    });

                    yield();
                }

                reset_cooldown();
                cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD);
                cast(BOSS.RIDER_ID, ACTIVE, CONFOUND);

                while(BOSS.PHASE == 0d2) {
                    handle_cast_cooldown({
                        cast_spells({
                            BOSS.RANDOM_SPELL = randrange(0d3);

                            if(BOSS.RANDOM_SPELL == 0d0) {
                                cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD);
                                cast(BOSS.RIDER_ID, ACTIVE, CONFOUND);
                            } else if(BOSS.RANDOM_SPELL == 0d1) {
                                cast(BOSS.RIDER_ID, ACTIVE, CONFOUND);
                            } else if(BOSS.RANDOM_SPELL == 0d2) {
                                cast(BOSS.RIDER_ID, ACTIVE, DRAIN, 0d20);
                            }
                        });
                    });
                    
                    yield();
                }

                if(BOSS.DEBUG) {
                    subtext("phase 2");
                }

                boss_killed();
            }

            fun spawn_boss(x, y) {
                add_enemy(VERMINATOR, x, y);
                <LAST_ENTITY>[HP] = BOSS.HP;
                BOSS.RIDER_ID = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(boss_damage));
                attribute(LAST_ENTITY, ROOT, True);

                add_enemy(RAPTOR_BLACK, x, y);
                <LAST_ENTITY>[HP] = BOSS.HP_MOUNT;
                BOSS.MOUNT_ID = <LAST_ENTITY>;
                // attribute(LAST_ENTITY, ROOT, True);
            }

            fun trigger_enter() {
                default_init_room(True, False);
                character_selection(BOY);

                if!(SOULS_MEMORY.DEAD_ARENA_RADAHN) {
                    close_exits(True);

                    spawn_boss(0d16, 0d19);
                    stack_sprite(BOSS.MOUNT_ID, BOSS.RIDER_ID, 0d0, 0d20);
                    boss_watcher();
                }
            }
        };
    };

    map eastern_barrier(CROSSING_ACT3) {
        enum entrance {
            north = entrance(0x14, 0x05, SOUTH), // entrance(0x17, 0x01, SOUTH),
            east = entrance(0x2b, 0x11, WEST),
            west = entrance(0x06, 0x18, EAST),
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum ROOM {
            WALL = retained_object(0x00),
        }

        enum stepon_trigger {
            exit_west = @install() {
                map_transition(east_inbetwixx, east, WEST);
            },
            stepon_1 = @install() {
                debug_subtext("S=1");
            },
            exit_north = @install() {
                fog_wall_outside(True, SOUTH);
                map_transition(graveyard, south, NORTH);
            },
            exit_east = @install() {
                // TODO: EAST-NONE doesn't make the player walk
                map_transition(pipe_entrance, pipe_west, EAST);
            },
        }

        enum b_trigger {
            barrier = @install() fun trigger_wall() {
                bombable_object(WALL_AXE3, True, ROOM.WALL, 0x00, 0x01);
            },
        }

        fun trigger_enter() {
            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // downstairs
                add_enemy(FLOWER_PURPLE, 0d18, 0d28);

                // upstairs
                add_enemy(FLOWER_PURPLE, 0d30, 0d11);
            }

            default_init_room(True, True);

            add_bombable(0d18, 0d11, ROOM.WALL, reference(trigger_wall));
        }
    };

    map graveyard(GRAVEYARD) {
        // sniff=vanilla

        enum entrance {
            north = entrance(0x32, 0x0f, SOUTH),
            south = entrance(0x2f, 0x5f, NORTH)
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
            // default = soundtrack(BOSS, 0xff)
        }

        enum BOSS {
            DEBUG = False,
            IN_PROGRESS = memory(WORD, TEMP),

            RIDER_ID = memory(WORD, TEMP),
            MOUNT_ID = memory(WORD, TEMP),

            PHASE = memory(WORD, TEMP),
            TIMER = memory(WORD, TEMP),

            HP = 0x03e8, // 1000

            COUNTDOWN = 0x03,

            STOMP_ENTITY = memory(WORD, TEMP),
            STOMP_DISTANCE = 0x20,
            STOMP_COOL_DOWN_TIMER = memory(WORD, TEMP),
            STOMP_COOL_DOWN = 0x100,
            STOMP_DAMAGE_CLOSE = 0x50,
            STOMP_DAMAGE = 0x10,
            STOMP_EXPLOSION_DISTANCE = 0x30,

            // p1

            P1_THRESHOLD = 0x320, // 800
            P1_TIME_BEFORE_SALVAGE = 0x500,

            // p2

            P2_THRESHOLD = 0x1f4, // 500
            P2_TIME_BEFORE_SALVAGE = 0x300,

            RANDOM_SPELL = memory(WORD, TEMP),
            TIME_BEFORE_RANDOM_SPELL = 0x300,
        }

        fun boss_killed() {
            walk(BOSS.MOUNT_ID, COORDINATE_ABSOLUTE_DIRECT, 0x00, 0x00, NONE);

            souls_boss_defeated(DEAD_STOMPY_RADAHN, REWARD_STOMPY_RADAHN);

            BOSS.IN_PROGRESS = 0x00;

            object[0x1f] = 0x00;
        }

        @install()
        @async()
        fun stomp() {
            BOSS.RIDER_ID[VELOCITY] = 0x38;
            BOSS.MOUNT_ID[VELOCITY] = 0x30;

            // attribute(BOSS.MOUNT_ID, ROOT, True);
            // animate(BOSS.MOUNT_ID, LOOP, ANIMATION_ENEMY.STERLING_FLY_1);

            sleep(0x60);

            add_placeholder(ANIMATION_PLACEHOLDER.EXPLOSION_GREEN_3, 0x00, 0x00);
            BOSS.STOMP_ENTITY = <LAST_ENTITY>;
            <LAST_ENTITY>[X] = BOSS.MOUNT_ID[X];
            <LAST_ENTITY>[Y] = BOSS.MOUNT_ID[Y] + 0x10;

            arg[0x00] = BOSS.STOMP_ENTITY[X];
            arg[0x02] = BOSS.STOMP_ENTITY[Y];
            arg[0x04] = <BOY>[X];
            arg[0x06] = <BOY>[Y];

            if(arg[0x00] < arg[0x04]) {
                arg[0x08] = arg[0x04] - arg[0x00];
            } else {
                arg[0x08] = arg[0x00] - arg[0x04];
            }

            if(arg[0x02] < arg[0x06]) {
                arg[0x0a] = arg[0x06] - arg[0x02];
            } else {
                arg[0x0a] = arg[0x02] - arg[0x06];
            }

            if((arg[0x08] <= BOSS.STOMP_DISTANCE) && (arg[0x0a] <= BOSS.STOMP_DISTANCE)) {
                damage(BOY, BOSS.STOMP_DAMAGE_CLOSE, True);
            } else if((arg[0x08] <= BOSS.STOMP_EXPLOSION_DISTANCE) && (arg[0x0a] <= BOSS.STOMP_EXPLOSION_DISTANCE)) {
                damage(BOY, BOSS.STOMP_DAMAGE, True);
            }

            if(BOSS.DEBUG) {
                debug_memory(arg[0x08], arg[0x0a]);
                sleep(0x20);
            }

            sleep(0x30);
            destroy(BOSS.STOMP_ENTITY);
            // attribute(BOSS.MOUNT_ID, ROOT, False);
        }

        @install()
        @async()
        fun stack_t01_offset() {
            while(alive(BOSS.MOUNT_ID)) {
                BOSS.RIDER_ID[X] = BOSS.MOUNT_ID[X];
                BOSS.RIDER_ID[Y] = BOSS.MOUNT_ID[Y] - 0x15;
                yield();

                if(BOSS.STOMP_COOL_DOWN_TIMER == 0x0000) {
                    arg[0x00] = BOSS.MOUNT_ID[X];
                    arg[0x02] = BOSS.MOUNT_ID[Y];
                    arg[0x04] = <ACTIVE>[X];
                    arg[0x06] = <ACTIVE>[Y];

                    if(arg[0x00] < arg[0x04]) {
                        arg[0x08] = arg[0x04] - arg[0x00];
                    } else {
                        arg[0x08] = arg[0x00] - arg[0x04];
                    }

                    if(arg[0x02] < arg[0x06]) {
                        arg[0x0a] = arg[0x06] - arg[0x02];
                    } else {
                        arg[0x0a] = arg[0x02] - arg[0x06];
                    }

                    if((arg[0x08] <= BOSS.STOMP_DISTANCE) && (arg[0x0a] <= BOSS.STOMP_DISTANCE)) {
                        BOSS.STOMP_COOL_DOWN_TIMER = BOSS.STOMP_COOL_DOWN;

                        stomp();
                        call_async(ADDRESS.STERLING_ROAR);
                    }
                    yield();

                    // if(BOSS.DEBUG) {
                    //     debug_memory(arg[0x08], arg[0x0a]);
                    //     sleep(0x20);
                    // }
                } else {
                    BOSS.STOMP_COOL_DOWN_TIMER--;
                }
            }
        }

        fun cast_salvage(target:CHARACTER, level) {
            animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_CAST_1);
            cast(BOSS.RIDER_ID, target, FIREBALL, level);
            cast(BOSS.RIDER_ID, target, FLASH, level);
            cast(BOSS.RIDER_ID, target, FIREBALL, level);
            cast(BOSS.RIDER_ID, target, FLASH, level);
        }

        @install()
        fun boss_damage() {
            // animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_DAMAGE);

            if(BOSS.PHASE == 0x00) {
                BOSS.TIMER = 0x00;

                if(BOSS.RIDER_ID[HP] < BOSS.P1_THRESHOLD) {
                    BOSS.PHASE = 0x01;
                }
            }
            if(BOSS.PHASE == 0x01) {
                if(BOSS.RIDER_ID[HP] < BOSS.P2_THRESHOLD) {
                    BOSS.PHASE = 0x02;
                }
            }
            if(BOSS.PHASE == 0x02) {
                BOSS.TIMER -= 0x60;
            }

            if(BOSS.DEBUG) {
                MEMORY.STRING_PARAMETER_1 = BOSS.RIDER_ID[HP];
                MEMORY.STRING_PARAMETER_2 = BOSS.HP;

                subtext("Rider = [MEM1]/[MEM2]");
            }
        }

        @install()
        @async()
        fun boss_watcher() {
            if(BOSS.DEBUG) {
                subtext("phase 0");
            }

            while(BOSS.PHASE == 0x00) {
                if(BOSS.TIMER > BOSS.P1_TIME_BEFORE_SALVAGE) {
                    cast_salvage(ACTIVE, 0x00);

                    BOSS.TIMER = 0x00;
                }
            
                if(BOSS.RIDER_ID[0x0b] == 0x0800) { // TODO: buggy, since menu resets paletts
                    BOSS.TIMER++;
                }
                yield();
            }

            if(BOSS.DEBUG) {
                subtext("phase 1");
            }

            BOSS.TIMER = 0x0000;
            cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD, 0x05);
            cast(BOSS.RIDER_ID, ACTIVE, CONFOUND, 0x05);

            while(BOSS.PHASE == 0x01) {
                if(BOSS.TIMER > BOSS.P2_TIME_BEFORE_SALVAGE) {
                    cast_salvage(ACTIVE, 0x00);

                    BOSS.TIMER = 0x00;
                }
            
                if(BOSS.RIDER_ID[PALETTE] == 0x0800) { // TODO: buggy, since menu resets paletts
                    BOSS.TIMER++;
                }
                yield();
            }

            BOSS.TIMER = 0x0000;
            BOSS.STOMP_COOL_DOWN_TIMER = BOSS.STOMP_COOL_DOWN;
            cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD, 0x05);
            cast(BOSS.RIDER_ID, ACTIVE, CONFOUND, 0x05);

            while(BOSS.PHASE == 0x01) {
                BOSS.TIMER++;

                if(BOSS.TIMER > BOSS.TIME_BEFORE_RANDOM_SPELL) {
                    BOSS.TIMER = 0x0000;

                    BOSS.RANDOM_SPELL = randrange(0x03);

                    if(BOSS.RANDOM_SPELL == 0x00) {
                        cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD, 0x05);
                        cast(BOSS.RIDER_ID, ACTIVE, CONFOUND, 0x05);
                    } else if(BOSS.RANDOM_SPELL == 0x01) {
                        cast(BOSS.RIDER_ID, ACTIVE, DRAIN, 0x30);
                    } else if(BOSS.RANDOM_SPELL == 0x02) {
                        cast(BOSS.RIDER_ID, ACTIVE, PLAGUE, 0x01);
                    } 
                }
                yield();
            }

            if(BOSS.DEBUG) {
                subtext("phase 2");
            }

            boss_killed();
        }

        fun spawn_boss(x, y) {
            add_enemy(VERMINATOR, x, y);
            <LAST_ENTITY>[HP] = BOSS.HP;
            BOSS.RIDER_ID = <LAST_ENTITY>;
            attach_script(LAST_ENTITY, DAMAGE, reference(boss_damage));
            attribute(LAST_ENTITY, ROOT, True);
            // attribute(LAST_ENTITY, NO_CLIP, True);

            // add_enemy(STERLING, x, y);
            add_enemy(FORESTDRAKE, x, y);
            BOSS.MOUNT_ID = <LAST_ENTITY>;
            // attach_sterling_script_to_last_entity();
            // attribute(LAST_ENTITY, ROOT, True);
        }

        enum stepon_trigger {
            exit_north = @install() {
                debug_subtext("S=0");
            },
            exit_south = @install() {
                fog_wall_inside(!SOULS_MEMORY.DEAD_STOMPY_RADAHN, NORTH);

                map_transition(eastern_barrier, north, SOUTH);
            },
            spawn_boss = @install() {
                if!(SOULS_MEMORY.DEAD_STOMPY_RADAHN) {
                    if!(BOSS.IN_PROGRESS) {
                        push_music(BOSS);
                        spawn_boss(0x39, 0x23);
                        control(BOSS.MOUNT_ID, True);
                        stack_t01_offset();

                        set_camera(COORDINATE_CORNER, 0x0108, 0xa0, 0x18);
                        walk(BOY, TILE_ABSOLUTE, 0x2d, 0x25, NONE);
                        walk(DOG, TILE_ABSOLUTE, 0x36, 0x25, BOTH, BOTH);
                        free_camera();

                        BOSS.IN_PROGRESS = True;
                        object[0x1f] = 0x7e;
                        
                        control(BOSS.MOUNT_ID, False);
                        boss_watcher();
                    }
                }
            }
        }

        enum b_trigger {
            sniff__1_ash = @install() {
                debug_subtext("B=0");
                _loot(0x0c, ASH, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=1");
                _loot(0x02, OIL, 0d01, 0d00);
            },
            sniff__1_ash_1 = @install() {
                debug_subtext("B=2");
                _loot(0x06, ASH, 0d01, 0d01);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=3");
                _loot(0x0e, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=4");
                _loot(0x0f, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=5");
                _loot(0x07, ASH, 0d01, 0d00);
            },
            sniff__1_wax_1 = @install() {
                debug_subtext("B=6");
                _loot(0x1b, WAX, 0d01, 0d01);
            },
            sniff__1_wax_2 = @install() {
                debug_subtext("B=7");
                _loot(0x1c, WAX, 0d01, 0d02);
            },
            sniff__1_ash_1 = @install() {
                debug_subtext("B=8");
                _loot(0x11, ASH, 0d01, 0d01);
            },
            sniff__1_ash_2 = @install() {
                debug_subtext("B=9");
                _loot(0x18, ASH, 0d01, 0d02);
            },

            sniff__1_clay_2 = @install() {
                debug_subtext("B=10");
                _loot(0x05, CLAY, 0d01, 0d02);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=11");
                _loot(0x09, CLAY, 0d01, 0d00);
            },
            sniff__1_oil_2 = @install() {
                debug_subtext("B=12");
                _loot(0x19, OIL, 0d01, 0d02);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=13");
                _loot(0x12, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=14");
                _loot(0x15, ROOTS, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=15");
                _loot(0x08, OIL, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=16");
                _loot(0x0a, CLAY, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=17");
                _loot(0x01, WATER, 0d01, 0d00);
            },
            sniff__1_wter_1 = @install() {
                debug_subtext("B=18");
                _loot(0x03, WATER, 0d01, 0d01);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=19");
                _loot(0x0d, ROOTS, 0d01, 0d00);
            },

            sniff__1_roots_1 = @install() {
                debug_subtext("B=20");
                _loot(0x1d, ROOTS, 0d01, 0d01);
            },
            sniff__1_roots_3 = @install() {
                debug_subtext("B=21");
                _loot(0x1a, ROOTS, 0d01, 0d03);
            },
            sniff__1_water_2 = @install() {
                debug_subtext("B=22");
                _loot(0x13, WATER, 0d01, 0d02);
            },
            sniff__1_clay_1 = @install() {
                debug_subtext("B=23");
                _loot(0x04, CLAY, 0d01, 0d01);
            },
            sniff__1_roots_2 = @install() {
                debug_subtext("B=24");
                _loot(0x0b, ROOTS, 0d01, 0d02);
            },
            sniff__1_water = @install() {
                debug_subtext("B=25");
                _loot(0x1e, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=26");
                _loot(0x10, ROOTS, 0d01, 0d00);
            },
            sniff__1_clay_1 = @install() {
                debug_subtext("B=27");
                _loot(0x17, CLAY, 0d01, 0d01);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=28");
                _loot(0x16, ASH, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=29");
                _loot(0x14, CLAY, 0d01, 0d00);
            }
        }

        fun trigger_enter() {
            default_init_room(True, True);
        }
    };

    area pipe_maze() {
        enum PIPE_MAZE {
            MARIO_BOSS_ROOM_OPEND = memory(FLAG, SRAM),
            HIDDEN_ROOM_OPEND = memory(FLAG, SRAM),

            MUSIC_ENTRANCE = 0x72,
            MUSIC_MAZE = 0x72,
        }

        map pipe_entrance(PIPEMAZE_ROOMS) {
            // sniff=none

            enum entrance {
                pipe_east = entrance(0x2d, 0x17, NONE),
                south = entrance(0x1a, 0x2f, NORTH),
                pipe_west = entrance(0x07, 0x17, NONE),

                bonfire = entrance(0d14, 0d31, NONE, { bonfire_wakeup(-0d32, 0d8, 0d32, 0d8); }),
            }
            
            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_ENTRANCE, 0xff)
            }

            enum ROOM {
                DEBUG = False,

                SECRET_PASSAGE_TRIGGER = memory(WORD, TEMP),
                SECRET_PASSAGE_DISTANCE = 0x20,

                GOURD = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                switch_triggered = nop(),
                exit_room_switch = nop(),
                exit_room_gate = nop(),
                exit_room_empty = nop(),
                exit_north_1 = @install() {
                    map_transition(pipe_entrance_left, pipe_switch, NORTH);
                },
                exit_north_2 = @install() {
                    map_transition(pipe_maze, pipe_east, NORTH);
                },
                jump_room_switch = nop(),
                jump_room_gate = nop(),
                exit_south = @install() {
                    map_transition(pipe_caves_1, north, SOUTH);
                },
                jump_empty_room = nop(),

                exit_gate = nop(),
                approach_gate = nop(),
            }

            fun gourd_looted() {
                bonfire(0d14, 0d31, SOULS_MEMORY.BONFIRE_PIPES);
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                b_trigger_2 = @install() {
                    debug_subtext("B=2");
                },
                b_trigger_3 = @install() {
                    debug_subtext("B=3");
                },
                b_trigger_4 = @install() {
                    debug_subtext("B=4");
                },
                b_trigger_5 = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                b_trigger_7 = @install() {
                    debug_subtext("B=7");
                },
                b_trigger_8 = @install() {
                    debug_subtext("B=8");
                },
                b_trigger_9 = @install() {
                    sound(WEIRD_SOUND);
                    set(ROOM.GOURD);
                    object[0x07] = 0x02; // loot gourd_entrance
                    gourd_looted();
                },

                b_trigger_10 = @install() {
                    debug_subtext("B=10");
                },
                b_trigger_11 = @install() {
                    debug_subtext("B=11");
                },
                b_trigger_12 = @install() {
                    debug_subtext("B=12");
                },
                b_trigger_13 = @install() {
                    debug_subtext("B=13");
                },
            }

            @install()
            @async()
            fun hidden_exit_check() {
                while(True) {
                    arg[0x00] = <ACTIVE>[X];
                    arg[0x02] = <ACTIVE>[Y];
                    arg[0x04] = ROOM.SECRET_PASSAGE_TRIGGER[X];
                    arg[0x06] = ROOM.SECRET_PASSAGE_TRIGGER[Y];

                    if(arg[0x00] < arg[0x04]) {
                        arg[0x08] = arg[0x04] - arg[0x00];
                    } else {
                        arg[0x08] = arg[0x00] - arg[0x04];
                    }

                    if(arg[0x02] < arg[0x06]) {
                        arg[0x0a] = arg[0x06] - arg[0x02];
                    } else {
                        arg[0x0a] = arg[0x02] - arg[0x06];
                    }

                    if((arg[0x08] <= ROOM.SECRET_PASSAGE_DISTANCE) && (arg[0x0a] <= ROOM.SECRET_PASSAGE_DISTANCE)) {
                        map_transition(eastern_barrier, east, WEST);
                        end();
                    }
                    yield();

                    if(ROOM.DEBUG) {
                        debug_memory(arg[0x08], arg[0x0a]);
                        sleep(0x20);
                    }
                }
            }

            @install()
            fun test_triggered() {
                if(PIPE_MAZE.HIDDEN_ROOM_OPEND) {
                    map_transition(pipe_caves_side, pipe, EAST);
                } else {
                    error_message(DOOR_CONTRAPTION);
                }
            }
            
            @install()
            fun debug_triggered() {
                set(PIPE_MAZE.HIDDEN_ROOM_OPEND);

                destroy(SCRIPT_OWNER);
            }

            fun trigger_enter() {
                if(FLAG.DEBUG) {
                    if!(PIPE_MAZE.HIDDEN_ROOM_OPEND) {
                        add_debug_entity(0x2F, 0x1b, reference(debug_triggered));
                    }
                }

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    add_enemy(RAT, 0d38, 0d33);
                }

                if(ROOM.GOURD) {
                    object[0x07] = 0x02; // loot gourd_entrance
                    gourd_looted();
                } else {
                    object[0x07] = 0x01; // loot gourd_entrance
                }
                // bonfire(0x1e, 0x22);

                default_init_room(True, False);

                if(SOULS_MEMORY.BIG_MUSHROOM) {
                    CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
                }

                add_enemy(PLACEHOLDER, 0x2d, 0x16);
                attach_script(LAST_ENTITY, B, reference(test_triggered));
                
                add_enemy(PLACEHOLDER, 0x05, 0x16);
                ROOM.SECRET_PASSAGE_TRIGGER = <LAST_ENTITY>;

                sleep(0x10);
                hidden_exit_check();
            }
        };

        map pipe_entrance_left(PIPEMAZE_ROOMS) {
            // sniff=none

            enum entrance {
                pipe_switch = entrance(0xbf, 0x23, NONE),
                pipe_gate = entrance(0x87, 0x1f, NONE),
                gate = entrance(0x98, 0x10, SOUTH),
            }

            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_ENTRANCE, 0xff)
            }

            enum stepon_trigger {
                switch_triggered = @install() {
                    debug_subtext("S=0");

                    if!(PIPE_MAZE.HIDDEN_ROOM_OPEND) {
                        sound(MAGMA_HARDENING);

                        notification_door_opened();

                        set(PIPE_MAZE.HIDDEN_ROOM_OPEND);
                    }
                },
                exit_room_switch = @install() {
                    debug_subtext("S=1");

                    map_transition(mosquito_arena, right, NORTH);
                },
                exit_room_gate = @install() {
                    debug_subtext("S=2");

                    map_transition(pipe_maze, pipe_west, NONE);
                },
                exit_room_empty = nop(),
                exit_north_1 = nop(),
                exit_north_2 = nop(),
                jump_room_switch = @install() {
                    debug_subtext("S=6");

                    call(0x94af0d);
                },
                jump_room_gate = @install() {
                    debug_subtext("S=7");

                    call(0x94af34);
                },
                exit_south = nop(),
                jump_empty_room = nop(),

                exit_gate = @install() {
                    debug_subtext("S=10");

                    map_transition(mario_dungeon_boss, south, NORTH);
                },
                approach_gate = @install() {
                    debug_subtext("S=11");

                    if!(PIPE_MAZE.MARIO_BOSS_ROOM_OPEND) {
                        subtext("Locked by a mechanism.");
                    }
                },
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                b_trigger_2 = @install() {
                    debug_subtext("B=2");
                },
                b_trigger_3 = @install() {
                    debug_subtext("B=3");
                },
                b_trigger_4 = @install() {
                    debug_subtext("B=4");
                },
                b_trigger_5 = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                b_trigger_7 = @install() {
                    debug_subtext("B=7");
                },
                b_trigger_8 = @install() {
                    debug_subtext("B=8");
                },
                b_trigger_9 = @install() {
                    debug_subtext("B=9");
                },

                b_trigger_10 = @install() {
                    debug_subtext("B=10");
                },
                b_trigger_11 = @install() {
                    debug_subtext("B=11");
                },
                b_trigger_12 = @install() {
                    debug_subtext("B=12");
                },
                b_trigger_13 = @install() {
                    debug_subtext("B=13");
                },
            }

            fun open_gate() {
                object[0x06] = 0x7e; // open gate
            }

            @install()
            fun debug_triggered() {
                PIPE_MAZE.MARIO_BOSS_ROOM_OPEND = True;
                open_gate();

                destroy(SCRIPT_OWNER);
            }

            fun trigger_enter() {
                if(PIPE_MAZE.MARIO_BOSS_ROOM_OPEND) {
                    open_gate();
                }

                if(FLAG.DEBUG) {
                    if!(PIPE_MAZE.MARIO_BOSS_ROOM_OPEND) {
                        add_debug_entity(0x9c, 0x17, reference(debug_triggered));
                    }
                }

                default_init_room(True, False);

                if(SOULS_MEMORY.BIG_MUSHROOM) {
                    CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
                }
            }
        };

        map mosquito_arena(RAPTORS) {
            // sniff=vanilla

            enum entrance {
                north = entrance(0x1b, 0x03, SOUTH),
                south = entrance(0x1d, 0x33, NORTH),

                left = entrance(0x15, 0x1c, NONE, { crash_both(); }),
                center = entrance(0x1e, 0x21, NONE, { crash_both(); }),
                right = entrance(0x2a, 0x23, NONE, { crash_both(); }),
            }

            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_ENTRANCE, 0xff),
                boss = soundtrack(BOSS_JUNGLE, 0xff),
            }

            enum stepon_trigger {
                exit_north = @install() {
                    fog_wall_inside(!SOULS_MEMORY.DEAD_ARENA_MOSQUITO, SOUTH);

                    map_transition(pipe_caves_1, south_2, NORTH);
                },
                exit_south = nop(),
                center = nop(),
            }
                
            enum b_trigger {
                sniff__1_crystal_1 = @install() {
                    debug_subtext("B=0");
                    _loot(0x09, CRYSTAL, 0d01, 0d01);
                },
                sniff__1_oil_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x08, OIL, 0d01, 0d01);
                },
                sniff__1_crystal_2 = @install() {
                    debug_subtext("B=2");
                    _loot(0x07, CRYSTAL, 0d01, 0d02);
                },
                sniff__1_water_2 = @install() {
                    debug_subtext("B=3");
                    _loot(0x06, WATER, 0d01, 0d02);
                },
            }

            enum BOSS {
                PROGRESS = memory(FLAG, TEMP),
                BOSS_ID = memory(WORD, TEMP),

                BOSS_START_X = memory(WORD, TEMP),
                BOSS_START_Y = memory(WORD, TEMP),
                BOSS_START_TIMER = memory(WORD, TEMP),

                MOSQUITO_1_ID = memory(WORD, TEMP),
                MOSQUITO_1_X = 0x13,
                MOSQUITO_1_Y = 0x19,
                MOSQUITO_2_ID = memory(WORD, TEMP),
                MOSQUITO_2_X = 0x29,
                MOSQUITO_2_Y = 0x1b,
                MOSQUITO_3_ID = memory(WORD, TEMP),
                MOSQUITO_3_X = 0x13,
                MOSQUITO_3_Y = 0x29,
                MOSQUITO_4_ID = memory(WORD, TEMP),
                MOSQUITO_4_X = 0x29,
                MOSQUITO_4_Y = 0x2b,
            }

            fun close_exits(close) {
                if(close) {
                    object[0x04] = 0x04;
                } else {
                    object[0x05] = 0x04;
                }
            }

            @install()
            fun boss_defeated() {
                BOSS.PROGRESS = False;

                souls_boss_defeated(DEAD_ARENA_MOSQUITO, REWARD_ARENA_MOSQUITO);

                close_exits(False);

                damage(BOSS.MOSQUITO_1_ID, 0d999, True);
                damage(BOSS.MOSQUITO_2_ID, 0d999, True);
                damage(BOSS.MOSQUITO_3_ID, 0d999, True);
                damage(BOSS.MOSQUITO_4_ID, 0d999, True);
            }

            fun mosquito_dead(id, x, y) {
                if(BOSS.PROGRESS) {
                    // yield();
                    animate(SCRIPT_OWNER, ONCE_FREEZE, ANIMATION_ENEMY.GORE);
                    attribute(SCRIPT_OWNER, INVINCIBLE, True);

                    if((BOSS.BOSS_ID[X] >= MEMORY.CAMERA_X_MIN) && ((BOSS.BOSS_ID[X] <= MEMORY.CAMERA_X_MAX)) && (BOSS.BOSS_ID[Y] >= MEMORY.CAMERA_Y_MIN) && ((BOSS.BOSS_ID[Y] <= MEMORY.CAMERA_Y_MAX))) {
                        cast(id, BOSS.BOSS_ID, FIREBALL, 0d250);
                    } else {
                        cast(id, BOY, FIREBALL, 0d10);
                    }

                    sleep(0d30);
                    animate(SCRIPT_OWNER, ONCE_FREEZE, INVISIBLE);
                    teleport(id, x, y);
                    sleep(0d90);

                    // full_heal(SCRIPT_OWNER, 0x10, False);
                    animate(SCRIPT_OWNER, ONCE, DEFAULT);
                    <SCRIPT_OWNER>[PALETTE] = 0x0a00;
                    attribute(SCRIPT_OWNER, INVINCIBLE, False);
                }
            }

            @install()
            fun mosquito_1_dead() {
                mosquito_dead(BOSS.MOSQUITO_1_ID, BOSS.MOSQUITO_1_X, BOSS.MOSQUITO_1_Y);
            }
            @install()
            fun mosquito_2_dead() {
                mosquito_dead(BOSS.MOSQUITO_2_ID, BOSS.MOSQUITO_2_X, BOSS.MOSQUITO_2_Y);
            }
            @install()
            fun mosquito_3_dead() {
                mosquito_dead(BOSS.MOSQUITO_3_ID, BOSS.MOSQUITO_3_X, BOSS.MOSQUITO_3_Y);
            }
            @install()
            fun mosquito_4_dead() {
                mosquito_dead(BOSS.MOSQUITO_4_ID, BOSS.MOSQUITO_4_X, BOSS.MOSQUITO_4_Y);
            }

            fun spawn_mosquito(id, x, y, script_id) {
                add_enemy(MOSQUITO, x, y);
                id = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, script_id);
            }

            @install()
            @async()
            fun lock_temporary() {
                BOSS.BOSS_START_X = BOSS.BOSS_ID[X];
                BOSS.BOSS_START_Y = BOSS.BOSS_ID[Y];

                while(BOSS.BOSS_START_TIMER < 0d120) {
                    BOSS.BOSS_START_TIMER++;

                    BOSS.BOSS_ID[X] = BOSS.BOSS_START_X;
                    BOSS.BOSS_ID[Y] = BOSS.BOSS_START_Y;

                    yield();
                }
            }

            fun init_room() {
                default_init_room(True, False);
            }

            fun trigger_enter() {
                if!(SOULS_MEMORY.DEAD_ARENA_MOSQUITO) {
                    push_music(BOSS_JUNGLE);

                    close_exits(True);

                    add_enemy(MAGMAR, 0x1e, 0x21);
                    animate(LAST_ENTITY, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);
                    BOSS.BOSS_ID = <LAST_ENTITY>;
                    attach_script(LAST_ENTITY, DEATH, reference(boss_defeated));
                    lock_temporary();

                    CUSTOM_FLAG.NO_DOG = True;
                    init_room();

                    BOSS.PROGRESS = True;

                    spawn_mosquito(BOSS.MOSQUITO_1_ID, BOSS.MOSQUITO_1_X, BOSS.MOSQUITO_1_Y, reference(mosquito_1_dead));
                    sleep(0x40);
                    spawn_mosquito(BOSS.MOSQUITO_2_ID, BOSS.MOSQUITO_2_X, BOSS.MOSQUITO_2_Y, reference(mosquito_2_dead));
                    sleep(0x20);
                    spawn_mosquito(BOSS.MOSQUITO_3_ID, BOSS.MOSQUITO_3_X, BOSS.MOSQUITO_3_Y, reference(mosquito_3_dead));
                    sleep(0x20);
                    spawn_mosquito(BOSS.MOSQUITO_4_ID, BOSS.MOSQUITO_4_X, BOSS.MOSQUITO_4_Y, reference(mosquito_4_dead));
                } else {
                    object[0x04] = 0x04;
                    object[0x05] = 0x04;

                    init_room();
                }
            }
        };

        map pipe_caves_1(VOLCANO_ROOMS) { // variant: room_nss
            // sniff=none

            enum entrance {
                north = entrance(0x9e, 0x05, SOUTH),
                south_1 = entrance(0x9e, 0x37, NORTH),
                south_2 = entrance(0x84, 0x37, NORTH),
            }

            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_ENTRANCE, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_room_nne_north_2 = nop(),
                exit_south_2 = @install() {
                    if!(SOULS_MEMORY.DEAD_ARENA_MOSQUITO) {
                        error_message(DOOR_WRONG_SIDE, NORTH);
                    } else {
                        map_transition(mosquito_arena, north, SOUTH);
                    }
                },
                exit_south_1 = @install() {
                    map_transition(pipe_caves_2, north, SOUTH);
                },
                exit_north = @install() {
                    map_transition(pipe_entrance, south, NORTH);
                },
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff__1_roots = @install() {
                    debug_subtext("B=15");
                    _loot(0x0b, ROOTS, 0d01, 0d00);
                },
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff__1_wax = @install() {
                    debug_subtext("B=22");
                    _loot(0x12, WAX, 0d01, 0d00);
                },
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0x01) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0x02) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0x03) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0x04) {
                    init_map(0xb4, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0x05) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0x06) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_nne
                } else if(index == 0x07) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0x08) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_entrance
                } else if(index == 0x09) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0x0a) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_s
                } else if(index == 0x0b) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_shop
                }
            }

            fun trigger_enter() {
                init_room(0x03);

                default_init_room(True, False);

                if(SOULS_MEMORY.BIG_MUSHROOM) {
                    CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
                }
            }
        };
        map pipe_caves_2(VOLCANO_ROOMS) { // variant: room_alchemist
            // chests=vanilla
            // sniff=none
            
            enum entrance {
                north = entrance(0xd0, 0x05, SOUTH),
            }

            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_ENTRANCE, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_north = @install() {
                    map_transition(pipe_caves_1, south_1, NORTH);
                },
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff__1_ash = @install() {
                    debug_subtext("B=0");
                    _loot(0x17, ASH, 0d01, 0d00);
                },
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_west__3_water = @install() {
                    debug_subtext("B=6");
                    _loot_chest(0x02, WATER, 0d03);
                },
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_hidden_2__5_wax = @install() {
                    debug_subtext("B=9");
                    _loot_chest(0x06, WAX, 0d05);
                },
                gourd_hidden_1__6_water = @install() {
                    debug_subtext("B=10");
                    _loot_chest(0x07, WATER, 0d06);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0x01) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0x02) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0x03) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0x04) {
                    init_map(0xb4, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0x05) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0x06) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_nne
                } else if(index == 0x07) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0x08) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_entrance
                } else if(index == 0x09) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0x0a) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_s
                } else if(index == 0x0b) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_shop
                }
            }

            @install()
            fun stone_locked() {
                add_enemy(STONE_ROUND, 0d222, 0d39);
                attach_script(LAST_ENTITY, B, reference(@install() { error_message(); }));

                init_map(0xb4, 0x04, 0xe0, 0x36); // room_alchemist
            }
            @install()
            fun stone_unlocked() {
                add_enemy(STONE_ROUND, 0d222, 0d39);
                // add_enemy(STONE_ROUND, 0xdc, 0x26);

                init_room(0x04);
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_SIDE_QUESTS || (NPC_MARIO.PROGRESS == 0d0)) {
                    if(NPC_MARIO.PROGRESS < 0d1) {
                        stone_locked();
                    } else if(NPC_MARIO.PROGRESS == 0d1) {
                        add_enemy(STONE_ROUND, 0d222, 0d39);
                        attach_script(LAST_ENTITY, B, reference(npc_mario_dialog_1));

                        if(NPC_MARIO.SUB_PROGRESS > 0x00) {
                            add_souls_npc_mario(0d229, 0d39, INACTIVE);
                            face(LAST_ENTITY, WEST);

                            init_room(0x04);
                        } else {
                            init_map(0xb4, 0x04, 0xe0, 0x36); // room_alchemist
                        }
                    } else {
                        stone_unlocked();
                    }
                } else {
                    stone_locked();
                }
                
                default_init_room(True, False);

                if(SOULS_MEMORY.BIG_MUSHROOM) {
                    CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
                }

                fake_walls();
            }
        };

        map pipe_caves_side(IVOR_SEWERS_EXTERIOR) {
            enum entrance {
                west = entrance(0x05, 0x0b, EAST),
                pipe = entrance(0x05, 0x15, NONE),

                cinematic_east = entrance(0x2d, 0x7, NONE),
            }

            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_ENTRANCE, 0xff)
            }

            enum stepon_trigger {
                pipe = @install() {
                    pit_act3_sewers();
                },
                exit_west = @install() {
                    map_transition(pipe_caves_1, south_2, WEST);
                },
            }

            @install()
            fun debug_triggered() {
                set(SOULS_MEMORY.BIG_MUSHROOM);
                CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;

                destroy(SCRIPT_OWNER);
            }

            fun trigger_enter() {
                if(FLAG.DEBUG) {
                    if!(SOULS_MEMORY.BIG_MUSHROOM) {
                        add_debug_entity(0x0c, 0x0e, reference(debug_triggered));
                    }
                }

                if(SOULS_MEMORY.WITH_SIDE_QUESTS) {
                    if(NPC_MARIO.PROGRESS == 0d2) {
                        add_souls_npc_mario(0d13, 0d32);
                        // NPC_MARIO.ID = <LAST_ENTITY>;
                        attach_script(LAST_ENTITY, B, reference(npc_mario_dialog_2));
                    }
                }

                default_init_room(True, True);

                if(SOULS_MEMORY.BIG_MUSHROOM) {
                    CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
                }
            }
        };

        map pipe_maze(PIPEMAZE) {
            enum entrance {
                pipe_east = entrance(0x67, 0x94, NONE),
                pipe_west = entrance(0x5b, 0x94, NONE),
            }

            enum soundtrack {
                default = soundtrack(PIPE_MAZE.MUSIC_MAZE, 0xff)
            }

            enum ROOM {
                WITH_STERLING_RATS = True,
                DEBUG_STERLING_RATS = False,
            }

            fun pit_west_1_triggered() {
                map_transition(mario_prison_2, crash, NONE);
            }
            fun pit_west_2_triggered() {
                map_transition(mario_prison_1, crash, NONE);
            }
            fun pit_west_3_triggered() {
                map_transition(mario_prison_4, crash, NONE);
            }
            fun pit_west_4_triggered() {
                map_transition(mario_prison_5, pipe, NONE);
            }
            fun pit_west_5_triggered() {
                map_transition(mario_prison_3, crash, NONE);
            }

            fun pit_east_1_triggered() {
                map_transition(town_center, crash, NONE);
            }
            fun pit_east_2_triggered() {
                map_transition(town_market, crash, NONE);
            }
            fun pit_east_3_triggered() {
                map_transition(town_level_1, crash, NONE);
            }
            fun pit_east_4_triggered() {
                map_transition(town_level_2, crash, NONE);
            }
            fun pit_east_5_triggered() {
                map_transition(town_level_3, crash, NONE);
            }

            enum stepon_trigger {
                pit_west_3_west = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.EAST);
                    pit_west_3_triggered();
                },
                exit_room_nw_west = @install() {
                    debug_subtext("S=1");
                },
                crossing_pit_east_3_2 = @install() {
                    object[0x06] = 0x00;
                },
                crossing_pit_east_1_3 = @install() {
                    object[0x06] = 0x01;
                },
                crossing_pit_west_1_top = @install() {
                    debug_subtext("S=4");
                },
                crossing_pit_west_4_2_top = @install() {
                    debug_subtext("S=5");
                },
                crossing_pit_west_1_bottom = @install() {
                    debug_subtext("S=6");
                },
                crossing_pit_west_4_2_bottom = @install() {
                    debug_subtext("S=7");
                },
                crossing_pit_west_3_2_bottom = @install() {
                    debug_subtext("S=8");
                },
                crossing_pit_west_3_2_top = @install() {
                    debug_subtext("S=9");
                },

                crossing_pit_west_1_4_top_1 = @install() {
                    debug_subtext("S=10");
                },
                crossing_pit_west_1_4_top_2 = @install() {
                    debug_subtext("S=11");
                },
                crossing_pit_west_1_4_bottom_2 = @install() {
                    debug_subtext("S=12");
                },
                crossing_pit_west_1_4_bottom_1 = @install() {
                    debug_subtext("S=13");
                },
                crossing_pit_west_4_top = @install() {
                    debug_subtext("S=14");
                },
                crossing_pit_west_4_bottom = @install() {
                    debug_subtext("S=15");
                },
                crossing_pit_west_1_3_top = @install() {
                    debug_subtext("S=16");
                },
                crossing_pit_west_1_3_bottom = @install() {
                    debug_subtext("S=17");
                },
                crossing_pit_east_1_2 = @install() {
                    object[0x07] = 0x01;
                },
                pit_west_3_north = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_west_3_triggered();
                },

                pit_west_3_east = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.WEST);
                    pit_west_3_triggered();
                },
                pit_west_3_south = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.NORTH);
                    pit_west_3_triggered();
                },
                pit_west_4_north = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_west_4_triggered();
                },
                pit_west_4_east = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.WEST);
                    pit_west_4_triggered();
                },
                pit_west_4_south = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.NORTH);
                    pit_west_4_triggered();
                },
                pit_west_5_north = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_west_5_triggered();
                },
                pit_west_5_west = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.EAST);
                    pit_west_5_triggered();
                },
                pit_west_2_west = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.EAST);
                    pit_west_2_triggered();
                },
                pit_west_2_north = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_west_2_triggered();
                },
                pit_west_2_east = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.WEST);
                    pit_west_2_triggered();
                },

                pit_west_1_west = @install() {
                    generic_yeet(<ACTIVE>, DIRECTION.EAST);
                    pit_west_1_triggered();
                },
                pit_east_1_north = @install() {
                    // <0x24b3> = 0x0002;
                    // <0x24b5> = 0x002d;
                    // <0x24b7> = 0x0000;

                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_east_1_triggered();
                },
                pit_east_1_south = @install() {
                    // <0x24b3> = 0x002a;
                    // <0x24b5> = 0x0023;
                    // <0x24b7> = 0x0000;
                    
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.NORTH);
                    pit_east_1_triggered();
                },
                pit_east_5_north = @install() {
                    // <0x24c3> = 0x0008;
                    // <0x24b3> = 0x0002;
                    // <0x24b5> = 0x002d;
                    // <0x24b7> = 0x0000;
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_east_5_triggered();
                },
                pit_east_4_south = @install() {
                    // <0x24c3> = 0x0007;
                    // <0x24b3> = 0x002a;
                    // <0x24b5> = 0x0023;
                    // <0x24b7> = 0x0000;
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.NORTH);
                    pit_east_4_triggered();
                },
                pit_east_3_north = @install() {
                    // <0x24c3> = 0x0009;
                    // <0x24b3> = 0x0002;
                    // <0x24b5> = 0x002d;
                    // <0x24b7> = 0x0000;
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_east_3_triggered();
                },
                pit_east_3_west = @install() {
                    // <0x24c3> = 0x0009;
                    // <0x24b3> = 0x0002;
                    // <0x24b5> = 0x0022;
                    // <0x24b7> = 0x0016;
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.EAST);
                    pit_east_3_triggered();
                },
                pit_east_2_north = @install() {
                    // <0x24c3> = 0x000a;
                    // <0x24b3> = 0x0002;
                    // <0x24b5> = 0x002d;
                    // <0x24b7> = 0x0000;
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.SOUTH);
                    pit_east_2_triggered();
                },
                pit_east_2_east = @install() {
                    // <0x24c3> = 0x000a;
                    // <0x24b3> = 0x0002;
                    // <0x24b5> = 0x0022;
                    // <0x24b7> = -0x0011;
                    // call(0x94ac56);

                    generic_yeet(<ACTIVE>, DIRECTION.WEST);
                    pit_east_2_triggered();
                },
            }

            fun trigger_enter() {
                default_init_room(True, False);

                if(SOULS_MEMORY.BIG_MUSHROOM) {
                    CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.MARIO;
                }

                // west
                add_enemy(FRIPPO, 0d91, 0d125);
                attribute(LAST_ENTITY, INVINCIBLE, True);

                // east
                if(ROOM.WITH_STERLING_RATS) {
                    // south west
                    add_enemy(RAT_RED, 0d103, 0d120);
                    attach_sterling_script(<LAST_ENTITY>, False, 0d20, 0d130, 0d85, 0d784, 0d999);

                    add_enemy(RAT_RED, 0d103, 0d84); // 0d116, 0d77);
                    attach_sterling_script(<LAST_ENTITY>, False, 0d20, 0d130, 0d85, 0d784, 0d999); // TODO: doesn't trigger anymore

                    // south east
                    add_enemy(RAT_RED, 0d154, 0d111);
                    attach_sterling_script(<LAST_ENTITY>, False, 0d20, 0d130, 0d85, 0d784, 0d999);

                    add_enemy(RAT_RED, 0d139, 0d103);
                    attach_sterling_script(<LAST_ENTITY>, False, 0d20, 0d130, 0d85, 0d784, 0d999);

                    sterling_rats_scanner(0d103, 0d136);
                }
            }
        };

        area mario_dungeon() {
            enum MARIO {
                DEFAULT_MUSIC = MUSIC.SWAMP_AMBIENT,

                ROOMS_CLEARED = memory(BYTE, SRAM),
                ROOMS_REQUIRED = 0d3, // was 5/5
            }

            group mario_helper() {
                fun exit_mario_prison() {
                    map_transition(pipe_entrance, pipe_east, NORTH);
                }
                fun room_cleared(flag) {
                    if!(flag) {
                        set(flag);

                        MARIO.ROOMS_CLEARED++;

                        if(MARIO.ROOMS_CLEARED == MARIO.ROOMS_REQUIRED) {
                            PIPE_MAZE.MARIO_BOSS_ROOM_OPEND = True;
                            notification_door_opened();

                            dialog("[SLOW]A big door has opened somewhere as well.[B]");
                        }
                    }
                }

                fun update_condition(doors_opened, doors, enemies_killed, enemies) {
                    if(doors == 0d0) {
                        MEMORY.STRING_PARAMETER_1 = enemies_killed;
                        MEMORY.STRING_PARAMETER_2 = enemies;
                        
                    } else if(enemies == 0d0) {
                        MEMORY.STRING_PARAMETER_1 = doors_opened;
                        MEMORY.STRING_PARAMETER_2 = doors;
                    }

                    subtext("[MEM1]/[MEM2]");
                }
                fun room_condition(room_cleared_flag, doors_opened, doors, enemies_killed, enemies) {
                    if(False) {
                        debug_memory(doors_opened, doors);
                        sleep(0d60);
                        debug_memory(enemies_killed, enemies);
                        sleep(0d60);
                    }

                    if((doors == 0d0) && (enemies > 0d0)) {
                        MEMORY.STRING_PARAMETER_1 = enemies;
                        subtext("Kill [MEM1] enemies");
                    } else if((doors > 0d0) && (enemies == 0d0)) {
                        MEMORY.STRING_PARAMETER_1 = doors;
                        subtext("Open [MEM1] doors");
                    } else {
                        subtext("Reach the door");
                        end();
                    }

                    while((doors_opened < doors) || (enemies_killed < enemies)) {
                        yield();
                    }

                    subtext("The door has opened");

                    room_cleared(room_cleared_flag);
                }

                fun door_triggered(object_id, room_cleared_flag) {
                    if!(room_cleared_flag) {
                        error_message(DOOR_CONTRAPTION);
                        end();
                    }

                    // TODO: vanilla_act3_sewer_door
                    object[object_id] = 0x01; // opens door

                    exit_mario_prison();
                }


                fun koopa_rolling(enemy) {
                    animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.LIZARD_ROLL);

                    if(True) {
                        if(<BOY>[Y] < enemy[Y]) {
                            arg[0x10] = enemy[Y] - <BOY>[Y];
                        } else {
                            arg[0x10] = <BOY>[Y] - enemy[Y];
                        }

                        if(arg[0x10] <= 0d5) {
                            if(<BOY>[X] > enemy[X]) {
                                face(enemy, WEST);
                            } else if(<BOY>[X] < enemy[X]) {
                                face(enemy, EAST);
                            }
                        } else {
                            if(<BOY>[Y] > enemy[Y]) {
                                face(enemy, NORTH);
                            } else if(<BOY>[Y] < enemy[Y]) {
                                face(enemy, SOUTH);
                            }
                        }
                    }

                    while(enemy[GENERAL_PURPOSE] == 0d2) {
                        arg[0x12] = enemy[X];
                        arg[0x14] = enemy[Y];
                        sleep(0d5);
                        
                        if((enemy[X] == arg[0x12]) && (enemy[Y] == arg[0x14])) {
                            arg[0x16]++;

                            if(arg[0x16] > 0d5) {
                                animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.LIZARD_ROLL);
                                arg[0x16] = 0d0;
                            }

                            if(enemy[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                                face(enemy, SOUTH);
                            } else if(enemy[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                                face(enemy, WEST);
                            } else if(enemy[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                                face(enemy, NORTH);
                            } else if(enemy[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                                face(enemy, EAST);
                            }
                        } else {
                            arg[0x16] = 0d0;
                        }
                    }
                }
                fun add_mario_koopa(x, y, crash) {
                    add_enemy(LIZARD, x, y);
                    attach_to_script(LAST_ENTITY);
                    <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0x0000;
                    attach_script(SCRIPT_OWNER, DAMAGE, reference(@install() {
                        if(<SCRIPT_OWNER>[GENERAL_PURPOSE] == 0d1) { // make koopa roll
                            <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0d2;

                            heal(SCRIPT_OWNER, 0x00, False);

                            yield();
                            
                            koopa_rolling(<SCRIPT_OWNER>, { nop(); });
                        } else { // make koopa duck
                            <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0d1;
                            
                            yield();
                            animate(SCRIPT_OWNER, ONCE_FREEZE, ANIMATION_ENEMY.LIZARD_DUCK_1);
                        }
                    }));
                    
                    if(crash) {
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.LIZARD_ROLL);
                        attribute(SCRIPT_OWNER, ROOT, True);

                        if(True) {
                            <SCRIPT_OWNER>[Z] = 0d4000;
                            yield();
                            while(<SCRIPT_OWNER>[Z] > 0d0) {
                                yield();
                            }
                        }

                        if(True) {
                            <SCRIPT_OWNER>[VELOCITY] = 0d30;
                            yield();
                            while(<SCRIPT_OWNER>[Z] > 0d0) {
                                yield();
                            }
                        }

                        attribute(SCRIPT_OWNER, ROOT, False);
                        animate(SCRIPT_OWNER, ONCE, DEFAULT);
                    }
                }
                fun add_mario_fireflower(x, y) {
                    add_enemy(FLOWER_ORANGE, x, y);

                    attach_script(LAST_ENTITY, B, reference(@install() {
                        destroy(SCRIPT_OWNER);
                        fake_loot();

                        CUSTOM_FLAG.START_MARIO_FIREFLOWER = True;
                    }));
                }

                @install()
                @async()
                fun stack_boy_yoshi(entity) {
                    attach_to_script(entity);

                    while(alive(<SCRIPT_OWNER>)) {
                        <BOY>[X] = <SCRIPT_OWNER>[X];
                        <BOY>[Y] = <SCRIPT_OWNER>[Y] - 0x0a;

                        if((<BOY>[FACE_DIRECTION] != arg[0x10]) || (arg[0x12] > 0d40)) {
                            arg[0x12] = 0d0;

                            if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                                face(SCRIPT_OWNER, SOUTH);
                                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y] - 0d64, NONE);
                            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                                face(SCRIPT_OWNER, WEST);
                                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X] + 0d64, <SCRIPT_OWNER>[Y], NONE);
                            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                                face(SCRIPT_OWNER, NORTH);
                                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y] + 0d64, NONE);
                            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                                face(SCRIPT_OWNER, EAST);
                                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE, <SCRIPT_OWNER>[X] - 0d64, <SCRIPT_OWNER>[Y], NONE);
                            }

                            arg[0x10] = <BOY>[FACE_DIRECTION];
                        } else {
                            arg[0x12]++;
                        }

                        sleep(0x01);
                    }
                }

                fun add_yoshi(x, y) {
                    add_enemy(RAPTOR_GREEN, x, y);
                    // add_enemy(RAPTOR_GREEN, 0x36, 0x30, INACTIVE);
                    control(LAST_ENTITY, True);
                    attribute(LAST_ENTITY, INVINCIBLE, True);
                }
            };

            map mario_prison_1(IVOR_EBON_PRISON) { // goombas
                enum entrance {
                    door = entrance(0x2e, 0x11, SOUTH),
                    cave_1 = entrance(0x18, 0x1d, SOUTH),
                    cave_2 = entrance(0x47, 0x11, SOUTH),
                    cave_3 = entrance(0x56, 0x39, SOUTH),
                    // ???
                    cave_5 = entrance(0x47, 0x3d, SOUTH),
                    cave_6 = entrance(0x21, 0x39, SOUTH),
                    cave_7 = entrance(0x0c, 0x2f, SOUTH),

                    crash = entrance(0x36, 0x35, NONE, { crash_both(); }),
                }

                enum soundtrack {
                    default = soundtrack(MARIO.DEFAULT_MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = False,

                    ROOM_CLEARED = memory(FLAG, SRAM),

                    ENEMY_COUNT = memory(WORD, TEMP),
                    KILL_COUNT = memory(WORD, TEMP),
                    KILLS_REQUIRED = 0d7,
                    GATE_COUNT = memory(WORD, TEMP),
                    GATES_REQUIRED = 0d0,

                    CELL_1_CLEARED = memory(FLAG, TEMP),
                    CELL_2_CLEARED = memory(FLAG, TEMP),
                    CELL_3_CLEARED = memory(FLAG, TEMP),
                    CELL_4_CLEARED = memory(FLAG, TEMP),
                    CELL_5_CLEARED = memory(FLAG, TEMP),
                    CELL_6_CLEARED = memory(FLAG, TEMP),
                    CELL_7_CLEARED = memory(FLAG, TEMP),
                }

                fun add_mario_frippo(x, y) {
                    add_enemy(FRIPPO, x, y);
                    attach_script(LAST_ENTITY, DEATH, reference(@install() {
                        ROOM.ENEMY_COUNT--;
                        ROOM.KILL_COUNT++;

                        update_condition(ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }));

                    ROOM.ENEMY_COUNT++;
                }

                fun init_gate(index, flag) {
                    if(flag) {
                        ROOM.GATE_COUNT++;

                        if(index == 0x01) {
                            object[0x00] = 0x01; // press switch_1
                            object[0x01] = 0x7e; // opens gate_1
                        } else if(index == 0x02) {
                            object[0x08] = 0x01; // press switch_2
                            object[0x07] = 0x7e; // opens gate_2
                        } else if(index == 0x03) {
                            object[0x0a] = 0x01; // press switch_3
                            object[0x09] = 0x7e; // opens gate_3
                        } else if(index == 0x04) {
                            object[0x0e] = 0x01; // press switch_4
                            object[0x0c] = 0x7e; // opens gate_4
                        } else if(index == 0x05) {
                            object[0x0d] = 0x01; // press switch_5
                            object[0x0b] = 0x7e; // opens gate_5
                        } else if(index == 0x06) {
                            object[0x05] = 0x01; // press switch_6
                            object[0x04] = 0x7e; // opens gate_6
                        } else if(index == 0x07) {
                            object[0x03] = 0x01; // press switch_7
                            object[0x02] = 0x7e; // opens gate_7
                        }
                    }
                }

                fun open_gate(index, flag) {
                    if(flag) {
                        end();
                    } else {
                        set(flag);

                        ROOM.GATE_COUNT++;

                        if(ROOM.DEBUG) {
                            debug_memory(ROOM.GATE_COUNT, ROOM.ENEMY_COUNT);
                        }

                        update_condition(ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }

                    if(index == 0x01) {
                        object[0x00] = 0x01; // press switch_1

                        object[0x01] = 0x01; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x02; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x03; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x7e; // opens gate_1
                    } else if(index == 0x02) {
                        object[0x08] = 0x01; // press switch_2

                        object[0x07] = 0x01; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x02; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x03; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x7e; // opens gate_2
                    } else if(index == 0x03) {
                        object[0x0a] = 0x01; // press switch_3

                        object[0x09] = 0x01; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x02; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x03; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x7e; // opens gate_3
                    } else if(index == 0x04) {
                        object[0x0e] = 0x01; // press switch_4

                        object[0x0c] = 0x01; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x02; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x03; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x7e; // opens gate_4
                    } else if(index == 0x05) {
                        object[0x0d] = 0x01; // press switch_5

                        object[0x0b] = 0x01; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x02; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x03; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x7e; // opens gate_5
                    } else if(index == 0x06) {
                        object[0x05] = 0x01; // press switch_6

                        object[0x04] = 0x01; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x02; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x03; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x7e; // opens gate_6
                    } else if(index == 0x07) {
                        object[0x03] = 0x01; // press switch_7

                        object[0x02] = 0x01; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x02; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x03; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x7e; // opens gate_7
                    }
                }

                fun switch_triggered(index, flag, x, y) {
                    if!(ROOM.ROOM_CLEARED) {
                        open_gate(index, flag);

                        add_mario_frippo(x, y);
                    }
                }

                enum stepon_trigger {
                    switch_6 = @install() {
                        switch_triggered(0x06, ROOM.CELL_6_CLEARED, 0x20, 0x3b);
                    },
                    switch_5 = @install() {
                        switch_triggered(0x05, ROOM.CELL_5_CLEARED, 0x47, 0x3f);
                    },
                    switch_4 = @install() {
                        switch_triggered(0x04, ROOM.CELL_4_CLEARED, 0x54, 0x3b);
                    },
                    switch_3 = @install() {
                        switch_triggered(0x03, ROOM.CELL_3_CLEARED, 0x53, 0x1d);
                    },
                    switch_2 = @install() {
                        switch_triggered(0x02, ROOM.CELL_2_CLEARED, 0x47, 0x13);
                    },
                    switch_7 = @install() {
                        switch_triggered(0x07, ROOM.CELL_7_CLEARED, 0x0d, 0x31);
                    },
                    switch_1 = @install() {
                        switch_triggered(0x01, ROOM.CELL_1_CLEARED, 0x18, 0x1e);
                    },
                    exit_door = @install() {
                        door_triggered(0x06, ROOM.ROOM_CLEARED);
                    },
                    stepon_8 = @install() {
                        debug_subtext("S=8");
                    },
                    stepon_9 = @install() {
                        debug_subtext("S=9");
                    },

                    stepon_10 = @install() {
                        debug_subtext("S=10");
                    },
                    stepon_11 = @install() {
                        debug_subtext("S=11");
                    },
                    stepon_12 = @install() {
                        debug_subtext("S=12");
                    },
                    stepon_13 = @install() {
                        debug_subtext("S=13");
                    },
                    stepon_14 = @install() {
                        debug_subtext("S=14");
                    },
                    pipe_3_1 = @install() {
                        debug_subtext("S=15");
                    },
                    pipe_1_1 = @install() {
                        debug_subtext("S=16");
                    },
                    pipe_2_1 = @install() {
                        debug_subtext("S=17");
                    },
                    pipe_2_2 = @install() {
                        debug_subtext("S=18");
                    },
                    pipe_2_3 = @install() {
                        debug_subtext("S=19");
                    },

                    pipe_1_2 = @install() {
                        debug_subtext("S=20");
                    },
                    pipe_1_3 = @install() {
                        debug_subtext("S=21");
                    },
                    pipe_1_4 = @install() {
                        debug_subtext("S=22");
                    },
                    pipe_3_2 = @install() {
                        debug_subtext("S=23");
                    },
                    pipe_3_3 = @install() {
                        debug_subtext("S=24");
                    },
                    pipe_3_4 = @install() {
                        debug_subtext("S=25");
                    },
                    exit_cell_2 = @install() {
                        debug_subtext("S=26");
                    },
                    exit_cell_3 = @install() {
                        debug_subtext("S=27");
                    },
                    exit_cell_4 = @install() {
                        debug_subtext("S=28");
                    },
                    exit_cell_5 = @install() {
                        debug_subtext("S=29");
                    },

                    exit_cell_6 = @install() {
                        debug_subtext("S=30");
                    },
                    exit_cell_7 = @install() {
                        debug_subtext("S=31");
                    },
                }

                enum b_trigger {
                    cell_1_gourd = @install() {
                        debug_subtext("B=0");
                    },
                }

                fun trigger_enter() {
                    if(ROOM.ROOM_CLEARED) {
                        set(ROOM.CELL_1_CLEARED);
                        object[0x00] = 0x01; // press switch_1
                        object[0x01] = 0x7e; // opens gate_1
                        set(ROOM.CELL_2_CLEARED);
                        object[0x08] = 0x01; // press switch_2
                        object[0x07] = 0x7e; // opens gate_2
                        set(ROOM.CELL_3_CLEARED);
                        object[0x0a] = 0x01; // press switch_3
                        object[0x09] = 0x7e; // opens gate_3
                        set(ROOM.CELL_4_CLEARED);
                        object[0x0e] = 0x01; // press switch_4
                        object[0x0c] = 0x7e; // opens gate_4
                        set(ROOM.CELL_5_CLEARED);
                        object[0x0d] = 0x01; // press switch_5
                        object[0x0b] = 0x7e; // opens gate_5
                        set(ROOM.CELL_6_CLEARED);
                        object[0x05] = 0x01; // press switch_6
                        object[0x04] = 0x7e; // opens gate_6
                        set(ROOM.CELL_7_CLEARED);
                        object[0x03] = 0x01; // press switch_7
                        object[0x02] = 0x7e; // opens gate_7
                    }

                    mario_init(False, False);

                    if!(ROOM.ROOM_CLEARED) {
                        room_condition(ROOM.ROOM_CLEARED, ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }
                }
            };

            map mario_prison_2(IVOR_EBON_PRISON) { // bowser gate
                enum entrance {
                    door = entrance(0x2e, 0x11, SOUTH),
                    cave_1 = entrance(0x18, 0x1d, SOUTH),
                    cave_2 = entrance(0x47, 0x11, SOUTH),
                    cave_3 = entrance(0x56, 0x39, SOUTH),
                    // ???
                    cave_5 = entrance(0x47, 0x3d, SOUTH),
                    cave_6 = entrance(0x21, 0x39, SOUTH),
                    cave_7 = entrance(0x0c, 0x2f, SOUTH),

                    crash = entrance(0x36, 0x35, NONE, { crash_both(); }),
                }

                enum soundtrack {
                    default = soundtrack(MARIO.DEFAULT_MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = False,

                    ENEMY_COUNT = memory(WORD, TEMP),
                    KILL_COUNT = memory(WORD, TEMP),
                    KILLS_REQUIRED = 0d0,
                    GATE_COUNT = memory(WORD, TEMP),
                    GATES_REQUIRED = 0d0,

                    ROOM_CLEARED = memory(FLAG, SRAM),
                }

                fun init_gate(index) {
                    if(index == 0x01) {
                        object[0x00] = 0x01; // press switch_1
                        object[0x01] = 0x01; // opens gate_1
                    } else if(index == 0x02) {
                        object[0x08] = 0x01; // press switch_2
                        object[0x07] = 0x02; // opens gate_2
                    } else if(index == 0x03) {
                        object[0x0a] = 0x01; // press switch_3
                        object[0x09] = 0x03; // opens gate_3
                    } else if(index == 0x04) {
                        object[0x0e] = 0x01; // press switch_4
                        object[0x0c] = 0x01; // opens gate_4
                    } else if(index == 0x05) {
                        object[0x0d] = 0x01; // press switch_5
                        object[0x0b] = 0x02; // opens gate_5
                    } else if(index == 0x06) {
                        object[0x05] = 0x01; // press switch_6
                        object[0x04] = 0x03; // opens gate_6
                    } else if(index == 0x07) {
                        object[0x03] = 0x01; // press switch_7
                        object[0x02] = 0x01; // opens gate_7
                    }
                }

                enum stepon_trigger {
                    switch_6 = nop(),
                    switch_5 = nop(),
                    switch_4 = nop(),
                    switch_3 = nop(),
                    switch_2 = nop(),
                    switch_7 = nop(),
                    switch_1 = nop(),
                    exit_door = @install() {
                        room_cleared(ROOM.ROOM_CLEARED);

                        door_triggered(0x06, ROOM.ROOM_CLEARED);
                    },
                    stepon_8 = @install() {
                        debug_subtext("S=8");
                    },
                    stepon_9 = @install() {
                        debug_subtext("S=9");
                    },

                    stepon_10 = @install() {
                        debug_subtext("S=10");
                    },
                    stepon_11 = @install() {
                        debug_subtext("S=11");
                    },
                    stepon_12 = @install() {
                        debug_subtext("S=12");
                    },
                    stepon_13 = @install() {
                        debug_subtext("S=13");
                    },
                    stepon_14 = @install() {
                        debug_subtext("S=14");
                    },
                    pipe_3_1 = @install() {
                        debug_subtext("S=15");
                    },
                    pipe_1_1 = @install() {
                        debug_subtext("S=16");
                    },
                    pipe_2_1 = @install() {
                        debug_subtext("S=17");
                    },
                    pipe_2_2 = @install() {
                        debug_subtext("S=18");
                    },
                    pipe_2_3 = @install() {
                        debug_subtext("S=19");
                    },

                    pipe_1_2 = @install() {
                        debug_subtext("S=20");
                    },
                    pipe_1_3 = @install() {
                        debug_subtext("S=21");
                    },
                    pipe_1_4 = @install() {
                        debug_subtext("S=22");
                    },
                    pipe_3_2 = @install() {
                        debug_subtext("S=23");
                    },
                    pipe_3_3 = @install() {
                        debug_subtext("S=24");
                    },
                    pipe_3_4 = @install() {
                        debug_subtext("S=25");
                    },
                    exit_cell_2 = @install() {
                        debug_subtext("S=26");
                    },
                    exit_cell_3 = @install() {
                        debug_subtext("S=27");
                    },
                    exit_cell_4 = @install() {
                        debug_subtext("S=28");
                    },
                    exit_cell_5 = @install() {
                        debug_subtext("S=29");
                    },

                    exit_cell_6 = @install() {
                        debug_subtext("S=30");
                    },
                    exit_cell_7 = @install() {
                        debug_subtext("S=31");
                    },
                }

                enum b_trigger {
                    cell_1_gourd = @install() {
                        debug_subtext("B=0");
                    },
                }

                enum BOSS {
                    DEBUG = False,

                    ID = memory(WORD, TEMP),

                    RNG = memory(WORD, TEMP),
                }

                fun shoot_boss(x, y) {
                    shoot_entity_absolute(BOSS.ID, SPEAR, x, y, 0x30, 0x00);
                }

                @install()
                @async()
                fun boss_ai_yump() {
                    while((BOSS.ID[Y] - 0x0a) < <BOY>[Y]) {
                        BOSS.RNG = randrange(0x04);
                        if(BOSS.RNG == 0x00) {
                            BOSS.ID[VELOCITY] = 0x10;
                            sleep(0x10);
                        } else if(BOSS.RNG == 0x01) {
                            BOSS.ID[VELOCITY] = 0x20;
                            sleep(0x20);
                        } else if(BOSS.RNG == 0x02) {
                            BOSS.ID[VELOCITY] = 0x30;
                            sleep(0x30);
                        }

                        sleep(0x30);
                    }
                }

                @install()
                @async()
                fun boss_ai_hammer() {
                    sleep(0d160);

                    while((BOSS.ID[Y] - 0d10) < <BOY>[Y]) {
                        BOSS.RNG = 0d1 + randrange(0d8);
                        if(BOSS.DEBUG) {
                            subtext("rng");
                        }
                        
                        animate(BOSS.ID, LOOP, ANIMATION_ENEMY.LIZARD_TALK);
                        ai_move_projectile_toss(BOSS.ID, SPEAR, <BOY>, BOSS.RNG);
                        animate(BOSS.ID, LOOP, DEFAULT);

                        sleep(0x50);
                    }
                }

                @install()
                @async()
                fun anti_yump() {
                    while((BOSS.ID[Y] - 0x0a) < <BOY>[Y]) {
                        // if(BOSS.ID[Y] < (<BOY>[Y] - 0x0a)) {
                        if(True) {
                            if((BOSS.ID[VELOCITY] > 0x00) && (<BOY>[VELOCITY] > 0x00)) {
                                damage(BOY, 0x01, True);
                            }
                        }
                        yield();
                    }
                }

                fun add_bowser_blocker(x, y) {
                    add_enemy(LIZARD, x, y, INACTIVE_IMORTAL);
                    animate(LAST_ENTITY, LOOP, ANIMATION_PLACEHOLDER.PILLAR_VIGOR);
                }

                fun add_bowser(x, y) {
                    add_enemy(LIZARD_BLACK, x, y);
                    attribute(LAST_ENTITY, ROOT, True);
                    attribute(LAST_ENTITY, INVINCIBLE, True);
                    BOSS.ID = <LAST_ENTITY>;
                    animate(LAST_ENTITY, LOOP, DEFAULT);

                    ROOM.ENEMY_COUNT++;

                    // anti_yump();
                    boss_ai_yump();
                    boss_ai_hammer();
                }

                fun trigger_enter() {
                    init_gate(0x01);
                    init_gate(0x02);
                    init_gate(0x03);
                    init_gate(0x04);
                    init_gate(0x05);
                    init_gate(0x06);
                    init_gate(0x07);

                    if!(ROOM.ROOM_CLEARED) {
                        add_bowser(0x2e, 0x19);
                        push_music(BOSS_MINI);
                    }
                    add_bowser_blocker(0x2e + 0x03, 0x19 - 0x01);
                    add_bowser_blocker(0x2e - 0x03, 0x19 - 0x01);

                    mario_init(False, False);

                    if!(ROOM.ROOM_CLEARED) {
                        CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.NORMAL;

                        room_condition(ROOM.ROOM_CLEARED, ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }
                }
            };

            map mario_prison_3(IVOR_EBON_PRISON) { // yoshi (sorry)
                enum entrance {
                    door = entrance(0x2e, 0x11, SOUTH),
                    cave_1 = entrance(0x18, 0x1d, SOUTH),
                    cave_2 = entrance(0x47, 0x11, SOUTH),
                    cave_3 = entrance(0x56, 0x39, SOUTH),
                    // ???
                    cave_5 = entrance(0x47, 0x3d, SOUTH),
                    cave_6 = entrance(0x21, 0x39, SOUTH),
                    cave_7 = entrance(0x0c, 0x2f, SOUTH),

                    crash = entrance(0x36, 0x35, NONE, { crash_both(); }),
                }

                enum soundtrack {
                    default = soundtrack(MARIO.DEFAULT_MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = False,

                    ROOM_CLEARED = memory(FLAG, SRAM),

                    ENEMY_COUNT = memory(WORD, TEMP),
                    KILL_COUNT = memory(WORD, TEMP),
                    KILLS_REQUIRED = 0d0,
                    GATE_COUNT = memory(WORD, TEMP),
                    GATES_REQUIRED = 0d7,

                    CELL_1_CLEARED = memory(FLAG, TEMP),
                    CELL_2_CLEARED = memory(FLAG, TEMP),
                    CELL_3_CLEARED = memory(FLAG, TEMP),
                    CELL_4_CLEARED = memory(FLAG, TEMP),
                    CELL_5_CLEARED = memory(FLAG, TEMP),
                    CELL_6_CLEARED = memory(FLAG, TEMP),
                    CELL_7_CLEARED = memory(FLAG, TEMP),
                }

                fun add_mario_frippo(x, y) {
                    add_enemy(FRIPPO, x, y);

                    ROOM.ENEMY_COUNT++;
                }

                fun init_gate(index, flag) {
                    if(flag) {
                        ROOM.GATE_COUNT++;

                        if(index == 0x01) {
                            object[0x00] = 0x01; // press switch_1
                            object[0x01] = 0x7e; // opens gate_1
                        } else if(index == 0x02) {
                            object[0x08] = 0x01; // press switch_2
                            object[0x07] = 0x7e; // opens gate_2
                        } else if(index == 0x03) {
                            object[0x0a] = 0x01; // press switch_3
                            object[0x09] = 0x7e; // opens gate_3
                        } else if(index == 0x04) {
                            object[0x0e] = 0x01; // press switch_4
                            object[0x0c] = 0x7e; // opens gate_4
                        } else if(index == 0x05) {
                            object[0x0d] = 0x01; // press switch_5
                            object[0x0b] = 0x7e; // opens gate_5
                        } else if(index == 0x06) {
                            object[0x05] = 0x01; // press switch_6
                            object[0x04] = 0x7e; // opens gate_6
                        } else if(index == 0x07) {
                            object[0x03] = 0x01; // press switch_7
                            object[0x02] = 0x7e; // opens gate_7
                        }
                    }
                }

                fun open_gate(index, flag) {
                    if(flag) {
                        end();
                    } else {
                        set(flag);

                        ROOM.GATE_COUNT++;

                        if(ROOM.DEBUG) {
                            debug_memory(ROOM.GATE_COUNT, ROOM.ENEMY_COUNT);
                        }

                        update_condition(ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }

                    if(index == 0x01) {
                        object[0x00] = 0x01; // press switch_1

                        object[0x01] = 0x01; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x02; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x03; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x7e; // opens gate_1
                    } else if(index == 0x02) {
                        object[0x08] = 0x01; // press switch_2

                        object[0x07] = 0x01; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x02; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x03; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x7e; // opens gate_2
                    } else if(index == 0x03) {
                        object[0x0a] = 0x01; // press switch_3

                        object[0x09] = 0x01; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x02; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x03; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x7e; // opens gate_3
                    } else if(index == 0x04) {
                        object[0x0e] = 0x01; // press switch_4

                        object[0x0c] = 0x01; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x02; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x03; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x7e; // opens gate_4
                    } else if(index == 0x05) {
                        object[0x0d] = 0x01; // press switch_5

                        object[0x0b] = 0x01; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x02; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x03; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x7e; // opens gate_5
                    } else if(index == 0x06) {
                        object[0x05] = 0x01; // press switch_6

                        object[0x04] = 0x01; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x02; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x03; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x7e; // opens gate_6
                    } else if(index == 0x07) {
                        object[0x03] = 0x01; // press switch_7

                        object[0x02] = 0x01; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x02; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x03; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x7e; // opens gate_7
                    }
                }

                enum stepon_trigger {
                    switch_6 = @install() {
                        open_gate(0x06, ROOM.CELL_6_CLEARED);

                        add_mario_frippo(0x20, 0x3b);
                    },
                    switch_5 = @install() {
                        open_gate(0x05, ROOM.CELL_5_CLEARED);

                        add_mario_frippo(0x47, 0x3f);
                    },
                    switch_4 = @install() {
                        open_gate(0x04, ROOM.CELL_4_CLEARED);

                        add_mario_frippo(0x54, 0x3b);
                    },
                    switch_3 = @install() {
                        open_gate(0x03, ROOM.CELL_3_CLEARED);

                        add_mario_frippo(0x53, 0x1d);
                    },
                    switch_2 = @install() {
                        open_gate(0x02, ROOM.CELL_2_CLEARED);

                        add_mario_frippo(0x47, 0x13);
                    },
                    switch_7 = @install() {
                        open_gate(0x07, ROOM.CELL_7_CLEARED);

                        add_mario_frippo(0x0d, 0x31);
                    },
                    switch_1 = @install() {
                        open_gate(0x01, ROOM.CELL_1_CLEARED);

                        add_mario_frippo(0x18, 0x1e);
                    },
                    exit_door = @install() {
                        door_triggered(0x06, ROOM.ROOM_CLEARED);
                    },
                    stepon_8 = @install() {
                        debug_subtext("S=8");
                    },
                    stepon_9 = @install() {
                        debug_subtext("S=9");
                    },

                    stepon_10 = @install() {
                        debug_subtext("S=10");
                    },
                    stepon_11 = @install() {
                        debug_subtext("S=11");
                    },
                    stepon_12 = @install() {
                        debug_subtext("S=12");
                    },
                    stepon_13 = @install() {
                        debug_subtext("S=13");
                    },
                    stepon_14 = @install() {
                        debug_subtext("S=14");
                    },
                    pipe_3_1 = @install() {
                        debug_subtext("S=15");
                    },
                    pipe_1_1 = @install() {
                        debug_subtext("S=16");
                    },
                    pipe_2_1 = @install() {
                        debug_subtext("S=17");
                    },
                    pipe_2_2 = @install() {
                        debug_subtext("S=18");
                    },
                    pipe_2_3 = @install() {
                        debug_subtext("S=19");
                    },

                    pipe_1_2 = @install() {
                        debug_subtext("S=20");
                    },
                    pipe_1_3 = @install() {
                        debug_subtext("S=21");
                    },
                    pipe_1_4 = @install() {
                        debug_subtext("S=22");
                    },
                    pipe_3_2 = @install() {
                        debug_subtext("S=23");
                    },
                    pipe_3_3 = @install() {
                        debug_subtext("S=24");
                    },
                    pipe_3_4 = @install() {
                        debug_subtext("S=25");
                    },
                    exit_cell_2 = @install() {
                        debug_subtext("S=26");
                    },
                    exit_cell_3 = @install() {
                        debug_subtext("S=27");
                    },
                    exit_cell_4 = @install() {
                        debug_subtext("S=28");
                    },
                    exit_cell_5 = @install() {
                        debug_subtext("S=29");
                    },

                    exit_cell_6 = @install() {
                        debug_subtext("S=30");
                    },
                    exit_cell_7 = @install() {
                        debug_subtext("S=31");
                    },
                }

                enum b_trigger {
                    cell_1_gourd = @install() {
                        debug_subtext("B=0");
                    },
                }

                fun trigger_enter() {
                    if(ROOM.ROOM_CLEARED) {
                        set(ROOM.CELL_1_CLEARED);
                        object[0x00] = 0x01; // press switch_1
                        object[0x01] = 0x7e; // opens gate_1
                        set(ROOM.CELL_2_CLEARED);
                        object[0x08] = 0x01; // press switch_2
                        object[0x07] = 0x7e; // opens gate_2
                        set(ROOM.CELL_3_CLEARED);
                        object[0x0a] = 0x01; // press switch_3
                        object[0x09] = 0x7e; // opens gate_3
                        set(ROOM.CELL_4_CLEARED);
                        object[0x0e] = 0x01; // press switch_4
                        object[0x0c] = 0x7e; // opens gate_4
                        set(ROOM.CELL_5_CLEARED);
                        object[0x0d] = 0x01; // press switch_5
                        object[0x0b] = 0x7e; // opens gate_5
                        set(ROOM.CELL_6_CLEARED);
                        object[0x05] = 0x01; // press switch_6
                        object[0x04] = 0x7e; // opens gate_6
                        set(ROOM.CELL_7_CLEARED);
                        object[0x03] = 0x01; // press switch_7
                        object[0x02] = 0x7e; // opens gate_7
                    }

                    mario_init(False, False);

                    add_yoshi(0x36, 0x30);
                    stack_boy_yoshi(<LAST_ENTITY>);

                    if!(ROOM.ROOM_CLEARED) {
                        room_condition(ROOM.ROOM_CLEARED, ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }
                }
            };

            map mario_prison_4(IVOR_EBON_PRISON) { // koopas
                enum entrance {
                    door = entrance(0x2e, 0x11, SOUTH),
                    cave_1 = entrance(0x18, 0x1d, SOUTH),
                    cave_2 = entrance(0x47, 0x11, SOUTH),
                    cave_3 = entrance(0x56, 0x39, SOUTH),
                    // ???
                    cave_5 = entrance(0x47, 0x3d, SOUTH),
                    cave_6 = entrance(0x21, 0x39, SOUTH),
                    cave_7 = entrance(0x0c, 0x2f, SOUTH),

                    crash = entrance(0x36, 0x35, NONE, { crash_both(); }),
                }

                enum soundtrack {
                    default = soundtrack(MARIO.DEFAULT_MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = False,

                    ROOM_CLEARED = memory(FLAG, SRAM),

                    ENEMY_COUNT = memory(WORD, TEMP),
                    KILL_COUNT = memory(WORD, TEMP),
                    KILLS_REQUIRED = 0d7,
                    GATE_COUNT = memory(WORD, TEMP),
                    GATES_REQUIRED = 0d0,

                    CELL_1_CLEARED = memory(FLAG, TEMP),
                    CELL_2_CLEARED = memory(FLAG, TEMP),
                    CELL_3_CLEARED = memory(FLAG, TEMP),
                    CELL_4_CLEARED = memory(FLAG, TEMP),
                    CELL_5_CLEARED = memory(FLAG, TEMP),
                    CELL_6_CLEARED = memory(FLAG, TEMP),
                    CELL_7_CLEARED = memory(FLAG, TEMP),
                }

                fun add_mario_frippo(x, y) {
                    add_enemy(FRIPPO, x, y);
                    attach_script(LAST_ENTITY, DEATH, reference(@install() {
                        ROOM.ENEMY_COUNT--;
                        ROOM.KILL_COUNT++;

                        update_condition(ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }));

                    ROOM.ENEMY_COUNT++;
                }

                fun init_gate(index, flag) {
                    if(flag) {
                        ROOM.GATE_COUNT++;

                        if(index == 0x01) {
                            object[0x00] = 0x01; // press switch_1
                            object[0x01] = 0x7e; // opens gate_1
                        } else if(index == 0x02) {
                            object[0x08] = 0x01; // press switch_2
                            object[0x07] = 0x7e; // opens gate_2
                        } else if(index == 0x03) {
                            object[0x0a] = 0x01; // press switch_3
                            object[0x09] = 0x7e; // opens gate_3
                        } else if(index == 0x04) {
                            object[0x0e] = 0x01; // press switch_4
                            object[0x0c] = 0x7e; // opens gate_4
                        } else if(index == 0x05) {
                            object[0x0d] = 0x01; // press switch_5
                            object[0x0b] = 0x7e; // opens gate_5
                        } else if(index == 0x06) {
                            object[0x05] = 0x01; // press switch_6
                            object[0x04] = 0x7e; // opens gate_6
                        } else if(index == 0x07) {
                            object[0x03] = 0x01; // press switch_7
                            object[0x02] = 0x7e; // opens gate_7
                        }
                    }
                }

                fun open_gate(index, flag) {
                    if(flag) {
                        end();
                    } else {
                        set(flag);

                        ROOM.GATE_COUNT++;

                        if(ROOM.DEBUG) {
                            debug_memory(ROOM.GATE_COUNT, ROOM.ENEMY_COUNT);
                        }

                        update_condition(ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }

                    if(index == 0x01) {
                        object[0x00] = 0x01; // press switch_1

                        object[0x01] = 0x01; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x02; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x03; // opens gate_1
                        sleep(0x10);
                        object[0x01] = 0x7e; // opens gate_1
                    } else if(index == 0x02) {
                        object[0x08] = 0x01; // press switch_2

                        object[0x07] = 0x01; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x02; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x03; // opens gate_2
                        sleep(0x10);
                        object[0x07] = 0x7e; // opens gate_2
                    } else if(index == 0x03) {
                        object[0x0a] = 0x01; // press switch_3

                        object[0x09] = 0x01; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x02; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x03; // opens gate_3
                        sleep(0x10);
                        object[0x09] = 0x7e; // opens gate_3
                    } else if(index == 0x04) {
                        object[0x0e] = 0x01; // press switch_4

                        object[0x0c] = 0x01; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x02; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x03; // opens gate_4
                        sleep(0x10);
                        object[0x0c] = 0x7e; // opens gate_4
                    } else if(index == 0x05) {
                        object[0x0d] = 0x01; // press switch_5

                        object[0x0b] = 0x01; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x02; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x03; // opens gate_5
                        sleep(0x10);
                        object[0x0b] = 0x7e; // opens gate_5
                    } else if(index == 0x06) {
                        object[0x05] = 0x01; // press switch_6

                        object[0x04] = 0x01; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x02; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x03; // opens gate_6
                        sleep(0x10);
                        object[0x04] = 0x7e; // opens gate_6
                    } else if(index == 0x07) {
                        object[0x03] = 0x01; // press switch_7

                        object[0x02] = 0x01; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x02; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x03; // opens gate_7
                        sleep(0x10);
                        object[0x02] = 0x7e; // opens gate_7
                    }
                }

                fun switch_triggered(index, flag, x, y) {
                    if!(ROOM.ROOM_CLEARED) {
                        open_gate(index, flag);

                        add_mario_frippo(x, y);
                    }
                }

                enum stepon_trigger {
                    switch_6 = @install() {
                        switch_triggered(0x06, ROOM.CELL_6_CLEARED, 0x20, 0x3b);
                    },
                    switch_5 = @install() {
                        switch_triggered(0x05, ROOM.CELL_5_CLEARED, 0x47, 0x3f);
                    },
                    switch_4 = @install() {
                        switch_triggered(0x04, ROOM.CELL_4_CLEARED, 0x54, 0x3b);
                    },
                    switch_3 = @install() {
                        switch_triggered(0x03, ROOM.CELL_3_CLEARED, 0x53, 0x1d);
                    },
                    switch_2 = @install() {
                        switch_triggered(0x02, ROOM.CELL_2_CLEARED, 0x47, 0x13);
                    },
                    switch_7 = @install() {
                        switch_triggered(0x07, ROOM.CELL_7_CLEARED, 0x0d, 0x31);
                    },
                    switch_1 = @install() {
                        switch_triggered(0x01, ROOM.CELL_1_CLEARED, 0x18, 0x1e);
                    },
                    exit_door = @install() {
                        door_triggered(0x06, ROOM.ROOM_CLEARED);
                    },
                    stepon_8 = @install() {
                        debug_subtext("S=8");
                    },
                    stepon_9 = @install() {
                        debug_subtext("S=9");
                    },

                    stepon_10 = @install() {
                        debug_subtext("S=10");
                    },
                    stepon_11 = @install() {
                        debug_subtext("S=11");
                    },
                    stepon_12 = @install() {
                        debug_subtext("S=12");
                    },
                    stepon_13 = @install() {
                        debug_subtext("S=13");
                    },
                    stepon_14 = @install() {
                        debug_subtext("S=14");
                    },
                    pipe_3_1 = @install() {
                        debug_subtext("S=15");
                    },
                    pipe_1_1 = @install() {
                        debug_subtext("S=16");
                    },
                    pipe_2_1 = @install() {
                        debug_subtext("S=17");
                    },
                    pipe_2_2 = @install() {
                        debug_subtext("S=18");
                    },
                    pipe_2_3 = @install() {
                        debug_subtext("S=19");
                    },

                    pipe_1_2 = @install() {
                        debug_subtext("S=20");
                    },
                    pipe_1_3 = @install() {
                        debug_subtext("S=21");
                    },
                    pipe_1_4 = @install() {
                        debug_subtext("S=22");
                    },
                    pipe_3_2 = @install() {
                        debug_subtext("S=23");
                    },
                    pipe_3_3 = @install() {
                        debug_subtext("S=24");
                    },
                    pipe_3_4 = @install() {
                        debug_subtext("S=25");
                    },
                    exit_cell_2 = @install() {
                        debug_subtext("S=26");
                    },
                    exit_cell_3 = @install() {
                        debug_subtext("S=27");
                    },
                    exit_cell_4 = @install() {
                        debug_subtext("S=28");
                    },
                    exit_cell_5 = @install() {
                        debug_subtext("S=29");
                    },

                    exit_cell_6 = @install() {
                        debug_subtext("S=30");
                    },
                    exit_cell_7 = @install() {
                        debug_subtext("S=31");
                    },
                }

                enum b_trigger {
                    cell_1_gourd = @install() {
                        debug_subtext("B=0");
                    },
                }

                fun trigger_enter() {
                    if(ROOM.ROOM_CLEARED) {
                        set(ROOM.CELL_1_CLEARED);
                        object[0x00] = 0x01; // press switch_1
                        object[0x01] = 0x7e; // opens gate_1
                        set(ROOM.CELL_2_CLEARED);
                        object[0x08] = 0x01; // press switch_2
                        object[0x07] = 0x7e; // opens gate_2
                        set(ROOM.CELL_3_CLEARED);
                        object[0x0a] = 0x01; // press switch_3
                        object[0x09] = 0x7e; // opens gate_3
                        set(ROOM.CELL_4_CLEARED);
                        object[0x0e] = 0x01; // press switch_4
                        object[0x0c] = 0x7e; // opens gate_4
                        set(ROOM.CELL_5_CLEARED);
                        object[0x0d] = 0x01; // press switch_5
                        object[0x0b] = 0x7e; // opens gate_5
                        set(ROOM.CELL_6_CLEARED);
                        object[0x05] = 0x01; // press switch_6
                        object[0x04] = 0x7e; // opens gate_6
                        set(ROOM.CELL_7_CLEARED);
                        object[0x03] = 0x01; // press switch_7
                        object[0x02] = 0x7e; // opens gate_7
                    }

                    mario_init(False, False);

                    add_mario_koopa(0x36, 0x30, False);

                    if!(ROOM.ROOM_CLEARED) {
                        room_condition(ROOM.ROOM_CLEARED, ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }
                }
            };

            map mario_prison_5(IVOR_SEWERS) {
                enum entrance {
                    door = entrance(0x66, 0x0d, SOUTH),
                    pipe = entrance(0x49, 0x0d, SOUTH),

                    east = entrance(0xdf, 0x66, WEST),
                }

                enum soundtrack {
                    default = soundtrack(MARIO.DEFAULT_MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = False,

                    ROOM_CLEARED = memory(FLAG, SRAM),

                    ENEMY_COUNT = memory(WORD, TEMP),
                    KILL_COUNT = memory(WORD, TEMP),
                    KILLS_REQUIRED = 0d0,
                    GATE_COUNT = memory(WORD, TEMP),
                    GATES_REQUIRED = 0d0,

                    YOSHI_ID = memory(WORD, TEMP),
                    
                    BEE_COLLECTED = memory(FLAG, SRAM),
                }

                enum stepon_trigger {
                    exit_pipe = @install() {
                        debug_subtext("S=0");
                    },
                    exit_door = @install() {
                        debug_subtext("S=1");

                        room_cleared(ROOM.ROOM_CLEARED);

                        door_triggered(0x00, ROOM.ROOM_CLEARED);
                    },
                    exit_east_2 = @install() {
                        debug_subtext("S=2");
                    },
                    exit_east_1 = @install() {
                        debug_subtext("S=3");
                    },
                }

                enum b_trigger {
                    b_trigger_0 = @install() {
                        debug_subtext("B=0");
                    },
                    b_trigger_1 = @install() {
                        debug_subtext("B=1");
                    },
                    b_trigger_2 = @install() {
                        debug_subtext("B=2");
                    },
                    b_trigger_3 = @install() {
                        debug_subtext("B=3");
                    },
                    b_trigger_4 = @install() {
                        debug_subtext("B=4");
                    },
                    b_trigger_5 = @install() {
                        debug_subtext("B=5");
                    },
                    b_trigger_6 = @install() {
                        debug_subtext("B=6");
                    },
                    b_trigger_7 = @install() {
                        debug_subtext("B=7");
                    },
                }

                fun trigger_enter() {
                    mario_init(False, False);

                    if(False) {
                        add_yoshi(0d72, 0d27);
                        ROOM.YOSHI_ID = <LAST_ENTITY>;
                        attach_script(LAST_ENTITY, B, reference(@install() {
                            stack_boy_yoshi(<SCRIPT_OWNER>);
                            attach_script(SCRIPT_OWNER, B, reference(nop));
                        }));
                    }

                    add_mario_fireflower(0d214, 0d111);

                    add_bee(0d45, 0d171, reference(@install() {
                        bee_collected(ROOM.BEE_COLLECTED);
                    }));

                    // object[0x00] = 0x01; // open door
                    // object[0x01] = 0x01; // open chest_4_1
                    // object[0x02] = 0x01; // open chest_4_2
                    // object[0x03] = 0x01; // open chest_3_1
                    // object[0x04] = 0x01; // open chest_3_2
                    // object[0x05] = 0x01; // open chest_3_3
                    // object[0x06] = 0x01; // open chest_2
                    // object[0x07] = 0x01; // open chest_1_1
                    // object[0x08] = 0x01; // open chest_1_2

                    if!(ROOM.ROOM_CLEARED) {
                        room_condition(ROOM.ROOM_CLEARED, ROOM.GATE_COUNT, ROOM.GATES_REQUIRED, ROOM.KILL_COUNT, ROOM.KILLS_REQUIRED);
                    }
                }
            };

            map mario_dungeon_boss(MAGMAR) {
                enum entrance {
                    south = entrance(0x18, 0x47, NORTH)
                }

                enum soundtrack {
                    default = soundtrack(PIPE_MAZE.MUSIC_MAZE, 0xff)
                }

                enum BOSS {
                    DEBUG = False,
                    PROGRESS = memory(FLAG, TEMP),

                    ID = memory(WORD, TEMP),

                    PHASE = memory(WORD, TEMP),
                    RNG = memory(WORD, TEMP),
                    ENEMY_COUNT = memory(WORD, TEMP),

                    HIT_COUNTER = memory(WORD, TEMP), // TODO: byte
                    HIT_COUNTER_KOOPA_THRESHOLD = 0d3,

                    SHELL_COLLISION = 0d15,
                    SHELL_DAMAGE = 0d50,

                    HP = 0d500,
                    P0_HP_THRESHOLD = 0d300,
                }

                enum stepon_trigger {
                    exit_south = @install() {
                        fog_wall_inside(!SOULS_MEMORY.DEAD_BOWSER, NORTH);

                        map_transition(pipe_entrance_left, gate, SOUTH);
                    }
                }

                group boss_ai() {
                    fun boss_defeated() {
                        souls_boss_defeated(DEAD_BOWSER, REWARD_BOWSER);

                        unset(BOSS.PROGRESS);
                    }

                    fun check_phase() {
                        if(dead(BOSS.ID)) {
                            BOSS.PHASE = 0d10;
                        } else if(BOSS.PHASE == 0d0) {
                            if(BOSS.DEBUG) {
                                debug_memory(BOSS.ID[HP], BOSS.P0_HP_THRESHOLD);
                            }

                            if(BOSS.ID[HP] < BOSS.P0_HP_THRESHOLD) {
                                BOSS.PHASE = 0d1;
                            }
                        }
                    }

                    @install()
                    fun boss_hit() {
                        // subtext("bang");
                        damage(BOSS.ID, BOSS.SHELL_DAMAGE, True);
                        check_phase();
                    }
                    @install()
                    @async()
                    fun koopa_collision_scanner(entity_1, entity_2) {
                        range_checker(entity_1, entity_2, BOSS.SHELL_COLLISION, BOSS.SHELL_COLLISION, {
                            if(<SCRIPT_OWNER>[GENERAL_PURPOSE] == 0d2) {
                                if(False) {
                                    subtext("POW");
                                }

                                BOSS.ENEMY_COUNT--;
                                destroy(<SCRIPT_OWNER>);
                                boss_hit();
                            }
                        });
                    }
                    fun spawn_koopa() {
                        if(BOSS.ENEMY_COUNT <= 0d0) {
                            BOSS.ENEMY_COUNT++;

                            add_mario_koopa(0d24, 0d46, True);
                            koopa_collision_scanner(<LAST_ENTITY>, BOSS.ID);
                        }
                    }

                    fun boss_cast() {
                        animate(BOSS.ID, ONCE, ANIMATION_ENEMY.LIZARD_TALK);
                        face(BOSS.ID, SOUTH);
                    }
                    @install()
                    @async()
                    fun boss_ai() {
                        if(BOSS.DEBUG) {
                            subtext("phase 0");
                        }
                        
                        while(BOSS.PHASE <= 0d0) {
                            BOSS.RNG = randrange(0d4);
                            if(False && BOSS.DEBUG) {
                                subtext("rng");
                            }
                            
                            if(BOSS.RNG == 0d0) {
                                spawn_koopa();
                            } else if(BOSS.RNG == 0d1) {
                                boss_cast();
                                
                                ai_move_projectile_toss(BOSS.ID, SPEAR, <BOY>, 0d1);
                            } else if(BOSS.RNG == 0d2) {
                                boss_cast();

                                shoot_entity_entity(BOSS.ID, ONION, BOY, 0x10, 0xff);
                            } else if(BOSS.RNG == 0d3) {
                                nop();
                            }

                            sleep(0d180); // TODO
                        }

                        if(BOSS.DEBUG) {
                            subtext("phase 1");
                        }

                        add_mario_fireflower(0d8, 0d31);
                        add_mario_fireflower(0d38, 0d31);
                        
                        while(BOSS.PHASE <= 0d1) {
                            BOSS.RNG = randrange(0d3);
                            if(False && BOSS.DEBUG) {
                                subtext("rng");
                            }
                            
                            if(BOSS.RNG == 0d0) {
                                boss_cast();
                                
                                ai_move_projectile_toss(BOSS.ID, SPEAR, <BOY>, 0d3 + randrange(0d3));
                            } else if(BOSS.RNG == 0d1) {
                                boss_cast();

                                shoot_entity_entity(BOSS.ID, ONION, BOY, 0d20, 0xff);
                                sleep(0d10);
                                shoot_entity_entity(BOSS.ID, ONION, BOY, 0d10, 0xff);
                            } else if(BOSS.RNG == 0d2) {
                                nop();
                            }

                            sleep(0d180); // TODO
                        }

                        if(BOSS.DEBUG) {
                            subtext("yatta");
                        }

                        boss_defeated();
                    }

                    @install()
                    fun boss_damage() {
                        check_phase();

                        BOSS.HIT_COUNTER++;
                        if(BOSS.DEBUG) {
                            debug_memory(BOSS.HIT_COUNTER, BOSS.HIT_COUNTER_KOOPA_THRESHOLD);
                        }
                        if(BOSS.HIT_COUNTER >= BOSS.HIT_COUNTER_KOOPA_THRESHOLD) {
                            BOSS.HIT_COUNTER = 0d0;
                            
                            spawn_koopa();
                        }
                    }
                    
                    fun add_mario_enemy_bowser(x, y) {
                        add_enemy(LIZARD_BLACK, x, y);
                        BOSS.ID = <LAST_ENTITY>;
                        <LAST_ENTITY>[HP] = BOSS.HP;
                        attach_script(LAST_ENTITY, DAMAGE, reference(boss_damage));

                        boss_ai();
                    }
                };

                fun trigger_enter() {
                    if!(SOULS_MEMORY.DEAD_BOWSER) {
                        add_mario_enemy_bowser(0x18, 0x23);
                        push_music(BOSS);
                        set(BOSS.PROGRESS);
                    }

                    mario_init(False, False);
                }
            };
        };
    };
};

area southern_jungle() {
    enum AREA_SOUTHERN_JUNGLE {
        WATER_REMOVED = memory(FLAG, SRAM),
    }

    area southern_camp() {
        map eastern_waterfall(WATERFALL) {
            enum entrance {
                south = entrance(0x11, 0x3f, NORTH),

                swirl = entrance(0d19, 0d33, NONE, { swirl_entrance(); }),
            }

            enum soundtrack {
                default = soundtrack(WATERFALL_AMBIENT, 0xff)
            }

            @install()
            fun waterfall_triggered() {
                if(SOULS_MEMORY.WITH_METRO) {
                    generic_yeet_waterfall(0d250, 0d200);

                pit_fall_damage_callback(0d500, 0d50, {
                    map_transition(junkyard_northeast, crash_south, NONE);
                }, {
                    dust_unreachable(0d24, 0d34);
                });
                } else {
                    error_message(DLC);
                }
            }

            enum stepon_trigger {
                stepon_0 = waterfall_triggered(),
                stepon_1 = waterfall_triggered(),
                stepon_2 = waterfall_triggered(),
                stepon_3 = waterfall_triggered(),
                stepon_4 = waterfall_triggered(),
                stepon_5 = waterfall_triggered(),
                stepon_6 = @install() {
                    map_transition(eastern_river, north, SOUTH);
                }
            }

            fun trigger_enter() {
                default_init_room(True, True);
            }
        };

        map eastern_river(HORACE) {
            // sniff=vanilla
            
            enum entrance {
                north = entrance(0x53, 0x04, SOUTH),
                east = entrance(0x81, 0x31, WEST),
                south = entrance(0x55, 0x6e, NORTH),
            }

            enum soundtrack {
                default = soundtrack(SEWER_AMBIENT_WATER, 0xff)
            }

            enum stepon_trigger {
                stepon_0 = @install() {
                    debug_subtext("S=0");
                },
                stepon_1 = @install() {
                    debug_subtext("S=1");
                },
                stepon_2 = @install() {
                    debug_subtext("S=2");
                },
                exit_north = @install() {
                    map_transition(eastern_waterfall, south, NORTH);
                },
                exit_east = @install() {
                    map_transition(east_crossing, west, EAST);
                },
                exit_south = @install() {
                    map_transition(pyramid, north, SOUTH);
                },
            }

            enum b_trigger {
                sniff__1_ethanol_3 = @install() {
                    debug_subtext("B=0");
                    _loot(0x02, ETHANOL, 0d01, 0d03);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x03, ROOTS, 0d01, 0d01);
                },
                sniff__1_wax_2 = @install() {
                    debug_subtext("B=2");
                    _loot(0x04, WAX, 0d01, 0d02);
                },
                sniff__1_limestone = @install() {
                    debug_subtext("B=3");
                    _loot(0x05, LIMESTONE, 0d01, 0d00);
                },
                sniff__1_limestone_2 = @install() {
                    debug_subtext("B=4");
                    _loot(0x06, LIMESTONE, 0d01, 0d02);
                },
                sniff__1_water_1 = @install() {
                    debug_subtext("B=5");
                    _loot(0x07, WATER, 0d01, 0d01);
                },
                sniff__1_vinegar_2 = @install() {
                    debug_subtext("B=6");
                    _loot(0x08, VINEGAR, 0d01, 0d02);
                },
                sniff__1_ash_2 = @install() {
                    debug_subtext("B=7");
                    _loot(0x09, ASH, 0d01, 0d02);
                },
                sniff__1_bone = @install() {
                    debug_subtext("B=8");
                    _loot(0x0a, BONE, 0d01, 0d00);
                },
                sniff__1_bone = @install() {
                    debug_subtext("B=9");
                    _loot(0x0b, BONE, 0d01, 0d00);
                },

                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=10");
                    _loot(0x0c, BRIMSTONE, 0d01, 0d01);
                },
                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=11");
                    _loot(0x0d, BRIMSTONE, 0d01, 0d01);
                },
                sniff__1_brimstone = @install() {
                    debug_subtext("B=12");
                    _loot(0x0e, BRIMSTONE, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=13");
                    _loot(0x0f, WATER, 0d01, 0d00);
                },
                sniff__1_crystal_2 = @install() {
                    debug_subtext("B=14");
                    _loot(0x10, CRYSTAL, 0d01, 0d02);
                },
                sniff__1_clay_1 = @install() {
                    debug_subtext("B=15");
                    _loot(0x11, CLAY, 0d01, 0d01);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=16");
                    _loot(0x12, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=17");
                    _loot(0x13, ROOTS, 0d01, 0d01);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=18");
                    _loot(0x14, CLAY, 0d01, 0d00);
                },
                sniff__1_oil_2 = @install() {
                    debug_subtext("B=19");
                    _loot(0x15, OIL, 0d01, 0d02);
                },
            }

            enum ROOM {
                DEBUG = False,

                ALCHEMIST_ID = memory(WORD, TEMP),
            }

            fun remove_water(remove) {
                if(remove) {
                    object[0x00] = 0x01;
                    object[0x01] = 0x01;
                } else {
                    object[0x00] = 0x00;
                    object[0x01] = 0x00;
                }
            }

            fun add_raptor(type:ENEMY, x, y) {
                add_enemy(type, x, y);

                ROOM.ALCHEMIST_ID[GENERAL_PURPOSE]++;

                if(ROOM.DEBUG) {
                    debug_memory(ROOM.ALCHEMIST_ID[GENERAL_PURPOSE]);
                }

                attach_script(LAST_ENTITY, DEATH, reference(@install() {
                    ROOM.ALCHEMIST_ID[GENERAL_PURPOSE]--;

                    if(ROOM.DEBUG) {
                        debug_memory(ROOM.ALCHEMIST_ID[GENERAL_PURPOSE]);
                    }
                }));
            }

            @install()
            fun radiating_relic_examined() {
                MEMORY.QUESTION_ANSWER = 0d0;
                while(MEMORY.QUESTION_ANSWER == 0d0) {
                    arg[0x0e] = randrange(0d4);

                    increase_radiation(RADIATION.RADIATION_BUMP_TOUCH);

                    if(arg[0x0e] == 0d0) {
                        conversation_dialog("[SLOW]It feels warped. Who crafted such bad armor?[B]");
                    } else if(arg[0x0e] == 0d1) {
                        conversation_dialog("[SLOW]It feels extremely heavy?! Who crafted such bad armor?[B]");
                    } else if(arg[0x0e] == 0d2) {
                        conversation_dialog("[SLOW]The soil around the armor seems to be discolored.[B]");
                    } else if(arg[0x0e] == 0d3) {
                        conversation_dialog("[SLOW]It feels somewhat soft. Who crafted such bad armor?[B]");
                    }

                    conversation_question("[SLOW]Examine again?[CHOICE]examine…[CHOICE]leave…");
                }
            }

            fun trigger_enter() {
                // object[0x00] = 0x01;
                // object[0x01] = 0x01;

                if(FLAG.ACID_RAIN && (NPC_ARCHAEOLOGIST.PROGRESS >= 0x10) && (NPC_ARCHAEOLOGIST.PROGRESS < 0x13)) {
                    add_souls_npc_archaeologist(0d33, 0d55);
                }

                add_souls_npc_alchemist_acid_rain(0d78, 0d82);
                <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
                ROOM.ALCHEMIST_ID = <LAST_ENTITY>;

                if!(AREA_SOUTHERN_JUNGLE.WATER_REMOVED) {
                    add_enemy(REVEALER_TARGET_ENTITY, 0x52, 0x26);
                    special_script(REVEALER, reference(@install() {
                        destroy(SCRIPT_OWNER);

                        remove_water(True);

                        AREA_SOUTHERN_JUNGLE.WATER_REMOVED = True;
                    }));

                    add_debug_entity(0x5b, 0x23, reference(@install() {
                        remove_water(True);

                        AREA_SOUTHERN_JUNGLE.WATER_REMOVED = True;

                        destroy(SCRIPT_OWNER);
                    }));
                } else {
                    remove_water(True);
                }

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(FLAG.ACID_RAIN) {
                        // east
                        add_raptor(RAPTOR_PURPLE, 0d95, 0d30);

                        add_raptor(RAPTOR_PURPLE, 0d99, 0d63);

                        add_enemy(FLOWER_PURPLE, 0d96, 0d60);

                        // west
                        add_raptor(RAPTOR_GREEN, 0d40, 0d47);

                        add_raptor(RAPTOR_GREEN, 0d61, 0d81);

                        // river
                        if(AREA_SOUTHERN_JUNGLE.WATER_REMOVED) {
                            add_raptor(RAPTOR_PURPLE, 0d82, 0d38);
                        }   
                    }
                }

                default_init_room(True, True);

                place_statue(HORACE, 0d91, 0d75);

                if(True) {
                    // site - row 1
                    add_enemy(PLACEHOLDER, 0d21, 0d43); // wagon west (skull)
                    prepare_radiating_entity(<LAST_ENTITY>);
                    add_enemy(PLACEHOLDER, 0d21, 0d43); // grave 1-1 (skull)
                    prepare_radiating_entity(<LAST_ENTITY>);

                    add_enemy(PLACEHOLDER, 0d49, 0d51); // grave 1-2 (chest)
                    prepare_radiating_entity(<LAST_ENTITY>);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        animate_boy_kneel(<BOY>);

                        conversation({
                            conversation_question("[SLOW]Why is that armor not green? They look more grey[CHOICE]examine…[CHOICE]leave…", 0d5);

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                radiating_relic_examined();
                            }
                        });

                        animate(BOY, ONCE, DEFAULT);
                    }));

                    // site - row 2
                    add_enemy(PLACEHOLDER, 0d23, 0d59); // grave 2-1 (skull)
                    prepare_radiating_entity(<LAST_ENTITY>);
                    add_enemy(PLACEHOLDER, 0d21, 0d63); // grave 2-1 (chest)
                    prepare_radiating_entity(<LAST_ENTITY>);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        animate_boy_kneel(<BOY>);

                        conversation({
                            conversation_question("[SLOW]Is there something white on the armor? Are they infected by something?[CHOICE]examine…[CHOICE]leave…", 0d6);

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                radiating_relic_examined();
                            }
                        });

                        animate(BOY, ONCE, DEFAULT);
                    }));
                    add_enemy(PLACEHOLDER, 0d38, 0d61); // grave 2-2 (skull)
                    prepare_radiating_entity(<LAST_ENTITY>);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        animate_boy_kneel(<BOY>);

                        conversation({
                            conversation_question("[SLOW]Those rips don't look human.[CHOICE]examine…[CHOICE]leave…", 0d5);

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                increase_radiation(RADIATION.RADIATION_BUMP_TOUCH);

                                if!(SOULS_MEMORY.CLEARANCE_VAULT_NORTH_EAST) {
                                    custom_reward(GLOVE_PIPBOY_NORTH_WEST, True);
                                } else {
                                    conversation_dialog("[SLOW]The bones look discolored. I wonder what happened to them.[B]");
                                }
                            }
                        });

                        animate(BOY, ONCE, DEFAULT);
                    }));

                    // site - row 3
                    add_enemy(PLACEHOLDER, 0d57, 0d73); // wagon east (skull)
                    prepare_radiating_entity(<LAST_ENTITY>);

                    // north
                    add_enemy(PLACEHOLDER, 0d71, 0d15); // center skull
                    prepare_radiating_entity(<LAST_ENTITY>);

                    // east
                    add_enemy(PLACEHOLDER, 0d108, 0d49); // center skull
                    prepare_radiating_entity(<LAST_ENTITY>);
                }
            }
        };
    };

    area pyramid() {
        enum AREA_PYRAMID {
            MUSIC = MUSIC.JUNGLE_AMBIENT_BIRDS,
        }

        map pyramid(PYRAMID_EXTERIOR) {
            // sniff=vanilla

            enum ROOM {
                DEBUG = False,

                BRIDGE_SIZE = 0d45,
                BRIDGE_REVEALED = memory(FLAG, SRAM),
                BRIDGE_REVEALER_ENTITY = memory(WORD, TEMP),

                TRI_STONE_LOOTED = memory(FLAG, SRAM),

                CAVE_OPENED = memory(FLAG, SRAM),

                BEE_COLLECTED = memory(FLAG, SRAM),
            }

            @install()
            @async()
            fun entrance_water() {
                if(AREA_SOUTHERN_JUNGLE.WATER_REMOVED) {
                    end();    
                }

                control(NONE);

                arg[0x10] = <BOY>[Y];
                arg[0x12] = <BOY>[X] + 0d40;

                _teleport(DOG, <BOY>[X] + 0d24, <BOY>[Y]);
                face(DOG, WEST);

                face(BOY, EAST);
                <BOY>[Y] += 0d75;

                animate(BOY, LOOP, ANIMATION_BOY.SLEEP_WATER);
                sleep(0d30);

                while(<BOY>[Y] > arg[0x10]) {
                    <BOY>[Y]--;
                    sleep(0d3);
                }

                if(False) {
                    animate(BOY, ONCE, ANIMATION_BOY.SLEEP_DOWN);

                    while(<BOY>[Y] > 0d1020) {
                        <BOY>[Y]--;
                        sleep(0d3);
                    }

                    animate(BOY, ONCE, ANIMATION_BOY.LOOT);
                } else {
                    animate(BOY, LOOP, ANIMATION_BOY.DRAGGED);
                    animate(DOG, LOOP, ANIMATION_DOG.ACT1_DRAGGING);

                    while(<BOY>[X] < arg[0x12]) {
                        <BOY>[X]++;
                        <DOG>[X] = <BOY>[X] + 0d24;
                        sleep(0d3);
                    }
                }

                control(BOTH);
            }

            enum entrance {
                north = entrance(0x66, 0x04, SOUTH),
                east = entrance(0xa3, 0x71, WEST),

                cave_tiny = entrance(0x87, 0x84, SOUTH, {
                    ROOM.CAVE_OPENED = True;
                }),

                pyramid_1_1 = entrance(0x4c, 0x6b, SOUTH),
                pyramid_2_1 = entrance(0x46, 0x4e, SOUTH),
                pyramid_2_2 = entrance(0x5e, 0x4e, SOUTH),
                pyramid_3_1 = entrance(0x52, 0x38, SOUTH),
                pyramid_3_2 = entrance(0x5b, 0x33, EAST),

                wings = entrance(0x3d, 0x71, NONE),

                water = entrance(0d95, 0d130, NONE, { entrance_water(); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_PYRAMID.MUSIC, 0xff)
            }

            @install()
            fun pit_triggered() {
                guard_z();
                
                generic_fall(0d100, 0d1030);

                dust_unreachable(0d143, 0d108);
                damage(BOTH, 0d999, True);
                sleep(0d30);
                damage(BOTH, SYSTEM.HP_MAX, False);
            }

            enum stepon_trigger {
                stepon_0 = @install() {
                    debug_subtext("S=0");
                },
                door_tiny = @install() {
                    debug_subtext("S=1");

                    if(ROOM.CAVE_OPENED) {
                        map_transition(pyramid_cave, south, NORTH);
                    }
                },
                pit_1 = pit_triggered(),
                pit_2 = pit_triggered(),
                pit_3 = pit_triggered(),
                stairs_bottom = @install() {
                    debug_subtext("S=5");
                },
                switch_left = @install() {
                    debug_subtext("S=6");

                    error_message(SWITCH_STUCK);
                },
                switch_right = @install() {
                    debug_subtext("S=7");

                    error_message(SWITCH_STUCK);
                },
                switch_bottom_south = @install() {
                    debug_subtext("S=8");
                },
                switch_bottom_west = @install() {
                    debug_subtext("S=9");
                },

                pit_4 = pit_triggered(),
                pit_5 = pit_triggered(),
                pit_6 = pit_triggered(),
                pit_7 = pit_triggered(),
                pit_8 = pit_triggered(),
                exit_east = @install() {
                    map_transition(flowers, west, EAST);
                },
                stepon_16 = @install() {
                    debug_subtext("S=16");
                },
                door_2_1 = @install() {
                    debug_subtext("S=17");

                    error_message(DLC, SOUTH);
                },
                door_2_2 = @install() {
                    debug_subtext("S=18");

                    error_message(DLC, SOUTH);
                },
                door_3_2 = @install() {
                    debug_subtext("S=19");

                    error_message(DLC, EAST);
                },

                switch_bottom = @install() {
                    debug_subtext("S=20");

                    error_message(SWITCH_STUCK);
                },
                stepon_21 = @install() {
                    debug_subtext("S=21");
                },
                switch_left_west = @install() {
                    debug_subtext("S=22");
                },
                switch_left_south = @install() {
                    debug_subtext("S=23");
                },
                switch_right_east = @install() {
                    debug_subtext("S=24");
                },
                switch_right_south = @install() {
                    debug_subtext("S=25");
                },
                exit_north = @install() {
                    map_transition(eastern_river, south, NORTH);
                },
            }

            enum b_trigger {
                sniff__1_wax_1 = @install() {
                    debug_subtext("B=0");
                    _loot(0x10, WAX, 0d01, 0d01);
                },
                sniff__1_wax_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x11, WAX, 0d01, 0d01);
                },
                sniff__1_wax_1 = @install() {
                    debug_subtext("B=2");
                    _loot(0x12, WAX, 0d01, 0d01);
                },
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=3");
                    _loot(0x13, ASH, 0d01, 0d01);
                },
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=4");
                    _loot(0x14, ASH, 0d01, 0d01);
                },
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=5");
                    _loot(0x15, ASH, 0d01, 0d01);
                },
                sniff__1_bone_1 = @install() {
                    debug_subtext("B=6");
                    _loot(0x16, BONE, 0d01, 0d01);
                },
                sniff__1_bone_1 = @install() {
                    debug_subtext("B=7");
                    _loot(0x17, BONE, 0d01, 0d01);
                },
                sniff__1_bone_1 = @install() {
                    debug_subtext("B=8");
                    _loot(0x18, BONE, 0d01, 0d01);
                },
                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=9");
                    _loot(0x19, BRIMSTONE, 0d01, 0d01);
                },

                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=10");
                    _loot(0x1a, BRIMSTONE, 0d01, 0d01);
                },
                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=11");
                    _loot(0x1b, BRIMSTONE, 0d01, 0d01);
                },
                sniff__1_brimstone_1 = @install() {
                    debug_subtext("B=12");
                    _loot(0x1c, BRIMSTONE, 0d01, 0d01);
                },
                sniff__1_water_1 = @install() {
                    debug_subtext("B=13");
                    _loot(0x1d, WATER, 0d01, 0d01);
                },
                sniff__1_limestone_1 = @install() {
                    debug_subtext("B=14");
                    _loot(0x1e, LIMESTONE, 0d01, 0d01);
                },
                sniff__1_limestone_1 = @install() {
                    debug_subtext("B=15");
                    _loot(0x1f, LIMESTONE, 0d01, 0d01);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=16");
                    _loot(0x20, ROOTS, 0d01, 0d01);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=17");
                    _loot(0x21, ROOTS, 0d01, 0d01);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=18");
                    _loot(0x22, ROOTS, 0d01, 0d01);
                },
                sniff__1_vinegar_1 = @install() {
                    debug_subtext("B=19");
                    _loot(0x23, VINEGAR, 0d01, 0d01);
                },
            }

            @install()
            fun message_triggered() {
                player_message_triggered();

                subtext("shortcut ahead, therefore try jumping"); // https://soapstone.retzudo.com/04j243v
            }

            @install()
            @async()
            fun revealer_approached() {
                range_checker(ROOM.BRIDGE_REVEALER_ENTITY, <ACTIVE>, ROOM.BRIDGE_SIZE, ROOM.BRIDGE_SIZE, { pit_triggered(); });
            }

            @install()
            fun tri_stones_triggered() {
                if!(ROOM.TRI_STONE_LOOTED) {
                    set(ROOM.TRI_STONE_LOOTED);

                    fake_loot();
                    subtext("todo");
                }
            }

            fun remove_water(remove) {
                if(remove) {
                    object[0x04] = 0x01;
                    object[0x05] = 0x01;
                    object[0x06] = 0x01;
                    object[0x07] = 0x01;
                    object[0x08] = 0x01;
                    object[0x09] = 0x01;
                    object[0x0a] = 0x01;
                } else {
                    object[0x04] = 0x00;
                    object[0x05] = 0x00;
                    object[0x06] = 0x00;
                    object[0x07] = 0x00;
                    object[0x08] = 0x00;
                    object[0x09] = 0x00;
                    object[0x0a] = 0x00;
                }
            }

            fun trigger_enter() {
                if(AREA_SOUTHERN_JUNGLE.WATER_REMOVED) {
                    remove_water(True);
                }

                if(False) {
                    if!(ROOM.BRIDGE_REVEALED) {
                        add_enemy(REVEALER_TARGET_ENTITY, 0d148, 0d119);
                        ROOM.BRIDGE_REVEALER_ENTITY = <LAST_ENTITY>;

                        special_script(REVEALER, reference(@install() {
                            set(ROOM.BRIDGE_REVEALED);
                            object[0x0b] = 0x7e;
                            sleep(0x29);
                            destroy(ROOM.BRIDGE_REVEALER_ENTITY);
                        }));
                        revealer_approached();
                    } else {
                        revealer_triggered();
                    }
                } else {
                    add_enemy(PLACEHOLDER, 0d148, 0d119);
                    ROOM.BRIDGE_REVEALER_ENTITY = <LAST_ENTITY>;

                    revealer_approached();
                }

                if!(ROOM.CAVE_OPENED) {
                    add_enemy(STONE_ROUND, 0d135, 0d136);
                    <LAST_ENTITY>[Z_LEVEL] = 0x30; // the water seems to linger for a few frames

                    attach_script(LAST_ENTITY, B, reference(@install() {
                        error_message(DOOR_WRONG_SIDE);
                    }));
                }

                add_bee(0d143, 0d24, reference(@install() {
                    bee_collected(ROOM.BEE_COLLECTED);
                }));

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if(AREA_SOUTHERN_JUNGLE.WATER_REMOVED) {
                        // river east
                        add_enemy(DRAKE, 0d136, 0d71);

                        // river west
                        add_enemy(SPIDER_GREEN, 0d43, 0d29);
                        add_enemy(DRAKE, 0d50, 0d125);
                        
                        // river south
                        add_enemy(SPIDER_GREEN, 0d103, 0d141);
                    }

                    // pyramid entry
                    add_enemy(DRAKE, 0d61, 0d114);
                }

                add_enemy(REVEALER_TARGET_ENTITY, 0d92, 0d134);
                special_script(REVEALER, reference(@install() {
                    destroy(SCRIPT_OWNER);

                    remove_water(True);

                    AREA_SOUTHERN_JUNGLE.WATER_REMOVED = True;
                }));

                default_init_room(True, True);

                player_message(0d134, 0d122, reference(message_triggered));

                if!(ROOM.TRI_STONE_LOOTED) {
                    add_enemy(PLACEHOLDER, 0d23, 0d134);
                    attach_script(LAST_ENTITY, B, reference(tri_stones_triggered));
                }

                no_clip_box(0d1126, 0d892, 0d1240, 0d956);

                if(False) {
                    fake_pit_scanner(0d512, 0d643, 0d543, 0d684, True, False, True, False);
                    fake_pit_scanner(0d699, 0d643, 0d735, 0d691, True, False, True, False);
                }
            }
        };

        map pyramid_cave(PYRAMID_CAVE) {
            enum entrance {
                south = entrance(0x15, 0x23, NORTH),

                teleporter = entrance(0d23, 0d18, NONE, { teleporter_in(SOUTH); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_PYRAMID.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_south = @install() {
                    map_transition(pyramid, cave_tiny, SOUTH);
                },
                exit_teleporter = @install() {
                    debug_subtext("S=1");

                    teleporter_out(0d23, 0d17);
                    map_transition(desert_cave, teleporter, NONE);
                },
            }

            fun trigger_enter() {
                default_init_room(False, False);
            }
        };
    };

    map flowers(FLOWERS) {
        // gourd=vanilla
        // sniff=vanilla

        enum entrance {
            north = entrance(0x62, 0x0b, SOUTH),
            west = entrance(0x04, 0x1f, EAST),

            crash = entrance(0x64, 0x5b, NONE),
        }

        enum soundtrack {
            default = soundtrack(JUNGLE_AMBIENT, 0xff)
        }

        enum stepon_trigger {
            exit_north = @install() {
                map_transition(northern_jungle, south, NORTH);
            },
            exit_south = @install() {
                map_transition(pyramid, east, WEST);
            },
        }

        enum b_trigger {
            gourd__15_money = @install() {
                debug_subtext("B=0");
                _loot_chest(0x05, MONEY, 0d15);
            },
            gourd__1_petal = @install() {
                debug_subtext("B=1");
                _loot_chest(0x00, PETAL, 0d01);
            },
            gourd__1_petal = @install() {
                debug_subtext("B=2");
                _loot_chest(0x02, PETAL, 0d01);
            },
            gourd__1_nectar = @install() {
                debug_subtext("B=3");
                _loot_chest(0x04, NECTAR, 0d01);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=4");
                _loot(0x1c, CLAY, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=5");
                _loot(0x1b, ASH, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=6");
                _loot(0x1a, ROOTS, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=7");
                _loot(0x19, WATER, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=8");
                _loot(0x18, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=9");
                _loot(0x17, ASH, 0d01, 0d00);
            },

            sniff__1_water = @install() {
                debug_subtext("B=10");
                _loot(0x16, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=11");
                _loot(0x15, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=12");
                _loot(0x14, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=13");
                _loot(0x13, ROOTS, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=14");
                _loot(0x12, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=15");
                _loot(0x11, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=16");
                _loot(0x10, ROOTS, 0d01, 0d00);
            },
            sniff__2_roots = @install() {
                debug_subtext("B=17");
                _loot(0x0e, CLAY, 0d02, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=18");
                _loot(0x0f, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=19");
                _loot(0x0d, ROOTS, 0d01, 0d00);
            },

            sniff__1_water = @install() {
                debug_subtext("B=20");
                _loot(0x0b, WATER, 0d01, 0d00);
            },
            sniff__2_roots = @install() {
                debug_subtext("B=21");
                _loot(0x09, ROOTS, 0d02, 0d00); // same as B=22
            },
            sniff__2_roots = @install() {
                debug_subtext("B=22");
                _loot(0x09, ROOTS, 0d02, 0d00); // same as B=21
            },
            gourd__1_oil = @install() {
                debug_subtext("B=23");
                _loot_chest(0x01, OIL, 0x01);
            },
            gourd__shell_helmet = @install() {
                debug_subtext("B=24");
                _loot_chest(0x03, HELM_1_2, 0x01);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=25");
                _loot(0x0a, ROOTS, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=26");
                _loot(0x07, ASH, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=27");
                _loot(0x08, WATER, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=28");
                _loot(0x0c, ROOTS, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=29");
                _loot(0x1d, WATER, 0d01, 0d00);
            },

            sniff__1_roots = @install() {
                debug_subtext("B=30");
                _loot(0x1e, ROOTS, 0d01, 0d00);
            },
        }

        enum ROOM {
            DEBUG = False,

            LIFT_TRIGGER = memory(WORD, TEMP),
            LIFT_CORD = memory(WORD, TEMP),
            LIFT_TRIGGER_RADIUS = 0x20,
            LIFT_START = 0x0fff,
            LIFT_END = 0x30,
            LIFT_SPEED_INCREMEND = 0x01,
            LIFT_SPEED_SLEEP = 0x05,
        }

        @install()
        fun lift_triggered() {
            control(NONE);

            add_placeholder(LIFT_CORD_VERTICAL, 0x00, 0x00);
            ROOM.LIFT_CORD = <LAST_ENTITY>;
            ROOM.LIFT_CORD[X] = ROOM.LIFT_TRIGGER[X];
            ROOM.LIFT_CORD[Y] = ROOM.LIFT_TRIGGER[Y] - 0xb0;
            ROOM.LIFT_CORD[Z] = ROOM.LIFT_START;

            ROOM.LIFT_TRIGGER[Z] = ROOM.LIFT_START;
            yield();
            animate(ROOM.LIFT_TRIGGER, LOOP, ANIMATION_PLACEHOLDER.LIFT_MOVING);

            sleep(0x50);

            animate(ROOM.LIFT_TRIGGER, ONCE_FREEZE, ANIMATION_PLACEHOLDER.LIFT_MOVING);

            walk(DOG, COORDINATE_ABSOLUTE, ROOM.LIFT_TRIGGER[X] - 0x0a, ROOM.LIFT_TRIGGER[Y], NONE);
            walk(BOY, COORDINATE_ABSOLUTE, ROOM.LIFT_TRIGGER[X] + 0x0a, ROOM.LIFT_TRIGGER[Y], BOTH);

            face(BOY, SOUTH);
            face(DOG, SOUTH);

            animate(ROOM.LIFT_TRIGGER, LOOP, ANIMATION_PLACEHOLDER.LIFT_MOVING);

            while(arg[0x00] < ROOM.LIFT_END) {
                ROOM.LIFT_TRIGGER[VELOCITY] = arg[0x00];
                ROOM.LIFT_CORD[VELOCITY] = arg[0x00];
                <BOY>[VELOCITY] = arg[0x00];
                <DOG>[VELOCITY] = arg[0x00];

                arg[0x00] += ROOM.LIFT_SPEED_INCREMEND;
                sleep(ROOM.LIFT_SPEED_SLEEP);
            }

            map_transition(tree_house, door, NONE);
        }
        
        @install()
        @async()
        fun hidden_lift_check() {
            while(True) {
                arg[0x00] = <ACTIVE>[X];
                arg[0x02] = <ACTIVE>[Y];
                arg[0x04] = ROOM.LIFT_TRIGGER[X];
                arg[0x06] = ROOM.LIFT_TRIGGER[Y];

                if(arg[0x00] < arg[0x04]) {
                    arg[0x08] = arg[0x04] - arg[0x00];
                } else {
                    arg[0x08] = arg[0x00] - arg[0x04];
                }

                if(arg[0x02] < arg[0x06]) {
                    arg[0x0a] = arg[0x06] - arg[0x02];
                } else {
                    arg[0x0a] = arg[0x02] - arg[0x06];
                }

                if((arg[0x08] <= ROOM.LIFT_TRIGGER_RADIUS) && (arg[0x0a] <= ROOM.LIFT_TRIGGER_RADIUS)) {
                    lift_triggered();
                    end();
                }
                yield();

                if(ROOM.DEBUG) {
                    debug_memory(arg[0x08], arg[0x0a]);
                    sleep(0x20);
                }
            }
        }
        
        fun trigger_enter() {
            init_map(0x00, 0x02, 0x80, 0x96);

            if!(FLAG.IN_ANIMATION) {
                crash_both();
            }

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // north (west entrance)
                add_enemy(RAPTOR_PURPLE, 0d49, 0d59);
                
                // north east (north entrance)
                add_enemy(RAPTOR_GREEN, 0d101, 0d41);

                // east
                add_enemy(SPIDER, 0d102, 0d87);

                // west
                add_enemy(RAPTOR_GREEN, 0d19, 0d80);

                // center
                add_enemy(SPIDER, 0d49, 0d84);

                // south east
                add_enemy(SPIDER, 0d78, 0d113);

                add_enemy(RAPTOR_GREEN, 0d110, 0d132);
            }

            default_init_room(True, True);

            add_enemy(PLACEHOLDER, 0x72, 0x75);
            ROOM.LIFT_TRIGGER = <LAST_ENTITY>;

            hidden_lift_check();
        }
    };

    map tree_house(STRONGHEART) {
        // chests=vanilla
        
        enum entrance {
            door = entrance(0x12, 0x23, NORTH)
        }

        enum stepon_trigger {
            door = @install() {
                map_transition(flowers, crash, NONE);
            }
        }

        enum b_trigger {
            gourd_1__1_oil = @install() {
                debug_subtext("B=0");
                _loot_chest(0x00, OIL, 0d01);
            },
            gourd_2__1_wax = @install() {
                debug_subtext("B=1");
                _loot_chest(0x02, WAX, 0d01);
            },
            gourd_3__1_wax = @install() {
                debug_subtext("B=2");
                _loot_chest(0x01, WAX, 0d01);
            },
        }

        fun trigger_enter() {
            default_init_room(True, False);
        }
    };

    area northern_jungle() {
        map northern_jungle(NORTH_JUNGLE) {
            // chest=vanilla
            // sniff=vanilla

            enum ROOM {
                HIDDEN_TUNNEL_OPENED = memory(FLAG, SRAM),
                FAKE_FOG_GATE = memory(FLAG, SRAM),
            }

            enum entrance {
                north = entrance(0x56, 0x05, SOUTH),
                south = entrance(0x07, 0x4d, NORTH),

                cave_1 = entrance(0x08, 0x0f, SOUTH),
                cave_2 = entrance(0x48, 0x13, SOUTH, { ROOM.HIDDEN_TUNNEL_OPENED = True; }),

                wings = entrance(0x0f, 0x3f, NONE),
            }

            enum soundtrack {
                default = soundtrack(JUNGLE_AMBIENT, 0xff)
            }

            enum stepon_trigger {
                exit_north = @install() {
                    debug_subtext("S=10");

                    fog_wall_outside(!ROOM.FAKE_FOG_GATE, SOUTH);
                    ROOM.FAKE_FOG_GATE = True;

                    map_transition(jungle_firepit, south, NORTH);
                },
                cave_2 = @install() {
                    debug_subtext("S=1");

                    if!(ROOM.HIDDEN_TUNNEL_OPENED) {
                        error_message(DOOR_WRONG_SIDE, SOUTH);
                    } else {
                        map_transition(northern_jungle_tunnel_1, south, NORTH);
                    }
                },
                cave_1 = @install() {
                    debug_subtext("S=2");

                    map_transition(jungle_portal, south, NORTH);
                },
                exit_south = @install() {
                    map_transition(flowers, north, SOUTH);
                },
            }
            
            enum b_trigger {
                sniff__1_water = @install() {
                    debug_subtext("B=0");
                    _loot(0x02, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=1");
                    _loot(0x03, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=2");
                    _loot(0x04, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=3");
                    _loot(0x05, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=4");
                    _loot(0x06, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=5");
                    _loot(0x07, WATER, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=6");
                    _loot(0x08, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=7");
                    _loot(0x09, OIL, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=8");
                    _loot(0x0a, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=9");
                    _loot(0x0b, ROOTS, 0d01, 0d00);
                },

                sniff__1_roots = @install() {
                    debug_subtext("B=10");
                    _loot(0x0c, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=11");
                    _loot(0x0d, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=12");
                    _loot(0x0e, ROOTS, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=13");
                    _loot(0x0f, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=14");
                    _loot(0x10, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=15");
                    _loot(0x11, CLAY, 0d01, 0d00);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=16");
                    _loot(0x12, ASH, 0d01, 0d00);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=17");
                    _loot(0x13, ASH, 0d01, 0d00);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=18");
                    _loot(0x14, ASH, 0d01, 0d00);
                },
                sniff__1_wax = @install() {
                    debug_subtext("B=19");
                    _loot(0x15, WAX, 0d01, 0d00);
                },

                sniff__1_wax = @install() {
                    debug_subtext("B=20");
                    _loot(0x16, WAX, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=21");
                    _loot_chest(0x00, CLAY, 0d01);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=22");
                    _loot_chest(0x01, NECTAR, 0d01);
                },
            }
            
            fun trigger_enter() {
                init_map(0x00, 0x00, 0x63, 0x4f);

                if!(ROOM.HIDDEN_TUNNEL_OPENED) {
                    add_enemy(STONE_ROUND, 0d72, 0d22);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        error_message(DOOR_WRONG_SIDE, SOUTH);
                    }));
                }

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // right path
                    // add_enemy(RAPTOR_GREEN, 0d41, 0d57);

                    add_enemy(RAPTOR_GREEN, 0d58, 0d48);
                    add_enemy(RAPTOR_GREEN, 0d58, 0d48);

                    // right pocket
                    add_enemy(RAPTOR_PURPLE, 0d69, 0d48);
                    // add_enemy(RAPTOR_PURPLE, 0d78, 0d56);
                }

                default_init_room(True, True);
            }
        };

        map jungle_portal(PYRAMID_CAVE) {
            enum entrance {
                south = entrance(0x15, 0x23, NORTH),

                teleporter = entrance(0d23, 0d18, NONE, { teleporter_in(SOUTH); }),
            }
            
            enum soundtrack {
                default = soundtrack(JUNGLE_AMBIENT, 0xff)
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");

                    map_transition(northern_jungle, cave_1, SOUTH);
                },
                exit_teleporter = @install() {
                    debug_subtext("S=1");

                    teleporter_out(0d23, 0d17);
                    map_transition(junkyard_south, teleporter, NONE);
                },
            }

            fun trigger_enter() {
                default_init_room(False, False);
            }
        };

        area northern_jungle_tunnel() {
            map northern_jungle_tunnel_1(VOLCANO_ROOMS) { // variant: room_ns
                enum entrance {
                    north = entrance(0x1c, 0x3d, SOUTH),
                    south = entrance(0x22, 0x7b, NORTH),
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_south = nop(),
                    exit_room_s_south = nop(),
                    exit_room_nne_east = nop(),
                    exit_south = @install() {
                        debug_subtext("S=5");

                        map_transition(northern_jungle, cave_2, SOUTH);
                    },
                    exit_room_sw_west = nop(),
                    exit_north = @install() {
                        debug_subtext("S=7");

                        map_transition(northern_jungle_tunnel_2, south_2, NORTH);
                    },
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_room_nss_south_2 = nop(),
                    exit_room_nss_south_1 = nop(),
                    exit_room_nss_north = nop(),
                    exit_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd__4_ash = @install() {
                        debug_subtext("B=3");
                        _loot_chest(0x04, ASH, 0d04);
                    },
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd_room_s__2_wax = nop(),
                    gourd_room_s__3_ash = nop(),
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff__1_clay = @install() {
                        debug_subtext("B=14");
                        _loot(0x0a, CLAY, 0d01, 0d00);
                    },
                    sniff_room_nss__1_roots = nop(),
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff_room_s__1_oil = nop(),
                    sniff_room_nw__1_oil = nop(),
                    sniff_room_nss__1_wax = nop(),
                    sniff__1_wax = @install() {
                        debug_subtext("B=23");
                        _loot(0x13, WAX, 0d01, 0d00);
                    },
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_nne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    init_room(0d4);
                    default_init_room(False, False);
                }
            };

            map northern_jungle_tunnel_2(VOLCANO_ROOMS) { // variant: room_nss
                enum entrance {
                    north = entrance(0x9e, 0x05, SOUTH),
                    south_1 = entrance(0x9e, 0x37, NORTH),
                    south_2 = entrance(0x84, 0x37, NORTH),
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_south = nop(),
                    exit_room_s_south = nop(),
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_room_sw_west = nop(),
                    exit_room_ns_north = nop(),
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_south_2 = @install() {
                        debug_subtext("S=13");

                        map_transition(northern_jungle_tunnel_1, north, SOUTH);
                    },
                    exit_south_1 = @install() {
                        debug_subtext("S=14");

                        map_transition(northern_jungle_tunnel_gourds, north, SOUTH);
                    },
                    exit_north = @install() {
                        debug_subtext("S=15");

                        map_transition(northern_jungle_tunnel_end, south, NORTH);
                    },
                    exit_room_alchemist_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd_room_ns__4_ash = nop(),
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd_room_s__2_wax = nop(),
                    gourd_room_s__3_ash = nop(),
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff__1_roots = @install() {
                        debug_subtext("B=15");
                        _loot(0x0b, ROOTS, 0d01, 0d00);
                    },
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff_room_s__1_oil = nop(),
                    sniff_room_nw__1_oil = nop(),
                    sniff__1_wax = @install() {
                        debug_subtext("B=22");
                        _loot(0x12, WAX, 0d01, 0d00);
                    },
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_nne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    init_room(0d2);
                    default_init_room(False, False);
                }
            };

            map northern_jungle_tunnel_gourds(VOLCANO_ROOMS) { // variant: room_alchemist
                enum entrance {
                    north = entrance(0xd0, 0x05, SOUTH),
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_south = nop(),
                    exit_room_s_south = nop(),
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_room_sw_west = nop(),
                    exit_room_ns_north = nop(),
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_room_nss_south_2 = nop(),
                    exit_room_nss_south_1 = nop(),
                    exit_room_nss_north = nop(),
                    exit_north = @install() {
                        debug_subtext("S=16");

                        map_transition(northern_jungle_tunnel_2, south_1, NORTH);
                    },
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff__1_ash = @install() {
                        debug_subtext("B=0");
                        _loot(0x17, ASH, 0d01, 0d00);
                    },
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd_room_ns__4_ash = nop(),
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_west__3_water = @install() {
                        debug_subtext("B=6");
                        _loot_chest(0x02, WATER, 0d03);
                    },
                    gourd_room_s__2_wax = nop(),
                    gourd_room_s__3_ash = nop(),
                    gourd_hidden_2__5_wax = @install() {
                        debug_subtext("B=9");
                        _loot_chest(0x06, WAX, 0d05);
                    },
                    gourd_hidden_1__6_water = @install() {
                        debug_subtext("B=10");
                        _loot_chest(0x07, WATER, 0d06);
                    },
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff_room_nss__1_roots = nop(),
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff_room_s__1_oil = nop(),
                    sniff_room_nw__1_oil = nop(),
                    sniff_room_nss__1_wax = nop(),
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_nne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    init_room(0d3);
                    default_init_room(False, False);
                }
            };

            map northern_jungle_tunnel_end(VOLCANO_ROOMS) { // variant: cave
                enum entrance {
                    south = entrance(0x54, 0xb1, NORTH),

                    crash = entrance(0d85, 0d167, NONE, { crash_both(); }),
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_south = @install() {
                        debug_subtext("S=2");

                        map_transition(northern_jungle_tunnel_2, north, SOUTH);
                    },
                    exit_room_s_south = nop(),
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_room_sw_west = nop(),
                    exit_room_ns_north = nop(),
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_room_nss_south_2 = nop(),
                    exit_room_nss_south_1 = nop(),
                    exit_room_nss_north = nop(),
                    exit_room_alchemist_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd__3_wax = @install() {
                        debug_subtext("B=1");
                        _loot_chest(0x16, WAX, 0d03);
                    },
                    gourd__1_wax = @install() {
                        debug_subtext("B=2");
                        _loot_chest(0x15, DRY_ICE, 0d01);
                    },
                    gourd_room_ns__4_ash = nop(),
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd_room_s__2_wax = nop(),
                    gourd_room_s__3_ash = nop(),
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff_room_nss__1_roots = nop(),
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff__1_roots = @install() {
                        debug_subtext("B=18");
                        _loot(0x0e, ROOTS, 0d01, 0d00);
                    },
                    sniff_room_es__1_oil = nop(),
                    sniff_room_s__1_oil = nop(),
                    sniff_room_nw__1_oil = nop(),
                    sniff_room_nss__1_wax = nop(),
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_nne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    init_room(0d9);
                    default_init_room(False, False);
                }
            };
        };

        map jungle_firepit(FIREPIT_JUNGLE) {
            // sniff=vanilla

            enum entrance {
                south = entrance(0x17, 0x2c, NORTH),

                bonfire = entrance(0d15, 0d23, NONE, { bonfire_wakeup(0d8, 0d32, 0d40, 0d16); }),
            }

            enum soundtrack {
                default = soundtrack(JUNGLE_AMBIENT, 0xff)
            }

            enum stepon_trigger {
                exit_south = @install() {
                    map_transition(northern_jungle, north, SOUTH);
                },
                windwalker = @install() {
                    debug_subtext("S=1");
                },
            }

            enum b_trigger {
                sniff__1_clay_2 = @install() {
                    debug_subtext("B=0");
                    _loot(0x06, CLAY, 0d01, 0d02);
                },
                sniff__1_ash_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x05, ASH, 0d01, 0d01);
                },
                sniff__1_oil_1 = @install() {
                    debug_subtext("B=2");
                    _loot(0x04, OIL, 0d01, 0d01);
                },
                sniff__1_oil_3 = @install() {
                    debug_subtext("B=3");
                    _loot(0x03, OIL, 0d01, 0d03);
                },
            }

            enum ROOM {
                DEBUG = False,

                STATUE_REVEALED = memory(FLAG, SRAM),

                PIT_IGNITED = memory(FLAG, SRAM),
                FIRE_ORB_TRIGGER_COUNTER = memory(WORD, TEMP),
            }

            fun ignite_pit() {
                object[0x01] = 0x01; // ignite firepit

                bonfire(0d15, 0d23, SOULS_MEMORY.BONFIRE_JUNGLE_PIT);
                attribute(LAST_ENTITY, INVISIBLE, True);
                <LAST_ENTITY>[Z_LEVEL] = <BOY>[Z_LEVEL];
            }

            @install()
            fun firepit_damage() {
                check_damage_type(FIRE, ROOM.FIRE_ORB_TRIGGER_COUNTER);

                if(ROOM.FIRE_ORB_TRIGGER_COUNTER) {
                    ROOM.FIRE_ORB_TRIGGER_COUNTER = 0x00;
                    set(ROOM.PIT_IGNITED);
                    ignite_pit();
                    destroy(SCRIPT_OWNER);

                    set(SOULS_MEMORY.BONFIRE_JUNGLE_PIT);
                } else {
                    heal(SCRIPT_OWNER, 0x00, False);
                    // damage(SCRIPT_OWNER, 0x00, True);
                }

                // reset_alchemy_types();
            }

            fun show_statue(show) {
                if(show) {
                    object[0x02] = 0x01; // show dog_statue

                    place_statue(DOG, 0d26, 0d19);
                } else {
                    object[0x02] = 0x00; // show dog_statue
                }
            }

            @install()
            fun revealer_triggered() {
                show_statue(True);

                destroy(SCRIPT_OWNER);
            }

            fun trigger_enter() {
                // object[0x00] = 0x02; // add windwalker_hitbox
                // object[0x01] = 0x01; // ignite firepit
                // object[0x02] = 0x01; // show dog_statue

                if!(ROOM.PIT_IGNITED) {
                    add_enemy(FACE_ENTITY, 0d14, 0d22);
                    attribute(LAST_ENTITY, INVISIBLE, True);
                    attach_script(LAST_ENTITY, DAMAGE, reference(firepit_damage));

                    reset_alchemy_types();
                } else {
                    ignite_pit();
                }

                if!(ROOM.STATUE_REVEALED) {
                    add_enemy(REVEALER_TARGET_ENTITY, 0d26, 0d16);

                    special_script(REVEALER, reference(revealer_triggered));
                } else {
                    show_statue(True);
                }

                default_init_room(True, True);
            }
        };
    };
};

area town() {
    enum AREA_TOWN_TEMPLE {
        DEBUG = False,
        DEBUG_DONATION = True,
        DEBUG_MARKET = True,

        SECRET_PASSAGE_OPENED = memory(FLAG, SRAM),
        SECRET_PASSAGE_2_OPENED = memory(FLAG, SRAM),

        DONATED_INGREDIENTS = memory(BYTE, SRAM),
        DONATED_INGREDIENTS_PARTIAL = 0d5,
        DONATED_INGREDIENTS_MAX = 0d20,

        MUSIC_TOWN = 0x42,
    }

    map town_market_alley(IVOR_MARKET) {
        enum entrance {
            north = entrance(0x2a, 0x01, SOUTH),
            east = entrance(0x39, 0xc3, WEST),
        }

        enum soundtrack {
            default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
        }

        enum stepon_trigger {
            exit_north = @install() {
                map_transition(temple, south, NORTH);
            },
            exit_east = @install() {
                map_transition(town_center, west_2, EAST);
            },
        }

        fun trigger_enter() {
            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // south
                add_enemy(RAT, 0d23, 0d179);

                add_enemy(RAT, 0d41, 0d141);

                // center
                add_enemy(MAGGOT, 0d15, 0d116);

                // north
                add_enemy(MAGGOT, 0d9, 0d31);
                add_enemy(MAGGOT, 0d39, 0d38);

                add_enemy(MAGGOT_RED, 0d39, 0d13);
            }

            init_map(0x0, 0x0, 0x3a, 0xcc);
            default_init_room(False, False);

            add_sterling_rat(0d41, 0d93, 0d42, 0d172, 0d1530);
        }
    };

    area temple() {
        enum AREA_TEMPLE {
            MUSIC = MUSIC.HALLS_1,

            // level 0
            NORTHERN_WALL = 0d408,

            // level 1
            UNLOCKED_LEVEL_1 = memory(FLAG, SRAM),

            // level 2
            UNLOCKED_LEVEL_2 = memory(FLAG, SRAM),
        }

        group temple_helper() {
            @install()
            @async()
            fun fake_northern_wall() {
                init_map(0x00, 0x30, 0x50, 0x8a);

                while(True) {
                    if(<BOY>[Y] < AREA_TEMPLE.NORTHERN_WALL) {
                        <BOY>[Y] = AREA_TEMPLE.NORTHERN_WALL;
                    }
                    if(<DOG>[Y] < AREA_TEMPLE.NORTHERN_WALL) {
                        <DOG>[Y] = AREA_TEMPLE.NORTHERN_WALL;
                    }

                    yield();
                }
            }

            fun open_elevator(open) {
                sound(MECHANICAL_MOVEMENT);

                if(open) {
                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d1; // open elevator
                    sleep(0d20);

                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d2; // open elevator
                    sleep(0d20);

                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d3; // open elevator
                    sleep(0d20);

                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d4; // open elevator
                    sleep(0d20);
                } else {
                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d3; // open elevator
                    sleep(0d20);

                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d2; // open elevator
                    sleep(0d20);

                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d1; // open elevator
                    sleep(0d20);

                    sound(ELEVATOR_DOOR);
                    object[0x05] = 0d0; // open elevator
                    sleep(0d20);
                }
            }

            @install()
            @async()
            fun _elevator_entrance() {
                sleep(0d50);

                open_elevator(False);
            }
            fun elevator_entrance() {
                object[0x05] = 0d4;

                _elevator_entrance();
            }

            @install()
            fun elevator_leave() {
                if(False) {
                    map_transition(temple, elevator, NONE); // TODO: walk out again
                } else {
                    open_elevator(True);

                    walk(BOY, TILE_ABSOLUTE, 0d43, 0d82, NONE);
                    walk(DOG, TILE_ABSOLUTE, 0d39, 0d82, BOTH);

                    open_elevator(False);

                    control(BOTH);
                }
            }

            fun elevator_triggered(current_level) {
                if!(AREA_TEMPLE.UNLOCKED_LEVEL_1) {
                    error_message(DOOR_CONTRAPTION, SOUTH);

                    end();
                }

                control(NONE);

                open_elevator(True);

                walk(BOY, TILE_ABSOLUTE, 0d43, 0d73, NONE);
                walk(DOG, TILE_ABSOLUTE, 0d39, 0d73, BOTH);

                face(BOY, SOUTH);
                face(DOG, SOUTH);
                
                open_elevator(False);

                // map_transition(temple_underground, elevator, NONE);

                if(AREA_TEMPLE.UNLOCKED_LEVEL_2) {
                    _question("[SLOW]Press a button:[CHOICE]1[CHOICE]2[CHOICE]3");
                } else if(AREA_TEMPLE.UNLOCKED_LEVEL_1) {
                    _question("[SLOW]Press a button:[CHOICE]1[CHOICE]2");
                }

                if(MEMORY.QUESTION_ANSWER == 0d00) {
                    if(current_level == 0d0) {
                        elevator_leave();
                    } else {
                        map_transition(temple, elevator, NONE);
                    }
                } else if(MEMORY.QUESTION_ANSWER == 0d01) {
                    if(current_level == 0d1) {
                        elevator_leave();
                    } else {
                        map_transition(temple_underground, elevator, NONE);
                    }
                } else if(MEMORY.QUESTION_ANSWER == 0d02) {
                    if(current_level == 0d2) {
                        elevator_leave();
                    } else {
                        map_transition(temple_underground_castle, elevator, NONE);
                    }
                } else {
                    elevator_leave();
                }
            }
        };

        area level_0() {
            map temple(HALLS_CENTER) {
                // chests=nothing

                enum entrance {
                    north = entrance(0x29, 0x03, SOUTH),
                    east_1 = entrance(0x4b, 0x3f, WEST),
                    east_2 = entrance(0x49, 0x5d, WEST),
                    south = entrance(0x29, 0x8b, NORTH),
                    west_1 = entrance(0x09, 0x5d, EAST),
                    west_2 = entrance(0x09, 0x3f, EAST),

                    // elevator = entrance(0x29, 0x49, NONE),
                    elevator = entrance(0x29, 0x4c, SOUTH, { elevator_entrance(); }),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum ROOM {
                    DOOR_EAST_2 = memory(FLAG, TEMP),
                }

                enum stepon_trigger {
                    stepon_0 = @install() {
                        debug_subtext("S=0");
                    },
                    stepon_1 = @install() {
                        debug_subtext("S=1");
                    },
                    stepon_2 = @install() {
                        debug_subtext("S=2");
                    },
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    stepon_4 = @install() {
                        debug_subtext("S=4");
                    },
                    stepon_5 = @install() {
                        debug_subtext("S=5");
                    },
                    exit_south = @install() {
                        map_transition(town_market_alley, north, SOUTH);
                    },
                    door_west_2 = @install() {
                        map_transition(temple_north_west, east, WEST);
                    },
                    door_west_1 = @install() {
                        debug_subtext("S=8");
                    },
                    door_east_2 = @install() fun trigger_door_east_2() {
                        bombable_trigger(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED, ROOM.DOOR_EAST_2, ((DIRECTION.WEST << 0x0008) | ERROR_TYPE.DOOR_CONTRAPTION), {
                            if(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED) {
                                map_transition(town_level_2, west, EAST);
                            } else {
                                map_transition(town_level_2, west_closed, EAST);
                            }
                        });
                    },

                    door_east_1 = @install() {
                        fog_wall_outside(!SOULS_MEMORY.DEAD_TEMPLE_MINITAUR, WEST);

                        map_transition(temple_switch, west, EAST);
                    },
                    stepon_11 = @install() {
                        debug_subtext("S=11");
                    },
                    switch_triggered = @install() {
                        debug_subtext("S=12");
                    },
                    stepon_13 = @install() {
                        debug_subtext("S=13");
                    },
                    stepon_14 = @install() {
                        debug_subtext("S=14");
                    },
                    stepon_15 = @install() {
                        debug_subtext("S=15");
                    },
                    stepon_16 = @install() {
                        debug_subtext("S=16");
                    },
                    stepon_17 = @install() {
                        debug_subtext("S=17");
                    },
                    stepon_18 = @install() {
                        debug_subtext("S=18");
                    },
                    stepon_19 = @install() {
                        debug_subtext("S=19");
                    },

                    stepon_20 = @install() {
                        debug_subtext("S=20");
                    },
                    stepon_21 = @install() {
                        debug_subtext("S=21");
                    },
                    stepon_22 = @install() {
                        debug_subtext("S=22");
                    },
                    stepon_23 = @install() {
                        debug_subtext("S=23");
                    },
                    stepon_24 = @install() {
                        debug_subtext("S=24");
                    },
                    stepon_25 = @install() {
                        debug_subtext("S=25");
                    },
                    stepon_26 = @install() {
                        debug_subtext("S=26");
                    },
                    stepon_27 = @install() {
                        debug_subtext("S=27");
                    },
                    stepon_28 = @install() {
                        debug_subtext("S=28");
                    },
                    stepon_29 = @install() {
                        debug_subtext("S=29");
                    },

                    stepon_30 = @install() {
                        debug_subtext("S=30");
                    },
                    elevator = @install() {
                        elevator_triggered(0d0);
                    },
                }

                enum b_trigger {
                    gourd_1__2_VINEGAR = nop(),
                    gourd_2__1_NECTAR = nop(),
                }

                fun open_doors(open) {
                    if(open) {
                        object[0x09] = 0x01; // NE
                        object[0x03] = 0x01; // NW

                        object[0x08] = 0x01; // SE
                        object[0x07] = 0x01; // SW

                    } else {
                        object[0x09] = 0x00; // NE
                        object[0x03] = 0x00; // NW

                        object[0x08] = 0x00; // SE
                        object[0x07] = 0x00; // SW

                    }
                }

                @install()
                fun debug_triggered() {
                    AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED = True;
                    AREA_TEMPLE.UNLOCKED_LEVEL_1 = True;
                    AREA_TEMPLE.UNLOCKED_LEVEL_2 = True;

                    destroy(SCRIPT_OWNER);
                }

                fun trigger_enter() {
                    // object[0x00] = 0x7e; // enroll bridge
                    // object[0x01] = 0x01; // open gourde_2
                    // object[0x02] = 0x01; // open gourde_1
                    // object[0x03] = 0x01; // open door_NW
                    // object[0x04] = 0x04; // open door_boss
                    // object[0x05] = 0x7e; // open elevator
                    // object[0x06] = 0x01; // activate bridge_switch
                    // object[0x07] = 0x01; // open door_SW
                    // object[0x08] = 0x01; // open door_SE
                    // object[0x09] = 0x01; // open door_NE
                    // object[0x0a] = 0x01; // activate switch
                    // object[0x0b] = 0x01; // show bridge_left_1
                    // object[0x0c] = 0x01; // show bridge_left_2
                    // object[0x0d] = 0x01; // show bridge_left_3
                    // object[0x0e] = 0x01; // show bridge_right_1
                    // object[0x0f] = 0x01; // show bridge_right_2
                    // object[0x10] = 0x01; // show bridge_right_3
                    // object[0x11] = 0x01; // show bridge_right_4

                    add_bombable(0d71, 0d92, ROOM.DOOR_EAST_2, reference(trigger_door_east_2));

                    if!(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED) {
                        add_debug_entity(0d69, 0d87, reference(debug_triggered));
                    }

                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // east
                        add_enemy(MAGGOT_RED, 0d65, 0d78);

                        // south
                        add_enemy(MAGGOT_RED, 0d50, 0d109);
                        add_enemy(MAGGOT_RED, 0d63, 0d110);

                        // west
                        add_enemy(MAGGOT_RED, 0d26, 0d73);
                    }

                    open_doors(True);
                    object[0x07] = 0x00; // SW

                    fake_northern_wall();
                    default_init_room(False, False);
                }
            };

            map temple_north_west(HALLS_SW) {
                // chests=vanilla

                enum entrance {
                    north = entrance(0x24, 0x2e, SOUTH),
                    east = entrance(0x3b, 0x3f, WEST),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum ROOM {
                    LEFT_OPENED = memory(FLAG, SRAM),
                    CENTER_OPENED = memory(FLAG, SRAM),
                    RIGHT_TRIGGERED = memory(FLAG, TEMP),
                }

                enum stepon_trigger {
                    exit_east = @install() {
                        map_transition(temple, west_2, EAST);
                    },
                    stepon_1 = @install() {
                        debug_subtext("S=1");
                    },
                    switch_2 = @install() {
                        if((!ROOM.LEFT_OPENED) && (!ROOM.CENTER_OPENED)) {
                            object[0x01] = 0x7e; // activate switch_2

                            if!(ROOM.RIGHT_TRIGGERED) {
                                set(ROOM.CENTER_OPENED);
                                object[0x04] = 0x00; // gate 2
                            } else {
                                set(ROOM.LEFT_OPENED);
                                object[0x03] = 0x00; // gate 1
                            }
                        }
                    },
                    switch_1 = @install() {
                        if((!ROOM.LEFT_OPENED) && (!ROOM.CENTER_OPENED)) {

                            object[0x00] = 0x7e; // activate switch_1

                            if!(ROOM.RIGHT_TRIGGERED) {
                                set(ROOM.LEFT_OPENED);
                                object[0x03] = 0x00; // gate 1
                            } else {
                                set(ROOM.CENTER_OPENED);
                                object[0x04] = 0x00; // gate 2
                            }
                        }
                    },
                    switch_3 = @install() {
                        set(ROOM.RIGHT_TRIGGERED);

                        object[0x05] = 0x01; // gate 3
                        object[0x02] = 0x01; // activate switch_3
                    },
                    exit_north = @install() {
                        map_transition(temple_boss, south, NORTH);
                    },
                }

                enum b_trigger {
                    gourd_2__3_brimstone = @install() {
                        debug_subtext("B=0");
                        _loot_chest(0x08, LIMESTONE_TABLET, 0d01);
                    },
                    gourd_1_2__1_nectar = @install() {
                        debug_subtext("B=1");
                        _loot_chest(0x07, NECTAR, 0d01);
                    },
                    gourd_1_1__1_wings = @install() {
                        debug_subtext("B=2");
                        _loot_chest(0x06, WINGS, 0d01);
                    },
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // north
                        add_enemy(MAGGOT_RED, 0d49, 0d38);

                        // south
                        add_enemy(MAGGOT_RED, 0d31, 0d75);

                        // center
                        add_enemy(BOY, 0d36, 0d61, INACTIVE_IMORTAL);
                    }

                    if!(ROOM.LEFT_OPENED) {
                        object[0x03] = 0x03; // gate 1
                    } else {
                        object[0x00] = 0x7e; // activate switch_1
                    }
                    if!(ROOM.CENTER_OPENED) {
                        object[0x04] = 0x03; // gate 2
                    } else {
                        object[0x01] = 0x7e; // activate switch_2
                    }
                    object[0x05] = 0x02; // gate 3
                    if(ROOM.LEFT_OPENED || ROOM.CENTER_OPENED) {
                        object[0x02] = 0x7e; // activate switch_3
                    }

                    default_init_room(False, False);
                }
            };

            map temple_boss(MEGATAUR) {
                enum entrance {
                    south = entrance(0x41, 0x53, NORTH)
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_south = @install() {
                        map_transition(temple_north_west, north, SOUTH);
                    }
                }

                enum ROOM {
                    COLLECTIBLE_LOOTED = memory(FLAG, SRAM),
                }

                @install()
                fun debug_triggered() {
                    set(ROOM.COLLECTIBLE_LOOTED);
                    collectible_collected();

                    destroy(SCRIPT_OWNER);
                }

                fun trigger_enter() {
                    if!(ROOM.COLLECTIBLE_LOOTED) {
                        add_collectible(0x01, 0d64, 0d66, reference(debug_triggered));
                    }

                    init_map(0x30, 0x30 + 0x06, 0x50, 0x4c + 0x06);
                    default_init_room(False, False);
                }
            };

            map temple_switch(HALLS_SE) {
                enum entrance {
                    west = entrance(0x01, 0x1b, EAST),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum BOSS {
                    DEBUG = False,

                    DEFAULT_Z = 0x10,

                    RIDER_ID = memory(WORD, TEMP),
                    MOUNT_ID = memory(WORD, TEMP),
                    TMP_ID = memory(WORD, TEMP),

                    PHASE = memory(WORD, TEMP),
                    TIMER = memory(WORD, TEMP),

                    DISMOUNT = memory(WORD, TEMP),

                    COUNTDOWN = 0d03,

                    HP_MINITAUR = 0d200,
                    HP_MEGATAUR = 0d200,

                    P0_HIT_COUNTER = memory(WORD, TEMP),
                    P0_HP_THRESHOLD = 0d100,

                    P1_HIT_COUNTER = memory(WORD, TEMP),
                }

                fun show_switch(show) {
                    if(show) {
                        object[0x00] = 0x0a;
                    } else {
                        object[0x00] = 0x00;
                    }
                }

                @install()
                fun boss_defeated() {
                    souls_boss_defeated(DEAD_TEMPLE_MINITAUR, REWARD_TEMPLE_MINITAUR);

                    show_switch(True);
                }
                fun switch_activated() {
                    if!(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED) {
                        AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED = True;
                        AREA_TEMPLE.UNLOCKED_LEVEL_1 = True;

                        generic_switch_floor(0x00, True);
                    }
                }

                enum stepon_trigger {
                    exit_west = @install() {
                        fog_wall_inside(!SOULS_MEMORY.DEAD_TEMPLE_MINITAUR, EAST);

                        map_transition(temple, east_1, WEST);
                    },
                    switch = @install() {
                        switch_activated();
                    }
                }

                fun knockback_check(entity) {
                    if((entity[CURRENT_GROUND] & 0xff) != 0d16) {
                        if(True) {
                            if(BOSS.DEBUG) {
                                debug_memory(entity[CURRENT_GROUND], 0d0);
                            }

                            // _drag(entity, BOSS.MOUNT_ID[X], BOSS.MOUNT_ID[Y]);
                            _drag(SCRIPT_OWNER, 0d22 << 0d0003, 0d32 << 0d0003);
                            entity[Z_LEVEL] = BOSS.DEFAULT_Z;
                        } else {
                            heal(SCRIPT_OWNER, 0d0, False);
                            animate(SCRIPT_OWNER, ONCE, DEFAULT);

                            attribute(SCRIPT_OWNER, NO_CLIP, True);

                            while(<SCRIPT_OWNER>[CURRENT_GROUND] != 0d16) {
                                sleep(0d30);
                            }

                            attribute(SCRIPT_OWNER, NO_CLIP, False);
                        }

                        end();
                    }
                }

                @install()
                fun rider_damage() {
                    if(BOSS.PHASE == 0d00) {
                        BOSS.DISMOUNT += 0d240;
                        // attribute(BOSS.RIDER_ID, NO_CLIP, False);

                        if(script[0x9] == 0x200) { // TODO: too easy? megataur doesn't have magic resist
                            BOSS.PHASE = 0d2;
                            end();
                        }

                        knockback_check(<SCRIPT_OWNER>);
                        sleep(0d20);
                        knockback_check(<SCRIPT_OWNER>);
                    } else if(BOSS.PHASE == 0d01) {
                        BOSS.DISMOUNT += 0d240;
                        // attribute(BOSS.RIDER_ID, NO_CLIP, False);
                        animate(BOSS.RIDER_ID, ONCE, DEFAULT);

                        knockback_check(<SCRIPT_OWNER>);
                        sleep(0d20);
                        knockback_check(<SCRIPT_OWNER>);
                    }
                }
                @install()
                fun mount_damage() {
                    if(BOSS.PHASE == 0d00) {
                        BOSS.P0_HIT_COUNTER++;

                        if((BOSS.MOUNT_ID[HP] < BOSS.P0_HP_THRESHOLD) || (script[0x9] & 0x200)) {
                            BOSS.PHASE = 0d01;
                            end();
                        }

                        if(BOSS.DEBUG) {
                            debug_memory(BOSS.P0_HIT_COUNTER, BOSS.MOUNT_ID[HP]);
                        }
                    } if(BOSS.PHASE == 0d01) {
                        BOSS.P1_HIT_COUNTER++;

                        if(BOSS.DEBUG) {
                            debug_memory(BOSS.P1_HIT_COUNTER, BOSS.MOUNT_ID[HP]);
                        }

                        if(script[0x9] & 0x200) {
                            BOSS.PHASE = 0d02;
                            end();
                        }
                    }
                }

                @install()
                @async()
                fun boss_watcher() {
                    if(BOSS.DEBUG) {
                        subtext("phase 0");
                    }

                    while(BOSS.PHASE == 0d00) {
                        if(BOSS.DISMOUNT == 0d05) {
                            _drag(BOSS.RIDER_ID, BOSS.MOUNT_ID[X], BOSS.MOUNT_ID[Y] - 0d30);
                            // attribute(BOSS.RIDER_ID, NO_CLIP, True);
                            animate(BOSS.RIDER_ID, ONCE_FREEZE, ANIMATION_ENEMY.MEGATAUR_EXIT);
                            animate(BOSS.MOUNT_ID, ONCE, SLASH_1);
                        } else if(BOSS.DISMOUNT == 0d01) {
                            BOSS.RIDER_ID[Z_LEVEL] = BOSS.DEFAULT_Z;
                        } else if(BOSS.DISMOUNT == 0d00) {
                            if(BOSS.DISMOUNT == 0d00) {
                                BOSS.RIDER_ID[X] = BOSS.MOUNT_ID[X];
                                BOSS.RIDER_ID[Y] = BOSS.MOUNT_ID[Y] - 0d30;
                            }
                        }
                    
                        if(BOSS.DISMOUNT > 0d00) { // TODO: buggy, since menu resets paletts
                            BOSS.DISMOUNT--;
                        }

                        yield();
                    }

                    if(BOSS.DEBUG) {
                        subtext("phase 1");
                    }

                    BOSS.TMP_ID = BOSS.RIDER_ID;
                    BOSS.RIDER_ID = BOSS.MOUNT_ID;
                    BOSS.MOUNT_ID = BOSS.TMP_ID;

                    attach_script(BOSS.RIDER_ID, DAMAGE_DEATH, reference(rider_damage));
                    attach_script(BOSS.MOUNT_ID, DAMAGE_DEATH, reference(mount_damage));

                    yield();

                    BOSS.DISMOUNT = 0d240;
                    _drag(BOSS.RIDER_ID, BOSS.MOUNT_ID[X], BOSS.MOUNT_ID[Y] - 0d30);
                    BOSS.RIDER_ID[Z_LEVEL] = BOSS.DEFAULT_Z;
                    animate(BOSS.MOUNT_ID, ONCE, DEFAULT);

                    // walk(BOSS.MOUNT_ID, TILE_ABSOLUTE_DIRECT, 0d22, 0d32, NONE);
                    _drag(BOSS.MOUNT_ID, 0d22 << 0d0003, 0d32 << 0d0003);
                    BOSS.MOUNT_ID[Z_LEVEL] = BOSS.DEFAULT_Z;

                    while(BOSS.PHASE == 0d01) {
                        if(BOSS.DISMOUNT == 0d05) {
                            _drag(BOSS.RIDER_ID, BOSS.MOUNT_ID[X], BOSS.MOUNT_ID[Y] - 0d30);
                            // attribute(BOSS.RIDER_ID, NO_CLIP, True);
                            animate(BOSS.RIDER_ID, ONCE_FREEZE, ANIMATION_ENEMY.MEGATAUR_EXIT);
                        } else if(BOSS.DISMOUNT == 0d01) {
                            BOSS.RIDER_ID[Z_LEVEL] = BOSS.DEFAULT_Z;
                        } else if(BOSS.DISMOUNT == 0d00) {
                            if(BOSS.DISMOUNT == 0d00) {
                                BOSS.RIDER_ID[X] = BOSS.MOUNT_ID[X];
                                BOSS.RIDER_ID[Y] = BOSS.MOUNT_ID[Y] - 0d30;
                            }
                        }
                    
                        if(BOSS.DISMOUNT > 0d00) { // TODO: buggy, since menu resets paletts
                            BOSS.DISMOUNT--;
                        }

                        yield();
                    }

                    if(BOSS.DEBUG) {
                        subtext("yatta");
                    }

                    if(alive(BOSS.MOUNT_ID)) {
                        destroy(BOSS.MOUNT_ID);
                    }
                    if(alive(BOSS.RIDER_ID)) {
                        destroy(BOSS.RIDER_ID);
                    }

                    boss_defeated();
                }

                fun spawn_boss(x, y) {
                    add_enemy(MINITAUR, x, y);
                    BOSS.MOUNT_ID = <LAST_ENTITY>;
                    <LAST_ENTITY>[HP] = BOSS.HP_MINITAUR;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(mount_damage));

                    add_enemy(MEGATAUR, x, y);
                    BOSS.RIDER_ID = <LAST_ENTITY>;
                    <LAST_ENTITY>[HP] = BOSS.HP_MEGATAUR;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(rider_damage));

                    animate(BOSS.RIDER_ID, FREEZE, ANIMATION_ENEMY.MEGATAUR_ENTER);
                    
                    boss_watcher();
                }

                fun trigger_enter() {
                    if!(SOULS_MEMORY.DEAD_TEMPLE_MINITAUR) {
                        show_switch(False);

                        spawn_boss(0d36, 0d36);

                        push_music(BOSS);
                    } else {
                        if(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED) {
                            object[0x00] = 0x0b;
                        } else {
                            show_switch(True);
                        }
                    }

                    default_init_room(False, False);
                }
            };
        };

        area level_1() {
            map temple_underground(HALLS_CENTER) {
                // chests=nothing

                enum entrance {
                    north = entrance(0x29, 0x03, SOUTH),
                    east_1 = entrance(0x4b, 0x3f, WEST),
                    east_2 = entrance(0x49, 0x5d, WEST),
                    south = entrance(0x29, 0x8b, NORTH),
                    west_1 = entrance(0x09, 0x5d, EAST),
                    west_2 = entrance(0x09, 0x3f, EAST),

                    // elevator = entrance(0x29, 0x49, NONE),
                    elevator = entrance(0x29, 0x4c, SOUTH, { elevator_entrance(); }),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = False,

                    BOSS_DOOR_OPENED = memory(FLAG, SRAM),
                    FIREPIT_UNLOCKED = memory(FLAG, SRAM),
                    DOOR_WALL_BOSS_OPENED = memory(FLAG, SRAM),
                    STONE_OFFSET = 0d8 * 0d4,

                    BRIDGE_LEFT = memory(WORD, TEMP),
                    BRIDGE_REVEALED_LEFT = memory(FLAG, SRAM),
                    BRIDGE_RIGHT = memory(WORD, TEMP),
                    BRIDGE_REVEALED_RIGHT = memory(FLAG, SRAM),

                    DOOR_SOUTH_OPENED = memory(FLAG, TEMP),
                }

                @install()
                fun pit_triggered() {
                    generic_fall(0d100, 0d295);

                    dust_unreachable(0d38, 0d36);
                    damage(BOTH, 0d999, True);
                    sleep(0d30);
                    damage(BOTH, SYSTEM.HP_MAX, False);
                }

                @install()
                fun switch_triggered() {
                    object[0x06] = 0x7e;

                    while(arg[0x10] <= 0d7) {
                        arg[0x10]++;

                        sleep(0d9);
                        sound(0x2c);
                        object[0x00] = arg[0x10];
                    }

                    while(arg[0x12] <= 0d4) {
                        arg[0x12]++;

                        sleep(0d9);
                        sound(0x76);
                        object[0x04] = arg[0x12];
                    }
                }

                enum stepon_trigger {
                    spear_check = @install() {
                        debug_subtext("S=0");

                        if!(ROOM.BOSS_DOOR_OPENED) {
                            guard_spear_2(NORTH, MEMORY.CAMERA_X_MIN, 0x0008);
                            
                            ROOM.BOSS_DOOR_OPENED = True;
                            switch_triggered();
                        }
                    },
                    pit_5 = pit_triggered(),
                    pit_4 = pit_triggered(),
                    pit_3 = pit_triggered(),
                    pit_2 = pit_triggered(),
                    pit_1 = pit_triggered(),
                    exit_south = @install() fun trigger_door_south() {
                        if(<SCRIPT_OWNER> == <ACTIVE>) {
                            if((!ROOM.DOOR_SOUTH_OPENED) && (!AREA_TEMPLE.UNLOCKED_LEVEL_2) && FLAG.QUEENS_KEY) {
                                dialog("[SLOW]Weird. The key seems to fit, but the door still does not open from this side.[B]What on earth was sealed behind that door?[B]");
                            }
                        }

                        bombable_trigger(AREA_TEMPLE.UNLOCKED_LEVEL_2, ROOM.DOOR_SOUTH_OPENED, ((DIRECTION.NORTH << 0x0008) | ERROR_TYPE.DOOR_WRONG_SIDE), {
                            map_transition(temple_underground_castle_stairs, north_2, SOUTH);
                        });
                    },
                    door_west_2 = @install() {
                        debug_subtext("S=7");

                        fog_wall_outside(!SOULS_MEMORY.DEAD_WALL, EAST);
                        map_transition(temple_underground_wall_boss, fake_lift, WEST);
                    },
                    door_west_1 = @install() {
                        map_transition(temple_underground_castle_south_west, east_1, WEST);
                    },
                    door_east_2 = @install() {
                        debug_subtext("S=9");

                        if(ROOM.FIREPIT_UNLOCKED) {
                            map_transition(temple_underground_firepit, west, EAST);
                        }
                    },

                    door_east_1 = @install() {
                        debug_subtext("S=10");

                        error_message(DOOR_WRONG_SIDE, WEST);
                    },
                    door_boss = @install() {
                        debug_subtext("S=11");

                        fog_wall_outside(!SOULS_MEMORY.DEAD_TEMPLE_SQUAD, SOUTH);
                        map_transition(temple_underground_boss, south, NORTH);
                    },
                    switch_triggered = @install() {
                        debug_subtext("S=12");
                    },
                    pit_6 = pit_triggered(),
                    pit_13 = pit_triggered(),
                    pit_12 = pit_triggered(),
                    pit_11 = pit_triggered(),
                    pit_10 = pit_triggered(),
                    pit_7 = pit_triggered(),
                    pit_8 = pit_triggered(),

                    pit_9 = pit_triggered(),
                    pit_13 = pit_triggered(),
                    pit_14 = pit_triggered(),
                    pit_15 = pit_triggered(),
                    pit_16 = pit_triggered(),
                    pit_20 = pit_triggered(),
                    pit_19 = pit_triggered(),
                    pit_17 = pit_triggered(),
                    pit_18 = pit_triggered(),
                    revealer_left = @install() {
                        debug_subtext("S=29");
                    },

                    revealer_right = @install() {
                        debug_subtext("S=30");
                    },
                    elevator = @install() {
                        elevator_triggered(0d1);
                    },
                }

                enum b_trigger {
                    gourd_1__2_VINEGAR = @install() {
                        debug_subtext("B=0");
                        
                        _loot_chest(0x02, LIMESTONE_TABLET, 0d01);
                    },
                    gourd_2__1_NECTAR = @install() {
                        debug_subtext("B=1");
                        
                        _loot_chest(0x01, MUD_PEPPER, 0d01);
                    },
                }

                @install()
                @async()
                fun revealer_approached(entity) {
                    range_checker(entity, <ACTIVE>, 0x20, 0x20, { pit_triggered(); });
                }

                fun open_doors(open) {
                    if(open) {
                        object[0x09] = 0x01; // NE
                        // object[0x03] = 0x01; // NW

                        // object[0x08] = 0x01; // SE
                        object[0x07] = 0x01; // SW

                    } else {
                        object[0x09] = 0x00; // NE
                        // object[0x03] = 0x00; // NW

                        // object[0x08] = 0x00; // SE
                        object[0x07] = 0x00; // SW

                    }
                }
                fun show_bridge_left() {
                    object[0x0b] = 0x01; // show bridge_left_1
                    object[0x0c] = 0x01; // show bridge_left_2
                    object[0x0d] = 0x01; // show bridge_left_3
                }
                fun show_bridge_right() {
                    object[0x0e] = 0x01; // show bridge_right_1
                    object[0x0f] = 0x01; // show bridge_right_2
                    object[0x10] = 0x01; // show bridge_right_3
                    object[0x11] = 0x01; // show bridge_right_4
                }

                fun trigger_enter() {
                    add_bombable(0d42, 0d133, ROOM.DOOR_SOUTH_OPENED, reference(trigger_door_south));

                    // object[0x00] = 0x7e; // enroll bridge
                    // object[0x01] = 0x01; // open gourde_2
                    // object[0x02] = 0x01; // open gourde_1
                    // object[0x03] = 0x01; // open door_NW
                    // object[0x04] = 0x04; // open door_boss
                    // object[0x05] = 0x7e; // open elevator
                    // object[0x06] = 0x01; // activate bridge_switch
                    // object[0x07] = 0x01; // open door_SW
                    // object[0x08] = 0x01; // open door_SE
                    // object[0x09] = 0x01; // open door_NE
                    // object[0x0a] = 0x01; // activate switch
                    // object[0x0b] = 0x01; // show bridge_left_1
                    // object[0x0c] = 0x01; // show bridge_left_2
                    // object[0x0d] = 0x01; // show bridge_left_3
                    // object[0x0e] = 0x01; // show bridge_right_1
                    // object[0x0f] = 0x01; // show bridge_right_2
                    // object[0x10] = 0x01; // show bridge_right_3
                    // object[0x11] = 0x01; // show bridge_right_4

                    if(ROOM.BOSS_DOOR_OPENED) {
                        object[0x00] = 0x7e; // enroll bridge
                        object[0x06] = 0x01; // activate bridge_switch
                        object[0x04] = 0x04; // open door_boss
                    }

                    if(ROOM.BRIDGE_REVEALED_RIGHT) {
                        show_bridge_right();
                    } else {
                        add_enemy(REVEALER_TARGET_ENTITY, 0d51, 0d32);
                        ROOM.BRIDGE_RIGHT = <LAST_ENTITY>;

                        revealer_approached(<LAST_ENTITY>);
                    }
                    if(ROOM.BRIDGE_REVEALED_LEFT) {
                        show_bridge_left();
                    } else {
                        add_enemy(REVEALER_TARGET_ENTITY, 0d32, 0d32);
                        ROOM.BRIDGE_LEFT = <LAST_ENTITY>;

                        revealer_approached(<LAST_ENTITY>);
                    }
                    special_script(REVEALER, reference(@install() {
                        if(<SCRIPT_OWNER> == ROOM.BRIDGE_LEFT) {
                            set(ROOM.BRIDGE_REVEALED_LEFT);

                            show_bridge_left();

                            destroy(SCRIPT_OWNER);
                        } else if(<SCRIPT_OWNER> == ROOM.BRIDGE_RIGHT) {
                            set(ROOM.BRIDGE_REVEALED_RIGHT);

                            show_bridge_right();

                            destroy(SCRIPT_OWNER);
                        }
                    }));

                    add_levitate_stone(0d8, 0d62, reference(@install() {
                        guard_levitate_stone(0d1);

                        object[0x03] = 0x01; // open door_NW
                        ROOM.DOOR_WALL_BOSS_OPENED = True;
                    }));
                    if(ROOM.DOOR_WALL_BOSS_OPENED) {
                        <LAST_ENTITY>[X] += ROOM.STONE_OFFSET;

                        object[0x03] = 0x01; // open door_NW
                    }
                    special_script(LEVITATE, reference(@install() {
                        if(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.INVINCIBLE_TEMP) {
                            end();
                        }

                        attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

                        if!(ROOM.DOOR_WALL_BOSS_OPENED) {
                            sleep(0d60);

                            ROOM.DOOR_WALL_BOSS_OPENED = True;
                            object[0x03] = 0x01; // open door_NW

                            sleep(0d60);

                            while(arg[0x10] < ROOM.STONE_OFFSET) {
                                arg[0x10]++;

                                <SCRIPT_OWNER>[X]++;

                                sleep(0d3);
                            }

                            sleep(0d360 - 0d3 * ROOM.STONE_OFFSET);
                        } else {
                            sleep(0d120);

                            while(arg[0x10] < ROOM.STONE_OFFSET) {
                                arg[0x10]++;

                                <SCRIPT_OWNER>[X]--;

                                sleep(0d3);
                            }

                            sleep(0d360 - 0d3 * ROOM.STONE_OFFSET);

                            ROOM.DOOR_WALL_BOSS_OPENED = False;
                            object[0x03] = 0x00; // open door_NW
                        }

                        attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
                    }));

                    set(AREA_TEMPLE.UNLOCKED_LEVEL_1);

                    open_doors(True);

                    if!(ROOM.FIREPIT_UNLOCKED) {
                        add_enemy(PLACEHOLDER, 0d77, 0d92);
                        attach_script(LAST_ENTITY, B, reference(@install() {
                            control(NONE);

                            ROOM.FIREPIT_UNLOCKED = True;
                            
                            sound(WEIRD_SOUND);
                            object[0x08] = 0x01; // open door_SE
                            sleep(0d30);

                            map_transition(temple_underground_firepit, west, EAST);
                        }));
                    } else {
                        object[0x08] = 0x01; // open door_SE
                    }

                    default_init_room(True, False);
                }
            };

            map temple_underground_firepit(FIREPIT_NOBILIA) {
                enum entrance {
                    west = entrance(0x05, 0x1b, EAST),

                    cutscene_landing = entrance(0x0b, 0x1b, NONE),
                    
                    bonfire = entrance(0d45, 0d17, NONE, { bonfire_wakeup(-0d40, 0d8, -0d32, 0d32); }),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    b_trigger_0 = @install() {
                        debug_subtext("S=0");
                    },
                    exit_west = @install() {
                        map_transition(temple_underground, east_2, WEST);
                    },
                }

                enum ROOM {
                    DEBUG = False,

                    PIT_IGNITED = memory(FLAG, SRAM),
                    FIRE_ORB_TRIGGER_COUNTER = memory(WORD, TEMP),
                }

                fun ignite_pit() {
                    object[0x00] = 0x01; // ignite firepit

                    bonfire(0d45, 0d17, SOULS_MEMORY.BONFIRE_TEMPLE_PIT);
                    attribute(LAST_ENTITY, INVISIBLE, True);
                    <LAST_ENTITY>[Z_LEVEL] = <BOY>[Z_LEVEL];
                }

                @install()
                fun firepit_damage() {
                    check_damage_type(FIRE, ROOM.FIRE_ORB_TRIGGER_COUNTER);

                    if(ROOM.FIRE_ORB_TRIGGER_COUNTER) {
                        ROOM.FIRE_ORB_TRIGGER_COUNTER = 0x00;
                        set(ROOM.PIT_IGNITED);
                        destroy(SCRIPT_OWNER);

                        set(SOULS_MEMORY.BONFIRE_TEMPLE_PIT);
                        ignite_pit();
                    } else {
                        heal(SCRIPT_OWNER, 0x00, False);
                        // damage(SCRIPT_OWNER, 0x00, True);
                    }

                    // reset_alchemy_types();
                }

                fun trigger_enter() {
                    // object[0x00] = 0x01; // ignite fire
                    // object[0x01] = 0x02; // show windwalker_collision

                    if!(ROOM.PIT_IGNITED) {
                        add_enemy(FACE_ENTITY, 0d45, 0d17);
                        attribute(LAST_ENTITY, INVISIBLE, True);
                        attach_script(LAST_ENTITY, DAMAGE, reference(firepit_damage));

                        reset_alchemy_types();
                    } else {
                        ignite_pit();
                    }

                    default_init_room(True, False);
                }
            };

            map temple_underground_wall_boss(HALLS_BRIDGE) {
                enum entrance {
                    test = entrance(0x21, 0x95, NORTH),
                    
                    fake_lift = entrance(0d78, 0d68, NONE, { crash_both(); }),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                fun lift_east_switch_triggered() {
                    object_animator(SWITCH_SPEAR_HALLS, False, 0x04, True, False);
                    object_animator(GATE_HALLS, False, 0x03, True, False);
                }
                fun lift_east_triggered() {
                    control(NONE);

                    walk(INACTIVE, COORDINATE_ABSOLUTE_DIRECT, <ACTIVE>[X], <ACTIVE>[Y], INACTIVE, NONE);

                    face(ACTIVE, SOUTH);
                    face(INACTIVE, SOUTH);

                    object_animator(GATE_HALLS, False, 0x03, False, False);
                    sleep(0d10);
                }

                enum BOSS {
                    DEBUG = False,

                    ID = memory(WORD, TEMP),
                    BARRIER_1_ID = memory(WORD, TEMP),
                    BARRIER_2_ID = memory(WORD, TEMP),

                    BRIDGE_3 = memory(WORD, TEMP),
                    BRIDGE_3_RESTORED = memory(FLAG, TEMP),
                    BRIDGE_6 = memory(WORD, TEMP),
                    BRIDGE_6_RESTORED = memory(FLAG, TEMP),
                    BRIDGE_12 = memory(WORD, TEMP),
                    BRIDGE_12_RESTORED = memory(FLAG, TEMP),

                    STEP_SIZE = 0d60,
                }

                fun bridge_triggered(flag) {
                    if!(flag) {
                        // debug_subtext("ded");

                        generic_fall(0d50, 0d1100);

                        dust_unreachable(0d39, 0d129);
                        damage(BOTH, 0d999, True);
                        sleep(0d30);
                        damage(BOTH, SYSTEM.HP_MAX, False);
                    }
                }

                fun update_camera_limit(x) {
                    if(False) {
                        _init_map(0d0, 0d0, x, 0d164 << 0d0003);
                    } else {
                        MEMORY.CAMERA_BOUNDRY_X_END = x + 0d5;
                    }
                }

                @install()
                fun boss_defeated() {
                    destroy(BOSS.BARRIER_1_ID);
                    destroy(BOSS.BARRIER_2_ID);

                    if(alive(BOSS.ID)) {
                        destroy(BOSS.ID);
                    }

                    souls_boss_defeated(DEAD_WALL, REWARD_WALL);

                    update_camera_limit(0xfff);
                }

                enum stepon_trigger {
                    lift_east = @install() {
                        debug_subtext("S=0");

                        lift_east_triggered();

                        map_transition(temple_underground, east_1, NONE);
                    },
                    gate_lift = @install() {
                        debug_subtext("S=1");
                    },
                    lift = @install() {
                        debug_subtext("S=2");
                    },
                    switch_monk = @install() {
                        debug_subtext("S=3");
                    },
                    switch_circle_1 = @install() {
                        debug_subtext("S=4");
                    },
                    switch_circle_5 = @install() {
                        debug_subtext("S=5");
                    },
                    switch_circle_4 = @install() {
                        debug_subtext("S=6");
                    },
                    switch_circle_6 = @install() {
                        debug_subtext("S=7");
                    },
                    switch_circle_3 = @install() {
                        debug_subtext("S=8");
                    },
                    switch_circle_2 = @install() {
                        debug_subtext("S=9");
                    },

                    switch_gate = @install() {
                        debug_subtext("S=10");
                    },
                    bridge_1 = @install() {
                        debug_subtext("S=11");
                    },
                    bridge_2 = @install() {
                        debug_subtext("S=12");
                    },
                    bridge_18 = @install() {
                        debug_subtext("S=13");
                    },
                    bridge_19 = @install() {
                        debug_subtext("S=14");
                    },
                    bridge_3 = @install() {
                        debug_subtext("S=15");
                    },
                    bridge_4 = @install() {
                        debug_subtext("S=16");
                    },
                    bridge_5 = @install() {
                        debug_subtext("S=17");

                        bridge_triggered(BOSS.BRIDGE_3_RESTORED);
                    },
                    bridge_6 = @install() {
                        debug_subtext("S=18");
                    },
                    bridge_7 = @install() {
                        debug_subtext("S=19");
                    },

                    bridge_8 = @install() {
                        debug_subtext("S=20");

                        bridge_triggered(BOSS.BRIDGE_6_RESTORED);
                    },
                    bridge_9 = @install() {
                        debug_subtext("S=21");
                    },
                    bridge_10 = @install() {
                        debug_subtext("S=22");
                    },
                    bridge_11 = @install() {
                        debug_subtext("S=23");
                    },
                    bridge_12 = @install() {
                        debug_subtext("S=24");
                    },
                    bridge_13 = @install() {
                        debug_subtext("S=25");
                    },
                    bridge_14 = @install() {
                        debug_subtext("S=26");

                        bridge_triggered(BOSS.BRIDGE_12_RESTORED);
                    },
                    bridge_15 = @install() {
                        debug_subtext("S=27");
                    },
                    bridge_16 = @install() {
                        debug_subtext("S=28");
                    },
                    bridge_17 = @install() {
                        debug_subtext("S=29");
                    },

                    secret_passage_1 = @install() {
                        debug_subtext("S=30");
                    },
                    secret_passage_2 = @install() {
                        debug_subtext("S=31");
                    },
                }

                enum b_trigger {
                    lift = @install() {
                        debug_subtext("B=0");

                        if!(SOULS_MEMORY.DEAD_WALL) {
                            boss_defeated();
                        }
                        
                        lift_east_switch_triggered();
                    },
                    gourd__3_honey = @install() {
                        debug_subtext("B=1");
                        if!(SOULS_MEMORY.DEAD_WALL) {
                            loot(LOOT_SNIFF, False, 0xff, MUD_PEPPER, 0d01, 0d0); // inifinite refill
                        } else {
                            _loot_chest(0x20, MUD_PEPPER, 0d01);
                        }
                    },
                }

                fun move_left(x) {
                    arg[0x12] = x;

                    while(arg[0x12] > 0d0) {
                        arg[0x12]--;
                        <SCRIPT_OWNER>[X]--;

                        update_camera_limit(<SCRIPT_OWNER>[X]);

                        yield();
                    }
                }
                fun move_right(x) {
                    arg[0x12] = x;

                    while(arg[0x12] > 0d0) {
                        arg[0x12]--;
                        <SCRIPT_OWNER>[X]++;

                        update_camera_limit(<SCRIPT_OWNER>[X]);

                        yield();
                    }
                }

                @install()
                @async()
                fun _barage(y_offset, level) {
                    shoot_entity_offset_relative(BOSS.ID, ONION, 0d0, y_offset, -0d30, 0d0, 0d20, 0d0);

                    sleep(0d20);
                    shoot_entity_offset_relative(BOSS.ID, ONION, 0d0, y_offset, -0d100, 0d0, 0d20, 0d0);

                    sleep(0d20);
                    shoot_entity_offset_relative(BOSS.ID, ONION, 0d0, y_offset, -0d150, 0d0, 0d20, 0d0);

                    sleep(0d20);
                    shoot_entity_offset_relative(BOSS.ID, ONION, 0d0, y_offset, -0d200, 0d0, 0d20, 0d0);

                    // sleep(0d20);
                    // shoot_entity_offset_relative(BOSS.ID, ONION, 0d0, y_offset, -0d250, 0d0, 0d20, 0d0);
                }
                fun prepare_rng() {
                    // debug_memory(<BOY>[Y], BOSS.ID[Y]);

                    if(randrange(0d2) == 0d0) {
                        if(<BOY>[Y] > BOSS.ID[Y]) { // boy south of boss
                            arg[0x14] = <BOY>[Y] - BOSS.ID[Y];

                            if(arg[0x14] < 0d15) {
                                arg[0x14] = 0d0;
                            } else {
                                arg[0x14] = 0d30;
                            }
                        } else { // boy north of boss
                            arg[0x14] = BOSS.ID[Y] - <BOY>[Y];

                            if(arg[0x14] < 0d15) {
                                arg[0x14] = 0d0;
                            } else {
                                arg[0x14] = -0d30;
                            }
                        }

                        arg[0x12] = arg[0x14];
                    } else {
                        arg[0x12] = randrange(0d3);

                        if(arg[0x12] == 0d0) {
                            arg[0x12] = -0d30;
                        } else if(arg[0x12] == 0d1) {
                            arg[0x12] = 0d0;
                        } else {
                            arg[0x12] = 0d30;
                        }
                    }

                    // debug_memory(<BOY>[Y] - BOSS.ID[Y], arg[0x14]);
                }
                @install()
                @async()
                fun barage(repeat, level) {
                    while(arg[0x10] < repeat) {
                        arg[0x10]++;

                        prepare_rng();

                        _barage(arg[0x12], level);

                        sleep(0d60);
                    }
                }

                @install()
                @async()
                fun movement_watcher() {
                    attach_to_script(BOSS.ID);

                    while(alive(<SCRIPT_OWNER>)) {
                        arg[0x10] = <SCRIPT_OWNER>[HP];

                        sleep(0d180);

                        arg[0x12] = arg[0x10] - <SCRIPT_OWNER>[HP];

                        if(BOSS.DEBUG) {
                            debug_memory(<SCRIPT_OWNER>[HP], arg[0x12]);
                        }

                        sound(ELEVATOR_DOOR);
                        sleep(0d30);

                        if(arg[0x12] == 0d0) {
                            move_left(BOSS.STEP_SIZE);
                        } else if(arg[0x12] > 0d80) {
                            move_right(BOSS.STEP_SIZE * 0d2);
                        } else if(arg[0x12] > 0d10) {
                            move_right(BOSS.STEP_SIZE);
                        }
                        sound(ELEVATOR_DOOR);

                        if(arg[0x14] > 0d0) {
                            arg[0x14]--;
                        } else {
                            barage(0d2, 0d1);

                            if(0d2 > 0d1) {
                                arg[0x14] = 0d2 - 0d1;
                            }
                        }
                    }
                }

                fun punish_position(entity, x) {
                    if(alive(entity)) {
                        if(entity[X] > (BOSS.ID[X] - x)) {
                            sound(TESLA);

                            face(entity, EAST);
                            damage(entity, 0d5, True);
                        }
                    }
                }

                @install()
                @async()
                fun stack_t0123() {
                    while(alive(BOSS.ID)) {
                        BOSS.BARRIER_1_ID[X] = BOSS.ID[X] - 0d40;
                        BOSS.BARRIER_2_ID[X] = BOSS.ID[X] - 0d40;

                        sleep(0d2);

                        punish_position(<BOY>, 0d50);
                        yield();
                        punish_position(<DOG>, 0d20);
                        yield();
                    }
                }

                @install()
                fun levitate_triggered() {
                    teleport(SCRIPT_OWNER, 0d0, 0d0);

                    if(<SCRIPT_OWNER> == BOSS.BRIDGE_3) {
                        object[0x13] = 0x00;
                        BOSS.BRIDGE_3_RESTORED = True;
                    } else if(<SCRIPT_OWNER> == BOSS.BRIDGE_6) {
                        object[0x16] = 0x00;
                        BOSS.BRIDGE_6_RESTORED = True;
                    } else if(<SCRIPT_OWNER> == BOSS.BRIDGE_12) {
                        object[0x1c] = 0x00;
                        BOSS.BRIDGE_12_RESTORED = True;
                    }

                    destroy(SCRIPT_OWNER);
                }

                fun trigger_enter() {
                    if((NPC_CRAFTER.PROGRESS >= 0x10) && (NPC_CRAFTER.PROGRESS < 0x20)) {
                        add_souls_npc_crafter(0d97, 0d82);
                    }

                    // object[0x00] = 0x7e; // light arena_spawn_left
                    // object[0x01] = 0x7e; // light arena_spawn_right
                    object[0x02] = 0x7e; // open arena_lift_gate
                    // object[0x03] = 0x7e; // open lift_gate
                    // object[0x04] = 0x01; // active lift_switch
                    // object[0x05] = 0x01; // active switch_circle_1
                    // object[0x06] = 0x01; // active switch_circle_2
                    // object[0x07] = 0x01; // active switch_circle_6
                    // object[0x08] = 0x01; // active switch_circle_3
                    // object[0x09] = 0x01; // active switch_circle_5
                    // object[0x0a] = 0x01; // active switch_circle_4
                    // object[0x0b] = 0x01; // active switch_gate_2
                    // object[0x0c] = 0x01; // active switch_gate_1
                    // object[0x0d] = 0x01; // active switch_monk
                    object[0x0e] = 0x7e; // open gate_arena
                    // object[0x0f] = 0x7e; // open gate_switch_circle
                    object[0x10] = 0x7e; // close gate
                    // object[0x20] = 0x7e; // loot gourd

                    default_init_room(True, False);

                    if!(SOULS_MEMORY.DEAD_WALL) {
                        while(<BOY>[Y] < 0d930) {
                            yield();
                        }

                        add_placeholder(SPARK_LEFT, 0d41, 0d131);
                        BOSS.BARRIER_1_ID = <LAST_ENTITY>;
                        add_placeholder(SPARK_LEFT, 0d41, 0d137);
                        BOSS.BARRIER_2_ID = <LAST_ENTITY>;

                        add_enemy(AEGIS_ENTITY, 0d48, 0d131); // 0d44, 0d131
                        BOSS.ID = <LAST_ENTITY>;
                        attach_script(LAST_ENTITY, DEATH, reference(boss_defeated));
                        // add_placeholder(SKELETON_SHIP_1, 0d41, 0d131);

                        walk(BOY, TILE_ABSOLUTE, 0d30, 0d133, NONE, NONE);
                        walk(DOG, TILE_ABSOLUTE, 0d25, 0d119, BOTH, BOTH);
                        face(BOY, EAST);
                        teleport(DOG, 0d6, 0d117);

                        stack_t0123();
                        update_camera_limit(<LAST_ENTITY>[X]);

                        movement_watcher();

                        push_music(BOSS);

                        // object[0x11] = 0x7e; // collapse bridge_1
                        // object[0x12] = 0x7e; // collapse bridge_2
                        object[0x13] = 0x7e; // collapse bridge_3
                        // object[0x14] = 0x7e; // collapse bridge_4
                        // object[0x15] = 0x7e; // collapse bridge_5
                        // object[0x16] = 0x7e; // collapse bridge_6
                        // object[0x17] = 0x7e; // collapse bridge_7
                        // object[0x18] = 0x7e; // collapse bridge_8
                        // object[0x19] = 0x7e; // collapse bridge_9
                        // object[0x1a] = 0x7e; // collapse bridge_10
                        // object[0x1b] = 0x7e; // collapse bridge_11
                        object[0x1c] = 0x7e; // collapse bridge_12
                        // object[0x1d] = 0x7e; // collapse bridge_13
                        // object[0x1e] = 0x7e; // collapse bridge_14
                        // object[0x1f] = 0x7e; // collapse bridge_15

                        if(False) {
                            add_enemy(REVEALER_TARGET_ENTITY, 0d54, 0d129); // bridge_3, trigger=17
                            BOSS.BRIDGE_3 = <LAST_ENTITY>;

                            // add_enemy(REVEALER_TARGET_ENTITY, 0d65, 0d129); // bridge_6, trigger=20
                            // BOSS.BRIDGE_6 = <LAST_ENTITY>;
                            BOSS.BRIDGE_6_RESTORED = True;

                            add_enemy(REVEALER_TARGET_ENTITY, 0d89, 0d129); // bridge_12, trigger=26
                            BOSS.BRIDGE_12 = <LAST_ENTITY>;

                            special_script(REVEALER, reference(levitate_triggered));
                        } else {
                            add_enemy(STONE, 0d54, 0d138, STONE_LEVITATE_INVISIBLE); // bridge_3, trigger=17
                            BOSS.BRIDGE_3 = <LAST_ENTITY>;

                            // add_enemy(REVEALER_TARGET_ENTITY, 0d65, 0d138, STONE_LEVITATE); // bridge_6, trigger=20
                            // BOSS.BRIDGE_6 = <LAST_ENTITY>;
                            BOSS.BRIDGE_6_RESTORED = True;

                            add_enemy(STONE, 0d89, 0d138, STONE_LEVITATE_INVISIBLE); // bridge_12, trigger=26
                            BOSS.BRIDGE_12 = <LAST_ENTITY>;

                            special_script(LEVITATE, reference(levitate_triggered));
                        }
                    } else {
                        BOSS.BRIDGE_3_RESTORED = True;
                        BOSS.BRIDGE_6_RESTORED = True;
                        BOSS.BRIDGE_12_RESTORED = True;
                    }
                }
            };

            map temple_underground_boss(MEGATAUR) {
                enum entrance {
                    south = entrance(0x41, 0x53, NORTH)
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum BOSS {
                    DEBBUG = False,

                    PROGRESS = memory(FLAG, TEMP),

                    SQUAD_COUNT = 0d5,
                    SQUAD_CHARGED = memory(WORD, TEMP),

                    SQUAD_REQURIED = 0d5,
                    SQUAD_REQURIED_COUNT = memory(WORD, TEMP),

                    SQUAD_1 = memory(WORD, TEMP),
                    SQUAD_2 = memory(WORD, TEMP),
                    SQUAD_3 = memory(WORD, TEMP),
                    SQUAD_4 = memory(WORD, TEMP),
                    SQUAD_5 = memory(WORD, TEMP),

                    PALETTE_DONOR = memory(WORD, TEMP),
                }

                enum stepon_trigger {
                    exit_south = @install() {
                        if(BOSS.PROGRESS) {
                            fog_wall_inside(!SOULS_MEMORY.DEAD_TEMPLE_SQUAD, NORTH);
                        }

                        map_transition(temple_underground, north, SOUTH);
                    }
                }

                fun boss_defeated() {
                    damage(BOSS.SQUAD_1, 0d999, True);
                    damage(BOSS.SQUAD_2, 0d999, True);
                    damage(BOSS.SQUAD_3, 0d999, True);
                    damage(BOSS.SQUAD_4, 0d999, True);
                    damage(BOSS.SQUAD_5, 0d999, True);

                    BOSS.PROGRESS = False;
                    souls_boss_defeated(DEAD_TEMPLE_SQUAD, REWARD_TEMPLE_SQUAD);
                }

                fun squad_killed() {
                    BOSS.SQUAD_REQURIED_COUNT++;

                    if(BOSS.SQUAD_REQURIED_COUNT >= BOSS.SQUAD_REQURIED) {
                        boss_defeated();
                        end();
                    }
                }

                @install()
                fun squad_death() {
                    if((BOSS.SQUAD_CHARGED == 0d0) || (BOSS.SQUAD_CHARGED == <SCRIPT_OWNER>)) {
                        BOSS.SQUAD_CHARGED = <SCRIPT_OWNER>;

                        squad_killed();

                        yield();

                        while((arg[0x14] == 0x0000) || (arg[0x14] == <SCRIPT_OWNER>)) {
                            arg[0x10] = randrange(BOSS.SQUAD_COUNT) + 0d1;

                            if(arg[0x10] == 0d1) {
                                arg[0x12] = BOSS.SQUAD_1;
                            } else if(arg[0x10] == 0d2) {
                                arg[0x12] = BOSS.SQUAD_2;
                            } else if(arg[0x10] == 0d3) {
                                arg[0x12] = BOSS.SQUAD_3;
                            } else if(arg[0x10] == 0d4) {
                                arg[0x12] = BOSS.SQUAD_4;
                            } else if(arg[0x10] == 0d5) {
                                arg[0x12] = BOSS.SQUAD_5;
                            }

                            if(alive(arg[0x12])) {
                                arg[0x14] = arg[0x12];
                            }

                            yield();
                        }

                        BOSS.SQUAD_CHARGED = arg[0x14];
                        // BOSS.SQUAD_CHARGED = 0d0;

                        attribute(BOY, INVINCIBLE_TEMP, True);

                        attribute(arg[0x12], ROOT, True);
                        animate(arg[0x12], LOOP, DEFAULT);
                        shoot_entity_entity_offset(<SCRIPT_OWNER>, LIGHTNING_BALL, arg[0x12], 0d0, -(0d50), 0d60, 0d0);
                        sleep(0d20);
                        attribute(BOY, INVINCIBLE_TEMP, False);
                        sleep(0d100);

                        if(alive(arg[0x14])) {
                            attribute(arg[0x14], ROOT, False);
                            animate(arg[0x14], ONCE, DEFAULT);

                            if(BOSS.DEBBUG) {
                                debug_memory(<SCRIPT_OWNER>[GENERAL_PURPOSE], arg[0x14]);
                            }

                            while(alive(arg[0x14])) {
                                if(arg[0x14][PALETTE] != BOSS.PALETTE_DONOR[PALETTE]) {
                                    arg[0x14][PALETTE] = BOSS.PALETTE_DONOR[PALETTE];
                                }
                                
                                sleep(0d5);
                            }
                        }
                    }

                    destroy(SCRIPT_OWNER);
                }

                fun spawn_oglin(x, y, memory, index) {
                    // debug_subtext("oglin");

                    add_enemy(OGLIN, x, y);
                    memory = <LAST_ENTITY>;
                    <LAST_ENTITY>[GENERAL_PURPOSE] = index;
                    attach_script(LAST_ENTITY, DEATH, reference(squad_death));

                    // attribute(LAST_ENTITY, NO_CLIP, True);
                    attribute(LAST_ENTITY, INVINCIBLE_TEMP, True);
                    animate(LAST_ENTITY, ONCE, SLASH_2);

                    sleep(0d60);

                    attribute(LAST_ENTITY, INVINCIBLE_TEMP, False);
                    // attribute(LAST_ENTITY, NO_CLIP, False);

                    attribute(LAST_ENTITY, True, True);
                }

                fun add_squad(x, y) {
                    while(BOSS.PROGRESS) {
                        if(dead(BOSS.SQUAD_1)) {
                            spawn_oglin(x, y, BOSS.SQUAD_1, 0d1);
                        } else if(dead(BOSS.SQUAD_2)) {
                            spawn_oglin(x, y, BOSS.SQUAD_2, 0d2);
                        } else if(dead(BOSS.SQUAD_3)) {
                            spawn_oglin(x, y, BOSS.SQUAD_3, 0d3);
                        } else if(dead(BOSS.SQUAD_4)) {
                            spawn_oglin(x, y, BOSS.SQUAD_4, 0d4);
                        } else if(dead(BOSS.SQUAD_5)) {
                            spawn_oglin(x, y, BOSS.SQUAD_5, 0d5);
                        }

                        sleep(0d60);
                    }
                }

                fun trigger_enter() {   
                    CUSTOM_FLAG.NO_DOG = True;

                    // attribute(BOY, INVINCIBLE_TEMP, True);

                    add_enemy(DOG_1_BLACK, 0d0, 0d0, INVISBLE_INVINCIBLE_INACTIVE);
                    BOSS.PALETTE_DONOR = <LAST_ENTITY>;

                    if!(SOULS_MEMORY.DEAD_TEMPLE_SQUAD) {
                        BOSS.PROGRESS = True;
                        push_music(BOSS);

                        default_init_room(False, False);

                        add_squad(0d64, 0d32);
                    } else {
                        default_init_room(False, False);
                    }

                    // 0d64, 0d22
                    // 0d64, 0d40
                }
            };
        };

        area level_2() {
            map temple_underground_castle(HALLS_CENTER) {
                // chests=nothing

                enum entrance {
                    north = entrance(0x29, 0x03, SOUTH),
                    east_1 = entrance(0x4b, 0x3f, WEST),
                    east_2 = entrance(0x49, 0x5d, WEST),
                    south = entrance(0x29, 0x8b, NORTH),
                    west_1 = entrance(0x09, 0x5d, EAST),
                    west_2 = entrance(0x09, 0x3f, EAST),

                    // elevator = entrance(0x29, 0x49, NONE),
                    elevator = entrance(0x29, 0x4c, SOUTH, { elevator_entrance(); }),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    stepon_0 = @install() {
                        debug_subtext("S=0");
                    },
                    stepon_1 = @install() {
                        debug_subtext("S=1");
                    },
                    stepon_2 = @install() {
                        debug_subtext("S=2");
                    },
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    stepon_4 = @install() {
                        debug_subtext("S=4");
                    },
                    stepon_5 = @install() {
                        debug_subtext("S=5");
                    },
                    exit_south = @install() {
                        map_transition(temple_underground_castle_stairs, north_1, SOUTH);
                    },
                    door_west_2 = @install() {
                        debug_subtext("S=7");
                    },
                    door_west_1 = @install() {
                        map_transition(temple_underground_castle_south_west, east_2, WEST);
                    },
                    door_east_2 = @install() {
                        fog_wall_outside(SOULS_MEMORY.PROGRESS_NARIS, WEST);

                        map_transition(temple_underground_castle_south_east, west, EAST);
                    },

                    door_east_1 = @install() {
                        debug_subtext("S=10");
                    },
                    stepon_11 = @install() {
                        debug_subtext("S=11");
                    },
                    switch_triggered = @install() {
                        debug_subtext("S=12");
                    },
                    stepon_13 = @install() {
                        debug_subtext("S=13");
                    },
                    stepon_14 = @install() {
                        debug_subtext("S=14");
                    },
                    stepon_15 = @install() {
                        debug_subtext("S=15");
                    },
                    stepon_16 = @install() {
                        debug_subtext("S=16");
                    },
                    stepon_17 = @install() {
                        debug_subtext("S=17");
                    },
                    stepon_18 = @install() {
                        debug_subtext("S=18");
                    },
                    stepon_19 = @install() {
                        debug_subtext("S=19");
                    },

                    stepon_20 = @install() {
                        debug_subtext("S=20");
                    },
                    stepon_21 = @install() {
                        debug_subtext("S=21");
                    },
                    stepon_22 = @install() {
                        debug_subtext("S=22");
                    },
                    stepon_23 = @install() {
                        debug_subtext("S=23");
                    },
                    stepon_24 = @install() {
                        debug_subtext("S=24");
                    },
                    stepon_25 = @install() {
                        debug_subtext("S=25");
                    },
                    stepon_26 = @install() {
                        debug_subtext("S=26");
                    },
                    stepon_27 = @install() {
                        debug_subtext("S=27");
                    },
                    stepon_28 = @install() {
                        debug_subtext("S=28");
                    },
                    stepon_29 = @install() {
                        debug_subtext("S=29");
                    },

                    stepon_30 = @install() {
                        debug_subtext("S=30");
                    },
                    elevator = @install() {
                        elevator_triggered(0d2);
                    },
                }

                enum b_trigger {
                    gourd_1__2_VINEGAR = @install() {
                        debug_subtext("B=0");
                        // _loot_chest(0x02, VINEGAR, 0d02);
                    },
                    gourd_2__1_NECTAR = @install() {
                        debug_subtext("B=1");
                        // _loot_chest(0x01, NECTAR, 0d01);
                    },
                }

                fun open_doors(open) {
                    if(open) {
                        object[0x09] = 0x01; // NE
                        object[0x03] = 0x01; // NW

                        object[0x08] = 0x01; // SE
                        object[0x07] = 0x01; // SW
                    } else {
                        object[0x09] = 0x00; // NE
                        object[0x03] = 0x00; // NW

                        object[0x08] = 0x00; // SE
                        object[0x07] = 0x00; // SW
                    }
                }

                fun trigger_enter() {
                    set(AREA_TEMPLE.UNLOCKED_LEVEL_2);

                    fake_northern_wall();

                    open_doors(True);

                    default_init_room(True, False);
                }
            };

            map temple_underground_castle_stairs(EBON_HALL) {
                enum entrance {
                    test = entrance(0x10, 0x10, NONE),

                    north_1 = entrance(0x14, 0x4b, SOUTH),
                    north_2 = entrance(0x40, 0x11, SOUTH, {
                        object[0x03] = 0x01;
                        object[0x04] = 0x01;
                    }),
                    south = entrance(0x25, 0x75, NORTH),
                    west = entrance(0x07, 0x53, EAST),
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_west = @install() {
                        debug_subtext("S=0");
                    },
                    exit_north_1 = @install() {
                        debug_subtext("S=1");

                        map_transition(temple_underground_castle, south, NORTH);
                    },
                    exit_south = @install() {
                        debug_subtext("S=2");
                    },
                    exit_north_2 = @install() {
                        debug_subtext("S=3");

                        map_transition(temple_underground, south, NORTH);
                    },
                    stairs_helper_1 = @install() {
                        debug_subtext("S=4");

                        vanilla_a3_stairs_helper(0x04, 0x44, 0x34, True);
                    },
                    stairs_helper_2 = @install() {
                        debug_subtext("S=5");

                        vanilla_a3_stairs_helper(0x04, 0x44, 0x2e, False);
                    },
                    stairs_helper_3 = @install() {
                        debug_subtext("S=6");

                        vanilla_a3_stairs_helper(0x03, 0x44, 0x24, True);
                    },
                    stairs_helper_4 = @install() {
                        debug_subtext("S=7");

                        vanilla_a3_stairs_helper(0x03, 0x44, 0x1e, False);
                    },
                }

                fun trigger_enter() {
                    // object[0x00] = 0x01; // hide statue
                    // object[0x01] = 0x01; // hide rubble
                    // 2-4 ?
                    // object[0x05] = 0x01; // open door
                    // >5 ?

                    default_init_room(True, False);
                }
            };
            
            map temple_underground_castle_south_east(NARIS) {
                enum entrance {
                    east = entrance(0x77, 0x29, WEST),
                    west = entrance(0x07, 0x28, EAST),
                }

                enum soundtrack {
                    default = soundtrack(WIND_AMBIENT_BIRDS_2, 0xff)
                }

                enum ROOM {
                    BEE_COLLECTED = memory(FLAG, SRAM),

                    DOOR_NORTH_1 = memory(FLAG, TEMP),
                    DOOR_NORTH_2 = memory(FLAG, TEMP),
                    DOOR_NORTH_3 = memory(FLAG, TEMP),
                    DOOR_SOUTH_1 = memory(FLAG, TEMP),
                    DOOR_SOUTH_2 = memory(FLAG, TEMP),
                    DOOR_SOUTH_3 = memory(FLAG, TEMP),

                    DOOR_PERMISSION = FLAG.QUEENS_KEY,
                }

                group boss_ai() {
                    enum BOSS {
                        DEBUG = False,
                        DEBUG_MARBLES = False,

                        PROGRESS = SOULS_MEMORY.PROGRESS_NARIS,
                        PHASE = memory(WORD, TEMP),

                        RIDER_ID = memory(WORD, TEMP),
                        MOUNT_ID = memory(WORD, TEMP),

                        FOLLOW_ID = memory(WORD, TEMP),

                        NARIS_BUSY = memory(FLAG, TEMP),
                        NARIS_BUSY_COUNT = 0d60 * 0d0005,

                        BOSS_HP = 0d3000,
                        THRESHOLD_P1 = 0d3000 - 0d500,
                        THRESHOLD_P2 = 0d3000 - 0d2000,

                        GUESS_RNG = memory(WORD, TEMP),
                        ANGER_LEVEL = 0x0000,

                        P1_THRESHOLD = 0x00,
                    }

                    fun boss_defeated() {
                        BOSS.PROGRESS = False;
                        
                        souls_boss_defeated(DEAD_NARIS, REWARD_NARIS);
                    }

                    fun spawn_enemies(enemy_id) {
                        _add_enemy(enemy_id, BOSS.MOUNT_ID[X], BOSS.MOUNT_ID[Y]);
                        _add_enemy(enemy_id, BOSS.MOUNT_ID[X], BOSS.MOUNT_ID[Y]);
                    }

                    @install()
                    fun _get_prime(digits) {
                        if(digits == 0d1) { // 2, 3, 5, 7
                            while((arg[0x10]) == 0d0 || (arg[0x10] == MEMORY.STRING_PARAMETER_1) || (arg[0x10] == MEMORY.STRING_PARAMETER_2) || (arg[0x10] == MEMORY.STRING_PARAMETER_3)) {
                                arg[0x12] = randrange(0d4);

                                if(arg[0x12] == 0d0) {
                                    arg[0x10] = 0d2;
                                } else if(arg[0x12] == 0d1) {
                                    arg[0x10] = 0d3;
                                } else if(arg[0x12] == 0d2) {
                                    arg[0x10] = 0d5;
                                } else if(arg[0x12] == 0d3) {
                                    arg[0x10] = 0d7;
                                }
                            }
                        } else if(digits == 0d2) { // 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97
                            while((arg[0x10]) == 0d0 || (arg[0x10] == MEMORY.STRING_PARAMETER_1) || (arg[0x10] == MEMORY.STRING_PARAMETER_2) || (arg[0x10] == MEMORY.STRING_PARAMETER_3)) {
                                arg[0x12] = randrange(0d21);

                                if(arg[0x12] == 0d0) {
                                    arg[0x10] = 0d11;
                                } else if(arg[0x12] == 0d1) {
                                    arg[0x10] = 0d13;
                                } else if(arg[0x12] == 0d2) {
                                    arg[0x10] = 0d17;
                                } else if(arg[0x12] == 0d3) {
                                    arg[0x10] = 0d19;
                                } else if(arg[0x12] == 0d4) {
                                    arg[0x10] = 0d23;
                                } else if(arg[0x12] == 0d5) {
                                    arg[0x10] = 0d29;
                                } else if(arg[0x12] == 0d6) {
                                    arg[0x10] = 0d31;
                                } else if(arg[0x12] == 0d7) {
                                    arg[0x10] = 0d37;
                                } else if(arg[0x12] == 0d8) {
                                    arg[0x10] = 0d41;
                                } else if(arg[0x12] == 0d9) {
                                    arg[0x10] = 0d43;
                                } else if(arg[0x12] == 0d10) {
                                    arg[0x10] = 0d47;
                                } else if(arg[0x12] == 0d11) {
                                    arg[0x10] = 0d53;
                                } else if(arg[0x12] == 0d12) {
                                    arg[0x10] = 0d59;
                                } else if(arg[0x12] == 0d13) {
                                    arg[0x10] = 0d61;
                                } else if(arg[0x12] == 0d14) {
                                    arg[0x10] = 0d67;
                                } else if(arg[0x12] == 0d15) {
                                    arg[0x10] = 0d71;
                                } else if(arg[0x12] == 0d16) {
                                    arg[0x10] = 0d73;
                                } else if(arg[0x12] == 0d17) {
                                    arg[0x10] = 0d79;
                                } else if(arg[0x12] == 0d18) {
                                    arg[0x10] = 0d83;
                                } else if(arg[0x12] == 0d19) {
                                    arg[0x10] = 0d89;
                                } else if(arg[0x12] == 0d20) {
                                    arg[0x10] = 0d97;
                                }
                            }
                        } else { // 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, …
                            while((arg[0x10]) == 0d0 || (arg[0x10] == MEMORY.STRING_PARAMETER_1) || (arg[0x10] == MEMORY.STRING_PARAMETER_2) || (arg[0x10] == MEMORY.STRING_PARAMETER_3)) {
                                arg[0x12] = randrange(0d18);

                                if(arg[0x12] == 0d0) {
                                    arg[0x10] = 0d101;
                                } else if(arg[0x12] == 0d1) {
                                    arg[0x10] = 0d103;
                                } else if(arg[0x12] == 0d2) {
                                    arg[0x10] = 0d107;
                                } else if(arg[0x12] == 0d3) {
                                    arg[0x10] = 0d109;
                                } else if(arg[0x12] == 0d4) {
                                    arg[0x10] = 0d113;
                                } else if(arg[0x12] == 0d5) {
                                    arg[0x10] = 0d127;
                                } else if(arg[0x12] == 0d6) {
                                    arg[0x10] = 0d131;
                                } else if(arg[0x12] == 0d7) {
                                    arg[0x10] = 0d137;
                                } else if(arg[0x12] == 0d8) {
                                    arg[0x10] = 0d139;
                                } else if(arg[0x12] == 0d9) {
                                    arg[0x10] = 0d149;
                                } else if(arg[0x12] == 0d10) {
                                    arg[0x10] = 0d151;
                                } else if(arg[0x12] == 0d11) {
                                    arg[0x10] = 0d157;
                                } else if(arg[0x12] == 0d12) {
                                    arg[0x10] = 0d163;
                                } else if(arg[0x12] == 0d13) {
                                    arg[0x10] = 0d167;
                                } else if(arg[0x12] == 0d14) {
                                    arg[0x10] = 0d173;
                                } else if(arg[0x12] == 0d15) {
                                    arg[0x10] = 0d179;
                                } else if(arg[0x12] == 0d16) {
                                    arg[0x10] = 0d181;
                                } else if(arg[0x12] == 0d17) {
                                    arg[0x10] = 0d191;
                                }
                            }
                        }

                        CUSTOM_MEMORY.RETURN = arg[0x10];
                    }
                    @install()
                    fun _get_non_prime(digits) {
                        if(digits == 0d1) { // 4, 6, 8, 9
                            while((arg[0x10]) == 0d0 || (arg[0x10] == MEMORY.STRING_PARAMETER_1) || (arg[0x10] == MEMORY.STRING_PARAMETER_2) || (arg[0x10] == MEMORY.STRING_PARAMETER_3)) {
                                arg[0x12] = randrange(0d4);

                                if(arg[0x12] == 0d0) {
                                    arg[0x10] = 0d4;
                                } else if(arg[0x12] == 0d1) {
                                    arg[0x10] = 0d6;
                                } else if(arg[0x12] == 0d2) {
                                    arg[0x10] = 0d8;
                                } else if(arg[0x12] == 0d3) {
                                    arg[0x10] = 0d9;
                                }
                            }
                        } else if(digits == 0d2) { // 12, 15, 18, 20, 25, 30, 33, 39, 42, 45, 49, 56, 60, 63, 69, 72, 75, 81, 88, 91, 99
                            while((arg[0x10]) == 0d0 || (arg[0x10] == MEMORY.STRING_PARAMETER_1) || (arg[0x10] == MEMORY.STRING_PARAMETER_2) || (arg[0x10] == MEMORY.STRING_PARAMETER_3)) {
                                arg[0x12] = randrange(0d21);

                                if(arg[0x12] == 0d0) {
                                    arg[0x10] = 0d12;
                                } else if(arg[0x12] == 0d1) {
                                    arg[0x10] = 0d15;
                                } else if(arg[0x12] == 0d2) {
                                    arg[0x10] = 0d18;
                                } else if(arg[0x12] == 0d3) {
                                    arg[0x10] = 0d20;
                                } else if(arg[0x12] == 0d4) {
                                    arg[0x10] = 0d25;
                                } else if(arg[0x12] == 0d5) {
                                    arg[0x10] = 0d30;
                                } else if(arg[0x12] == 0d6) {
                                    arg[0x10] = 0d33;
                                } else if(arg[0x12] == 0d7) {
                                    arg[0x10] = 0d39;
                                } else if(arg[0x12] == 0d8) {
                                    arg[0x10] = 0d42;
                                } else if(arg[0x12] == 0d9) {
                                    arg[0x10] = 0d45;
                                } else if(arg[0x12] == 0d10) {
                                    arg[0x10] = 0d49;
                                } else if(arg[0x12] == 0d11) {
                                    arg[0x10] = 0d56;
                                } else if(arg[0x12] == 0d12) {
                                    arg[0x10] = 0d60;
                                } else if(arg[0x12] == 0d13) {
                                    arg[0x10] = 0d63;
                                } else if(arg[0x12] == 0d14) {
                                    arg[0x10] = 0d69;
                                } else if(arg[0x12] == 0d15) {
                                    arg[0x10] = 0d72;
                                } else if(arg[0x12] == 0d16) {
                                    arg[0x10] = 0d75;
                                } else if(arg[0x12] == 0d17) {
                                    arg[0x10] = 0d81;
                                } else if(arg[0x12] == 0d18) {
                                    arg[0x10] = 0d88;
                                } else if(arg[0x12] == 0d19) {
                                    arg[0x10] = 0d91;
                                } else if(arg[0x12] == 0d20) {
                                    arg[0x10] = 0d99;
                                }
                            }
                        } else { // 102, 106, 108, 111, 115, 130, 133, 138, 141, 150, 153, 159, 164, 169, 175, 180, 183, 199, …
                            while((arg[0x10]) == 0d0 || (arg[0x10] == MEMORY.STRING_PARAMETER_1) || (arg[0x10] == MEMORY.STRING_PARAMETER_2) || (arg[0x10] == MEMORY.STRING_PARAMETER_3)) {
                                arg[0x12] = randrange(0d18);

                                if(arg[0x12] == 0d0) {
                                    arg[0x10] = 0d102;
                                } else if(arg[0x12] == 0d1) {
                                    arg[0x10] = 0d106;
                                } else if(arg[0x12] == 0d2) {
                                    arg[0x10] = 0d108;
                                } else if(arg[0x12] == 0d3) {
                                    arg[0x10] = 0d111;
                                } else if(arg[0x12] == 0d4) {
                                    arg[0x10] = 0d115;
                                } else if(arg[0x12] == 0d5) {
                                    arg[0x10] = 0d130;
                                } else if(arg[0x12] == 0d6) {
                                    arg[0x10] = 0d133;
                                } else if(arg[0x12] == 0d7) {
                                    arg[0x10] = 0d138;
                                } else if(arg[0x12] == 0d8) {
                                    arg[0x10] = 0d141;
                                } else if(arg[0x12] == 0d9) {
                                    arg[0x10] = 0d150;
                                } else if(arg[0x12] == 0d10) {
                                    arg[0x10] = 0d153;
                                } else if(arg[0x12] == 0d11) {
                                    arg[0x10] = 0d159;
                                } else if(arg[0x12] == 0d12) {
                                    arg[0x10] = 0d164;
                                } else if(arg[0x12] == 0d13) {
                                    arg[0x10] = 0d169;
                                } else if(arg[0x12] == 0d14) {
                                    arg[0x10] = 0d175;
                                } else if(arg[0x12] == 0d15) {
                                    arg[0x10] = 0d180;
                                } else if(arg[0x12] == 0d16) {
                                    arg[0x10] = 0d183;
                                } else if(arg[0x12] == 0d17) {
                                    arg[0x10] = 0d199;
                                }
                            }
                        }

                        CUSTOM_MEMORY.RETURN = arg[0x10];
                    }
                    fun get_prime(digits, memory) {
                        _get_prime(digits);

                        memory = CUSTOM_MEMORY.RETURN;
                    }
                    fun get_non_prime(digits, memory) {
                        _get_non_prime(digits);

                        memory = CUSTOM_MEMORY.RETURN;
                    }

                    @install()
                    fun young_naris_question(question_count, source) {
                        arg[0x10] = randrange(question_count);

                        if(arg[0x10] == 0d0) {
                            get_prime(BOSS.PHASE + 0d1, MEMORY.STRING_PARAMETER_1);
                        } else {
                            get_non_prime(BOSS.PHASE + 0d1, MEMORY.STRING_PARAMETER_1);
                        }
                        if(arg[0x10] == 0d1) {
                            get_prime(BOSS.PHASE + 0d1, MEMORY.STRING_PARAMETER_2);
                        } else {
                            get_non_prime(BOSS.PHASE + 0d1, MEMORY.STRING_PARAMETER_2);
                        }
                        if(arg[0x10] == 0d2) {
                            get_prime(BOSS.PHASE + 0d1, MEMORY.STRING_PARAMETER_3);
                        } else {
                            get_non_prime(BOSS.PHASE + 0d1, MEMORY.STRING_PARAMETER_3);
                        }

                        if(source == CHARACTER_ADDRESS.BOY) {
                            if(question_count <= 0d2) {
                                question("Guess the number of marbles in my hand and I'll give you something.[B]What's your guess?[PAUSE:3d][CHOICE][MEM1].[CHOICE][MEM2].");
                            } else {
                                question("Guess the number of marbles in my hand and I'll give you something.[B]What's your guess?[PAUSE:3d][CHOICE][MEM1].[CHOICE][MEM2].[CHOICE][MEM3].");
                            }

                            arg[0x12] = MEMORY.QUESTION_ANSWER;
                        } else {
                            if(question_count <= 0d2) {
                                dialog("Guess the number of marbles in my hand and I'll give you something.[B]What's your guess?[PAUSE:3d][CHOICE][MEM1].[CHOICE][MEM2].[PAUSE:80]");
                            } else {
                                dialog("Guess the number of marbles in my hand and I'll give you something.[B]What's your guess?[PAUSE:3d][CHOICE][MEM1].[CHOICE][MEM2].[CHOICE][MEM3].[PAUSE:80]");
                            }

                            arg[0x12] = randrange(question_count);

                            control(DOG, True);

                            while(arg[0x14] <= arg[0x12]) {
                                arg[0x14]++;

                                animate(DOG, ONCE, ANIMATION_DOG.ACT1_BARK);
                                if(<DOG>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                                    sound(DOG_ATTACK);
                                }
                                sleep(0d10);
                                animate(DOG, ONCE, DEFAULT);

                                sleep(0d30);
                            }

                            control(DOG, False);
                        }

                        if(arg[0x12] != 0xffff) {
                            if(arg[0x12] == arg[0x10]) {
                                if(BOSS.DEBUG_MARBLES) {
                                    subtext("yay");
                                }

                                damage(BOSS.MOUNT_ID, 0d666, True);
                            } else if(arg[0x12] == 0d0) {
                                if(BOSS.DEBUG_MARBLES) {
                                    subtext("nay 0");
                                }

                                spawn_enemies(ENEMY.MAGGOT);
                            } else if(arg[0x12] == 0d1) {
                                if(BOSS.DEBUG_MARBLES) {
                                    subtext("nay 1");
                                }

                                spawn_enemies(ENEMY.MOSQUITO);
                            } else if(arg[0x12] == 0d2) {
                                if(BOSS.DEBUG_MARBLES) {
                                    subtext("nay 2");
                                }

                                spawn_enemies(ENEMY.SKELESNAIL);
                            }
                        }
                        
                        if(BOSS.DEBUG_MARBLES) {
                            sleep(0x30);
                            debug_memory(arg[0x12], BOSS.GUESS_RNG);
                        }
                    }

                    @install()
                    fun mount_triggered() {
                        if(BOSS.PHASE == 0d0) {
                            if(<SCRIPT_OWNER>[HP] < BOSS.THRESHOLD_P1) {
                                BOSS.PHASE++;
                            }
                        }
                        if(BOSS.PHASE == 0d1) {
                            if(<SCRIPT_OWNER>[HP] < BOSS.THRESHOLD_P2) {
                                BOSS.PHASE++;
                            }
                        }
                        if(BOSS.PHASE == 0d2) {
                            if(dead(<SCRIPT_OWNER>)) {
                                BOSS.PHASE++;
                                end();
                            }
                        }

                        if(<SCRIPT_OWNER>[DAMAGE_SOURCE] != CHARACTER_ADDRESS.UNKNOWN) {
                            if((BOSS.FOLLOW_ID == CHARACTER_ADDRESS.UNKNOWN) || (<SCRIPT_OWNER>[DAMAGE_SOURCE] != BOSS.FOLLOW_ID)) {
                                BOSS.FOLLOW_ID = <SCRIPT_OWNER>[DAMAGE_SOURCE];
                                // heal(SCRIPT_OWNER, 0d0, False);

                                if!(BOSS.NARIS_BUSY) {
                                    BOSS.NARIS_BUSY = True;
                                    
                                    conversation({
                                        // conversation_dialog("[SLOW]Hi![PAUSE:29] I'm Naris, the smartest boy in Ebon Keep.[PAUSE:51] I bet you're not as smart as me![B]");

                                        if(BOSS.PHASE < 0d2) {
                                            arg[0x10] = 0d2;
                                        } else {
                                            arg[0x10] = 0d3;
                                        }
                                        young_naris_question(arg[0x10], <SCRIPT_OWNER>[DAMAGE_SOURCE]);
                                    }, <SCRIPT_OWNER>[DAMAGE_SOURCE]);

                                    sleep(BOSS.NARIS_BUSY_COUNT);

                                    BOSS.NARIS_BUSY = False;
                                }
                            }
                        }
                    }
                    @install()
                    fun rider_triggered() {
                        // control(BOSS.MOUNT_ID, True);
                        // face_each(BOSS.MOUNT_ID, <ACTIVE>);

                        attach_to_script(BOSS.MOUNT_ID);

                        attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

                        conversation({
                            conversation_dialog("[SLOW]Hi![PAUSE:29] I'm Naris, the smartest boy in Ebon Keep.[PAUSE:51] I bet you're not as smart as me![B]");
                        });

                        attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
                        // control(BOSS.MOUNT_ID, False);
                    }

                    @install()
                    fun activate_naris(entity) {
                        attribute(entity, INVINCIBLE, False);
                        attach_script(entity, DAMAGE_DEATH, reference(mount_triggered));

                        destroy(BOSS.RIDER_ID);

                        add_enemy(PLACEHOLDER, 0d0, 0d0);
                        BOSS.RIDER_ID = <LAST_ENTITY>;

                        stack_sprite(entity, BOSS.RIDER_ID);

                        attach_script(BOSS.RIDER_ID, B, reference(rider_triggered));
                    }

                    fun spawn_old_naris() {
                        arg[0x10] = BOSS.MOUNT_ID;
                        _add_enemy(VILLAGER_3_5, arg[0x10][X], arg[0x10][Y]);
                        BOSS.MOUNT_ID = <LAST_ENTITY>;
                        <LAST_ENTITY>[HP] = arg[0x10][HP];
                        // <LAST_ENTITY>[ATTACHED_SCRIPT_ID] = arg[0x10][ATTACHED_SCRIPT_ID];
                        // <LAST_ENTITY>[ATTACHED_SCRIPT_TRIGGER] = arg[0x10][ATTACHED_SCRIPT_TRIGGER];
                        activate_naris(<LAST_ENTITY>);

                        BOSS.FOLLOW_ID = 0x0000;
                        
                        destroy(arg[0x10]);
                    }

                    @install()
                    @async()
                    fun boss_follow_watcher() {
                        while!(BOSS.FOLLOW_ID) {
                            yield();
                        }

                        while(alive(BOSS.MOUNT_ID)) {
                            check_range(BOSS.MOUNT_ID, BOSS.FOLLOW_ID, 0d25, 0d12, {
                                // animate(BOSS.MOUNT_ID, ONCE, DEFAULT);

                                attach_to_script(BOSS.MOUNT_ID);

                                conversation({
                                    conversation_dialog("[SLOW]Hi![PAUSE:29] I'm Naris, the smartest boy in Ebon Keep.[PAUSE:51] I bet you're not as smart as me![B]");
                                }, BOSS.FOLLOW_ID);

                                sleep(0d60);
                            });

                            yield();
                        }
                    }
                    
                    @install()
                    @async()
                    fun boss_watcher() {
                        if(BOSS.DEBUG) {
                            subtext("phase 0");
                        }

                        while(BOSS.PHASE == 0d0) {
                            yield();
                        }

                        if(BOSS.DEBUG) {
                            subtext("phase 1");
                        }

                        while(BOSS.PHASE == 0d1) {
                            yield();
                        }

                        if(BOSS.DEBUG) {
                            subtext("phase 2");
                        }

                        spawn_old_naris();

                        while(BOSS.PHASE == 0d2) {
                            yield();
                        }

                        if(BOSS.DEBUG) {
                            subtext("yatta");
                        }

                        boss_defeated();
                    }

                    fun start_boss(waiting) {
                        if(waiting) {
                            while(BOSS.MOUNT_ID[Y] > 0d350) {
                                yield();
                            }
                        }

                        BOSS.PROGRESS = True;

                        push_music(BOSS);

                        activate_naris(BOSS.MOUNT_ID);
                        boss_watcher();
                        boss_follow_watcher();
                    }
                    @install()
                    fun naris_opening() {
                        dialog("[SLOW]Hi![PAUSE:29] I'm Naris, the smartest boy in Ebon Keep.[PAUSE:51] I bet you're not as smart as me![B]");

                        walk(BOSS.MOUNT_ID, TILE_ABSOLUTE, 0d64, 0d40, NONE, NONE);
                    }
                    fun add_boss(x, y) {
                        add_enemy(VILLAGER_3_2, x, y);
                        BOSS.MOUNT_ID = <LAST_ENTITY>;
                        attach_script(LAST_ENTITY, B, reference(naris_opening));
                        <LAST_ENTITY>[HP] = BOSS.BOSS_HP; 

                        if!(BOSS.PROGRESS) {
                            teleport(LAST_ENTITY, 0d96, 0d76);

                            start_boss(True);
                        } else {
                            start_boss(False);
                        }
                    }
                };

                enum stepon_trigger {
                    exit_west = @install() {
                        debug_subtext("S=0");

                        fog_wall_inside(BOSS.PROGRESS, EAST);
                        
                        map_transition(temple_underground_castle, east_2, WEST);
                    },
                    exit_east = @install() {
                        debug_subtext("S=1");

                        fog_wall_inside(BOSS.PROGRESS, WEST);

                        AREA_TOWN_TEMPLE.SECRET_PASSAGE_2_OPENED = True;
                        map_transition(town_level_1, door_1_3_back, EAST);
                    },
                }

                enum b_trigger {
                    gourd_north__8_oil = @install() {
                        debug_subtext("B=0");

                        _loot_chest(0x07, DRY_ICE, 0d01);
                    },
                    gourd_south__500_money = @install() {
                        debug_subtext("B=1");

                        _loot_chest(0x03, LIMESTONE_TABLET, 0d1);
                    },
                }

                fun open_boss_door(open) {
                    if(open) {
                        object[0x01] = 0x00;
                    } else {
                        object[0x01] = 0x01;
                    }
                }

                @install()
                fun debug_triggered() {
                    unlock(QUEENS_KEY);

                    destroy(SCRIPT_OWNER);
                }

                fun trigger_enter() {
                    CUSTOM_MEMORY.BOMBABLE_STATE = BOMBABLE_STATE.DOORS_UNLOCKED;

                    // object[0x03] = 0x01; // open gourd_south
                    object[0x02] = 0x01; // close door_south_1
                    object[0x01] = 0x01; // close door_south_2
                    object[0x00] = 0x01; // close door_south_3

                    // object[0x07] = 0x01; // open gourd_north
                    object[0x04] = 0x01; // close door_north_1
                    object[0x05] = 0x01; // close door_north_2
                    object[0x06] = 0x01; // close door_north_3

                    add_bombable_double_door(0d30, 0d21, ROOM.DOOR_NORTH_1, reference(@install() {
                        bombable_object(DOOR_FAKE, ROOM.DOOR_PERMISSION, ROOM.DOOR_NORTH_1, 0x04);
                    }), 0d9);
                    add_bombable_double_door(0d64, 0d21, ROOM.DOOR_NORTH_2, reference(@install() {
                        bombable_object(DOOR_FAKE, ROOM.DOOR_PERMISSION, ROOM.DOOR_NORTH_2, 0x05);
                    }), 0d9);
                    add_bombable_double_door(0d96, 0d21, ROOM.DOOR_NORTH_3, reference(@install() {
                        bombable_object(DOOR_FAKE, ROOM.DOOR_PERMISSION, ROOM.DOOR_NORTH_3, 0x06);
                    }), 0d9);

                    add_bombable_double_door(0d30, 0d57, ROOM.DOOR_SOUTH_3, reference(@install() {
                        bombable_object(DOOR_FAKE, ROOM.DOOR_PERMISSION, ROOM.DOOR_SOUTH_3, 0x00);
                    }), 0d13);
                    add_bombable_double_door(0d64, 0d57, ROOM.DOOR_SOUTH_2, reference(@install() {
                        bombable_object(DOOR_FAKE, ROOM.DOOR_PERMISSION, ROOM.DOOR_SOUTH_2, 0x01);
                    }), 0d13);
                    add_bombable_double_door(0d96, 0d57, ROOM.DOOR_SOUTH_1, reference(@install() {
                        bombable_object(DOOR_FAKE, ROOM.DOOR_PERMISSION, ROOM.DOOR_SOUTH_1, 0x02);
                    }), 0d13);

                    add_bee(0d63, 0d13, reference(@install() {
                        bee_collected(ROOM.BEE_COLLECTED);
                    }));

                    default_init_room(True, False);

                    if!(ROOM.DOOR_PERMISSION) {
                        add_debug_entity(0d69, 0d47, reference(debug_triggered));
                    }

                    if!(SOULS_MEMORY.DEAD_NARIS) {
                        add_boss(0d64, 0d35);
                    }
                }
            };

            map temple_underground_castle_south_west(MUNGOLA) {
                enum entrance {
                    east_1 = entrance(0x39, 0x15, WEST),
                    east_2 = entrance(0x39, 0x24, WEST)
                }

                enum soundtrack {
                    default = soundtrack(AREA_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    stairs = @install() {
                        debug_subtext("S=0");
                    },
                    exit_east_1 = @install() {
                        map_transition(temple_underground, west_1, EAST);
                    },
                    exit_east_2 = @install() {
                        map_transition(temple_underground_castle, west_1, EAST);
                    }
                }

                fun trigger_enter() {
                    // object[0x00] = 0x01; // shake banner_2
                    // object[0x01] = 0x01; // shake banner_4
                    // object[0x02] = 0x01; // shake banner_5
                    // object[0x03] = 0x01; // shake banner_1
                    // object[0x04] = 0x01; // shake banner_3
                    // object[0x05] = 0x01; // change mungola_1 (scalp - 0:hidden, 1:shown, 2:dead)
                    // object[0x06] = 0x01; // change mungola_2 (eye_left - 0:hidden, 1:hidden_wink, 2:shown, 3:dead)
                    // object[0x07] = 0x01; // change mungola_3 (mouth_left - 0:hidden, 2:shown, 3:shown_teeth, 4:dead)
                    // object[0x08] = 0x01; // shake banner_2_more
                    // object[0x09] = 0x01; // change mungola_4 (eye_right - 0:hidden, 1:hidden_wink, 2:shown, 3:dead)
                    // object[0x0a] = 0x01; // change mungola_5 (mouth_left - 0:hidden, 2:shown, 3:shown_teeth, 4:dead)
                    // object[0x0b] = 0x01; // change mungola_6 (chin - 0:hidden, 1:shown, 2:dead)
                    // object[0x0c] = 0x01; // open hole
                    object[0x0d] = 0x01; // unblock stairs
                    // object[0x0e] = 0x01; // close exit_east_2

                    default_init_room(True, False);            
                }
            };
        };
    };

    area town_level_0() {
        map town_center(NOBILIA_SQUARE) {
            enum entrance {
                north = entrance(0x2c, 0x03, SOUTH),
                east = entrance(0x5b, 0x37, WEST),
                west_1 = entrance(0x01, 0x40, EAST),
                west_2 = entrance(0x01, 0x14, EAST),

                door = entrance(0x08, 0x5d, SOUTH, { generic_door(True, False); }),

                crash = entrance(0x2c, 0x39, NONE, { crash_both(); }),
                bonfire = entrance(0d44, 0d58, NONE, { bonfire_wakeup(0d0, 0d8, 0d0, -0d8); }),

                center_north = entrance(0d43, 0d50, NONE),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            enum stepon_trigger {
                exit_east = @install() {
                    map_transition(town_market, west, EAST);
                },
                exit_door = @install() {
                    generic_door(False, False);
                    map_transition(town_room, south, NORTH);
                },
                exit_north = @install() {
                    map_transition(town_level_1, south, NORTH);
                },
                exit_west_1 = @install() {
                    map_transition(town_bridge, east, WEST);
                },
                exit_west_2 = @install() {
                    map_transition(town_market_alley, east, WEST);
                },
            }

            enum b_trigger {
                guard_south = guard_triggered(),
                guard_center_1 = @install() {
                    debug_subtext("B=1");
                },
                guard_center_2 = @install() {
                    debug_subtext("B=2");
                },
                guard_north = guard_triggered(),
                b_trigger_4 = @install() {
                    debug_subtext("B=4");
                },
            }

            enum ROOM {
                STATUE_LEFT_EYE = memory(FLAG, SRAM),
                STATUE_RIGHT_EYE = memory(FLAG, SRAM),
            }

            fun trigger_enter() {
                generic_door(True, False);

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // north
                    add_enemy(PIRATE_ANCHOR, 0d16, 0d20);

                    // east
                    add_enemy(RAT, 0d83, 0d42);

                    // west
                    add_enemy(SLIME, 0d7, 0d59);
                }

                if(False) {
                    add_souls_npc_smith_key(0d79, 0d95);
                    face(LAST_ENTITY, WEST);
                }

                // object[0x0e] = 0x01;

                // object[0x00] = 0x01; // show crowd_1_1
                // object[0x01] = 0x01; // show crowd_1_2
                // object[0x02] = 0x01; // show crowd_1_3
                // object[0x03] = 0x01; // show crowd_1_4
                // object[0x04] = 0x01; // show crowd_1_5
                // object[0x05] = 0x01; // show crowd_2_1
                // object[0x06] = 0x01; // show crowd_2_2
                // object[0x07] = 0x01; // show crowd_2_3
                // object[0x08] = 0x01; // show crowd_2_4
                // object[0x09] = 0x01; // show crowd_2_5
                // object[0x0a] = ???
                // object[0x0b] = same as crowd_2_2 ???
                // object[0x0c] = same as crowd_1_3 ???
                if(SOULS_MEMORY.DEAD_DOG_STATUE) {
                    object[0x0d] = 0x02; // show statue, crater, statue_reparing
                } else if(AREA_TOWN_TEMPLE.DONATED_INGREDIENTS >= AREA_TOWN_TEMPLE.DONATED_INGREDIENTS_MAX) {
                    object[0x0d] = 0x00; // show statue, crater, statue_reparing
                    object[0x0e] = 0x01; // show guard_statue

                    add_enemy(PLACEHOLDER, 0d43, 0d39);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        if((!ROOM.STATUE_LEFT_EYE) && STATUE_RIDDLE.CARRY_LEFT_EYE) {
                            ROOM.STATUE_LEFT_EYE = True;

                            _add_placeholder(DIAMOND_EYE_1, 0d346, 0d274);
                        } else if((!ROOM.STATUE_RIGHT_EYE) && STATUE_RIDDLE.CARRY_RIGHT_EYE) {
                            ROOM.STATUE_RIGHT_EYE = True;

                            _add_placeholder(DIAMOND_EYE_2, 0d346 + 0d12, 0d274);
                        } else {
                            if!(FLAG.ORACLE_BONE && FLAG.DIAMOND_EYES) {
                                subtext("…");
                            } else {
                                question("[SLOW]Touch the statue[CHOICE]touch…[CHOICE]leave…");

                                if(MEMORY.QUESTION_ANSWER == 0d0) {
                                    map_transition(town_center_secret_dog_statue_boss, center_north, NONE);
                                }
                            }
                        }
                    }));

                    if(ROOM.STATUE_LEFT_EYE) {
                        _add_placeholder(DIAMOND_EYE_1, 0d346, 0d274);
                    }
                    if(ROOM.STATUE_RIGHT_EYE) {
                        _add_placeholder(DIAMOND_EYE_2, 0d346 + 0d12, 0d274);
                    }
                } else if(AREA_TOWN_TEMPLE.DONATED_INGREDIENTS >= AREA_TOWN_TEMPLE.DONATED_INGREDIENTS_PARTIAL) {
                    object[0x0d] = 0x02; // show statue, crater, statue_reparing
                    object[0x0e] = 0x01; // show guard_statue
                } else {
                    object[0x0d] = 0x01; // show statue, crater, statue_reparing
                }

                bonfire(0d44, 0d58, SOULS_MEMORY.BONFIRE_TOWN_CENTER);

                default_init_room(False, False);
            }
        };

        map town_center_secret_dog_statue_boss(AEGIS) {
            enum soundtrack {
                default = soundtrack(WIND_AMBIENT_BIRDS_2, 0xff),
            }

            enum entrance {
                cinematic = entrance(0x21, 0x41, NONE),

                center_north = entrance(0d32, 0d37, NONE),
            }

            @install()
            fun bridge_explosion(object_id) {
                control(NONE);

                explode_barrier(<ACTIVE>, True); // TODO: wrong explosion

                sleep(0d10);

                object[object_id] = 0d1;
                animate(ACTIVE, ONCE, KNOCKBACK);

                sleep(0d60);

                control(BOTH);
            }

            enum stepon_trigger {
                bridge_east = @install() {
                    debug_subtext("S=0");

                    bridge_explosion(0x01);
                },
                bridge_west = @install() {
                    debug_subtext("S=1");

                    bridge_explosion(0x02);
                },
                bridge_south = @install() {
                    debug_subtext("S=2");

                    bridge_explosion(0x04);
                },
            }

            enum BOSS {
                DEBUG = False,
            }

            @install()
            @async()
            fun reveal_aegis(delay) {
                arg[0x10] = 0d1;

                while(arg[0x10] < 0d17) {
                    arg[0x10]++;

                    object[0x03] = arg[0x10]; // change layout_statue (0 = normal, 1-13 = statue exploding, 14-17 = aegis, 18 = empty, 19-21 = bridge)

                    sleep(delay);
                }
            }

            fun trigger_enter() {
                // object[0x00] = 0x01; // hide bridge_south
                // object[0x01] = 0x01; // hide bridge_east
                // object[0x02] = 0x01; // hide bridge_west
                object[0x03] = 0x00; // change layout_statue (0 = normal, 1-13 = statue exploding, 14-17 = aegis, 18 = empty, 19-21 = bridge)

                reveal_aegis(0d1);
                
                CUSTOM_FLAG.NO_DOG = True;
                default_init_room(False, False);

                add_custom_boss_aegis(0d32, 0d28, SOULS_MEMORY.DEAD_DOG_STATUE, {
                    object[0x03] = 0d18; // change layout_statue (0 = normal, 1-13 = statue exploding, 14-17 = aegis, 18 = empty, 19-21 = bridge)

                    souls_boss_defeated(DEAD_DOG_STATUE, REWARD_DOG_STATUE);

                    map_transition(town_center, center_north, NONE);
                }, 0d32, 0d24, 0d35, 0d40, 0d20);
            }
        };

        map town_room(CRUSTICIA_CAVES) { // variant: tavern
            // chest=todo

            enum entrance {
                south = entrance(0x6f, 0x51, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            enum stepon_trigger {
                monk = nop(),
                monk_trigger_west = nop(),
                monk_trigger_south = nop(),
                exit_cave_hammock = nop(),
                exit_south = @install() {
                    fog_wall_inside(!SOULS_MEMORY.DEAD_TAVERN_BOXERS, NORTH);

                    map_transition(town_center, door, SOUTH);
                },
                exit_ship_small = nop(),
                exit_cave_crates = nop(),
                exit_cave_monk = nop(),
            }

            enum b_trigger {
                gourd_hammock = nop(),
                gourd_monk_1 = nop(),
                gourd_monk_2 = nop(),
                gourd_crates = nop(),
                groud = @install() {
                    _loot_chest(0x06, LOOT_REWARD.WATER, 0x01);
                },
                gourd_ship = nop(),
                barkeeper = @install() {
                    debug_subtext("B=6");
                },
            }

            enum ROOM {
                RIDER_1_ID = memory(WORD, TEMP),
                MOUNT_1_ID = memory(WORD, TEMP),
                RIDER_2_ID = memory(WORD, TEMP),
                MOUNT_2_ID = memory(WORD, TEMP),
                RIDER_3_ID = memory(WORD, TEMP),
                MOUNT_3_ID = memory(WORD, TEMP),

                HITS_BOXER_1 = memory(WORD, TEMP),
                HITS_BOXER_2 = memory(WORD, TEMP),
                HITS_BOXER_3 = memory(WORD, TEMP),

                HITS_THRESHOLD = 0x05,

                BOXERS_BEATEN = memory(WORD, TEMP),

                BOXERS_BEATEN_THRESHOLD = 0x03,
            }

            @install()
            @async()
            fun stack_boxer1() {
                while(alive(ROOM.RIDER_1_ID)) {
                    ROOM.RIDER_1_ID[X] = ROOM.MOUNT_1_ID[X];
                    ROOM.RIDER_1_ID[Y] = ROOM.MOUNT_1_ID[Y];
                    yield();
                }
            }
            @install()
            @async()
            fun stack_boxer2() {
                while(alive(ROOM.RIDER_2_ID)) {
                    ROOM.RIDER_2_ID[X] = ROOM.MOUNT_2_ID[X];
                    ROOM.RIDER_2_ID[Y] = ROOM.MOUNT_2_ID[Y];
                    yield();
                }
            }
            @install()
            @async()
            fun stack_boxer3() {
                while(alive(ROOM.RIDER_3_ID)) {
                    ROOM.RIDER_3_ID[X] = ROOM.MOUNT_3_ID[X];
                    ROOM.RIDER_3_ID[Y] = ROOM.MOUNT_3_ID[Y];
                    yield();
                }
            }

            fun boxer_hit(rider_id, mount_id, hit_counter) { // TODO: buggy
                hit_counter++;

                debug_memory(hit_counter, ROOM.HITS_THRESHOLD);

                if(hit_counter >= ROOM.HITS_THRESHOLD) {
                    add_enemy(PLACEHOLDER, 0x00, 0x00);
                    animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.GORE_RED);
                    <LAST_ENTITY>[X] = rider_id[X];
                    <LAST_ENTITY>[Y] = rider_id[Y];

                    destroy(mount_id);
                    destroy(rider_id);

                    ROOM.BOXERS_BEATEN++;
                    
                }
            }

            fun boxer_killed() {
                ROOM.BOXERS_BEATEN++;

                if(ROOM.BOXERS_BEATEN >= ROOM.BOXERS_BEATEN_THRESHOLD) {
                    souls_boss_defeated(DEAD_TAVERN_BOXERS, REWARD_TAVERN_BOXERS);
                }
            }

            @install()
            fun boxer1dead() {
                // boxer_hit(ROOM.RIDER_1_ID, ROOM.MOUNT_1_ID ,ROOM.HITS_BOXER_1);

                ROOM.HITS_BOXER_1++;

                if(ROOM.HITS_BOXER_1 >= ROOM.HITS_THRESHOLD) {
                    add_enemy(PLACEHOLDER, 0x00, 0x00);
                    animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.GORE_RED);
                    <LAST_ENTITY>[X] = ROOM.RIDER_1_ID[X];
                    <LAST_ENTITY>[Y] = ROOM.RIDER_1_ID[Y];

                    destroy(ROOM.MOUNT_1_ID);
                    destroy(ROOM.RIDER_1_ID);

                    boxer_killed();
                }
            }
            @install()
            fun boxer2dead() {
                // boxer_hit(ROOM.RIDER_2_ID, ROOM.MOUNT_2_ID ,ROOM.HITS_BOXER_2);

                ROOM.HITS_BOXER_2++;

                if(ROOM.HITS_BOXER_2 >= ROOM.HITS_THRESHOLD) {
                    add_enemy(PLACEHOLDER, 0x00, 0x00);
                    animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.GORE_RED);
                    <LAST_ENTITY>[X] = ROOM.RIDER_2_ID[X];
                    <LAST_ENTITY>[Y] = ROOM.RIDER_2_ID[Y];

                    destroy(ROOM.RIDER_2_ID);
                    destroy(ROOM.MOUNT_2_ID);

                    boxer_killed();
                }
            }
            @install()
            fun boxer3dead() {
                // boxer_hit(ROOM.RIDER_3_ID, ROOM.MOUNT_3_ID ,ROOM.HITS_BOXER_3);

                ROOM.HITS_BOXER_3++;

                if(ROOM.HITS_BOXER_3 >= ROOM.HITS_THRESHOLD) {
                    add_enemy(PLACEHOLDER, 0x00, 0x00);
                    animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.GORE_RED);
                    <LAST_ENTITY>[X] = ROOM.RIDER_3_ID[X];
                    <LAST_ENTITY>[Y] = ROOM.RIDER_3_ID[Y];

                    destroy(ROOM.RIDER_3_ID);
                    destroy(ROOM.MOUNT_3_ID);

                    boxer_killed();
                }
            }

            fun add_boxer(id_rider, id_mount, enemy:ENEMY, x, y, trigger) {
                add_enemy(enemy, x, y);
                id_rider = <LAST_ENTITY>;
                <LAST_ENTITY>[HP] = SYSTEM.HP_MAX;
                attach_script(LAST_ENTITY, DAMAGE, trigger);
                add_enemy(MAGGOT_RED, x, y);
                id_mount = <LAST_ENTITY>;
                attribute(LAST_ENTITY, INVISIBLE, True);
                attribute(LAST_ENTITY, INVINCIBLE_TEMP, True);
            }

            fun init_room(index) {
                if(index == 0x00) {
                    init_map(0x00, 0x00, 0x2e, 0x2a); // hammock
                } else if(index == 0x01) {
                    init_map(0x00, 0x38, 0x26, 0x5c); // crates
                } else if(index == 0x02) {
                    init_map(0x32, 0x36, 0x56, 0x52); // ship
                } else if(index == 0x03) {
                    // init_map(0x58, 0x30, 0x86, 0x4e); // tavern
                    init_map(0x58, 0x30, 0x86, 0x50); // tavern
                } else if(index == 0x04) {
                    init_map(0x40, 0x00, 0x66, 0x24); // monk
                }
            }

            fun trigger_enter() {
                init_room(0x03);

                if!(SOULS_MEMORY.DEAD_TAVERN_BOXERS) {
                    push_music(BOSS_MINI);

                    add_boxer(ROOM.RIDER_1_ID, ROOM.MOUNT_1_ID, BOXER_1, 0x5c, 0x49, reference(boxer1dead));
                    add_boxer(ROOM.RIDER_2_ID, ROOM.MOUNT_2_ID, BOXER_2, 0x80, 0x3d, reference(boxer2dead));
                    add_boxer(ROOM.RIDER_3_ID, ROOM.MOUNT_3_ID, BOXER_2, 0x80, 0x45, reference(boxer3dead));

                    stack_boxer1();
                    stack_boxer2();
                    stack_boxer3();
                }

                default_init_room(False, False);
            }
        };

        map town_market(NOBILIA_MARKET) {
            fun enter_from_door() {
                generic_door(True, False);
            }
            fun enter_from_side() {
                _generic_open_doors(False, False);
            }

            enum entrance {
                north_1 = entrance(0x0f, 0x08, SOUTH, { enter_from_side(); }),
                north_2 = entrance(0x30, 0x08, SOUTH, { enter_from_side(); }),
                north_3 = entrance(0x54, 0x08, SOUTH, { enter_from_side(); }),
                east_1 = entrance(0x5f, 0x18, WEST, { enter_from_side(); }),
                east_2 = entrance(0x5f, 0x46, WEST, { enter_from_side(); }),
                west = entrance(0x05, 0x4b, EAST, { enter_from_side(); }),

                door_1 = entrance(0x5c, 0x3a, SOUTH, { enter_from_door(); }),
                door_2 = entrance(0x5a, 0x72, SOUTH, { enter_from_door(); }),

                crash = entrance(0x45, 0x7b, NONE, { enter_from_side(); }),
            }

            group market_helper() {
                group wheel_of_misforftune() {
                    enum WHEEL_OF_MISFORTUNE {
                        MAX = 0d20,

                        TICK_DELAY = 0d2,
                        TICK_EXTRA = 0d20,
                        TICK_ROLLBACK = 0d3,
                    }

                    fun tick(max, up, bonus_time) {
                        if(up) {
                            if(arg[0x10] <= max) {
                                arg[0x10]++;
                            } else {
                                arg[0x10] = 0d0;
                            }
                        } else {
                            if(arg[0x10] > 0d0) {
                                arg[0x10]--;
                            } else {
                                arg[0x10] = max;
                            }
                        }
                        
                        if(bonus_time !is None) {
                            sleep(WHEEL_OF_MISFORTUNE.TICK_DELAY + bonus_time);
                        } else {
                            sleep(WHEEL_OF_MISFORTUNE.TICK_DELAY);
                        }

                        MEMORY.STRING_PARAMETER_1 = arg[0x10];
                        subtext("[MEM1]");
                        sound(MENU_WHEEL_TURN);
                    }
                };

                @install()
                fun spin_secret_wheel(coins) {
                    if!(coins) {
                        end();
                    }

                    _dialog("[SLOW]Oh wow, that never happened…[B]Press [b] to stop the secret wheel.[B]");

                    while(coins) {
                        while(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                            yield();
                        }
                        while!(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                            tick(WHEEL_OF_MISFORTUNE.MAX, True);
                        }

                        while(arg[0x12] < WHEEL_OF_MISFORTUNE.TICK_EXTRA) {
                            tick(WHEEL_OF_MISFORTUNE.MAX, True, (arg[0x12] + arg[0x12] + arg[0x12]) >> 0d2);
                            
                            arg[0x12]++;
                        }

                        if!(randrange(WHEEL_OF_MISFORTUNE.TICK_ROLLBACK)) {
                            tick(WHEEL_OF_MISFORTUNE.MAX, False, (arg[0x12] + arg[0x12] + arg[0x12]) >> 0d2);
                        }

                        sleep(0d60);
                        clear_subtext();

                        _dialog("[SLOW][MEM1]![B]");

                        if(arg[0x10] == 0d0) {
                            reward(RUBY_HEART);
                        } else if(arg[0x10] == 0d5) {
                            reward(THUGS_CLOAK);
                        } else if(arg[0x10] == 0d10) {
                            reward(THUGS_CLOAK);
                        } else {
                            reward(NOTHING);

                            dialog("[SLOW]Better luck next time![B]");
                            end();
                        }

                        dialog("[SLOW]I'll remove the secret wheel entirely…[B]");
                    }
                }
                @install()
                fun spin_wheel(coins) {
                    if!(coins) {
                        end();
                    }

                    _dialog("[SLOW]Press [b] to stop the wheel![B]");

                    while(coins) {
                        while(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                            yield();
                        }
                        while!(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                            tick(WHEEL_OF_MISFORTUNE.MAX, True);
                        }

                        while(arg[0x12] < WHEEL_OF_MISFORTUNE.TICK_EXTRA) {
                            tick(WHEEL_OF_MISFORTUNE.MAX, True, (arg[0x12] + arg[0x12] + arg[0x12]) >> 0d2);
                            
                            arg[0x12]++;
                        }

                        if!(randrange(WHEEL_OF_MISFORTUNE.TICK_ROLLBACK)) {
                            tick(WHEEL_OF_MISFORTUNE.MAX, False, (arg[0x12] + arg[0x12] + arg[0x12]) >> 0d2);
                        }

                        sleep(0d60);
                        clear_subtext();

                        _dialog("[SLOW][MEM1]![B]");

                        if(arg[0x10] == 0d0) {
                            dialog("[SLOW]Spin again![B]");

                            coins++;
                        } else if(arg[0x10] == 0d20) {
                            spin_secret_wheel(0d1);
                        } else {
                            reward(NOTHING);

                            dialog("[SLOW]Better luck next time![B]");
                            end();
                        }

                        dialog("[SLOW]I'll have to lower the chances on that…[B]");
                    }
                }
            };

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
                // default = soundtrack(WIND_AMBIENT_BIRDS_2, 0xff)
            }

            enum ROOM {
                CONVERTION_SCAM = memory(FLAG, SRAM),
                CONVERTION_REWARD = ITEM.RICE,

                MARKET_ACTIVE = memory(FLAG, TEMP),

                FORCE_FULL_MARKET = False,

                PRICE_ESSENCE = 0d3,
                PRICE_WINGS = 0d3,
                PRICE_BISCUIT = 0d3,
            }

            enum stepon_trigger {
                prophet_south = @install() {
                    debug_subtext("S=0");
                },
                prophet_east = @install() {
                    debug_subtext("S=1");
                },
                prophet_north = @install() {
                    debug_subtext("S=2");
                },
                exit_north_2 = @install() {
                    debug_subtext("S=3");
                },
                exit_north_3 = @install() {
                    debug_subtext("S=4");
                },
                exit_north_1 = @install() {
                    debug_subtext("S=5");
                },
                exit_east_1 = @install() {
                    debug_subtext("S=6");
                },
                exit_east_2 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    map_transition(town_center, east, WEST);
                },
                door_1 = @install() {
                    control(NONE);
                    face(ACTIVE, NORTH);

                    generic_door(False, False);
                    map_transition(town_arena_entry, south_2, NORTH);
                },

                door_2 = @install() {
                    control(NONE);
                    face(ACTIVE, NORTH);

                    generic_door(False, False);
                    map_transition(town_market, east_1, NORTH);
                },
            }

            enum b_trigger {
                person_4_1__chicken_feeding = @install() {
                    debug_subtext("B=0");
                },
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                prophet = @install() {
                    debug_subtext("B=3");
                },
                vendor_10_5__glove = @install() {
                    debug_subtext("B=4");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Feathers?[CHOICE]Rice 2:1[CHOICE]Spice 2:1, [CHOICE]Wings 3:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d1, FEATHER, 0d2);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, FEATHER, 0d2);
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) { // wings
                        trade_items(WINGS, 0d1, FEATHER, ROOM.PRICE_WINGS);
                    }
                },
                vendor_10_4__silver_sheath = @install() {
                    debug_subtext("B=5");
                },
                vendor_10_3__appraisal = @install() {
                    debug_subtext("B=6");
                },
                vendor_10_2__moxa_stick = @install() {
                    debug_subtext("B=7");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Bones?[CHOICE]Rice 1:2[CHOICE]Spice 1:3, [CHOICE]Biscuit 3:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d1, BONE, 0d2);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, BONE, 0d3);
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) { // biscuit
                        trade_items(BISCUIT, 0d1, BONE, ROOM.PRICE_BISCUIT);
                    }
                },
                vendor_10_1__sun_stone = @install() {
                    debug_subtext("B=8");
                },
                vendor_7_2__limestone_tablet = @install() {
                    debug_subtext("B=9");

                    question("[SLOW]Do you want to trade for Mud Pepper?[CHOICE]1 Dry Ice…", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // dry ice
                        trade_items(MUD_PEPPER, 0d5, DRY_ICE, 0d1);
                    }

                    control(BOTH);
                },

                vendor_7_1__jeweled_scarab = @install() { // scarab lady
                    debug_subtext("B=10");

                    question("[SLOW]Do you want to trade for Mushrooms?[CHOICE]5 Limestone…[CHOICE]5 Vinegar…[CHOICE]3 Bones…", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // limestone
                        trade_items(MUSHROOM, 0d1, LIMESTONE, 0d5);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // vinegar
                        trade_items(MUSHROOM, 0d1, VINEGAR, 0d5);
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) { // bone
                        trade_items(MUSHROOM, 0d1, BONE, 0d3);
                    }

                    control(BOTH);
                },
                vendor_9_2__helmet = @install() {
                    debug_subtext("B=11");
                },
                vendor_9_1__ruby_heart = @install() {
                    debug_subtext("B=12");
                },
                vendor_8_2__jade_disk = @install() {
                    debug_subtext("B=13");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Meteorite?[CHOICE]Rice 1:10[CHOICE]Spice 1:10", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d10, METEORITE, 0d1);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d10, METEORITE, 0d1);
                    }
                },
                vendor_8_1__beads = @install() {
                    debug_subtext("B=14");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Dry Ice?[CHOICE]Rice 1:10[CHOICE]Spice 1:10", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d10, DRY_ICE, 0d1);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d10, DRY_ICE, 0d1);
                    }
                },
                vendor_6_1__beads = @install() {
                    debug_subtext("B=15");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Lime Tablets?[CHOICE]Rice 1:2[CHOICE]Spice 1:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d2, LIMESTONE_TABLET, 0d1);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, LIMESTONE_TABLET, 0d1);
                    }
                },
                vendor_5_4__currency = @install() {
                    debug_subtext("B=16");

                    prepare_market_trade();

                    show_currency(True);
                    question("[SLOW]Do you want to trade me your Lime Tablets?[CHOICE]Gold Coins 1:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // convert to gold
                        if_currency(MEMORY.CURRENCY_CURRENT < 0d1) {
                            show_currency(False);

                            dialog("[SLOW]I sense dishonisty, you don't have any money.[B]");
                        }

                        ROOM.CONVERTION_SCAM = True;
                        control(NONE);

                        show_currency(False);
                        _dialog("[SLOW]Visit us again soon. Your hard earned money is safe with us.[B]As a first time customer you earned yourself a reward![B]");

                        reward(ROOM.CONVERTION_REWARD);

                        animate(ACTIVE, LOOP, DEFAULT);
                        animate(INACTIVE, LOOP, DEFAULT);

                        show_currency(True);
                        currency_convert(0d1, TALONS, 0d1, GOLD_COINS);

                        sleep(0d30);
                        show_currency(True);

                        sleep(0d60);

                        fade_out();
                        sleep(0d30);

                        object[0x14] = 0x01; // remove vendor_5_4 (currency lady)

                        _fade_in();
                        face(ACTIVE, NORTH);
                        animate(ACTIVE, LOOP, DEFAULT);
                        animate(INACTIVE, LOOP, DEFAULT);

                        sleep(0d60);
                        show_currency(False);
                        sleep(0d60);

                        animate(ACTIVE, ONCE, DEFAULT);
                        animate(INACTIVE, ONCE, DEFAULT);
                    } else {
                        show_currency(False);

                        dialog("[SLOW]Be carful with your money. You never know what happens outside the gates.[B]");
                    }
                },
                b_trigger_17 = @install() {
                    debug_subtext("B=17");
                },
                vendor_5_2__spice = @install() {
                    debug_subtext("B=18");
                },
                vendor_5_1__perfume = @install() {
                    debug_subtext("B=19");
                },

                vendor_4_1__rice = @install() {
                    debug_subtext("B=20");

                    prepare_market_trade();
                    
                    question("Welcome to the wheel of misfortune![CHOICE]spin… (rice+spice)[CHOICE]leave…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // spin
                        trade_items(NO_ITEM, 0d0, RICE, 0d1, SPICE, 0d1);

                        if(CUSTOM_MEMORY.RETURN) {
                            spin_wheel(0d1);
                        } else {
                            dialog("[SLOW]Keep moving.[B]");
                        }
                    } else { // leave
                        dialog("[SLOW]Don't miss out on great prices![B]");
                    }
                },
                vendor_4_2__beads = @install() {
                    debug_subtext("B=21");
                },
                vendor_4_3__tapestry = @install() {
                    debug_subtext("B=22");
                },
                vendor_3_4__polish = @install() {
                    debug_subtext("B=23");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Roots?[CHOICE]Rice 1:1[CHOICE]Spice 1:1, [CHOICE]Essence 3:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d1, ROOT, 0d1);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, ROOT, 0d1);
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) { // essence
                        trade_items(HERBAL_ESSENCE, 0d1, ROOT, ROOM.PRICE_ESSENCE);
                    }
                },
                vendor_3_3__chest = @install() {
                    debug_subtext("B=24");
                },
                vendor_3_2__amulet = @install() {
                    debug_subtext("B=25");
                },
                vendor_3_1__jackal = @install() {
                    debug_subtext("B=26");

                    question("[SLOW]Do you want to donate materials for the restauration?[CHOICE]Limestone…[CHOICE]Clay…", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // limestone
                        item_pay(LIMESTONE, 0d1);

                        if(CUSTOM_MEMORY.RETURN) {
                            arg[0x10] = 0d5;
                        }
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // clay
                        item_pay(CLAY, 0d1);

                        if(CUSTOM_MEMORY.RETURN) {
                            arg[0x10] = 0d1;
                        }
                    }
   
                    if(arg[0x10] > 0d0) {
                        AREA_TOWN_TEMPLE.DONATED_INGREDIENTS += arg[0x10];

                        dialog("[SLOW]Your help is apreciated![B]");
                    }

                    if(AREA_TOWN_TEMPLE.DEBUG && AREA_TOWN_TEMPLE.DEBUG_DONATION) {
                        debug_memory(AREA_TOWN_TEMPLE.DONATED_INGREDIENTS, arg[0x10]);
                    }
                },
                vendor_2_3__pot = @install() {
                    debug_subtext("B=27");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Mushrooms?[CHOICE]Rice 10:1[CHOICE]Spice 5:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d1, MUSHROOM, 0d10);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, MUSHROOM, 0d5);
                    }
                },
                vendor_1_4__rice = @install() {
                    debug_subtext("B=28");
                },
                vendor_1_3__fish = @install() {
                    debug_subtext("B=29");
                },

                guard_1_1 = guard_triggered(),
                vendor_2_2__egg = @install() {
                    debug_subtext("B=31");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Iron?[CHOICE]Rice 10:1[CHOICE]Spice 5:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d1, IRON, 0d10);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, IRON, 0d5);
                    }
                },
                vendor_2_1__spoon = @install() {
                    debug_subtext("B=32");

                    prepare_market_trade();

                    question("[SLOW]Do you want to trade me your Mud Pepper?[CHOICE]Rice 1:1[CHOICE]Spice 1:1", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                        trade_items(RICE, 0d1, IRON, 0d1);
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) { // spice
                        trade_items(SPICE, 0d1, IRON, 0d1);
                    }
                },
                vendor_1_1__spice = @install() {
                    debug_subtext("B=33");
                },
                goat_xx = goat_triggered(),
                chicken_xx = chicken_triggered(),
                goat_xx = goat_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),

                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                chicken_xx = chicken_triggered(),
                pot_hidden = @install() {
                    debug_subtext("B=48");
                },
                guard_4_1 = guard_triggered(),

                person_4_2__juggler = @install() {
                    debug_subtext("B=50");
                },
                goat_xx = goat_triggered(),
                goat_xx = goat_triggered(),
                vendor_1_2__rice = @install() {
                    debug_subtext("B=53");
                },
                person_4_3__juggler_crowd_1 = @install() {
                    debug_subtext("B=54");
                },
                person_4_3__juggler_crowd_2 = @install() {
                    debug_subtext("B=55");
                },
                pot_xx = @install() {
                    debug_subtext("B=56");
                },
                pot_xx = @install() {
                    debug_subtext("B=57");
                },
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // west
                    add_enemy(RAT, 0d19, 0d59);
                    add_enemy(RAT, 0d23, 0d100);

                    // east
                    add_enemy(RAT, 0d73, 0d49);
                    add_enemy(RAT, 0d81, 0d81);
                }

                if!(FLAG.IN_ANIMATION) {
                    crash_both();
                }

                if(NPC_CRAFTER.PROGRESS < 0x10) {
                    add_souls_npc_crafter(0d66, 0d121);
                }

                if(time[0d0] >= MARKET.START) {
                    ROOM.MARKET_ACTIVE = True;
                }
                if(AREA_TOWN_TEMPLE.DEBUG && AREA_TOWN_TEMPLE.DEBUG_MARKET) {
                    ROOM.MARKET_ACTIVE = True;
                }

                if(ROOM.FORCE_FULL_MARKET) {
                    if(MARKET.DEBUG) {
                        debug_subtext("market force full");
                    }

                    nop();
                } else if(ROOM.MARKET_ACTIVE) {
                    if(MARKET.DEBUG) {
                        debug_subtext("market not empty");
                    }

                    object[0x00] = 0x01; // remove vendor_1_1 (spice guy)
                    object[0x01] = 0x01; // remove vendor_1_2 (rice lady)
                    // object[0x02] = 0x01; // remove guard_1_1 (next to rice lady)
                    object[0x03] = 0x01; // remove vendor_1_3 (fish lady)
                    object[0x04] = 0x01; // remove vendor_1_4 (other rice guy)
                    // object[0x05] = 0x01; // remove vendor_2_1 (spoon lady)
                    // object[0x06] = 0x01; // remove vendor_2_2 (egg guy)
                    // object[0x07] = 0x01; // remove vendor_3_1 (jackal lady)
                    // object[0x08] = 0x01; // remove vendor_2_3 (pot lady)
                    object[0x09] = 0x01; // remove person_4_1 (next to pot lady, feeds chicken)
                    object[0x0a] = 0x01; // remove vendor_3_2 (amulet guy)
                    object[0x0b] = 0x01; // remove vendor_3_3 (chest lady)
                    // object[0x0c] = 0x01; // remove ???
                    // object[0x0d] = 0x01; // remove vendor_3_4 (polish lady)
                    // object[0x0e] = 0x01; // remove guard_4_1 (next to entrance)
                    // object[0x0f] = 0x01; // remove vendor_4_1 (other rice lady)
                    object[0x10] = 0x01; // remove vendor_4_2 (other beads lady)
                    object[0x11] = 0x01; // remove person_4_2 (next to vendor_4_2, juggler)
                    object[0x12] = 0x01; // remove person_4_3 (next to vendor_4_2, juggler crowd)
                    object[0x13] = 0x01; // remove vendor_4_3 (tapestry lady)
                    if(ROOM.CONVERTION_SCAM) {
                        object[0x14] = 0x01; // remove vendor_5_4 (currency lady)
                    }
                    object[0x15] = 0x01; // remove vendor_5_1 (perfume lady)
                    object[0x16] = 0x01; // remove vendor_5_2 (other spice guy)
                    object[0x17] = 0x01; // remove vendor_5_3 (chicken guy)
                    // object[0x18] = 0x01; // remove vendor_6_1 (beads lady)
                    // object[0x19] = 0x01; // remove vendor_7_2 (tablet lady)
                    // object[0x1a] = 0x01; // remove vendor_8_1 (other beads guy)
                    // object[0x1b] = 0x01; // remove vendor_8_2 (jade disk lady)
                    object[0x1c] = 0x01; // remove vendor_9_1 (heart lady)
                    object[0x1d] = 0x01; // remove vendor_9_2 (helmet guy)
                    // object[0x1e] = 0x01; // remove vendor_7_1 (scarab lady)
                    object[0x1f] = 0x01; // remove vendor_10_1 (sunstone guy)
                    // object[0x20] = 0x01; // remove vendor_10_2 (moxa lady)
                    object[0x21] = 0x01; // remove vendor_10_3 (appraisal lady)
                    object[0x22] = 0x01; // remove vendor_10_4 (sheath guy)
                    // object[0x23] = 0x01; // remove ???
                    object[0x24] = 0x01; // remove vendor_11_1 (beads lady)
                    // object[0x24] = 0x01; // remove vendor_10_5 (glove lady)
                    // object[0x25] = 0x01; // remove ???
                    object[0x26] = 0x01; // remove basket (between vendor_1_1 ans vendor_1_2)
                    object[0x27] = 0x04; // remove prophet (goat, chicke, basket)
                } else {
                    if(MARKET.DEBUG) {
                        debug_subtext("market empty");
                    }

                    object[0x00] = 0x01; // remove vendor_1_1 (spice guy)
                    object[0x01] = 0x01; // remove vendor_1_2 (rice lady)
                    object[0x02] = 0x01; // remove guard_1_1 (next to rice lady)
                    object[0x03] = 0x01; // remove vendor_1_3 (fish lady)
                    object[0x04] = 0x01; // remove vendor_1_4 (other rice guy)
                    object[0x05] = 0x01; // remove vendor_2_1 (spoon lady)
                    object[0x06] = 0x01; // remove vendor_2_2 (egg guy)
                    object[0x07] = 0x01; // remove vendor_3_1 (jackal lady)
                    object[0x08] = 0x01; // remove vendor_2_3 (pot lady)
                    object[0x09] = 0x01; // remove person_4_1 (next to pot lady, feeds chicken)
                    object[0x0a] = 0x01; // remove vendor_3_2 (amulet guy)
                    object[0x0b] = 0x01; // remove vendor_3_3 (chest lady)
                    object[0x0c] = 0x01; // remove ???
                    object[0x0d] = 0x01; // remove vendor_3_4 (polish lady)
                    object[0x0e] = 0x01; // remove guard_4_1 (next to entrance)
                    object[0x0f] = 0x01; // remove vendor_4_1 (other rice lady)
                    object[0x10] = 0x01; // remove vendor_4_2 (other beads lady)
                    object[0x11] = 0x01; // remove person_4_2 (next to vendor_4_2, juggler)
                    object[0x12] = 0x01; // remove person_4_3 (next to vendor_4_2, juggler crowd)
                    object[0x13] = 0x01; // remove vendor_4_3 (tapestry lady)
                    object[0x14] = 0x01; // remove vendor_5_4 (currency lady)
                    object[0x15] = 0x01; // remove vendor_5_1 (perfume lady)
                    object[0x16] = 0x01; // remove vendor_5_2 (other spice guy)
                    object[0x17] = 0x01; // remove vendor_5_3 (chicken guy)
                    object[0x18] = 0x01; // remove vendor_6_1 (beads lady)
                    object[0x19] = 0x01; // remove vendor_7_2 (tablet lady)
                    object[0x1a] = 0x01; // remove vendor_8_1 (other beads guy)
                    object[0x1b] = 0x01; // remove vendor_8_2 (jade disk lady)
                    object[0x1c] = 0x01; // remove vendor_9_1 (heart lady)
                    object[0x1d] = 0x01; // remove vendor_9_2 (helmet guy)
                    object[0x1e] = 0x01; // remove vendor_7_1 (scarab lady)
                    object[0x1f] = 0x01; // remove vendor_10_1 (sunstone guy)
                    object[0x20] = 0x01; // remove vendor_10_2 (moxa lady)
                    object[0x21] = 0x01; // remove vendor_10_3 (appraisal lady)
                    object[0x22] = 0x01; // remove vendor_10_4 (sheath guy)
                    object[0x23] = 0x01; // remove ???
                    object[0x24] = 0x01; // remove vendor_11_1 (beads lady)
                    object[0x24] = 0x01; // remove vendor_10_5 (glove lady)
                    object[0x25] = 0x01; // remove ???
                    object[0x26] = 0x01; // remove basket (between vendor_1_1 ans vendor_1_2)
                    object[0x27] = 0x04; // remove prophet (goat, chicke, basket)
                }

                default_init_room(False, False);
            }
        };

        map town_arena_entry(NOBILIA_HOUSES) { // variant: shop
            enum entrance {
                south_1 = entrance(0x51, 0x1b, NORTH),
                south_2 = entrance(0x0d, 0x1b, NORTH),

                crash = entrance(0x0d, 0x15, NONE),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            fun guard_dog_interaction() {
                if(<ACTIVE> == <DOG>) {
                    dialog("[SLOW]For legal reasons animals aren't allowed in the arena.[B]");
                    end();
                }
            }

            enum ROOM {
                TICKET_PRICE = 0x05,

                DAMAGE_ELLBOW = 0d30,
            }

            enum stepon_trigger {
                exit_south_2 = @install() {
                    map_transition(town_market, door_1, SOUTH);
                },
                exit_inn_south = nop(),
                atlas = @install() {
                    debug_subtext("S=2");

                    if(<ACTIVE> != <BOY>) {
                        end();
                    }

                    control(NONE);

                    face(ACTIVE, EAST);
                    damage(ACTIVE, ROOM.DAMAGE_ELLBOW, True);

                    dealer_triggered();

                    control(BOTH);
                },
                exit_south_1 = @install() {
                    guard_dog_interaction();

                    if(MEMORY.TICKET_FOR_EXHIBITION < 0d1) {
                        dialog("[SLOW]Hey, you have to buy a ticket first![B]");

                        walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, -0d2, ACTIVE, ACTIVE);
                    } else {
                        question("[SLOW]Please enter a ticket[CHOICE]Yes.[CHOICE]No.");

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            MEMORY.TICKET_FOR_EXHIBITION--;

                            map_transition(gladiator_arena, south, SOUTH);
                        }
                    }
                },
            }

            enum b_trigger {
                vendor = @install() {
                    guard_dog_interaction();

                    show_currency(True);

                    if_currency(MEMORY.CURRENCY_CURRENT < ROOM.TICKET_PRICE) {
                        dialog("[SLOW]Welcome to the one and only...[B]Oh please come back if you have money.[B]");
                    } else {
                        if(MEMORY.TICKET_FOR_EXHIBITION == 0x01) {
                            dialog("[SLOW]Feel free to enter the arena directly.[B]");
                        } else if(MEMORY.TICKET_FOR_EXHIBITION > 0x01) {
                            MEMORY.STRING_PARAMETER_1 = MEMORY.TICKET_FOR_EXHIBITION;
                            dialog("[SLOW]Feel free to enter the arena directly.[B]");
                        }

                        MEMORY.STRING_PARAMETER_1 = ROOM.TICKET_PRICE;
                        question("[SLOW]Welcome to the bomb arena.[B]Tickets cost [MEM1] Souls[CHOICE]Yes.[CHOICE]No.");

                        if(MEMORY.QUESTION_ANSWER == 0d0) {
                            currency_take(TALONS, ROOM.TICKET_PRICE);
                            show_currency(True);

                            sound(PURCHASE);
                            MEMORY.TICKET_FOR_EXHIBITION++;
                        }
                    }

                    sleep(0d16);
                    show_currency(False);
                },
                vendor_inn = nop(),
            }

            fun init_room(index) {
                if(index == 0x01) {
                    init_map(0x02, 0x00, 0x5a, 0x1c);
                } else if(index == 0x02) {
                    init_map(0x00, 0x24, 0x24, 0x42);
                }
            }

            fun trigger_enter() {
                init_room(0x01);

                // bonfire(0x57, 0x08);
                // bonfire(0x07, 0x10);

                default_init_room(False, False);
            }
        };

        map gladiator_arena(ARENA) {
            enum entrance {
                north_cinematic = entrance(0x20, 0x07, NONE),
                south = entrance(0x22, 0x69, NORTH), // 0x22, 0x6a

                center = entrance(0x20, 0x53, NONE),
            }

            enum soundtrack {
                default = soundtrack(BOSS_ARENA, 0xff)
            }

            enum ROOM {
                DEBUG = False,

                MANAGER_ID = memory(WORD, TEMP),

                PROGRESS = memory(BYTE, SRAM),
                MAX_PROGRESS = 0d4,

                FIGHT_IN_PROGRESS = memory(FLAG, TEMP),
                CURRENT_BOSS_DEFEATED = memory(FLAG, TEMP),

                PILLAR_OPENED = memory(FLAG, TEMP),
                COLLECTIBLE_LOOTED = memory(FLAG, SRAM),

                REWARD_1_KILLS = 0d4,
                REWARD_1_CLAIMED = memory(FLAG, SRAM),
                REWARD_2_KILLS = 0d8,
                REWARD_2_CLAIMED = memory(FLAG, SRAM),
                REWARD_3_KILLS = 0d999,
                REWARD_3_CLAIMED = memory(FLAG, SRAM),
                REWARD_4_KILLS = 0d999,
                REWARD_4_CLAIMED = memory(FLAG, SRAM),
            }

            @install()
            fun spawn_next_gladiator() {
                ROOM.FIGHT_IN_PROGRESS = True;

                find_all(BOMB, {
                    destroy(current_id);
                });

                if(ROOM.DEBUG) {
                    debug_memory(ROOM.PROGRESS, ROOM.PROGRESS);
                }

                if(ROOM.PROGRESS == 0d0) {
                    add_enemy(MOSQUITO, 0x20, 0x53);
                    attach_script(LAST_ENTITY, DEATH, reference(gladiator_dead));
                } else if(ROOM.PROGRESS == 0d1) {
                    add_enemy(BOY_BLACK, 0x20, 0x53);
                    attach_script(LAST_ENTITY, DEATH, reference(gladiator_dead));
                } else if(ROOM.PROGRESS == 0d2) {
                    add_enemy(VIGOR, 0x20, 0x53);
                    attach_script(LAST_ENTITY, DEATH, reference(gladiator_dead));
                } else if(ROOM.PROGRESS == 0d3) {
                    add_enemy(FOOTKNIGHT, 0x20, 0x53);
                    attach_script(LAST_ENTITY, DEATH, reference(gladiator_dead));
                } else {
                    subtext("todo...");
                }
            }

            @install()
            fun gladiator_dead() {
                ROOM.FIGHT_IN_PROGRESS = False;
                ROOM.CURRENT_BOSS_DEFEATED = True;

                sound(ARENA_CHEER);
                
                animate(ROOM.MANAGER_ID, LOOP, ANIMATION_ENEMY.TINY_FLEX);
                sleep(0d160);
                animate(ROOM.MANAGER_ID, ONCE, DEFAULT);

                destroy(SCRIPT_OWNER);
            }

            fun claim_reward() {
                if((ROOM.PROGRESS >= ROOM.REWARD_1_KILLS) && !ROOM.REWARD_1_CLAIMED) {
                    set(ROOM.REWARD_1_CLAIMED);
                    
                    dialog("[SLOW]Let me teach you my secret formula.[B]");

                    reward(SOULS_MEMORY.REWARD_ARENA_BOMB_1);

                    dialog("[SLOW]This technique has been passed down for generations.[B]");

                    end();
                } else if((ROOM.PROGRESS >= ROOM.REWARD_2_KILLS) && !ROOM.REWARD_2_CLAIMED) {
                    set(ROOM.REWARD_2_CLAIMED);
                    
                    reward(SOULS_MEMORY.REWARD_ARENA_BOMB_2);

                    end();
                } else if((ROOM.PROGRESS >= ROOM.REWARD_3_KILLS) && !ROOM.REWARD_3_CLAIMED) {
                    set(ROOM.REWARD_3_CLAIMED);
                    
                    reward(SOULS_MEMORY.REWARD_ARENA_BOMB_3);

                    end();
                } else if((ROOM.PROGRESS >= ROOM.REWARD_4_KILLS) && !ROOM.REWARD_4_CLAIMED) {
                    set(ROOM.REWARD_4_CLAIMED);
                    
                    reward(SOULS_MEMORY.REWARD_ARENA_BOMB_4);

                    end();
                }
            }

            @install()
            fun manager_triggered() {
                if(ROOM.FIGHT_IN_PROGRESS) {
                    subtext("You should focus on your opponent!");
                    end();
                } else if(ROOM.CURRENT_BOSS_DEFEATED) {
                    ROOM.CURRENT_BOSS_DEFEATED = False;
                    ROOM.PROGRESS++;

                    sound(ARENA_CHEER);
                }

                claim_reward();

                if(ROOM.PROGRESS < ROOM.MAX_PROGRESS) {
                    question("[SLOW]Ready for the next oponent?[CHOICE]Yes…[CHOICE]No…[CHOICE]Leave…", 0d5);

                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        spawn_next_gladiator();
                    } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                        nop();
                    } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                        map_transition(town_arena_entry, south_1, NONE);
                    }
                } else {
                    question("[SLOW]There is no worthy opponent left for you…[CHOICE]Leave…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        map_transition(town_arena_entry, south_1, NONE);
                    }
                }
            }

            fun show_bridge(show) {
                if(show) {
                    object[0x00] = 0x01;
                } else {
                    object[0x00] = 0x00;
                }
            }

            fun trigger_enter() {
                CUSTOM_FLAG.NO_DOG = True;
                CUSTOM_FLAG.NO_XP_MONEY = True;
                CUSTOM_FLAG.VANILLA_BOMB_DAMAGE = True;
                
                init_map(0x00, 0x30, 0x40, 0x70);

                add_enemy(TINY, 0x20, 0x42, INACTIVE);
                ROOM.MANAGER_ID = <LAST_ENTITY>;

                add_enemy(PLACEHOLDER, 0x20, 0x48);
                attach_script(LAST_ENTITY, B, reference(manager_triggered));

                show_bridge(True);
                default_init_room(False, False);

                hint(PRESS_START);

                CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.BOMBS;

                sleep(0d15);
                show_bridge(False);

                add_bombable(0d53, 0d74, ROOM.COLLECTIBLE_LOOTED, reference(@install() {
                    bombable_object(DEFAULT, True, ROOM.PILLAR_OPENED, 0x01, 0x01);

                    add_collectible(0x00, 0x36, 0x48, reference(@install() {
                        ROOM.COLLECTIBLE_LOOTED = True;

                        collectible_collected();
                    }));
                }));
            }
        };
    };

    area town_level_1() {
        map town_level_1(IVOR_EBON_2) {
            enum ROOM {
                WITH_CLOSED_GATE = True,
                GATE_OPENED = AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED,
                GATE_OPEN = memory(FLAG, TEMP),

                BEE_COLLECTED = memory(FLAG, SRAM),

                TOWN_HOUSE_MAGGY_DOOR_OPENED = memory(FLAG, SRAM),
            }

            enum entrance {
                north = entrance(0x40, 0x0b, SOUTH),
                north_closed = entrance(0x40, 0d16, SOUTH),
                south = entrance(0x20, 0x77, NORTH),

                door_1_1_left = entrance(0x2c, 0x63, SOUTH, { generic_object_door(0x03, True, False); }),
                door_1_1_right = entrance(0x44, 0x63, SOUTH, { generic_object_door(0x02, True, False); }),
                door_1_2 = entrance(0x74, 0x63, SOUTH),
                door_1_3 = entrance(0xa2, 0x63, SOUTH),
                door_1_3_back = entrance(0x92, 0x4b, WEST),
                door_2_1 = entrance(0x8e, 0x29, SOUTH, { generic_object_door(0x01, True, False); }),
                door_2_1_back = entrance(0xb7, 0x1f, EAST),

                crash = entrance(0x5d, 0x5d, NONE, { crash_both(); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            enum stepon_trigger {
                gate = @install() {
                    debug_subtext("S=0");

                    if(ROOM.WITH_CLOSED_GATE) {
                        if!(ROOM.GATE_OPENED || ROOM.GATE_OPEN) {
                            error_message(DOOR_WRONG_SIDE);
                        }
                    }
                },
                door_1_1_left = @install() {
                    debug_subtext("S=1");

                    if!(SOULS_MEMORY.SMITH_KEY) {
                        error_message(DOOR_LOCKED, SOUTH);
                    } else {
                        generic_object_door(0x03, False, False);
                        map_transition(town_inn, door_left, NORTH);
                    }
                },
                door_1_1_right = @install() {
                    debug_subtext("S=2");

                    if(False) {
                        error_message(DOOR_LOCKED, SOUTH);
                    } else {
                        generic_object_door(0x02, False, False);
                        map_transition(town_inn, door_right, NORTH);
                    }
                },
                door_1_2 = @install() {
                    debug_subtext("S=3");

                    error_message(DOOR_LOCKED, SOUTH);
                },
                door_1_3 = @install() {
                    debug_subtext("S=4");

                    error_message(DOOR_LOCKED, SOUTH);
                },
                door_2_1 = @install() fun trigger_door_town_house_maggy() {
                    debug_subtext("S=5");

                    bombable_trigger(FLAG.QUEENS_KEY, ROOM.TOWN_HOUSE_MAGGY_DOOR_OPENED, ((DIRECTION.SOUTH << 0x0008) | ERROR_TYPE.DOOR_LOCKED), {
                        generic_object_door(0x01, False, False);
                        map_transition(town_house_maggy, door, NORTH);
                    }, 0x01, 0x01);
                },
                exit_south = @install() {
                    debug_subtext("S=6");

                    map_transition(town_center, north, SOUTH);
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_north = @install() {
                    debug_subtext("S=8");

                    map_transition(town_level_2, south, NORTH);
                },
                door_2_1_back = @install() {
                    debug_subtext("S=9");

                    if(False) {
                        error_message(DOOR_WRONG_SIDE, EAST);
                    } else {
                        map_transition(town_house_maggy, door_backroom, NONE);
                    }
                },

                door_1_3_back = @install() {
                    debug_subtext("S=10");

                    if(AREA_TOWN_TEMPLE.SECRET_PASSAGE_2_OPENED) {
                        fog_wall_outside(SOULS_MEMORY.PROGRESS_NARIS, WEST);
                        
                        map_transition(temple_underground_castle_south_east, east, NONE);
                    } else {
                        error_message(DOOR_WRONG_SIDE, WEST);
                    }
                },
            }

            fun trigger_enter() {
                add_bombable(0d142, 0d46, ROOM.TOWN_HOUSE_MAGGY_DOOR_OPENED, reference(trigger_door_town_house_maggy));

                if(ROOM.WITH_CLOSED_GATE) {
                    if(ROOM.GATE_OPENED) {
                        object[0x00] = 0x7e; // open gate
                    } else {
                        add_bombable(0d64, 0d22, ROOM.GATE_OPENED, reference(@install() {
                            bombable_object(DEFAULT, True, False, 0x00, 0x7e);
                            ROOM.GATE_OPEN = True;
                        }));
                    }
                } else {
                    object[0x00] = 0x7e; // open gate
                }

                // object[0x01] = 0x01; // open door_2_1
                // object[0x02] = 0x01; // open door_1_1_right
                // object[0x03] = 0x01; // open door_1_1_left
                // object[0x04] = 0x01; // replace flower_gate_1 (scrub)
                // object[0x05] = 0x01; // open door_2_1_back AND replace flower_gate_2 (scrub)
                // object[0x06] = 0x01; // replace flower_gate_3 (scrub)
                // object[0x07] = 0x01; // replace flower_gate_4 (scrub)
                // object[0x08] = 0x01; // replace flower_gate_stairs_1 (scrub)
                // object[0x09] = 0x01; // replace flower_gate_stairs_2 (scrub)
                // object[0x0a] = 0x01; // replace flower_gate_stairs_3 (scrub)
                // object[0x0b] = 0x01; // replace flower_gate_stairs_4 (scrub)
                // object[0x0c] = 0x01; // replace flower_gate_stairs_bed_1 (scrub)
                // object[0x0d] = 0x01; // replace flower_gate_stairs_bed_2 (scrub)
                // object[0x0e] = 0x01; // replace flower_gate_stairs_bed_3 (scrub)
                // object[0x0f] = 0x01; // replace door_2_1_flower_1 (scrub)
                // object[0x10] = 0x01; // replace door_2_1_flower_2 (scrub)
                // object[0x11] = 0x01; // replace door_2_1_flower_3 (scrub)
                // object[0x12] = 0x01; // replace door_2_1_flower_4 (scrub)
                // object[0x13] = 0x01; // replace door_2_1_flower_5 (scrub)
                // object[0x14] = 0x01; // replace stairs_lower_1 (scrub)
                // object[0x15] = 0x01; // replace stairs_lower_2 (scrub)
                // object[0x16] = 0x01; // replace stairs_lower_3 (scrub)
                // object[0x17] = 0x01; // replace door_1_3_flower_1 (scrub)
                // object[0x18] = 0x01; // replace door_1_2_flower_2 (scrub)
                // object[0x19] = 0x01; // replace door_1_2_flower_4 (scrub)
                // object[0x1a] = 0x01; // replace door_1_2_flower_3 (scrub)
                // object[0x1b] = 0x01; // replace door_1_2_flower_2 (scrub)
                // object[0x1c] = 0x01; // replace door_1_2_flower_1 (scrub)
                // object[0x1d] = 0x01; // replace door_1_1_flower_2 (scrub)
                // object[0x1e] = 0x01; // replace door_1_1_flower_1 (scrub)
                // object[0x1f] = 0x01; // replace door_1_2_flower_5 (scrub)
                object[0x20] = 0x02; // change door_1_2 (closed, open, barricaded)
                object[0x21] = 0x02; // change door_1_3 (closed, open, barricaded)
                // object[0x22] = 0x01; // close door_1_3_back (closed, open, barricaded)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // lower gate
                    add_enemy(PIRATE_ANCHOR, 0d19, 0d85);

                    // lower houses
                    add_enemy(FLOWER_PURPLE, 0d134, 0d102);
                    add_enemy(MAGGOT_RED, 0d133, 0d74);

                    // lower stairs
                    add_enemy(FLOWER_PURPLE, 0d191, 0d82);
                    
                    // lower houses
                    add_enemy(PIRATE_ANCHOR, 0d188, 0d51);

                    // upper stairs
                    add_enemy(FLOWER_PURPLE, 0d70, 0d52);

                    // upper gate
                    add_enemy(PIRATE_ANCHOR, 0d64, 0d34);
                }

                add_bee(0d94, 0d76, reference(@install() {
                    bee_collected(ROOM.BEE_COLLECTED);
                }));

                default_init_room(False, False);
            }
        };

        map town_inn(IVOR_EBON_HOUSES) {
            enum entrance {
                door_left = entrance(0x10, 0x8b, NORTH),
                door_right = entrance(0x38, 0x8b, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            enum ROOM {
                CHEST_LOOTED = memory(FLAG, SRAM),

                WITH_ARMOR_TRIGGER = False,
            }

            enum stepon_trigger {
                exit_backroom_3chests = nop(),
                exit_inn_2_left = nop(),
                exit_inn_2_right = nop(),
                exit_stairs_house_3 = nop(),
                exit_door_house_3 = nop(),
                exit_stairs_upstairs = nop(),
                exit_house_1 = nop(),
                exit_door_house_2 = nop(),
                exit_stairs_house_2 = nop(),
                exit_backroom_2chests = nop(),

                exit_door_left = @install() {
                    debug_subtext("S=10");
                    if!(SOULS_MEMORY.SMITH_KEY) {
                        error_message(DOOR_LOCKED, NORTH);
                    } else {
                        map_transition(town_level_1, door_1_1_left, SOUTH);
                    }
                },
                exit_door_right = @install() {
                    debug_subtext("S=11");
                    if(False) {
                        error_message(DOOR_LOCKED, NORTH);
                    } else {
                        map_transition(town_level_1, door_1_1_right, SOUTH);
                    }
                },
            }

            @install()
            fun inn_triggered() {
                if(SOULS_MEMORY.ISAAC_LETTER && !SOULS_MEMORY.ISAAC_WANTED_POSTER) {
                    question("An old newspaper.[CHOICE]Maggy article…[CHOICE]leave…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        custom_reward(ISAAC_WANTED_POSTER, True);

                        dialog("`Magdalena O. Moriah, …´[B]");
                    }
                } else {
                    dialog("An old newspaper. Nothing catches your eye.[B]");
                }
            }

            enum b_trigger {
                gourd_backroom_3chests_3 = nop(),
                gourd_backroom_3chests_2 = nop(),
                gourd_backroom_3chests_1 = nop(),
                gourd_inn_2 = nop(),
                gourd_house_2 = nop(),
                gourd_house_3_north = nop(),
                gourd_house_3_east = nop(),
                gourd_backroom_2chests_2 = nop(),
                gourd_backroom_2chests_1 = nop(),
                gourd_upstairs_1 = nop(),

                gourd_upstairs_2 = nop(),
                b_trigger_11 = @install() {
                    debug_subtext("B=11");
                },
                b_trigger_12 = @install() {
                    debug_subtext("B=12");
                },
                inn_inn_2_south = nop(),
                inn_inn_2_east = nop(),
                inn_east = inn_triggered(),
                inn_south = inn_triggered(),
                gourd = @install() {
                    debug_subtext("B=17");

                    fake_loot_gourd();

                    object[0x1f] = 0x01; // open gourd_inn_1
                    custom_reward(SMITH_KEY, True);
                    set(ROOM.CHEST_LOOTED);
                },
                vendor_south = @install() {
                    debug_subtext("B=18");
                },
                vendor_east = @install() {
                    debug_subtext("B=19");
                },

                b_trigger_20 = @install() {
                    debug_subtext("B=20");
                },
            }

            fun trigger_enter() {
                if(ROOM.CHEST_LOOTED) {
                    object[0x1f] = 0x01; // open gourd_inn_1
                }

                default_init_room(False, False);

                if(ROOM.WITH_ARMOR_TRIGGER) {
                    add_enemy(PLACEHOLDER, 0d63, 0d93);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        subtext("TODO");
                    }));
                }
            }
        };

        area town_house_maggy() {
            map town_house_maggy(IVOR_EBON_HOUSES) { // house_2_1
                enum entrance {
                    door = entrance(0x70, 0x47, NORTH),
                    stairs = entrance(0x56, 0x35, SOUTH),

                    door_backroom = entrance(0x8c, 0x10, SOUTH),
                }

                enum ROOM {
                    BIG_CHEST_LOOTED = memory(FLAG, SRAM),
                    SMALL_CHEST_LOOTED = memory(FLAG, SRAM),
                }

                enum stepon_trigger {
                    exit_backroom_3chests = nop(),
                    exit_inn_2_left = nop(),
                    exit_inn_2_right = nop(),
                    exit_stairs_house_3 = @install() {
                        debug_subtext("S=3");

                        map_transition(town_house_maggy_upstairs, stairs, NORTH);
                    },
                    exit_door_house_3 = @install() {
                        debug_subtext("S=4");

                        map_transition(town_level_1, door_2_1, SOUTH);
                    },
                    exit_stairs_upstairs = nop(),
                    exit_house_1 = nop(),
                    exit_door_house_2 = nop(),
                    exit_stairs_house_2 = nop(),
                    exit_backroom = @install() {
                        debug_subtext("S=9");

                        map_transition(town_level_1, door_2_1_back, NORTH);
                    },

                    exit_inn_1_left = nop(),
                    exit_inn_1_right = nop(),
                }

                enum b_trigger {
                    gourd_backroom_3chests_3 = nop(),
                    gourd_backroom_3chests_2 = nop(),
                    gourd_backroom_3chests_1 = nop(),
                    gourd_inn_2 = nop(),
                    gourd_house_2 = nop(),
                    gourd_north = @install() {
                        debug_subtext("B=5");

                        object[0x04] = 0x01; // open gourd_house_3_north
                        ROOM.BIG_CHEST_LOOTED = True;

                        reward(CHOCOBO_EGG);

                        // _loot_chest(0x04, CHOCOBO_EGG, 0d01);
                    },
                    gourd_east = @install() {
                        debug_subtext("B=6");

                        object[0x0b] = 0x01; // open gourd_house_3_east
                        ROOM.SMALL_CHEST_LOOTED = True;

                        custom_reward(ESTUS_SHARD, True);

                        // _loot_chest(0x0b, WATER, 0d01);
                    },
                    gourd_backroom_2chests_2 = @install() {
                        debug_subtext("B=7");

                        _loot_chest(0x06, HERBAL_ESSENCE, 0d01);
                    },
                    gourd_backroom_2chests_1 = @install() {
                        debug_subtext("B=8");

                        _loot_chest(0x05, WATER, 0d01);
                    },
                    gourd_upstairs_1 = nop(),

                    gourd_upstairs_2 = nop(),
                    b_trigger_11 = @install() {
                        debug_subtext("B=11");
                    },
                    b_trigger_12 = @install() {
                        debug_subtext("B=12");
                    },
                    inn_inn_2_south = nop(),
                    inn_inn_2_east = nop(),
                    inn_inn_1_east = nop(),
                    inn_inn_1_south = nop(),
                    gourd_inn_1 = nop(),
                    vendor_inn_1_south = nop(),
                    vendor_inn_1_east = nop(),

                    b_trigger_20 = @install() {
                        debug_subtext("B=20");
                    },
                }

                fun init_room(index) {
                    if(index == 0x00) {
                        init_map(0xa2, 0x24, 0xd8, 0x54); // house_1
                    } else if(index == 0x01) {
                        init_map(0x4a, 0x48, 0x9c, 0x7a); // house_2
                    } else if(index == 0x02) {
                        init_map(0x48, 0x08, 0x9a, 0x48); // house_3
                    } else if(index == 0x03) {
                        init_map(0x02, 0x4c, 0x46, 0x8c); // inn_1
                    } else if(index == 0x04) {
                        init_map(0x02, 0x08, 0x46, 0x48); // inn_2
                    } else if(index == 0x05) {
                        init_map(0xa2, 0x08, 0xd4, 0x24); // upstairs
                    }
                }

                fun trigger_enter() {
                    init_room(0x02);

                    if(ROOM.BIG_CHEST_LOOTED) {
                        object[0x04] = 0x01; // open gourd_house_3_north
                    }

                    if(ROOM.SMALL_CHEST_LOOTED) {
                        object[0x0b] = 0x01; // open gourd_house_3_east
                    }


                    // object[0x04] = 0x01; // open gourd_house_3_north
                    // object[0x0b] = 0x01; // open gourd_house_3_east

                    // object[0x05] = 0x01; // open gourd_backroom_2chests_1
                    // object[0x06] = 0x01; // open gourd_backroom_2chests_2

                    if!(NPC_MAGGY.FOUND) {
                        add_souls_npc_maggy(0d112, 0d44);
                    }

                    default_init_room(False, False);
                }
            };

            map town_house_maggy_upstairs(IVOR_EBON_HOUSES) { // house_2_1 upstairs
                enum entrance {
                    stairs = entrance(0xaa, 0x23, NORTH),
                }

                enum stepon_trigger {
                    exit_backroom_3chests = nop(),
                    exit_inn_2_left = nop(),
                    exit_inn_2_right = nop(),
                    exit_stairs_house_3 = nop(),
                    exit_door_house_3 = nop(),
                    exit_stairs = @install() {
                        debug_subtext("S=5");

                        map_transition(town_house_maggy, stairs, SOUTH);
                    },
                    exit_house_1 = nop(),
                    exit_door_house_2 = nop(),
                    exit_stairs_house_2 = nop(),
                    exit_backroom_2chests = nop(),

                    exit_inn_1_left = nop(),
                    exit_inn_1_right = nop(),
                }

                enum b_trigger {
                    gourd_backroom_3chests_3 = nop(),
                    gourd_backroom_3chests_2 = nop(),
                    gourd_backroom_3chests_1 = nop(),
                    gourd_inn_2 = nop(),
                    gourd_house_2 = nop(),
                    gourd_house_3_north = nop(),
                    gourd_house_3_east = nop(),
                    gourd_backroom_2chests_2 = nop(),
                    gourd_backroom_2chests_1 = nop(),
                    gourd_2_1 = @install() {
                        debug_subtext("B=9");

                        _loot_chest(0x07, DRY_ICE, 0d01);
                    },

                    gourd_2_2 = @install() {
                        debug_subtext("B=10");

                        _loot_chest(0x08, SPOON, 0d01);
                    },
                    b_trigger_11 = @install() {
                        debug_subtext("B=11");
                    },
                    b_trigger_12 = @install() {
                        debug_subtext("B=12");
                    },
                    inn_inn_2_south = nop(),
                    inn_inn_2_east = nop(),
                    inn_inn_1_east = nop(),
                    inn_inn_1_south = nop(),
                    gourd_inn_1 = nop(),
                    vendor_inn_1_south = nop(),
                    vendor_inn_1_east = nop(),

                    gourd_1 = @install() {
                        debug_subtext("B=20");

                        error_message(SWITCH_STUCK);
                    },
                }

                fun init_room(index) {
                    if(index == 0x00) {
                        init_map(0xa2, 0x24, 0xd8, 0x54); // house_1
                    } else if(index == 0x01) {
                        init_map(0x4a, 0x48, 0x9c, 0x7a); // house_2
                    } else if(index == 0x02) {
                        init_map(0x48, 0x08, 0x9a, 0x48); // house_3
                    } else if(index == 0x03) {
                        init_map(0x02, 0x4c, 0x46, 0x8c); // inn_1
                    } else if(index == 0x04) {
                        init_map(0x02, 0x08, 0x46, 0x48); // inn_2
                    } else if(index == 0x05) {
                        init_map(0xa2, 0x08, 0xd4, 0x24); // upstairs
                    }
                }

                fun trigger_enter() {
                    init_room(0x05);

                    // object[0x07] = 0x01; // open gourd_upstairs_1
                    // object[0x08] = 0x01; // open gourd_upstairs_2
                    object[0x1a] = 0x02; // change upstairs_layout (0 = bed, 1 = chest closed, wall pass through 2 = chest open, wall closed)
                    object[0x1b] = 0x01; // show wall_upstairs
                    // object[0x1c] = 0x01; // show cosmetic_upstairs_1 (crate instead of bed)
                    // object[0x1d] = 0x01; // show cosmetic_upstairs_2 (fruit bowl)
                    // object[0x1e] = 0x01; // hide cosmetic_upstairs_2 (clock)

                    add_enemy(PLACEHOLDER, 0d183, 0d18);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        if(False) {
                            fake_b();
                        } else {
                            object[0x1a] = 0x01; // change upstairs_layout (0 = bed, 1 = chest closed, wall pass through 2 = chest open, wall closed)

                            destroy(SCRIPT_OWNER);
                        }
                    }));

                    default_init_room(False, False);
                }
            };
        };
    };

    area town_level_2() {
        map town_level_2(IVOR_EBON_1) {
            enum entrance {
                north = entrance(0x20, 0x01, SOUTH),
                south = entrance(0x1c, 0x5f, NORTH),
                west = entrance(0x01, 0x3e, EAST),
                west_closed = entrance(0x01, 0x3d, EAST),

                door_1 = entrance(0x2a, 0x01, SOUTH),
                door_2 = entrance(0x2a, 0x01, SOUTH),
                door_3 = entrance(0x2a, 0x01, SOUTH),
                door_4 = entrance(0x2a, 0x01, SOUTH),
                door_5 = entrance(0x2a, 0x01, SOUTH),

                crash = entrance(0x6d, 0x41, NONE, { crash_both(); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            enum ROOM {
                STONE_MOVED = memory(FLAG, SRAM),
                STONE_OFFSET = 0d8 * 0d4,

                PASSAGE_OPENED = AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED,

                WITH_RAT = True,
                WITH_BIRDS = False,
            }

            enum stepon_trigger {
                door_1_1_back = @install() {
                    debug_subtext("S=0");

                    error_message(DOOR_LOCKED, WEST);
                },
                exit_west = @install() {
                    debug_subtext("S=1");

                    map_transition(temple, east_2, WEST);
                },
                exit_north = @install() {
                    debug_subtext("S=2");

                    fog_wall_outside(!SOULS_MEMORY.DEAD_TOWN_PUPPETS, SOUTH);

                    map_transition(town_level_3, south, NORTH);
                },
                exit_south = @install() {
                    debug_subtext("S=3");

                    if(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED) {
                        map_transition(town_level_1, north, SOUTH);
                    } else {
                        map_transition(town_level_1, north_closed, SOUTH);
                    }
                },
                door_1_1 = @install() {
                    debug_subtext("S=4");

                    error_message(DOOR_LOCKED, SOUTH);
                },
                door_2_1 = @install() {
                    debug_subtext("S=5");

                    error_message(DOOR_LOCKED, SOUTH);
                },
                door_2_2 = @install() {
                    debug_subtext("S=6");

                    error_message(DOOR_LOCKED, SOUTH);
                },
                door_2_3 = @install() {
                    debug_subtext("S=7");

                    error_message(DOOR_LOCKED, SOUTH);
                },
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                b_trigger_2 = @install() {
                    debug_subtext("B=2");
                },
                b_trigger_3 = @install() {
                    debug_subtext("B=3");
                },
                b_trigger_4 = @install() {
                    debug_subtext("B=4");
                },
                b_trigger_5 = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
            }

            fun block_market(block) {
                if(block) {
                    object[0x1a] = 0x01;
                } else {
                    object[0x1a] = 0x00;
                }
            }

            fun trigger_enter() {
                add_levitate_stone(0d31, 0d11, reference(@install() {
                    guard_levitate_stone(0d1);

                    ROOM.STONE_MOVED = True;
                }));
                if(ROOM.STONE_MOVED) {
                    <LAST_ENTITY>[X] -= ROOM.STONE_OFFSET;
                }

                add_bombable(0d9, 0d63, ROOM.PASSAGE_OPENED, reference(@install() {
                    bombable_object(DEFAULT, True, False, 0x1a, 0x00);
                }));

                special_script(LEVITATE, reference(@install() {
                    if(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.INVINCIBLE_TEMP) {
                        end();
                    }

                    attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

                    if!(ROOM.STONE_MOVED) {
                        sleep(0d60);

                        ROOM.STONE_MOVED = True;

                        sleep(0d60);

                        while(arg[0x10] < ROOM.STONE_OFFSET) {
                            arg[0x10]++;

                            <SCRIPT_OWNER>[X]--;

                            sleep(0d3);
                        }

                        sleep(0d360 - 0d3 * ROOM.STONE_OFFSET);
                    } else {
                        sleep(0d120);

                        while(arg[0x10] < ROOM.STONE_OFFSET) {
                            arg[0x10]++;

                            <SCRIPT_OWNER>[X]++;

                            sleep(0d3);
                        }

                        sleep(0d360 - 0d3 * ROOM.STONE_OFFSET);

                        ROOM.STONE_MOVED = False;
                    }

                    attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
                }));

                if!(AREA_TOWN_TEMPLE.SECRET_PASSAGE_OPENED) {
                    block_market(True);
                }

                // MEMORY.MAP_PALETTE = 0x07;

                object[0x00] = 0x02; // change door_2_3 (closed, open, barricaded)
                object[0x01] = 0x02; // change door_2_2 (closed, open, barricaded)
                object[0x02] = 0x02; // change door_2_1 (closed, open, barricaded)
                object[0x03] = 0x02; // change door_1_1 (closed, open, barricaded)
                // object[0x04] = 0x01; // close gate_south
                // object[0x05] = 0x01; // replace gate_north_flower_1 (scrub)
                // object[0x06] = 0x01; // replace gate_north_flower_2 (scrub)
                // object[0x07] = 0x01; // replace gate_north_flower_3 (scrub)
                // object[0x08] = 0x01; // replace gate_north_flower_4 (scrub)
                // object[0x09] = 0x01; // replace house_2_2_flower_1 (scrub)
                // object[0x0a] = 0x01; // replace house_2_2_flower_2 (scrub)
                // object[0x0b] = 0x01; // replace house_2_3_flower (scrub)
                // object[0x0c] = 0x01; // replace stairs_lower_flower_2 (scrub)
                // object[0x0d] = 0x01; // replace stairs_lower_flower_1 (scrub)
                // object[0x0e] = 0x01; // replace stairs_lower_flower_3 (scrub)
                // object[0x0f] = 0x01; // replace house_1_1_flower (scrub)
                // object[0x10] = 0x01; // replace market_flower_bed_2_3 (scrub)
                // object[0x11] = 0x01; // replace market_flower_bed_2_2 (scrub)
                // object[0x12] = 0x01; // replace market_flower_bed_2_1 (scrub)
                // object[0x13] = 0x01; // replace market_flower_bed_1_3 (scrub)
                // object[0x14] = 0x01; // replace market_flower_bed_1_2 (scrub)
                // object[0x15] = 0x01; // replace market_flower_bed_1_1 (scrub)
                // object[0x16] = 0x01; // replace market_flower_4 (scrub)
                // object[0x17] = 0x01; // replace market_flower_3 (scrub)
                // object[0x18] = 0x01; // replace market_flower_2 (scrub)
                // object[0x19] = 0x01; // replace market_flower_1 (scrub)
                // object[0x1a] = 0x01; // block exit_west
                // object[0x1b] = 0x01; // open door_1_1_back

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // lower stairs
                    add_enemy(FLOWER_ORANGE, 0d191, 0d63);

                    // upper houses
                    if(ROOM.WITH_BIRDS) {
                        add_enemy(BUZZARD_1, 0d177, 0d33);
                    }

                    add_enemy(DANCING_DEVIL_1, 0d109, 0d35);
                    if(ROOM.WITH_BIRDS) {
                        add_enemy(BUZZARD_1, 0d115, 0d35);
                    }

                    // upper stairs
                    // add_enemy(FLOWER_ORANGE, 0d25, 0d8);
                    // add_enemy(FLOWER_ORANGE, 0d38, 0d7);
                    
                    add_enemy(DANCING_DEVIL_1, 0d36, 0d26);
                    add_enemy(DANCING_DEVIL_1, 0d32, 0d30);
                }

                if(time[0d0] < MARKET.START) {
                    if(MARKET.DEBUG) {
                        debug_subtext("market not empty");
                    }

                    add_enemy(VILLAGER_1_3, 0d25, 0d63, INACTIVE);
                    face(LAST_ENTITY, SOUTH);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        guard_market_break(True);

                        question("[SLOW]Do you want to trade for Oil?[CHOICE]Ethanol 1:1", 0d5);

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // ethanol
                            trade_items(OIL, 0d1, ETHANOL, 0d1);
                        }

                        control(BOTH);
                    }));

                    add_enemy(VILLAGER_1_3, 0d60, 0d77, INACTIVE);
                    face(LAST_ENTITY, SOUTH);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        guard_market_break(True);

                        question("[SLOW]Do you want to trade for Tapestry?[CHOICE]Rice 1:5", 0d5);

                        if(MEMORY.QUESTION_ANSWER == 0d0) { // rice
                            trade_items(TAPESTRY, 0d1, RICE, 0d5);
                        }

                        control(BOTH);
                    }));
                } else {
                    if(MARKET.DEBUG) {
                        debug_subtext("market empty");
                    }
                }

                if(ROOM.WITH_RAT) {
                    if(SOULS_MEMORY.DEAD_TOWN_PUPPETS) {
                        add_sterling_rat(0d189, 0d41, 0d156, 0d46, 0d450, 0d186, 0d63);
                    } else {
                        add_enemy(RAT, 0d189, 0d41);
                    }
                }

                default_init_room(False, False);
            }
        };
    };

    area town_level_3() {
        map town_level_3(PALACE_EXTERIOR) {
            // sniff=vanilla

            enum entrance {
                north = entrance(0x56, 0x1f, SOUTH),
                south = entrance(0x56, 0x45, NORTH),

                crash = entrance(0x98, 0x15, NONE, { crash_both(); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_TOWN_TEMPLE.MUSIC_TOWN, 0xff)
            }

            enum BOSS {
                DEBUG = False,
                PROGRESS = memory(FLAG, TEMP),

                PHASE = memory(WORD, TEMP),
                TIMER = memory(WORD, TEMP),

                BOSS_1_ID = memory(WORD, TEMP),
                BOSS_2_ID = memory(WORD, TEMP),
                BOSS_REMAINING_ID = memory(WORD, TEMP),

                LAST_DAMAGED = memory(WORD, TEMP),
                NOT_LAST_DAMAGED = memory(WORD, TEMP),

                P1_SPELL = DISRUPT,
                P1_SPELL_LEVEL = 0d15,

                P1_TIMER_THRESHOLD = 0d600,
                P2_TIMER_THRESHOLD = 0d600,
            }

            enum stepon_trigger {
                stepon_0 = @install() {
                    debug_subtext("S=0");
                },
                exit_south = @install() {
                    if(BOSS.PROGRESS) {
                        fog_wall_inside(!SOULS_MEMORY.DEAD_TOWN_PUPPETS, NORTH);
                    }
                    
                    map_transition(town_level_2, north, SOUTH);
                },
                stepon_2 = @install() {
                    debug_subtext("S=2");
                },
                exit_north = @install() {
                    debug_subtext("S=3");

                    error_message(DLC);
                },
                stepon_4 = @install() {
                    debug_subtext("S=4");
                },
                stepon_5 = @install() {
                    debug_subtext("S=5");
                },
                stepon_6 = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                stepon_8 = @install() {
                    debug_subtext("S=8");
                },
                stepon_9 = @install() {
                    debug_subtext("S=9");
                },
            }

            enum b_trigger {
                sniff__2500_money = @install() {
                    debug_subtext("B=0");
                    // 2500 gold
                },
                sniff__1_limestone_1 = @install() {
                    debug_subtext("B=1");
                    _loot(0x0a, LIMESTONE, 0d01, 0d01);
                },
                sniff__1_bone = @install() {
                    debug_subtext("B=2");
                    _loot(0x09, BONE, 0d01, 0d00);
                },
                sniff__1_bone_1 = @install() {
                    debug_subtext("B=3");
                    _loot(0x08, BONE, 0d01, 0d01);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=4");
                    _loot(0x07, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots_1 = @install() {
                    debug_subtext("B=5");
                    _loot(0x06, ROOTS, 0d01, 0d01);
                },
                sniff__1_water_3 = @install() {
                    debug_subtext("B=6");
                    _loot(0x05, WATER, 0d01, 0d03);
                },
                sniff__1_vinegar_2 = @install() {
                    debug_subtext("B=7");
                    _loot(0x04, VINEGAR, 0d01, 0d02);
                },
                sniff__1_vinegar_1 = @install() {
                    debug_subtext("B=8");
                    _loot(0x03, VINEGAR, 0d01, 0d01);
                },
                sniff__1_water_2 = @install() {
                    debug_subtext("B=9");
                    _loot(0x02, WATER, 0d01, 0d02); // same as B=10
                },

                sniff__1_water_2 = @install() {
                    debug_subtext("B=10");
                    _loot(0x02, WATER, 0d01, 0d02); // same as B=9
                },
                sniff__1_water_2 = @install() {
                    debug_subtext("B=11");
                    _loot(0x01, WATER, 0d01, 0d02);
                },
            }

            fun open_gate(open) {
                if(open) {
                    object[0x00] = 0x7e;
                } else {
                    object[0x00] = 0x00;
                }
            }

            fun boss_defeated() {
                souls_boss_defeated(DEAD_TOWN_PUPPETS, REWARD_TOWN_PUPPETS);

                BOSS.PROGRESS = False;
            }

            fun puppet_damaged(other, dance_animation) {
                if(BOSS.PHASE == 0d0) {
                    BOSS.PHASE = 0d1;

                    cast(SCRIPT_OWNER, SCRIPT_OWNER, FORCE_FIELD, 0d1);
                }
                if(BOSS.PHASE == 0d1) {
                    if(dead(<SCRIPT_OWNER>)) {
                        BOSS.BOSS_REMAINING_ID = other;

                        BOSS.PHASE = 0d2;
                    }

                    if(BOSS.LAST_DAMAGED == <SCRIPT_OWNER>) {
                        sleep(0d5);
                        animate(SCRIPT_OWNER, LOOP, dance_animation);
                        sleep(0d30);
                        cast(SCRIPT_OWNER, BOY, BOSS.P1_SPELL, BOSS.P1_SPELL_LEVEL);
                        animate(SCRIPT_OWNER, ONCE, DEFAULT);
                    }
                    
                    BOSS.LAST_DAMAGED = <SCRIPT_OWNER>;
                    BOSS.NOT_LAST_DAMAGED = other;
                }
                if(BOSS.PHASE == 0d2) {
                    if(_dead(<SCRIPT_OWNER>) && _dead(other)) {
                        BOSS.PHASE = 0d3;
                    }
                }
            }

            @install()
            @async()
            fun boss_ai() {
                if(BOSS.DEBUG) {
                    subtext("phase 0");
                }
                
                while(BOSS.PHASE == 0d0) {
                    yield();
                }

                if(BOSS.DEBUG) {
                    subtext("phase 1");
                }
                
                while(BOSS.PHASE == 0d1) {
                    if(BOSS.TIMER > BOSS.P1_TIMER_THRESHOLD) {
                        BOSS.TIMER = 0d0;
                        arg[0x10] = randrange(0d5);

                        if(BOSS.NOT_LAST_DAMAGED == BOSS.BOSS_1_ID) {
                            animate(BOSS.BOSS_1_ID, ONCE, ANIMATION_ENEMY.PUPPET_1_DANCE);

                            if(arg[0x10] == 0d0) {
                                cast(BOSS.BOSS_1_ID, BOSS.BOSS_2_ID, FORCE_FIELD, 0d0);
                            } else if(arg[0x10] == 0d1) {
                                cast(BOSS.BOSS_1_ID, BOY, CONFOUND, 0d0);
                            } else {
                                cast(BOSS.BOSS_1_ID, BOY, FLASH, 0d5);
                            }
                        } else if(BOSS.NOT_LAST_DAMAGED == BOSS.BOSS_2_ID) {
                            animate(BOSS.BOSS_2_ID, ONCE, ANIMATION_ENEMY.PUPPET_2_DANCE);

                            if(arg[0x10] == 0d0) {
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_1_ID, FORCE_FIELD, 0d0);
                            } else if(arg[0x10] == 0d1) {
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_2_ID, HEAL, 0d15);
                            } else {
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_1_ID, HEAL, 0d15);
                            }
                        }
                    } else {
                        BOSS.TIMER++;
                    }

                    yield();
                }

                if(BOSS.DEBUG) {
                    subtext("phase 2");
                }

                BOSS.TIMER = 0x0000;

                while(BOSS.PHASE == 0d2) {
                    if(BOSS.TIMER > BOSS.P2_TIMER_THRESHOLD) {
                        BOSS.TIMER = 0d0;
                        arg[0x10] = randrange(0d5);

                        if(BOSS.BOSS_REMAINING_ID == BOSS.BOSS_1_ID) {
                            animate(BOSS.BOSS_1_ID, ONCE, ANIMATION_ENEMY.PUPPET_1_DANCE);

                            if(arg[0x10] == 0d0) {
                                cast(BOSS.BOSS_1_ID, BOY, CORROSION, 0d0);
                            } else if(arg[0x10] == 0d1) {
                                cast(BOSS.BOSS_1_ID, BOY, DISRUPT, 0d5);
                            } else {
                                cast(BOSS.BOSS_1_ID, BOY, FLASH, 0d5);
                                cast(BOSS.BOSS_1_ID, BOY, FLASH, 0d5);
                                cast(BOSS.BOSS_1_ID, BOSS.BOSS_1_ID, FORCE_FIELD, 0d0);
                            }
                        } else if(BOSS.BOSS_REMAINING_ID == BOSS.BOSS_2_ID) {
                            animate(BOSS.BOSS_2_ID, ONCE, ANIMATION_ENEMY.PUPPET_2_DANCE);

                            if(arg[0x10] == 0d0) {
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_1_ID, ONE_UP, 0d0);
                            } else if(arg[0x10] == 0d1) {
                                cast(BOSS.BOSS_1_ID, BOY, DISRUPT, 0d5);
                            } else {
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_1_ID, HEAL, 0d15);
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_1_ID, CURE, 0d0);
                                cast(BOSS.BOSS_2_ID, BOSS.BOSS_1_ID, FORCE_FIELD, 0d0);
                            }
                        }
                    } else {
                        BOSS.TIMER++;
                    }

                    yield();
                }

                if(BOSS.DEBUG) {
                    subtext("yatta");
                }

                boss_defeated();
            }

            fun puppet_1(x, y) {
                add_enemy(PUPPET_1, x, y);
                animate(LAST_ENTITY, LOOP, ANIMATION_ENEMY.PUPPET_1_DANGLING);
                attribute(LAST_ENTITY, ROOT, True);
            }
            fun puppet_2(x, y) {
                add_enemy(PUPPET_2, x, y);
                animate(LAST_ENTITY, LOOP, ANIMATION_ENEMY.PUPPET_2_DANGLING);
                attribute(LAST_ENTITY, ROOT, True);
            }

            fun trigger_enter() {
                open_gate(True);

                add_souls_npc_alchemist_firepower(0d86, 0d33, SOUTH);

                if!(SOULS_MEMORY.DEAD_TOWN_PUPPETS) {
                    BOSS.PROGRESS = True;

                    push_music(BOSS);

                    puppet_1(0d75, 0d41);
                    attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                        puppet_damaged(BOSS.BOSS_2_ID, ANIMATION_ENEMY.PUPPET_1_DANCE);
                    }));
                    BOSS.BOSS_1_ID = <LAST_ENTITY>;

                    puppet_2(0d97, 0d41);
                    attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                        puppet_damaged(BOSS.BOSS_1_ID, ANIMATION_ENEMY.PUPPET_2_DANCE);
                    }));
                    BOSS.BOSS_2_ID = <LAST_ENTITY>;

                    boss_ai();
                }

                default_init_room(False, False);
            }
        };
    };
};

map town_bridge(BAD_BOYS) {
    enum entrance {
        east = entrance(0x63, 0x1d, WEST),
        west = entrance(0x01, 0x21, EAST)
    }

    enum soundtrack {
        default = soundtrack(WIND_AMBIENT_BIRDS, 0xff)
    }

    enum stepon_trigger {
        exit_east = @install() {
            map_transition(town_center, west_1, EAST);
        },
        exit_west = @install() {
            map_transition(bog_curve, east, WEST);
        }
    }

    fun open_east_exit(open) {
        if(open) {
           object[0x00] = 0x00; 
        } else {
            object[0x00] = 0x7e;
        }
    }
    fun open_bridge(open) {
        if(open) {
           object[0x07] = 0x07e; 
        } else {
            object[0x07] = 0x00;
        }
    }

    enum ROOM {
        DEBUG = False,

        RIDDLE_SOLVED = memory(FLAG, SRAM),

        RIDDLE_PROGRESS = memory(WORD, TEMP),

        WITH_RAT = False,

        RIDDLE_STEP_1 = 0d6, // 6=2*3
        RIDDLE_STEP_2 = 0d2, // prime factor #1
        RIDDLE_STEP_3 = 0d4, // prime factor #1 squared
        RIDDLE_STEP_4 = 0d3, // prime factor #2
        RIDDLE_STEP_5 = 0d5, // sum of prime factor #1 and #2
        RIDDLE_STEP_6 = 0d1, // rest
    }

    fun riddle_solved() {
        sound(WEIRD_SOUND);

        ROOM.RIDDLE_SOLVED = True;

        if(ROOM.DEBUG) {
            debug_subtext("yatta");
        }
    }

    fun print_index(index) {
        if(index == 0d1) {
            subtext("I");
        } else if(index == 0d2) {
            subtext("II");
        } else if(index == 0d3) {
            subtext("III");
        } else if(index == 0d4) {
            subtext("IV");
        } else if(index == 0d5) {
            subtext("V");
        } else if(index == 0d6) {
            subtext("VI");
        }
    }
    fun remove_pillar(index) {
        if(index == 0d1) {
            object[0x01] = 0x7e;
        } else if(index == 0d2) {
            object[0x02] = 0x7e;
        } else if(index == 0d3) {
            object[0x03] = 0x7e;
        } else if(index == 0d4) {
            object[0x04] = 0x7e;
        } else if(index == 0d5) {
            object[0x05] = 0x7e;
        } else if(index == 0d6) {
            object[0x06] = 0x7e;
        }
    }
    @install()
    fun pillar_triggered() {
        print_index(<SCRIPT_OWNER>[GENERAL_PURPOSE]);

        if(
            (<ACTIVE> != <BOY>) ||
            (
                (MEMORY.CURRENT_WEAPON != WEAPON_INDEX.AXE_2) &&
                (MEMORY.CURRENT_WEAPON != WEAPON_INDEX.AXE_3) &&
                (MEMORY.CURRENT_WEAPON != WEAPON_INDEX.AXE_4)
            )
        ) {
            // animate(ACTIVE, ONCE, SLASH_1);
            end();
        }

        animate(BOY, ONCE, SLASH_2);

        if((ROOM.RIDDLE_PROGRESS == 0d0) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] == ROOM.RIDDLE_STEP_1)) {
            ROOM.RIDDLE_PROGRESS++;
        } else if((ROOM.RIDDLE_PROGRESS == 0d1) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] == ROOM.RIDDLE_STEP_2)) {
            ROOM.RIDDLE_PROGRESS++;
        } else if((ROOM.RIDDLE_PROGRESS == 0d2) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] == ROOM.RIDDLE_STEP_3)) {
            ROOM.RIDDLE_PROGRESS++;
        } else if((ROOM.RIDDLE_PROGRESS == 0d3) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] == ROOM.RIDDLE_STEP_4)) {
            ROOM.RIDDLE_PROGRESS++;
        } else if((ROOM.RIDDLE_PROGRESS == 0d4) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] == ROOM.RIDDLE_STEP_5)) {
            ROOM.RIDDLE_PROGRESS++;
        } else if((ROOM.RIDDLE_PROGRESS == 0d5) && (<SCRIPT_OWNER>[GENERAL_PURPOSE] == ROOM.RIDDLE_STEP_6)) {
            ROOM.RIDDLE_PROGRESS++;
        } else {
            ROOM.RIDDLE_PROGRESS = 0xffff;
        }

        animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.EXPLOSION_2);
        remove_pillar(<SCRIPT_OWNER>[GENERAL_PURPOSE]);

        wait(SCRIPT_OWNER);
        destroy(SCRIPT_OWNER);

        if(ROOM.RIDDLE_PROGRESS == 0d6) {
            sleep(0d10);

            riddle_solved();
        }
    }

    fun add_pillar(index, x, y) {
        add_enemy(PLACEHOLDER, x, y);
        attach_script(LAST_ENTITY, B, reference(pillar_triggered));
        <LAST_ENTITY>[GENERAL_PURPOSE] = index;
    }

    fun trigger_enter() {
        if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
            // east
            add_enemy(FLOWER_PURPLE, 0d93, 0d17);

            // west
            add_enemy(FLOWER_PURPLE, 0d34, 0d24);

            add_enemy(MONK, 0d25, 0d30);

            add_enemy(FLOWER_PURPLE, 0d15, 0d43);
        }

        if!(ROOM.RIDDLE_SOLVED) {
            add_pillar(0d1, 0d12, 0d24);
            add_pillar(0d2, 0d20, 0d24);
            add_pillar(0d3, 0d29, 0d24);

            add_pillar(0d4, 0d12, 0d38);
            add_pillar(0d5, 0d20, 0d38);
            add_pillar(0d6, 0d29, 0d38);
        } else {
            object[0x01] = 0x7e;
            object[0x02] = 0x7e;
            object[0x03] = 0x7e;

            object[0x04] = 0x7e;
            object[0x05] = 0x7e;
            object[0x06] = 0x7e;
        }
   
        open_bridge(True);

        default_init_room(True, True);

        if(ROOM.WITH_RAT) {
            add_enemy(RAT_RED, 0d68, 0d29);
            attach_sterling_script(<LAST_ENTITY>, False, 0d20, 0d68, 0d20, 0d350, 0d999);

            sterling_rats_scanner(0d80, 0d29);
        }
    }
};

map bog_curve(TIMBERDRAKE) {
    enum entrance {
        east = entrance(0x2b, 0x15, WEST),
        south = entrance(0x1b, 0x29, NORTH)
    }

    enum soundtrack {
        default = soundtrack(WIND_AMBIENT_BIRDS, 0xff)
    }

    enum BOSS {
        DEBUG = False,

        ID = memory(WORD, TEMP),

        PROGRESS = memory(FLAG, TEMP),
        PHASE = memory(WORD, TEMP),

        HP = 0d500,

        P1_THRESHOLD = 0d400,

        P2_THRESHOLD = 0d300,
    }

    enum stepon_trigger {
        exit_east = @install() {
            if(BOSS.PROGRESS) {
                fog_wall_inside(True, WEST);
            }
            map_transition(town_bridge, west, EAST);
        },
        exit_south = @install() {
            if(BOSS.PROGRESS) {
                fog_wall_inside(True, NORTH);
            }
            map_transition(bog_bridges, north, SOUTH);
        }
    }

    fun boss_defeated() {
        if!(SOULS_MEMORY.DEAD_HEART) {
            BOSS.PROGRESS = False;

            souls_boss_defeated(DEAD_HEART, REWARD_HEART);
        }
    }

    fun spawn_raptor(x1, y1, direction:DIRECTION, x2, y2) {
        while(BOSS.PROGRESS) {
            add_enemy(RAPTOR_PURPLE, x1, y1);
            attach_to_script(LAST_ENTITY);

            if(False) {
                if(direction == DIRECTION.NORTH) {
                    face(SCRIPT_OWNER, NORTH);
                } else if(direction == DIRECTION.EAST) {
                    face(SCRIPT_OWNER, EAST);
                } else if(direction == DIRECTION.SOUTH) {
                    face(SCRIPT_OWNER, SOUTH);
                } else if(direction == DIRECTION.WEST) {
                    face(SCRIPT_OWNER, WEST);
                }
            }

            walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, x2, y2, SCRIPT_OWNER, SCRIPT_OWNER);
            animate(SCRIPT_OWNER, ONCE, SLASH_1);

            while(alive(<SCRIPT_OWNER>)) {
                if!(BOSS.PROGRESS) {
                    destroy(<SCRIPT_OWNER>);
                    end();
                } else {
                    yield();
                }
            }

            sleep(0d300);
        }
    }

    @install()
    @async()
    fun spawn_south() {
        spawn_raptor(0d28, 0d45, NORTH, 0d25, 0d33);
    }
    @install()
    @async()
    fun spawn_east() {
        spawn_raptor(0d49, 0d18, WEST, 0d34, 0d20);
    }

    @install()
    fun heart_triggered() {
        sound(GORE_MOSQUITO);
        ai_move_projectile_puke(<SCRIPT_OWNER>, ONION, <BOY>, 0d4);

        if(dead(<SCRIPT_OWNER>)) {
            boss_defeated();
        } else if((BOSS.PHASE == 0d0) && (<SCRIPT_OWNER>[HP] < BOSS.P1_THRESHOLD)) {
            BOSS.PHASE = 0d1;

            if(BOSS.DEBUG) {
                debug_subtext("p1");
            }

            spawn_south();
        } else if((BOSS.PHASE == 0d1) && (<SCRIPT_OWNER>[HP] < BOSS.P2_THRESHOLD)) {
            BOSS.PHASE = 0d2;

            if(BOSS.DEBUG) {
                debug_subtext("p2");
            }

            spawn_east();
        }
    }

    @install()
    fun boss_triggered() {
        if!(BOSS.PROGRESS) {
            BOSS.PROGRESS = True;

            push_music(BOSS_JUNGLE);

            attach_script(SCRIPT_OWNER, DAMAGE, reference(heart_triggered));

            sound(GORE_MOSQUITO);
            ai_move_projectile_puke(<SCRIPT_OWNER>, ONION, <BOY>, 0d4);
        }
    }

    fun trigger_enter() {
        // object[0x00] = 0x7e;
        object[0x01] = 0x7e;

        // add_enemy(RAPTOR_PURPLE, 0d29, 0d25);

        if!(SOULS_MEMORY.DEAD_HEART) {
            add_enemy(THRAXX_HEART, 0d29, 0d25);
            BOSS.ID = <LAST_ENTITY>;
            <LAST_ENTITY>[HP] = BOSS.HP;
            attach_script(LAST_ENTITY, DAMAGE, reference(boss_triggered));
        }

        default_init_room(True, True);

        if!(SOULS_MEMORY.DEAD_HEART) {
            while!(BOSS.PROGRESS) {
                sound(GORE_MOSQUITO);
                sleep(0d10);
                sound(GORE_MOSQUITO);

                sleep(0d35);
            }
        }
    }
};

map bog_bridges(SWAMP_BRIDGE) {
    enum entrance {
        north = entrance(0x0b, 0x01, SOUTH),
        south = entrance(0x1b, 0x53, NORTH)
    }

    enum soundtrack {
        default = soundtrack(WIND_AMBIENT_BIRDS, 0xff)
    }

    enum stepon_trigger {
        exit_north = @install() {
            map_transition(bog_curve, south, NORTH);
        },
        exit_south = @install() {
            map_transition(bog_crossing, north_short, SOUTH);
        }
    }

    fun trigger_enter() {
        if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
            // north
            add_enemy(FLOWER_PURPLE, 0d19, 0d12);

            add_enemy(FLOWER_PURPLE, 0d38, 0d13);

            // center
            add_enemy(FLOWER_PURPLE, 0d22, 0d36);

            add_enemy(TENTACLE_WHIP, 0d35, 0d27);
            add_enemy(RAT, 0d40, 0d34);

            // south
            add_enemy(FLOWER_PURPLE, 0d22, 0d71);
        }

        default_init_room(True, True);
    }
};

map bog_crossing(CROSSING) {
    // chests=vanilla
    // sniff=vanilla

    enum entrance {
        north = entrance(0x2d, 0x01, SOUTH),
        east = entrance(0x5f, 0x4d, WEST),
        west_1 = entrance(0x04, 0x71, EAST),
        west_2 = entrance(0x04, 0x2f, EAST),

        north_short = entrance(0x24, 0x1f, SOUTH),
    }

    enum soundtrack {
        default = soundtrack(WATER_AMBIENT_SEAGULLS, 0xff)
    }

    enum ROOM {
        FAKE_EXIT_ID = memory(WORD, TEMP),

        WALL_1 = retained_object(0x01),
        WALL_2 = retained_object(0x00),

        COLLECTIBLE_LOOTED = memory(FLAG, SRAM),
    }

    enum stepon_trigger {
        stepon_0 = @install() {
            debug_subtext("S=0");
        },
        stepon_1 = @install() {
            debug_subtext("S=1");
        },
        stepon_2 = @install() {
            debug_subtext("S=2");
        },
        stepon_3 = @install() {
            debug_subtext("S=3");
        },
        stepon_4 = @install() {
            debug_subtext("S=4");
        },
        stepon_5 = @install() {
            debug_subtext("S=5");
        },
        stepon_6 = @install() {
            debug_subtext("S=6");
        },
        stepon_7 = @install() {
            debug_subtext("S=7");
        },
        exit_east = @install() {
            map_transition(bog_crossing_firepit, west, EAST);
        },
        exit_north = @install() {
            map_transition(bog_bridges, south, NORTH);
        },

        exit_west_2_east = @install() {
            map_transition(bog_crossing_gourds, east, WEST);
        },
        exit_west_1_exit = @install() {
            map_transition(ship, east, WEST);
        },
        stepon_12 = @install() {
            debug_subtext("S=12");
        },
        stepon_13 = @install() {
            debug_subtext("S=13");
        },
        stepon_14 = @install() {
            debug_subtext("S=14");
        },
        stepon_15 = @install() {
            debug_subtext("S=15");
        },
        stepon_16 = @install() {
            debug_subtext("S=16");
        },
        stepon_17 = @install() {
            debug_subtext("S=17");
        },
        stepon_18 = @install() {
            debug_subtext("S=18");
        },
        stepon_19 = @install() {
            debug_subtext("S=19");
        },
    }

    enum b_trigger {
        wall_2 = @install() fun trigger_wall_2() {
            bombable_object(WALL_AXE2, True, ROOM.WALL_2, 0x00, 0x01);
        },
        wall_1 = @install() fun trigger_wall_1() {
            bombable_object(WALL_AXE2, True, ROOM.WALL_1, 0x01, 0x01);
        },
        gourd_2_1__3_water = @install() {
            debug_subtext("B=2");
            _loot_chest(0x06, MUD_PEPPER, 0d01);
        },
        gourd_1_1__2_water = @install() {
            debug_subtext("B=3");
            _loot_chest(0x05, WATER, 0d02);
        },
        gourd_1_2__3_limestone = @install() {
            debug_subtext("B=4");
            _loot_chest(0x07, LIMESTONE, 0d03);
        },
        gourd_1_3__4_wax = @install() {
            debug_subtext("B=5");
            _loot_chest(0x08, WAX, 0d04);
        },
        sniff__1_ethanol_3 = @install() {
            debug_subtext("B=6");
            _loot(0x09, ETHANOL, 0d01, 0d03);
        },
        sniff__1_ethanol_2 = @install() {
            debug_subtext("B=7");
            _loot(0x0a, ETHANOL, 0d01, 0d02);
        },
        sniff__1_roots_1 = @install() {
            debug_subtext("B=8");
            _loot(0x0b, ROOTS, 0d01, 0d01);
        },
        sniff__1_roots_3 = @install() {
            debug_subtext("B=9");
            _loot(0x0c, ROOTS, 0d01, 0d03);
        },

        sniff__1_roots = @install() {
            debug_subtext("B=10");
            _loot(0x0d, ROOTS, 0d01, 0d00);
        },
        sniff__1_roots_2 = @install() {
            debug_subtext("B=11");
            _loot(0x0e, ROOTS, 0d01, 0d02);
        },
        sniff__1_limestone_2 = @install() {
            debug_subtext("B=12");
            _loot(0x0f, LIMESTONE, 0d01, 0d02);
        },
        sniff__1_limestone_1 = @install() {
            debug_subtext("B=13");
            _loot(0x10, LIMESTONE, 0d01, 0d01);
        },
        sniff__1_wax_2 = @install() {
            debug_subtext("B=14");
            _loot(0x11, WAX, 0d01, 0d02);
        },
        sniff__1_wax_2 = @install() {
            debug_subtext("B=15");
            _loot(0x12, WAX, 0d01, 0d02);
        },
        sniff__1_water_1 = @install() {
            debug_subtext("B=16");
            _loot(0x13, WATER, 0d01, 0d01);
        },
        sniff__1_vinegar_1 = @install() {
            debug_subtext("B=17");
            _loot(0x14, VINEGAR, 0d01, 0d01);
        },
        sniff__1_vinegar_1 = @install() {
            debug_subtext("B=18");
            _loot(0x15, VINEGAR, 0d01, 0d01);
        },
        sniff__1_bone_1 = @install() {
            debug_subtext("B=19");
            _loot(0x16, BONE, 0d01, 0d01);
        },
    }

    fun fake_exit() {
        map_transition(bog_bridges, south, NORTH);
    }

    @install()
    @async()
    fun fake_exit_scanner() {
        attach_to_script(ROOM.FAKE_EXIT_ID);

        while(True) {
            arg[0x00] = <ACTIVE>[X];
            arg[0x02] = <ACTIVE>[Y];
            arg[0x04] = <SCRIPT_OWNER>[X];
            arg[0x06] = <SCRIPT_OWNER>[Y];

            if(arg[0x00] < arg[0x04]) {
                arg[0x08] = arg[0x04] - arg[0x00];
            } else {
                arg[0x08] = arg[0x00] - arg[0x04];
            }

            if(arg[0x02] < arg[0x06]) {
                arg[0x0a] = arg[0x06] - arg[0x02];
            } else {
                arg[0x0a] = arg[0x02] - arg[0x06];
            }

            if((arg[0x08] <= 0x15) && (arg[0x0a] <= 0x15)) {
                fake_exit();
                end();
            }

            yield();
        }
    }

    @install()
    fun collectible_triggered() {
        set(ROOM.COLLECTIBLE_LOOTED);

        collectible_collected();
    }

    
    fun trigger_enter() {
        if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
            // top
            add_enemy(FLOWER_PURPLE, 0d38, 0d49);

            add_enemy(FLOWER_PURPLE, 0d12, 0d45);
            add_enemy(FLOWER_PURPLE, 0d19, 0d50);

            // center
            add_enemy(BUZZARD_1, 0d15, 0d68);
            add_enemy(BUZZARD_1, 0d22, 0d78);

            add_enemy(FLOWER_ORANGE, 0d35, 0d74);

            // south
            add_enemy(FLOWER_ORANGE, 0d33, 0d106);

            add_enemy(BUZZARD_1, 0d55, 0d104);
        }

        if!(ROOM.COLLECTIBLE_LOOTED) {
            add_collectible(0x01, 0x5e, 0x4d, reference(collectible_triggered));
        }

        if(True) {
            add_enemy(RAT_RED, 0d49, 0d51);
            attach_sterling_script(<LAST_ENTITY>, False, 0d20, 0d70, 0d55, 0d600, 0d999);

            sterling_rats_scanner(0d45, 0d42);
        }

        add_bombable(0d63, 0d63, ROOM.WALL_1, reference(trigger_wall_1));
        add_bombable(0d64, 0d99, ROOM.WALL_2, reference(trigger_wall_2));

        init_map(0x00, 0x1e, 0xff, 0xff);

        object[0x03] = 0x01;
        object[0x04] = 0x01;

        add_enemy(PLACEHOLDER, 0x24, 0x1f);
        ROOM.FAKE_EXIT_ID = <LAST_ENTITY>;

        default_init_room(True, True);

        sleep(0x10);
        fake_exit_scanner();
    }
};

map bog_crossing_firepit(FIREPIT_BEACH) { // unused
    enum entrance {
        west = entrance(0x03, 0x1f, EAST),
    }

    enum stepon_trigger {
        exit_east = @install() {
            map_transition(bog_crossing, east, WEST);
        },
        windwalker = @install() {
            debug_subtext("S=1");
        },
    }

    fun trigger_enter() {
        default_init_room(False, False);
    }
};

map bog_crossing_gourds(DEFEND) {
    enum entrance {
        east = entrance(0x26, 0x13, WEST),
    }

    enum soundtrack {
        default = soundtrack(WIND_AMBIENT_BIRDS, 0xff)
    }

    enum stepon_trigger {
        exit_east = @install() {
            map_transition(bog_crossing, west_2, EAST);
        },
    }

    enum b_trigger {
        gourd_2__1_call_beads = @install() {
            debug_subtext("B=0");
            _loot_chest(0x00, BISCUIT, 0x01);
        },
        gourd_1__4_clay = @install() {
            _loot_chest(0x01, CLAY, 0d04);
        },
        gourd_3__5_ash = @install() {
            debug_subtext("B=2");
            _loot_chest(0x02, ASH, 0d05);
        },
    }
    
    fun trigger_enter() {
        if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
            add_enemy(MONK, 0d10, 0d9);
            add_enemy(MONK, 0d15, 0d11);
        }

        default_init_room(True, True);
    }
};

area ship_caves() {
    enum AREA_SHIP {
        DEFAULT_MUSIC = MUSIC.SEWER_AMBIENT_WATER
    }

    map ship(CRUSTICIA) {
        enum ROOM {
            DEBUG = False,

            DOG_AVAILABLE = memory(FLAG, TEMP),
            PILLAR_CLEARED = memory(FLAG, SRAM),

            CAVE_OPENED = memory(FLAG, SRAM),
            CAVE_OPENED_DIG_COUNTER = memory(WORD, TEMP),
            CAVE_OPENED_DIG = 0d30,
        }

        enum entrance {
            east = entrance(0x5f, 0x5b, WEST, { ROOM.DOG_AVAILABLE = True; }),
            west = entrance(0x05, 0x59, EAST, { ROOM.DOG_AVAILABLE = True; }),

            door_1 = entrance(0x32, 0x40, SOUTH),
            door_2_1 = entrance(0x30, 0x22, SOUTH),
            door_2_2 = entrance(0x59, 0x2d, SOUTH),
            door_3_1 = entrance(0x13, 0x0d, SOUTH),
            door_3_2 = entrance(0x4b, 0x0c, SOUTH),

            swirl = entrance(0d46, 0d85, NONE, {
                ROOM.DOG_AVAILABLE = True;
                swirl_entrance();
            }),
        }

        enum soundtrack {
            default = soundtrack(AREA_SHIP.DEFAULT_MUSIC, 0xff)
        }

        fun cave_door_triggered() {
            map_transition(room_monk, south, NORTH);
        }

        enum stepon_trigger {
            door_3_1_stairs = @install() {
                debug_subtext("S=0");
            },
            door_3_2_stairs = @install() {
                debug_subtext("S=1");
            },
            door_2_2_stairs = @install() {
                debug_subtext("S=2");

                dog_stairs(DOG_SHIP_STAIRS, 0d84, 0d81);
            },
            door_1_1_stairs = @install() {
                debug_subtext("S=3");

                dog_stairs(DOG_SHIP, 0d50, 0d77);
            },
            lift_top = @install() {
                debug_subtext("S=4");
            },
            exit_west = @install() {
                if(AREA_GLOBAL.ROCK_MOVED_SHIP) {
                    map_transition(east_crossing, east, WEST);
                } else {
                    error_message(DOOR_CONTRAPTION);
                }
            },
            door_3_1 = @install() {
                debug_subtext("S=6");

                map_transition(cave_left_entrance, south_1, NORTH);
            },
            door_2_2 = @install() {
                debug_subtext("S=7");

                if(ROOM.CAVE_OPENED) {
                    cave_door_triggered();
                } else {
                    error_message(DOOR_REQUIRES_DIG);
                }
            },
            door_2_1 = @install() {
                debug_subtext("S=8");

                map_transition(ship_crates, south, NORTH);
            },
            door_1_1 = @install() {
                debug_subtext("S=9");

                map_transition(ship_tavern, south, NORTH);
            },

            door_3_2 = @install() {
                debug_subtext("S=10");

                map_transition(cave_right_entrance, south_3, NORTH);
            },
            exit_east = @install() {
                map_transition(bog_crossing, west_1, EAST);
            },
            lift_bottom = @install() {
                debug_subtext("S=12");
            },
        }

        @install()
        @async()
        fun persistent_animate_pillar(entity) {
            while(alive(entity)) {
                animate(entity, ONCE_FREEZE, ANIMATION_PLACEHOLDER.PILLAR_VIGOR);

                sleep(0d20);
            }
        }

        fun trigger_enter() {
            add_bombable(0d19, 0d14, ROOM.PILLAR_CLEARED, reference(@install() {
                bombable_object(WALL_AXE2_FAKE, True, ROOM.PILLAR_CLEARED);
            }), STONE_ROUND, PILLAR_VIGOR);
            persistent_animate_pillar(<LAST_ENTITY>);

            if(SOULS_MEMORY.DOG_SHIP_STAIRS) {
                _dog_stairs(DOG_SHIP_STAIRS, 0d84, 0d81, ROOM.DOG_AVAILABLE);
            }
            if(SOULS_MEMORY.DOG_SHIP) {
                _dog_stairs(DOG_SHIP, 0d50, 0d77, ROOM.DOG_AVAILABLE);
            }

            if!(ROOM.CAVE_OPENED) {
                archaeology_dig(0d89, 0d42, ROOM.CAVE_OPENED_DIG_COUNTER, ROOM.CAVE_OPENED_DIG, reference(@install() {
                    guard_archaeology_dig(ROOM.CAVE_OPENED, ROOM.CAVE_OPENED_DIG_COUNTER);

                    cave_door_triggered();
                }));
            }

            if(ROOM.DEBUG) {
                debug_memory(SOULS_MEMORY.DOG_SHIP_STAIRS, SOULS_MEMORY.DOG_SHIP, CUSTOM_FLAG.DOG_BUSY);
            }

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // north
                add_enemy(RAPTOR_GREEN, 0d45, 0d21);

                // south-east
                add_enemy(RAPTOR_GREEN, 0d76, 0d80);

                // south
                add_enemy(RAPTOR_PURPLE, 0d49, 0d88);

                // south-west
                add_enemy(RAPTOR_GREEN, 0d41, 0d78);
            }

            add_levitate_stone_ship(0d0, 0d89);

            default_init_room(True, True);
        }
    };

    area ship_inside() {
        map ship_tavern(CRUSTICIA_CAVES) { // variant: tavern
            enum entrance {
                south = entrance(0x6f, 0x51, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_SHIP.DEFAULT_MUSIC, 0xff)
            }

            enum stepon_trigger {
                monk = nop(),
                monk_trigger_west = nop(),
                monk_trigger_south = nop(),
                exit_cave_hammock = nop(),
                exit_south = @install() {
                    debug_subtext("S=4");

                    map_transition(ship, door_1, SOUTH);
                },
                exit_ship_small = nop(),
                exit_cave_crates = nop(),
                exit_cave_monk = nop(),
            }

            enum ROOM {
                RAT_COUNTER = memory(WORD, TEMP),
                RATS_CLEARED = memory(FLAG, SRAM),
            }

            @install()
            @async()
            fun entity_general_purpose_check(entity) {
                while(entity[GENERAL_PURPOSE] == 0x00) {
                    yield();
                }

                map_transition(arena_trap_rimsala, right, NONE);
            }

            enum b_trigger {
                gourd_hammock__1_water = nop(),
                gourd_monk_1__1_nectar = nop(),
                gourd_monk_2__1_clay = nop(),
                gourd_crates__1_nectar = nop(),
                groud__1_wax = @install() {
                    debug_subtext("B=4");

                    <ACTIVE>[GENERAL_PURPOSE] = 0x00;
                    gourd_trap(0x06, <ACTIVE>, 0d112, 0d56);
                    entity_general_purpose_check(<ACTIVE>);

                    // _loot_chest(0x06, WAX, 0d01);
                },
                gourd_ship__1_water = nop(),
                tavern_barkeeper = @install() {
                    debug_subtext("B=6");
                },
            }

            fun init_room(index) {
                if(index == 0x00) {
                    init_map(0x00, 0x00, 0x2e, 0x2a); // hammock
                } else if(index == 0x01) {
                    init_map(0x00, 0x38, 0x26, 0x5c); // crates
                } else if(index == 0x02) {
                    init_map(0x32, 0x36, 0x56, 0x52); // ship
                } else if(index == 0x03) {
                    init_map(0x58, 0x30, 0x86, 0x4e); // tavern
                } else if(index == 0x04) {
                    init_map(0x40, 0x00, 0x66, 0x24); // monk
                }
            }

            @install()
            fun add_rat(x, y) {
                if!(ROOM.RATS_CLEARED) {
                    add_enemy(RAT_RED, x, y);
                    ROOM.RAT_COUNTER++;
                    attach_script(LAST_ENTITY, DEATH, reference(@install() {
                        ROOM.RAT_COUNTER--;

                        if(ROOM.RAT_COUNTER == 0d0) {
                            ROOM.RATS_CLEARED = True;
                        }
                    }));
                    attach_sterling_script(<LAST_ENTITY>, False, 0d30, 0d111, 0d50, 0d580, 0d999);
                } else {
                    add_enemy(RAT, x, y);
                }
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.DEAD_TRAP_RIMSALA) {
                    object[0x06] = 0x01; // loot gourd_tavern
                }

                // north
                add_rat(0d107, 0d61);
                add_rat(0d110, 0d61);
                
                // east
                add_rat(0d129, 0d74);

                // west
                add_rat(0d94, 0d71);

                init_room(0x03);
                default_init_room(False, False);
            }
        };

        map arena_trap_rimsala(RAPTORS) {
            // sniff=vanilla
            
            enum entrance {
                north = entrance(0x1b, 0x03, SOUTH),
                south = entrance(0x1d, 0x33, NORTH),

                left = entrance(0x15, 0x1c, NONE),
                center = entrance(0x1e, 0x21, NONE),
                right = entrance(0x2a, 0x23, NONE),
            }

            enum soundtrack {
                default = soundtrack(BOSS_JUNGLE, 0xff)
            }

            enum stepon_trigger {
                exit_north = nop(),
                exit_south = nop(),
                center = nop(),
            }


            fun close_exits(close) {
                if(close) {
                    object[0x04] = 0x04;
                } else {
                    object[0x05] = 0x04;
                }
            }

            group boss_ai() {
                enum BOSS {
                    DEBUG = False,
                    DEBUG_CHARGE_BOY = False,
                    DEBUG_CHARGE_BOSS = False,

                    ID = memory(WORD, TEMP),

                    PROGRESS = memory(FLAG, TEMP),

                    HP = 0d500,

                    STUCK = memory(FLAG, TEMP),
                    CHARGING = memory(WORD, TEMP),

                    PALETTE_DONOR_BOY = memory(WORD, TEMP),
                    PALETTE_DONOR_DOG = memory(WORD, TEMP),

                    PALETTE_BOY = memory(WORD, TEMP),
                    PALETTE_DOG = memory(WORD, TEMP),
                    PALETTE_BOY_DONOR = memory(WORD, TEMP),
                    PALETTE_DOG_DONOR = memory(WORD, TEMP),

                    ENTITY_NORTH_WEST = memory(WORD, TEMP),
                    ENTITY_NORTH_EAST = memory(WORD, TEMP),
                    ENTITY_SOUTH_WEST = memory(WORD, TEMP),
                    ENTITY_SOUTH_EAST = memory(WORD, TEMP),
                }

                fun boss_defeated() {
                    souls_boss_defeated(DEAD_TRAP_RIMSALA, REWARD_TRAP_RIMSALA);

                    BOSS.PROGRESS = False;

                    map_transition(ship, swirl, NONE);
                }

                @install()
                fun update_palette() {
                    if(BOSS.DEBUG && BOSS.DEBUG_CHARGE_BOY) {
                        debug_memory(<BOY>[GENERAL_PURPOSE]);
                    }
                    if(BOSS.DEBUG && BOSS.DEBUG_CHARGE_BOSS) {
                        debug_memory(BOSS.ID[GENERAL_PURPOSE]);
                    }

                    while(<BOY>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) {
                        yield();
                    }
                    yield();

                    if(<BOY>[GENERAL_PURPOSE] >= 0d10) {
                        <BOY>[PALETTE] = BOSS.PALETTE_BOY_DONOR;
                    } else if(<BOY>[GENERAL_PURPOSE] <= 0d5) {
                        <BOY>[PALETTE] = BOSS.PALETTE_BOY;
                    }

                    if(BOSS.ID[GENERAL_PURPOSE] >= 0d10) {
                        BOSS.ID[PALETTE] = BOSS.PALETTE_DOG_DONOR;
                    } else if(BOSS.ID[GENERAL_PURPOSE] <= 0d5) {
                        BOSS.ID[PALETTE] = BOSS.PALETTE_DOG;
                    }
                }

                @install()
                @async()
                fun decay_charge() {
                    while(alive(BOSS.ID)) {
                        sleep(0d120);

                        if(<BOY>[GENERAL_PURPOSE] > 0d0) {
                            <BOY>[GENERAL_PURPOSE]--;
                        }
                        if(BOSS.ID[GENERAL_PURPOSE] > 0d0) {
                            BOSS.ID[GENERAL_PURPOSE]--;
                        }

                        update_palette();

                        // debug_memory(<BOY>[PALETTE] & 0xff00, BOSS.PALETTE_BOY_DONOR & 0xff00);
                        // if((<BOY>[PALETTE] & 0xff00) == (BOSS.PALETTE_BOY_DONOR & 0xff00)) {
                        if(<BOY>[PALETTE] == BOSS.PALETTE_BOY_DONOR) {
                            MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;

                            if(False) {
                                if(<BOY>[HP] > 0d2) {
                                    damage(BOY, 0d2, True);
                                } else {
                                    damage(BOY, <BOY>[HP] - 0d1, True);
                                }
                            } else {
                                damage(BOY, 0d2, True);
                            }
                        }
                        if(BOSS.ID[PALETTE] == BOSS.PALETTE_DOG_DONOR) {
                            damage(BOSS.ID, 0d2, True);
                        }
                    }
                }
                @install()
                @async()
                fun cheese_protection() {
                    while(alive(BOSS.ID)) {
                        sleep(0d120);

                        if(BOSS.CHARGING) {
                            while(BOSS.CHARGING) {
                                sleep(0d30);
                            }

                            sleep(0d120);
                        }

                        if((arg[0x10] == BOSS.ID[X]) && (arg[0x12] == BOSS.ID[Y])) {
                            BOSS.STUCK = True;

                            if!(BOSS.ID[PALETTE] == BOSS.PALETTE_DOG_DONOR) {
                                cast(BOSS.ID, BOY, FLASH, 0d1);
                            } else {
                                cast(BOSS.ID, BOY, FIREBALL, 0d1);
                            }
                        } else {
                            BOSS.STUCK = False;
                        }

                        arg[0x10] = BOSS.ID[X];
                        arg[0x12] = BOSS.ID[Y];
                    }
                }

                fun add_boss(x, y) {
                    add_enemy(RIMSALA_GOLD, x, y);
                    BOSS.ID = <LAST_ENTITY>;
                    <LAST_ENTITY>[HP] = BOSS.HP;
                    <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(@install() {
                        if(alive(<SCRIPT_OWNER>)) {
                            if(<SCRIPT_OWNER>[PALETTE] == BOSS.PALETTE_DOG_DONOR) {
                                heal(BOSS.ID, 0d10, True);
                            }
                            if(<BOY>[PALETTE] == BOSS.PALETTE_BOY_DONOR) {
                                damage(BOSS.ID, 0d20, True);
                            }
                        } else {
                            boss_defeated();
                        }
                    }));
                }

                fun add_charging_stations() {
                    add_enemy(PLACEHOLDER, 0d18, 0d23);
                    BOSS.ENTITY_NORTH_WEST = <LAST_ENTITY>;
                    add_enemy(PLACEHOLDER, 0d40, 0d25);
                    BOSS.ENTITY_NORTH_EAST = <LAST_ENTITY>;
                    add_enemy(PLACEHOLDER, 0d19, 0d38);
                    BOSS.ENTITY_SOUTH_WEST = <LAST_ENTITY>;
                    add_enemy(PLACEHOLDER, 0d40, 0d41);
                    BOSS.ENTITY_SOUTH_EAST = <LAST_ENTITY>;
                }

                fun add_palette_donors() {
                    add_enemy(BOY_BLACK, 0d00, 0d00, INVISBLE_INVINCIBLE_INACTIVE);
                    BOSS.PALETTE_DONOR_BOY = <LAST_ENTITY>;
                    add_enemy(RIMSALA, 0d00, 0d00, INVISBLE_INVINCIBLE_INACTIVE);
                    BOSS.PALETTE_DONOR_DOG = <LAST_ENTITY>;

                    BOSS.PALETTE_BOY = <BOY>[PALETTE];
                    BOSS.PALETTE_DOG = BOSS.ID[PALETTE];
                    BOSS.PALETTE_BOY_DONOR = BOSS.PALETTE_DONOR_BOY[PALETTE];
                    BOSS.PALETTE_DOG_DONOR = BOSS.PALETTE_DONOR_DOG[PALETTE];
                }

                fun find_nearest_bush(out_memory) {
                    if((BOSS.ID[X] < (0d30 << 0d0003)) && ((BOSS.ID[Y] < (0d30 << 0d0003)))) {
                        if(BOSS.DEBUG) {
                            debug_subtext("north west");
                        }

                        out_memory = BOSS.ENTITY_NORTH_WEST;
                    } else if((BOSS.ID[X] >= (0d30 << 0d0003)) && ((BOSS.ID[Y] < (0d32 << 0d0003)))) {
                        if(BOSS.DEBUG) {
                            debug_subtext("north east");
                        }

                        out_memory = BOSS.ENTITY_NORTH_EAST;
                    } else if((BOSS.ID[X] < (0d30 << 0d0003)) && ((BOSS.ID[Y] >= (0d30 << 0d0003)))) {
                        if(BOSS.DEBUG) {
                            debug_subtext("south west");
                        }

                        out_memory = BOSS.ENTITY_SOUTH_WEST;
                    } else { // if((BOSS.ID[X] < (0d30 << 0d0003)) && ((BOSS.ID[Y] >= (0d32 << 0d0003)))) {
                        if(BOSS.DEBUG) {
                            debug_subtext("south east");
                        }

                        out_memory = BOSS.ENTITY_SOUTH_EAST;
                    }
                }
                fun charge_beam(source) {
                    while(_alive(BOSS.ID) && (BOSS.ID[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) && (!(BOSS.ID[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK))) {
                        sound(TESLA);

                        arg[0x10] = False;
                        arg[0x12] = False;

                        if(BOSS.ID[X] > source[X]) {
                            if((<BOY>[X] < BOSS.ID[X]) && (<BOY>[X] > source[X])) {
                                arg[0x10] = True;
                            }
                        } else {
                            if((<BOY>[X] > BOSS.ID[X]) && (<BOY>[X] < source[X])) {
                                arg[0x10] = True;
                            }
                        }

                        if(BOSS.ID[Y] > source[Y]) {
                            if((<BOY>[Y] < BOSS.ID[Y]) && (<BOY>[Y] > source[Y])) {
                                arg[0x12] = True;
                            }
                        } else {
                            if((<BOY>[Y] > BOSS.ID[Y]) && (<BOY>[Y] < source[Y])) {
                                arg[0x12] = True;
                            }
                        }

                        if!((arg[0x10] == True) && (arg[0x12] == True)) {
                            arg[0x16] = BOSS.ID;
                        } else {
                            arg[0x16] = <BOY>;
                        }

                        shoot_entity_entity(source, LIGHTNING, arg[0x16], 0d2, 0d0);

                        if(arg[0x16][GENERAL_PURPOSE] < 0d100) {
                            arg[0x16][GENERAL_PURPOSE]++;

                            BOSS.CHARGING = arg[0x16];
                        }

                        update_palette();

                        sleep(0d30);
                    }
                }
                @install()
                @async()
                fun boss_loop() {
                    while(alive(BOSS.ID)) {
                        animate(BOSS.ID, LOOP, DEFAULT);

                        find_nearest_bush(arg[0x14]);
                        
                        BOSS.CHARGING = True;
                        charge_beam(arg[0x14]);
                        BOSS.CHARGING = 0x0000;
                        
                        if(False) {
                            sleep(0d300);
                        }
                        animate(BOSS.ID, ONCE, DEFAULT);

                        sleep(0d600);
                    }
                }
            };

            fun trigger_enter() {
                close_exits(True);

                default_init_room(False, False);

                if!(SOULS_MEMORY.DEAD_TRAP_RIMSALA) {
                    <BOY>[GENERAL_PURPOSE] = 0d0;
                    <DOG>[GENERAL_PURPOSE] = 0d0;

                    add_boss(0d24, 0d30);
                    add_palette_donors();
                    add_charging_stations();

                    cheese_protection();
                    decay_charge();

                    boss_loop();
                }
            }
        };
    };

    map ship_crates(CRUSTICIA_CAVES) { // variant: ship
        enum entrance {
            south = entrance(0x47, 0x51, NORTH),
        }

        enum soundtrack {
            default = soundtrack(AREA_SHIP.DEFAULT_MUSIC, 0xff)
        }

        enum stepon_trigger {
            monk = nop(),
            monk_trigger_west = nop(),
            monk_trigger_south = nop(),
            exit_cave_hammock = nop(),
            exit_ship_tavern = nop(),
            exit_south = @install() {
                debug_subtext("S=5");

                map_transition(ship, door_2_1, SOUTH);
            },
            exit_cave_crates = nop(),
            exit_cave_monk = nop(),
        }

        enum b_trigger {
            gourd_hammock__1_water = nop(),
            gourd_monk_1__1_nectar = nop(),
            gourd_monk_2__1_clay = nop(),
            gourd_crates__1_nectar = nop(),
            groud_tavern__1_wax = nop(),
            gourd__1_water = @install() {
                debug_subtext("B=5");
                
                _loot_chest(0x05, WATER, 0d01);
            },
            tavern_barkeeper = nop(),
        }

        fun init_room(index) {
            if(index == 0x00) {
                init_map(0x00, 0x00, 0x2e, 0x2a); // hammock
            } else if(index == 0x01) {
                init_map(0x00, 0x38, 0x26, 0x5c); // crates
            } else if(index == 0x02) {
                init_map(0x32, 0x36, 0x56, 0x52); // ship
            } else if(index == 0x03) {
                init_map(0x58, 0x30, 0x86, 0x4e); // tavern
            } else if(index == 0x04) {
                init_map(0x40, 0x00, 0x66, 0x24); // monk
            }
        }

        fun trigger_enter() {
            // ???
            // object[0x05] = 0x01; // loot gourd_ship

            init_room(0x02);

            default_init_room(False, False);
        }
    };

    map room_monk(CRUSTICIA_CAVES) { // variant: monk
        enum entrance {
            south = entrance(0x4f, 0x23, NORTH),
        }

        enum soundtrack {
            default = soundtrack(AREA_SHIP.DEFAULT_MUSIC, 0xff)
        }

        enum ROOM {
            VOLCANO_TUNNEL_REVEALED = memory(FLAG, SRAM),

            MONK = memory(WORD, TEMP),
        }

        @install()
        fun monk_triggered() {
            conversation({
                if!((SOULS_MEMORY.PROGRESS_COUNTER >= SOULS_MEMORY.FAME_THRESHOLD) || SOULS_MEMORY.DEAD_GIDEON) {
                    arg[0x0e] = randrange(0d3);
                    if(arg[0x0e] == 0d0) {
                        conversation_dialog("[SLOW]Who are you?[B]");
                    } else if(arg[0x0e] == 0d1) {
                        conversation_dialog("[SLOW]Didn't I close my door properly?[B]");
                    } else {
                        conversation_dialog("[SLOW]I don't know you.[B]");
                    }
                } else {
                    conversation_question("[SLOW]I have heard about your adventures.[B]Digging those tunnels took a life time.[CHOICE]jump…[CHOICE]leave…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) { // jump
                        walk(ACTIVE, TILE_ABSOLUTE, 0d74, 0d16, ACTIVE, NONE);

                        walk(ACTIVE, TILE_ABSOLUTE_DIRECT, 0d72, 0d16, ACTIVE, NONE);

                        sleep(0d30);

                        map_transition(northern_jungle_tunnel_end, crash, NONE);
                    } else {
                        error_walk_back(EAST);
                    }
                }
            });
        }

        enum stepon_trigger {
            monk = @install() {
                debug_subtext("S=0");

                attach_to_script(ROOM.MONK);
                monk_triggered();
            },
            monk_trigger_west = @install() {
                debug_subtext("S=1");
            },
            monk_trigger_south = @install() {
                debug_subtext("S=2");
            },
            exit_cave_hammock = nop(),
            exit_ship_tavern = nop(),
            exit_ship_small = nop(),
            exit_cave_crates = nop(),
            south = @install() {
                debug_subtext("S=7");

                map_transition(ship, door_2_2, SOUTH);
            },
        }

        enum b_trigger {
            gourd_hammock__1_water = nop(),
            gourd_1__1_nectar = @install() {
                debug_subtext("B=1");
                _loot_chest(0x02, NECTAR, 0d01);
            },
            gourd_2__1_clay = @install() {
                debug_subtext("B=2");
                _loot_chest(0x01, CLAY, 0d01);
            },
            gourd_crates__1_nectar = nop(),
            groud_tavern__1_wax = nop(),
            gourd_ship__1_water = nop(),
            tavern_barkeeper = nop(),
        }

        fun init_room(index) {
            if(index == 0x00) {
                init_map(0x00, 0x00, 0x2e, 0x2a); // hammock
            } else if(index == 0x01) {
                init_map(0x00, 0x38, 0x26, 0x5c); // crates
            } else if(index == 0x02) {
                init_map(0x32, 0x36, 0x56, 0x52); // ship
            } else if(index == 0x03) {
                init_map(0x58, 0x30, 0x86, 0x4e); // tavern
            } else if(index == 0x04) {
                init_map(0x40, 0x00, 0x66, 0x24); // monk
            }
        }

        fun trigger_enter() {
            init_room(0x04);

            add_enemy(MONK, 0d77, 0d15, INACTIVE_IMORTAL);
            attach_script(LAST_ENTITY, B, reference(monk_triggered));
            ROOM.MONK = <LAST_ENTITY>;

            if(ROOM.VOLCANO_TUNNEL_REVEALED) {
                add_enemy(REVEALER_TARGET_ENTITY, 0d69, 0d17);
                special_script(REVEALER, reference(@install() {
                    destroy(SCRIPT_OWNER);

                    ROOM.VOLCANO_TUNNEL_REVEALED = True;
                }));
            }
            
            default_init_room(False, False);
        }
    };
};

area desert_bug() {
    fun dungeon_legs(up) {
        debug_memory(up, 0d0);

        if(up) {
            object[0x00] = 0x01; // raise dungeon_leg_west_1
            object[0x01] = 0x01; // raise dungeon_leg_west_2
            object[0x02] = 0x01; // raise dungeon_leg_west_3
            object[0x03] = 0x01; // raise dungeon_leg_east_1
            object[0x04] = 0x01; // raise dungeon_leg_east_2
            object[0x05] = 0x01; // raise dungeon_leg_east_3
        } else {
            object[0x00] = 0x00; // raise dungeon_leg_west_1
            object[0x01] = 0x00; // raise dungeon_leg_west_2
            object[0x02] = 0x00; // raise dungeon_leg_west_3
            object[0x03] = 0x00; // raise dungeon_leg_east_1
            object[0x04] = 0x00; // raise dungeon_leg_east_2
            object[0x05] = 0x00; // raise dungeon_leg_east_3
        }
    }

    map bugmuck(BUGMUCK) {
        enum ROOM {
            CODE_BOT_HACKED = memory(FLAG, TEMP),
            CODE_BOT_DIG_COUNT = 0d100,
            CODE_BOT_X = 0d138,
            CODE_BOT_Y = 0d44,
        }

        enum entrance {
            north_1 = entrance(0x0b, 0x01, SOUTH),
            north_2 = entrance(0x1b, 0x01, SOUTH),
            cave = entrance(0x24, 0x4c, SOUTH),

            dungeon_north = entrance(0x7c, 0d18, NORTH),
            dungeon_east_1 = entrance(0x85, 0x34, EAST, { dungeon_legs(True); }),
            dungeon_east_2 = entrance(0x85, 0x3e, EAST, { dungeon_legs(True); }),
            dungeon_east_3 = entrance(0x85, 0x4a, EAST, { dungeon_legs(True); }),
            dungeon_south = entrance(0x7c, 0x75, SOUTH),
            dungeon_west_1 = entrance(0x73, 0x4a, WEST, { dungeon_legs(True); }),
            dungeon_west_2 = entrance(0x73, 0x3e, WEST, { dungeon_legs(True); }),
            dungeon_west_3 = entrance(0x73, 0x34, WEST, { dungeon_legs(True); }),

            code_bot = entrance(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, NONE, {
                ROOM.CODE_BOT_HACKED = True;

                hacking_wakeup(0d24, 0d0, 0d24, 0d16);
            }),
        }

        enum soundtrack {
            default = soundtrack(BUGMUCK_AMBIENT_MELODY, 0xff)
        }

        enum stepon_trigger {
            helper_bug_east_south = @install() {
                debug_subtext("S=0");
            },
            helper_bug_west_south = @install() {
                debug_subtext("S=1");
            },
            helper_bug_west_north = @install() {
                debug_subtext("S=2");
            },
            exit_north_1 = @install() {
                debug_subtext("S=3");

                map_transition(desert, south, NORTH);
            },
            exit_north_2 = @install() {
                debug_subtext("S=4");

                map_transition(bugmuck_cave_7, north_1, NORTH);
            },
            exit_cave = @install() {
                debug_subtext("S=5");

                map_transition(bugmuck_cave_1, south, NORTH);
            },
            bbm_south = @install() {
                debug_subtext("S=6");

                if(SOULS_MEMORY.DEAD_DOUBLE_THRAXX) {
                    map_transition(bbm_1, south, NORTH);
                } else {
                    error_message(DOOR_WRONG_SIDE, SOUTH);
                }
            },
            bbm_west_1 = @install() {
                debug_subtext("S=7");

                map_transition(bbm_2, level_2_west, EAST);
            },
            bbm_west_2 = @install() {
                debug_subtext("S=8");

                map_transition(bbm_2, level_1_west, EAST);
            },
            bbm_west_3 = @install() {
                debug_subtext("S=9");

                map_transition(bbm_2, level_0_west, EAST);
            },

            bbm_east_1 = @install() {
                debug_subtext("S=10");

                map_transition(bbm_2, level_0_east, WEST);
            },
            bbm_east_2 = @install() {
                debug_subtext("S=11");

                map_transition(bbm_2, level_1_east, WEST);
            },
            bbm_east_3 = @install() {
                debug_subtext("S=12");

                map_transition(bbm_2, level_2_east, WEST);
            },
        }

        enum b_trigger {
            gourd__2_crystal = @install() {
                debug_subtext("B=0");
                _loot_chest(0x0d, CRYSTAL, 0d02);
            },
            gourd__glove_1_2 = @install() {
                debug_subtext("B=1");
                _loot_chest(0x0c, JEWELED_SCARAB, 0d01);
            },
            gourd__1_petal = @install() {
                debug_subtext("B=2");
                _loot_chest(0x0b, JEWELED_SCARAB, 0d01);
            },
            gourd__4_water = @install() {
                debug_subtext("B=3");
                _loot_chest(0x09, WATER, 0d04);
            },
            gourd__2_crystal = @install() {
                debug_subtext("B=4");
                _loot_chest(0x0a, CRYSTAL, 0d02);
            },
            gourd__1_biscuit = @install() {
                debug_subtext("B=5");
                _loot_chest(0x07, JEWELED_SCARAB, 0d01);
            },
            gourd__1_clay = @install() {
                debug_subtext("B=6");
                _loot_chest(0x08, CLAY, 0d01);
            },
            gourd__1_petal = @install() {
                debug_subtext("B=7");
                _loot_chest(0x06, JEWELED_SCARAB, 0d01);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=8");
                _loot(0x0e, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=9");
                _loot(0x0f, OIL, 0d01, 0d00);
            },

            sniff__1_oil = @install() {
                debug_subtext("B=10");
                _loot(0x10, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=11");
                _loot(0x11, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=12");
                _loot(0x12, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=13");
                _loot(0x13, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=14");
                _loot(0x14, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=15");
                _loot(0x15, OIL, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=16");
                _loot(0x16, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=17");
                _loot(0x17, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=18");
                _loot(0x18, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=19");
                _loot(0x19, ROOTS, 0d01, 0d00);
            },

            sniff__1_roots = @install() {
                debug_subtext("B=20");
                _loot(0x1a, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=21");
                _loot(0x1b, ROOTS, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=22");
                _loot(0x1c, ROOTS, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=23");
                _loot(0x1d, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=24");
                _loot(0x1e, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=25");
                _loot(0x1f, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=26");
                _loot(0x20, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=27");
                _loot(0x21, ASH, 0d01, 0d00);
            },
            sniff__1_crystal_2 = @install() {
                debug_subtext("B=28");
                _loot(0x22, CRYSTAL, 0d01, 0d02);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=29");
                _loot(0x23, WAX, 0d01, 0d00);
            },

            sniff__1_crystal_1 = @install() {
                debug_subtext("B=30");
                _loot(0x24, CRYSTAL, 0d01, 0d01);
            },
            sniff__1_crystal = @install() {
                debug_subtext("B=31");
                _loot(0x25, CRYSTAL, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=32");
                _loot(0x26, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=33");
                _loot(0x27, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=34");
                _loot(0x28, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=35");
                _loot(0x29, CLAY, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=36");
                _loot(0x2a, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=37");
                _loot(0x2b, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=38");
                _loot(0x2c, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=39");
                _loot(0x2d, WAX, 0d01, 0d00);
            },

            sniff__1_wax = @install() {
                debug_subtext("B=40");
                _loot(0x2e, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("B=41");
                _loot(0x2f, WAX, 0d01, 0d00);
            },
        }

        @install()
        @async()
        fun fake_exit_scanner(entity) {
            range_checker(entity, <ACTIVE>, 0x20, 0x20, @install() {
                fog_wall_outside((!SOULS_MEMORY.DEAD_DOUBLE_THRAXX) && SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX, NORTH);
                
                if!(SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX) {
                    map_transition(thraxx, north, SOUTH);
                } else {
                    map_transition(thraxx, spider, SOUTH);
                }
            });
        }

        fun trigger_enter() {
            // object[0x00] = 0x01; // raise dungeon_leg_west_1
            // object[0x01] = 0x01; // raise dungeon_leg_west_2
            // object[0x02] = 0x01; // raise dungeon_leg_west_3
            // object[0x03] = 0x01; // raise dungeon_leg_east_1
            // object[0x04] = 0x01; // raise dungeon_leg_east_2
            // object[0x05] = 0x01; // raise dungeon_leg_east_3
            // object[0x06] = 0x01; // gourd_bbm_east (petal)
            // object[0x07] = 0x01; // gourd_bbm_west_1 (dog biscuit)
            // object[0x08] = 0x01; // gourd_south
            // object[0x09] = 0x01; // gourd_hb_south
            // object[0x0a] = 0x01; // gourd_hb_east
            // object[0x0b] = 0x01; // gourd_bbm_west_2 (petal)
            // object[0x0c] = 0x01; // gourd_upstairs_2
            // object[0x0d] = 0x01; // gourd_upstairs_1

            if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                // top-south
                add_enemy(BUZZARD_1, 0d35, 0d49);

                // top-north
                add_enemy(MAGGOT_RED, 0d54, 0d15);
                add_enemy(MAGGOT_RED, 0d87, 0d12);

                // north-west
                add_enemy(MAGGOT_RED, 0d22, 0d50);

                // south-west
                add_enemy(BUZZARD_1, 0d40, 0d108);

                // east
                add_enemy(BUZZARD_1, 0d158, 0d96);

                // south
                add_enemy(BUZZARD_1, 0d56, 0d133);

                // center
                add_enemy(BUZZARD_1, 0d57, 0d42);

                add_enemy(MAGGOT_RED, 0d97, 0d38);

                // dungeon-south
                add_enemy(SPIDER_YELLOW, 0d122, 0d126);
                add_enemy(SPIDER_YELLOW, 0d133, 0d134);

                // dungeon-east
                add_enemy(SPIDER_YELLOW, 0d162, 0d51);

                // dungeon-west
                add_enemy(MAGGOT_RED, 0d76, 0d45);

                add_enemy(SPIDER_YELLOW, 0d73, 0d73);

                add_enemy(SPIDER_YELLOW, 0d71, 0d93);
            }
            
            default_init_room(False, False);

            archaeology_dig_code_bot(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, ARCHAEOLOGY_DIG.CODE_4, ROOM.CODE_BOT_DIG_COUNT, ROOM.CODE_BOT_HACKED);

            add_enemy(PLACEHOLDER, 0d124, 0d18);
            fake_exit_scanner(<LAST_ENTITY>);
        }
    };

    area bugmuck_cave() {
        enum AREA_BUGMUCK_CAVE {
            MUSIC = MUSIC.BUGMUCK_AMBIENT_MELODY,
        }

        map bugmuck_cave_1(VOLCANO_ROOMS) { // variant: room_ns
            enum entrance {
                north = entrance(0x1c, 0x3d, SOUTH),
                south = entrance(0x22, 0x7b, NORTH),

                bonfire = entrance(0d34, 0d100, NONE, { bonfire_wakeup(-0d24, 0d0, 0d0, 0d8); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_south = @install() {
                    debug_subtext("S=5");

                    map_transition(bugmuck, cave, SOUTH);
                },
                exit_room_sw_west = nop(),
                exit_north = @install() {
                    debug_subtext("S=7");

                    map_transition(bugmuck_cave_2_6, south, NORTH);
                },
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd__4_ash = @install() {
                    debug_subtext("B=3");
                    _loot_chest(0x04, ASH, 0d04);
                },
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff__1_clay = @install() {
                    debug_subtext("B=14");
                    _loot(0x0a, CLAY, 0d01, 0d00);
                },
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff__1_wax = @install() {
                    debug_subtext("B=23");
                    _loot(0x13, WAX, 0d01, 0d00);
                },
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0d0) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0d1) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0d2) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0d3) {
                    init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0d4) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0d5) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                } else if(index == 0d6) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0d7) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                } else if(index == 0d8) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0d9) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                } else if(index == 0d10) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                }
            }

            fun trigger_enter() {
                bonfire(0d34, 0d100, SOULS_MEMORY.BONFIRE_BUG);

                init_room(0d4);
                default_init_room(False, False);
            }
        };
        map bugmuck_cave_2_6(VOLCANO_ROOMS) { // variant: main
            enum entrance {
                north = entrance(0xd3, 0x3d, SOUTH),
                east = entrance(0xf7, 0x5b, WEST),
                south = entrance(0xd5, 0x95, NORTH),
                west = entrance(0xbb, 0x5d, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_cave_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_east = @install() {
                    debug_subtext("S=17");

                    map_transition(bugmuck_cave_5, west, EAST);
                },
                exit_west = @install() {
                    debug_subtext("S=18");

                    map_transition(bugmuck_cave_7, east, WEST);
                },
                exit_north = @install() {
                    debug_subtext("S=19");

                    map_transition(bugmuck_cave_3, south, NORTH);
                },

                exit_south = @install() {
                    debug_subtext("S=20");

                    map_transition(bugmuck_cave_1, north, SOUTH);
                },
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd__1_call_bead = @install() {
                    debug_subtext("B=5");
                    _loot_chest(0x03, CALL_BEADS, 0d01); // amount+=0
                },
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff__1_roots = @install() {
                    debug_subtext("B=17");
                    _loot(0x0d, ROOTS, 0d01, 0d00);
                },
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff__1_wax = @install() {
                    debug_subtext("B=24");
                    _loot(0x14, WAX, 0d01, 0d00);
                },
            }

            fun init_room(index) {
                if(index == 0d0) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0d1) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0d2) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0d3) {
                    init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0d4) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0d5) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                } else if(index == 0d6) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0d7) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                } else if(index == 0d8) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0d9) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                } else if(index == 0d10) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                }
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // center
                    add_enemy(MAGGOT, 0d214, 0d106);

                    // west
                    add_enemy(MAGGOT, 0d183, 0d125);

                    // top-north
                    add_enemy(MAGGOT, 0d214, 0d88);

                    // top-east
                    add_enemy(MAGGOT, 0d224, 0d102);
                }

                init_room(0d7);
                // init_room(0d10);
                default_init_room(False, False);
            }
        };
        map bugmuck_cave_3(VOLCANO_ROOMS) { // variant: room_es
            enum entrance {
                east = entrance(0x67, 0x1c, WEST),
                south = entrance(0x4c, 0x39, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_south = @install() {
                    debug_subtext("S=10");

                    map_transition(bugmuck_cave_2_6, north, SOUTH);
                },
                exit_east = @install() {
                    debug_subtext("S=11");

                    map_transition(bugmuck_cave_4, west, EAST);
                },
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff__1_oil = @install() {
                    debug_subtext("B=19");
                    _loot(0x0f, OIL, 0d01, 0d00);
                },
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0d0) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0d1) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0d2) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0d3) {
                    init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0d4) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0d5) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                } else if(index == 0d6) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0d7) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                } else if(index == 0d8) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0d9) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                } else if(index == 0d10) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                }
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // south
                    add_enemy(LIZARD, 0d67, 0d39);
                }

                init_room(0d1);
                default_init_room(False, False);
            }
        };
        map bugmuck_cave_4(VOLCANO_ROOMS) { // variant: room_sw
            enum entrance {
                south = entrance(0x1c, 0x3b, NORTH),
                west = entrance(0x01, 0x24, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_cave_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_west = @install() {
                    debug_subtext("S=6");

                    map_transition(bugmuck_cave_3, east, WEST);
                },
                exit_room_ns_north = nop(),
                exit_south = @install() {
                    debug_subtext("S=8");

                    map_transition(bugmuck_cave_5, north, SOUTH);
                },
                exit_room_nne_north_1 = nop(),

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd__4_ash = @install() {
                    debug_subtext("B=4");
                    _loot_chest(0x05, ASH, 0d04);
                },
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=12");
                    _loot(0x08, WATER, 0d01, 0d00);
                },
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0d0) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0d1) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0d2) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0d3) {
                    init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0d4) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0d5) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                } else if(index == 0d6) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0d7) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                } else if(index == 0d8) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0d9) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                } else if(index == 0d10) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                }
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // east
                    add_enemy(LIZARD, 0d36, 0d35);

                    // south
                    add_enemy(MAGGOT, 0d18, 0d45);
                }

                init_room(0d0);
                default_init_room(False, False);
            }
        };
        map bugmuck_cave_5(VOLCANO_ROOMS) { // variant: room_nw
            enum entrance {
                north = entrance(0x20, 0x85, SOUTH),
                west = entrance(0x01, 0xa3, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_north = @install() {
                    debug_subtext("S=0");

                    map_transition(bugmuck_cave_4, south, NORTH);
                },
                exit_west = @install() {
                    debug_subtext("S=1");

                    map_transition(bugmuck_cave_2_6, east, WEST);
                },
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff__1_oil = @install() {
                    debug_subtext("B=21");
                    _loot(0x11, OIL, 0d01, 0d00);
                },
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0d0) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0d1) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0d2) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0d3) {
                    init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0d4) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0d5) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                } else if(index == 0d6) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0d7) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                } else if(index == 0d8) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0d9) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                } else if(index == 0d10) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                }
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // north
                    add_enemy(LIZARD, 0d18, 0d153);

                    // east
                    add_enemy(MAGGOT, 0d37, 0d166);

                    // south
                    add_enemy(MAGGOT, 0d24, 0d171);
                }

                init_room(0d8);
                default_init_room(False, False);
            }
        };
        map bugmuck_cave_7(VOLCANO_ROOMS) { // variant: room_nne
            enum entrance {
                north_1 = entrance(0x4c, 0x36, SOUTH),
                north_2 = entrance(0x60, 0x39, SOUTH),
                east = entrance(0x7f, 0x60, WEST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_east = @install() {
                    debug_subtext("S=4");

                    map_transition(bugmuck_cave_2_6, west, EAST);
                },
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_north_1 = @install() {
                    debug_subtext("S=9");

                    map_transition(bugmuck, north_2, NORTH);
                },

                exit_room_es_south = nop(),
                exit_room_es_east = nop(),
                exit_north_2 = @install() {
                    debug_subtext("S=12");

                    map_transition(bugmuck_cave_portal, south, NORTH);
                },
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff__1_water = @install() {
                    debug_subtext("B=13");
                    _loot(0x09, WATER, 0d01, 0d00);
                },
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff__1_roots = @install() {
                    debug_subtext("B=16");
                    _loot(0x0c, ROOTS, 0d01, 0d00);
                },
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff_room_es__1_oil = nop(),
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun init_room(index) {
                if(index == 0d0) {
                    init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                } else if(index == 0d1) {
                    init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                } else if(index == 0d2) {
                    init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                } else if(index == 0d3) {
                    init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                } else if(index == 0d4) {
                    init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                } else if(index == 0d5) {
                    init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                } else if(index == 0d6) {
                    init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                } else if(index == 0d7) {
                    init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                } else if(index == 0d8) {
                    init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                } else if(index == 0d9) {
                    init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                } else if(index == 0d10) {
                    init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                }
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // north
                    add_enemy(MAGGOT, 0d84, 0d85);

                    // east
                    add_enemy(MAGGOT, 0d107, 0d84);

                    // west
                    add_enemy(LIZARD, 0d74, 0d92);
                }

                init_room(0d5);
                default_init_room(False, False);
            }
        };

        map bugmuck_cave_portal(PYRAMID_CAVE) {
            enum entrance {
                south = entrance(0x15, 0x23, NORTH),

                teleporter = entrance(0d23, 0d18, NONE, { teleporter_in(SOUTH); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUGMUCK_CAVE.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");

                    map_transition(bugmuck_cave_7, north_2, SOUTH);
                },
                exit_teleporter = @install() {
                    debug_subtext("S=1");

                    teleporter_out(0d23, 0d17);
                    map_transition(cave_left_north_west, teleporter, NONE);
                },
            }

            fun trigger_enter() {
                default_init_room(False, False);
            }
        };
    };

    area bug_dungeon() {
        enum AREA_BUG_DUNGEON {
            MUSIC = MUSIC.BUGMUCK_AMBIENT_MELODY,
        }

        group bbm_helper() {
            @install()
            @async()
            fun spider_trap(entity) {
                entity[GENERAL_PURPOSE] = True;

                attribute(entity, ROOT, True);

                _add_enemy(SPIDER, entity[X], entity[Y], INVINCIBLE);
                attach_to_script(LAST_ENTITY);

                attribute(SCRIPT_OWNER, ROOT, True);

                <SCRIPT_OWNER>[Z] = 0d10000 + randrange(0d500);

                yield();
                while(<SCRIPT_OWNER>[Z] > 0d0) {
                    yield();
                }

                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE_DIRECT, entity[X], entity[Y], NONE, NONE);
                wait(SCRIPT_OWNER);

                control(entity, True);
                smart_animate(entity, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);

                attribute(SCRIPT_OWNER, ROOT, False);

                if(randrange(0d2)) {
                    walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, 0d1, 0d0, SCRIPT_OWNER, NONE);

                    while(arg[0x10] < 0d3) {
                        arg[0x10]++;

                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, -0d1, 0d1, SCRIPT_OWNER, NONE);
                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, -0d1, -0d1, SCRIPT_OWNER, NONE);
                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, 0d1, -0d1, SCRIPT_OWNER, NONE);
                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, 0d1, 0d1, SCRIPT_OWNER, NONE);
                    }
                } else {
                    walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, -0d1, 0d0, SCRIPT_OWNER, NONE);

                    while(arg[0x10] < 0d3) {
                        arg[0x10]++;

                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, 0d1, -0d1, SCRIPT_OWNER, NONE);
                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, 0d1, 0d1, SCRIPT_OWNER, NONE);
                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, -0d1, 0d1, SCRIPT_OWNER, NONE);
                        walk(SCRIPT_OWNER, TILE_RELATIVE_DIRECT, -0d1, -0d1, SCRIPT_OWNER, NONE);
                    }
                }

                walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE_DIRECT, entity[X], entity[Y] + 0d10, SCRIPT_OWNER, NONE);
                face(SCRIPT_OWNER, SOUTH);

                while(entity[Z] < 0d10000) {
                    arg[0x12] = randrange(0d5);

                    entity[VELOCITY] += arg[0x12];
                    <SCRIPT_OWNER>[VELOCITY] += arg[0x12];

                    yield();
                }

                animate(entity, LOOP, ANIMATION_ALL.INVISIBLE);
                animate(SCRIPT_OWNER, LOOP, ANIMATION_ALL.INVISIBLE);

                entity[GENERAL_PURPOSE] = False;
            }

            fun collapse_bridge(object_id) {
                spider_trap(<ACTIVE>);
                control(INACTIVE, True);
                spider_trap(<INACTIVE>);

                if(object_id is Word) {
                    object[object_id] = 0x7e;
                }

                yield();
                while(<ACTIVE>[GENERAL_PURPOSE]) {
                    yield();
                }

                map_transition(thraxx, spider, NONE);
            }

            @install()
            @async()
            fun spider_drop(entity, x, y) {
                control(entity, True);
                entity[Z] = 0d10000 + randrange(0d500);

                _add_enemy(SPIDER, entity[X], entity[Y], INACTIVE_IMORTAL);
                attach_to_script(LAST_ENTITY);
                <SCRIPT_OWNER>[Z] = 0d10000 + randrange(0d500);

                smart_animate(entity, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);

                while(entity[Z] > 0d0) {
                    yield();
                }

                control(entity, False);
                animate(entity, ONCE, ANIMATION_ALL.DEFAULT);

                walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, x, y, SCRIPT_OWNER, NONE);

                destroy(<SCRIPT_OWNER>);
            }
        };

        map bbm_1(BBM_1) {
            enum entrance {
                north = entrance(0x34, 0x0b, SOUTH),
                south = entrance(0x32, 0xa9, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUG_DUNGEON.MUSIC, 0xff)
            }

            enum stepon_trigger {
                trap_5_2_north = @install() {
                    debug_subtext("S=0");

                    collapse_bridge(0x0b);
                },
                slide_left_2_1 = @install() {
                    debug_subtext("S=1");
                },
                slide_left_1_1 = @install() {
                    debug_subtext("S=2");
                },
                slide_left_1_2 = @install() {
                    debug_subtext("S=3");
                },
                slide_right_1_1 = @install() {
                    debug_subtext("S=4");
                },
                slide_right_1_2 = @install() {
                    debug_subtext("S=5");
                },
                slide_right_5_3 = @install() {
                    debug_subtext("S=6");
                },
                slide_right_5_2 = @install() {
                    debug_subtext("S=7");
                },
                slide_right_5_1 = @install() {
                    debug_subtext("S=8");
                },
                slide_right_3 = @install() {
                    debug_subtext("S=9");
                },

                slide_right_2 = @install() {
                    debug_subtext("S=10");
                },
                slide_right_bottom = @install() {
                    debug_subtext("S=11");
                },
                slide_left_bottom = @install() {
                    debug_subtext("S=12");
                },
                slide_left_1_3 = @install() {
                    debug_subtext("S=13");
                },
                slide_right_1_3 = @install() {
                    debug_subtext("S=14");
                },
                slide_right_4_3 = @install() {
                    debug_subtext("S=15");
                },
                slide_right_4_2 = @install() {
                    debug_subtext("S=16");
                },
                slide_right_1_4 = @install() {
                    debug_subtext("S=17");
                },
                slide_left_1_4 = @install() {
                    debug_subtext("S=18");
                },
                slide_left_2_2 = @install() {
                    debug_subtext("S=19");
                },

                slide_left_3 = @install() {
                    debug_subtext("S=20");
                },
                slide_left_4 = @install() {
                    debug_subtext("S=21");
                },
                slide_left_5_2 = @install() {
                    debug_subtext("S=22");
                },
                slide_left_5_1 = @install() {
                    debug_subtext("S=23");
                },
                exit_south = @install() {
                    debug_subtext("S=24");

                    if(SOULS_MEMORY.DEAD_DOUBLE_THRAXX) {
                        map_transition(bugmuck, dungeon_south, SOUTH);
                    } else {
                        error_message(DOOR_WRONG_SIDE, NORTH);
                    }
                },
                exit_north = @install() {
                    debug_subtext("S=25");
                    map_transition(bbm_2, level_0_south, NORTH);
                },
                trap_1_3_east = @install() {
                    debug_subtext("S=26");

                    collapse_bridge(0x00);
                },
                trap_2_4_east = @install() {
                    debug_subtext("S=27");

                    collapse_bridge(0x01);
                },
                trap_2_4_north = @install() {
                    debug_subtext("S=28");

                    collapse_bridge(0x02);
                },
                trap_3_4_north = @install() {
                    debug_subtext("S=29");

                    collapse_bridge(0x08);
                },

                trap_4_4_north = @install() {
                    debug_subtext("S=30");

                    collapse_bridge(0x0a);
                },
                trap_6_3_north = @install() {
                    debug_subtext("S=31");

                    // collapse_bridge(0x0f);
                },
                trap_6_1_north_2 = @install() {
                    debug_subtext("S=32");

                    collapse_bridge(0x0e);
                },
                trap_6_1_north_1 = @install() {
                    debug_subtext("S=33");

                    collapse_bridge(0x0e);
                },
                trap_6_0_east = @install() {
                    debug_subtext("S=34");

                    collapse_bridge(0x0d);
                },
                trap_5_1_north = @install() {
                    debug_subtext("S=35");

                    collapse_bridge(0x0c);
                },
                trap_3_0_north = @install() {
                    debug_subtext("S=36");

                    collapse_bridge(0x06);
                },
                trap_3_0_east = @install() {
                    debug_subtext("S=37");

                    collapse_bridge(0x05);
                },
                trap_3_2_north = @install() {
                    debug_subtext("S=38");

                    collapse_bridge(0x07);
                },
                trap_3_2_east = @install() {
                    debug_subtext("S=39");

                    collapse_bridge(0x09);
                },

                trap_2_0_east = @install() {
                    debug_subtext("S=40");

                    collapse_bridge(0x04);
                },
                trap_1_0_north = @install() {
                    debug_subtext("S=41");

                    collapse_bridge(0x03);
                },
            }

            enum b_trigger {
                sniff__1_water = @install() {
                    debug_subtext("B=0");
                    _loot(0x10, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=1");
                    _loot(0x11, WATER, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=2");
                    _loot(0x12, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=3");
                    _loot(0x13, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=4");
                    _loot(0x14, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=5");
                    _loot(0x15, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=6");
                    _loot(0x16, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=7");
                    _loot(0x17, CLAY, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=8");
                    _loot(0x18, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=9");
                    _loot(0x19, ROOTS, 0d01, 0d00);
                },

                sniff__1_roots = @install() {
                    debug_subtext("B=10");
                    _loot(0x1a, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=11");
                    _loot(0x1b, ROOTS, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=12");
                    _loot(0x1c, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=13");
                    _loot(0x1d, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=14");
                    _loot(0x1e, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=15");
                    _loot(0x1f, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=16");
                    _loot(0x20, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=17");
                    _loot(0x21, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=18");
                    _loot(0x22, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=19");
                    _loot(0x23, OIL, 0d01, 0d00);
                },

                sniff__1_ash = @install() {
                    debug_subtext("B=20");
                    _loot(0x24, ASH, 0d01, 0d00);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=21");
                    _loot(0x25, ASH, 0d01, 0d00);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=22");
                    _loot(0x26, ASH, 0d01, 0d00);
                },
                sniff__1_ash = @install() {
                    debug_subtext("B=23");
                    _loot(0x27, ASH, 0d01, 0d00);
                },
            }

            enum ROOM {
                DIAMOND_EYE_LOOTED = memory(FLAG, SRAM),
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // north
                    add_enemy(SPIDER_YELLOW, 0d51, 0d33);

                    // center
                    add_enemy(SPIDER_YELLOW, 0d47, 0d94);

                    add_enemy(SPIDER_YELLOW, 0d73, 0d86);

                    // south
                    add_enemy(MAGGOT, 0d52, 0d129);

                    add_enemy(MAGGOT, 0d36, 0d126);

                    add_enemy(SPIDER_YELLOW, 0d70, 0d124);
                }

                if!(SOULS_MEMORY.DEAD_DOUBLE_THRAXX) {
                    add_enemy(LANTERN_LIGHT, 0d49, 0d159, INACTIVE);
                    attribute(LAST_ENTITY, ROOT, True);
                    attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                        if(<ACTIVE> != <BOY>) {
                            end();
                        }
                        
                        // fake_b();

                        if!(<BOY>[FLAGS_4] & ATTRIBUTE_FLAGS.ROOT) {
                            // attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

                            SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX = True;
                            collapse_bridge();
                        }
                    }));
                }

                if!(ROOM.DIAMOND_EYE_LOOTED) {
                    add_placeholder(DIAMOND_EYE_2, 0d40, 0d159);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        ROOM.DIAMOND_EYE_LOOTED = True;
                        STATUE_RIDDLE.CARRY_RIGHT_EYE = True;

                        destroy(SCRIPT_OWNER);

                        reward(DIAMOND_EYE);
                    }));
                }

                default_init_room(False, False);
            }
        };

        map bbm_2(BBM_2) {
            enum entrance {
                level_0_east = entrance(0x39, 0x20, WEST),
                level_0_south = entrance(0x1c, 0x5b, NORTH),
                level_0_west = entrance(0x01, 0x20, EAST),

                level_1_east = entrance(0x39, 0x32, WEST),
                level_1_west = entrance(0x01, 0x32, EAST),

                level_2_north = entrance(0x1d, 0x05, SOUTH),
                level_2_east = entrance(0x39, 0x44, WEST),
                level_2_west = entrance(0x01, 0x44, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUG_DUNGEON.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_level_0_west = @install() {
                    debug_subtext("S=0");
                    map_transition(bugmuck, dungeon_west_3, WEST);
                },
                exit_level_1_west = @install() {
                    debug_subtext("S=1");
                    map_transition(bugmuck, dungeon_west_2, WEST);
                },
                exit_level_2_west = @install() {
                    debug_subtext("S=2");
                    map_transition(bugmuck, dungeon_west_1, WEST);
                },
                exit_level_2_east = @install() {
                    debug_subtext("S=3");
                    map_transition(bugmuck, dungeon_east_3, EAST);
                },
                exit_level_1_east = @install() {
                    debug_subtext("S=4");
                    map_transition(bugmuck, dungeon_east_2, EAST);
                },
                exit_level_0_east = @install() {
                    debug_subtext("S=5");
                    map_transition(bugmuck, dungeon_east_1, EAST);
                },
                exit_level_2_north = @install() {
                    debug_subtext("S=6");

                    fog_wall_outside((!SOULS_MEMORY.DEAD_DOUBLE_THRAXX) && SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX, SOUTH);
                    map_transition(thraxx, south, NORTH);
                },
                exit_level_0_south = @install() {
                    debug_subtext("S=7");
                    map_transition(bbm_1, north, SOUTH);
                },
            }

            enum b_trigger {
                sniff__1_water = @install() {
                    debug_subtext("B=0");
                    _loot(0x00, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=1");
                    _loot(0x01, WATER, 0d01, 0d00);
                },
                sniff__1_water = @install() {
                    debug_subtext("B=2");
                    _loot(0x02, WATER, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=3");
                    _loot(0x03, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=4");
                    _loot(0x04, CLAY, 0d01, 0d00);
                },
                sniff__1_clay = @install() {
                    debug_subtext("B=5");
                    _loot(0x05, CLAY, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=6");
                    _loot(0x06, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=7");
                    _loot(0x07, ROOTS, 0d01, 0d00);
                },
                sniff__1_roots = @install() {
                    debug_subtext("B=8");
                    _loot(0x08, ROOTS, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=9");
                    _loot(0x09, OIL, 0d01, 0d00);
                },

                sniff__1_oil = @install() {
                    debug_subtext("B=10");
                    _loot(0x0a, OIL, 0d01, 0d00);
                },
                sniff__1_oil = @install() {
                    debug_subtext("B=11");
                    _loot(0x0b, OIL, 0d01, 0d00);
                },
            }

            fun trigger_enter() {
                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    // north-lvl3
                    add_enemy(SPIDER_YELLOW, 0d13, 0d20);

                    // south-lvl3
                    add_enemy(MAGGOT_RED, 0d14, 0d57);

                    add_enemy(SPIDER_YELLOW, 0d28, 0d68);

                    // center-lvl2
                    add_enemy(SPIDER_YELLOW, 0d22, 0d50);

                    // north-lvl1
                    add_enemy(MAGGOT_RED, 0d27, 0d33);
                }

                default_init_room(False, False);
            }
        };

        map thraxx(THRAXX) {
            enum ROOM {
                DEBUG = False,

                TRIGGER_CAGE = memory(FLAG, TEMP),
            }

            enum entrance {
                north = entrance(0x18, 0x10, SOUTH),
                south = entrance(0x17, 0x3f, NORTH),
                
                spider = entrance(0d22, 0d56, NONE, {
                    spider_drop(<BOY>, 0d1, 0d63);
                    spider_drop(<DOG>, 0d46, 0d63);
                }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BUG_DUNGEON.MUSIC, 0xff)
            }

            group boss_ai() {
                enum BOSS {
                    DEBUG = False,
                    DEBUG_CAGE = False,
                    DEBUG_RNG = False,
                    DEBUG_ULTI = True,

                    // PROGRESS = memory(FLAG, TEMP),

                    ARM_LEFT_X = 0d152,
                    ARM_LEFT_Y = 0d112,

                    ARM_RIGHT_X = 0d232,
                    ARM_RIGHT_Y = 0d104,

                    HEART_ORANGE_ID = memory(WORD, TEMP),
                    HEART_WHITE_ID = memory(WORD, TEMP),

                    ARM_ORANGE_LEFT_ID = memory(WORD, TEMP),
                    ARM_ORANGE_RIGHT_ID = memory(WORD, TEMP),

                    ARM_WHITE_LEFT_ID = memory(WORD, TEMP),
                    ARM_WHITE_RIGHT_ID = memory(WORD, TEMP),

                    KNOCKBACK_DAMAGE = 0d3,

                    CAGE_OPEN = memory(FLAG, TEMP),
                    CAGE_BROKEN = memory(FLAG, TEMP),
                    CAGE_B_DAMAGE = 0d2 + randrange(0d2),
                    CAGE_OPEN_THRESHOLD = 0d10,
                    CAGE_BROKEN_THRESHOLD = 0d100,

                    CAGE_DAMAGE = memory(WORD, TEMP),
                    CAGE_DAMAGE_TOTAL = memory(WORD, TEMP),
                    CAGE_OPEN_TIMER = memory(WORD, TEMP),

                    MAGGOT_COUNTER = memory(WORD, TEMP),

                    PHASES_TILL_ULTI = 0d4,
                }

                fun fog_wall(exit_direction:DIRECTION) {
                    fog_wall_inside((!SOULS_MEMORY.DEAD_DOUBLE_THRAXX) && SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX, exit_direction);
                }

                fun open_thraxx_mouth(open) {
                    if(open) {
                        tile_animate(0x02, 0xff, 0x01);
                    } else {
                        tile_animate(0x02, 0xff, 0x00);
                    }
                }
                fun open_thraxx_rip_cage(value) {
                    tile_animate(0x01, 0xff, value); // 1=closed, 2=half_open, 3=open)
                }
                fun glow_thraxx_eys(value) {
                    tile_animate(0x03, 0xff, 0x00);
                }
                fun roar() {
                    sound(THRAXX_DAMAGE);
                }

                fun open_cage(open) {
                    if(BOSS.DEBUG && BOSS.DEBUG_CAGE) {
                        MEMORY.STRING_PARAMETER_1 = open;
                        subtext("cage = [MEM1]");
                    }
                    BOSS.CAGE_OPEN = open;

                    if(open) {
                        object[0x00] = 0x00; // change rip_entrance (0=open, 1=closed, 2=gone)
                        open_thraxx_rip_cage(0d3);
                    } else {
                        object[0x00] = 0x01; // change rip_entrance (0=open, 1=closed, 2=gone)
                        open_thraxx_rip_cage(0d1);
                    }
                }

                @install()
                fun thraxx_mode(palette:MAP_PALETTE, arm_left, arm_right, other_arm_left, other_arm_right) {
                    MEMORY.MAP_PALETTE = palette;

                    attribute(other_arm_left, INVINCIBLE_TEMP, True);
                    control(other_arm_left, True);
                    // animate(other_arm_left, ONCE_FREEZE, INVISIBLE);
                    attribute(other_arm_left, INVISIBLE, True);
                    attribute(other_arm_right, INVINCIBLE_TEMP, True);
                    control(other_arm_right, True);
                    // animate(other_arm_right, ONCE_FREEZE, INVISIBLE);
                    attribute(other_arm_right, INVISIBLE, True);

                    control(arm_left, False);
                    attribute(arm_left, INVISIBLE, False);
                    attribute(arm_left, INVINCIBLE_TEMP, False);
                    animate(arm_left, ONCE, DEFAULT);
                    control(arm_right, False);
                    attribute(arm_right, INVISIBLE, False);
                    attribute(arm_right, INVINCIBLE_TEMP, False);
                    animate(arm_right, ONCE, DEFAULT);

                    if(False) {
                        if(alive(<SCRIPT_OWNER>)) {
                            knockback(<SCRIPT_OWNER>, <ACTIVE>, BOSS.KNOCKBACK_DAMAGE);
                        } else {
                            boss_defeated();
                        }
                    }
                }

                @install()
                fun show_thraxx(show) {
                    if(show) {
                        object[0x00] = 0x00; // change rip_entrance (0=open, 1=closed, 2=gone)
                        object[0x01] = 0x00; // change body (0=present, 1=cocoon, 2=gone)
                        object[0x02] = 0x00; // change rip_entrance_right (0=present, 1=gone)
                        object[0x03] = 0x00; // change rip_entrance_left (0=present, 1=gone)
                    } else {
                        object[0x00] = 0x02; // change rip_entrance (0=open, 1=closed, 2=gone)
                        object[0x01] = 0x02; // change body (0=present, 1=cocoon, 2=gone)
                        object[0x02] = 0x01; // change rip_entrance_right (0=present, 1=gone)
                        object[0x03] = 0x01; // change rip_entrance_left (0=present, 1=gone)
                    }
                }

                fun boss_defeated() {
                    SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX = False;
                    // yield();

                    destroy(BOSS.HEART_ORANGE_ID);
                    destroy(BOSS.HEART_WHITE_ID);

                    destroy(BOSS.ARM_ORANGE_LEFT_ID);
                    destroy(BOSS.ARM_WHITE_LEFT_ID);

                    destroy(BOSS.ARM_ORANGE_RIGHT_ID);
                    destroy(BOSS.ARM_WHITE_RIGHT_ID);

                    show_thraxx(False);
                    
                    souls_boss_defeated(DEAD_DOUBLE_THRAXX, REWARD_DOUBLE_THRAXX);
                }
                fun fake_boss_defeated() {
                    if(BOSS.DEBUG) {
                        subtext("nice.");
                    }

                    roar();
                }

                @install()
                @async()
                fun double_hit_check() {
                    while(alive(BOSS.HEART_ORANGE_ID)) {
                        if((BOSS.HEART_ORANGE_ID[GENERAL_PURPOSE] > 0d0) && (BOSS.HEART_WHITE_ID[GENERAL_PURPOSE] > 0d0)) {
                            if(BOSS.DEBUG) {
                                subtext("double hit");
                            }

                            MEMORY.MAP_PALETTE = 0x03;
                        }

                        BOSS.HEART_ORANGE_ID[GENERAL_PURPOSE] = 0d00;
                        BOSS.HEART_WHITE_ID[GENERAL_PURPOSE] = 0d00;

                        sleep(0d01);
                    }
                }

                @install()
                @async()
                fun _knockback(heart:CHARACTER, entity:CHARACTER, damage, with_sound) {
                    sleep(0d21);
                    // maggot
                    sleep(0d29);

                    if(alive(heart)) {
                        control(NONE);

                        face(entity, NORTH);
                        animate(entity, FREEZE, KNOCKBACK);
                        attribute(entity, ROOT, True);
                        attribute(entity, UNKNOWN_2_1, True);

                        while(arg[0x14] <= 0d6) {
                            arg[0x14] += 0d1;

                            arg[0x16] = 0d0;
                            while(arg[0x16] < 0d7) {
                                arg[0x16] += 0d1;

                                teleport_relative(entity, 0d0, arg[0x14]);
                                yield();
                            }
                        }

                        animate(entity, ONCE, KNOCKBACK);
                        attribute(entity, ROOT, False);
                        attribute(entity, UNKNOWN_2_1, False);

                        damage(entity, damage, True);
                        // control(BOTH);

                        if(with_sound) {
                            roar();
                        }
                    }

                    control(BOTH);

                    open_thraxx_mouth(False);

                    // open_thraxx_rip_cage(0d1);
                }
                @install()
                fun knockback(heart:CHARACTER, entity:CHARACTER, damage, with_sound) {
                    if(BOSS.DEBUG) {
                        debug_subtext("heart triggered");
                    }

                    open_thraxx_mouth(True);
                    // open_thraxx_rip_cage(0d3);
                    BOSS.CAGE_OPEN_TIMER = 0d75;

                    control(entity, True);

                    heart[GENERAL_PURPOSE] += 0d1;

                    arg[0x10] = heart[HP];
                    arg[0x12] = heart[GENERAL_PURPOSE] * (rand(0x9) + 0d1);

                    damage(heart, arg[0x12], True);

                    _knockback(heart, entity, damage, with_sound);
                }

                fun thraxx_triggered(callback, callback_death, damage_threshold, damage) {
                    arg[0x10] = <SCRIPT_OWNER>[HP];
                    yield();
                    arg[0x12] = <SCRIPT_OWNER>[HP];
                    arg[0x14] = arg[0x10] - arg[0x12];

                    callback();

                    if(alive(<SCRIPT_OWNER>)) {
                        if(damage_threshold) {
                            knockback(<SCRIPT_OWNER>, <ACTIVE>, damage, True);
                        } else {
                            knockback(<SCRIPT_OWNER>, <ACTIVE>, 0d0, True);
                        }
                    } else {
                        callback_death();
                    }

                    yield();
                    arg[0x16] = arg[0x10] - <SCRIPT_OWNER>[HP];

                    if(BOSS.DEBUG) {
                        // debug_memory(BOSS.HEART_ORANGE_ID[GENERAL_PURPOSE], BOSS.HEART_WHITE_ID[GENERAL_PURPOSE]);
                        debug_memory(arg[0x16], arg[0x14]);
                    }
                }

                @install()
                fun thraxx_orange_triggered() {
                    thraxx_triggered({
                        thraxx_mode(THRAXX_ORANGE, BOSS.ARM_ORANGE_LEFT_ID, BOSS.ARM_ORANGE_RIGHT_ID, BOSS.ARM_WHITE_LEFT_ID, BOSS.ARM_WHITE_RIGHT_ID);
                    }, {
                        boss_defeated();
                    }, arg[0x14] >= 0d15, BOSS.KNOCKBACK_DAMAGE);
                }
                @install()
                fun thraxx_white_triggered() {
                    thraxx_triggered({
                        thraxx_mode(THRAXX_WHITE, BOSS.ARM_WHITE_LEFT_ID, BOSS.ARM_WHITE_RIGHT_ID, BOSS.ARM_ORANGE_LEFT_ID, BOSS.ARM_ORANGE_RIGHT_ID);
                    }, {
                        fake_boss_defeated();
                    }, arg[0x14] < 0d40, BOSS.KNOCKBACK_DAMAGE);
                }

                @install()
                @async()
                fun cage_tracker() {
                    open_cage(False);

                    while!(BOSS.CAGE_BROKEN) {
                        if!(SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX) {
                            show_thraxx(False);
                            end();
                        }

                        if(BOSS.CAGE_OPEN_TIMER > 0d0) {
                            BOSS.CAGE_OPEN_TIMER--;

                            if!(BOSS.CAGE_OPEN) {
                                open_cage(True);
                            }
                        } else {
                            if(BOSS.CAGE_OPEN) {
                                open_cage(False);
                            }
                        }
                        
                        yield();
                    }

                    open_cage(True);
                }

                fun cage_triggered() {
                    arg[0x10] = BOSS.CAGE_B_DAMAGE;
                    BOSS.CAGE_DAMAGE += arg[0x10];
                    BOSS.CAGE_DAMAGE_TOTAL += arg[0x10];

                    if(MEMORY.MAP_PALETTE == 0d0) {
                        damage(BOSS.HEART_ORANGE_ID, arg[0x10], True);
                    } else {
                        damage(BOSS.HEART_WHITE_ID, arg[0x10], True);
                    }

                    if(BOSS.CAGE_DAMAGE_TOTAL > BOSS.CAGE_BROKEN_THRESHOLD) {
                        BOSS.CAGE_BROKEN = True;
                    } else if(BOSS.CAGE_DAMAGE > BOSS.CAGE_OPEN_THRESHOLD) {
                        BOSS.CAGE_DAMAGE = 0d0;

                        BOSS.CAGE_OPEN_TIMER = 0d200;
                    }
                }

                fun throw_rock(entity) {
                    animate(entity, ONCE, DEFAULT);
                    animate(entity, ONCE, SLASH_1_3);
                    sleep(0d25);
                }

                @install()
                @async()
                fun boss_tracker() {
                    sleep(0d300);

                    while(_alive(BOSS.HEART_ORANGE_ID) || _alive(BOSS.HEART_WHITE_ID)) {
                        arg[0x10]++;

                        if(arg[0x10] < BOSS.PHASES_TILL_ULTI) {
                            arg[0x12] = randrange(0d3);
                            if(BOSS.DEBUG && BOSS.DEBUG_RNG) {
                                debug_memory(arg[0x12], MEMORY.MAP_PALETTE);
                            }

                            if(arg[0x12] == 0d0) {
                                arg[0x14] = 0d20;

                                while((arg[0x14] > 0d0) && (!(BOSS.ARM_ORANGE_LEFT_ID[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK)) && (!(BOSS.ARM_WHITE_LEFT_ID[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK))) {
                                    arg[0x14]--;
                                    
                                    if(MEMORY.MAP_PALETTE != MAP_PALETTE.THRAXX_WHITE) {
                                        if(alive(BOSS.ARM_ORANGE_LEFT_ID)) {
                                            throw_rock(BOSS.ARM_ORANGE_LEFT_ID);

                                            shoot_entity_offset_relative(BOSS.ARM_ORANGE_LEFT_ID, ONION, -0d50, 0d10, randrange(0d100) - 0d20, 0d100 + randrange(0d100), 0d20 + randrange(0d20), 0d10);
                                        }
                                    } else {
                                        if(alive(BOSS.ARM_WHITE_LEFT_ID)) {
                                            throw_rock(BOSS.ARM_WHITE_LEFT_ID);

                                            shoot_entity_offset_relative(BOSS.ARM_WHITE_LEFT_ID, ROCK, -0d50, 0d10, randrange(0d100) - 0d20, 0d100 + randrange(0d100), 0d20 + randrange(0d20), 0d10);
                                        }
                                    }
                                }
                            } else if(arg[0x12] == 0d1) {
                                arg[0x14] = 0d20;

                                while((arg[0x14] > 0d0) && (!(BOSS.ARM_ORANGE_RIGHT_ID[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK)) && (!(BOSS.ARM_WHITE_RIGHT_ID[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK))) {
                                    arg[0x14]--;
                                    
                                    if(MEMORY.MAP_PALETTE != MAP_PALETTE.THRAXX_WHITE) {
                                        if(alive(BOSS.ARM_ORANGE_LEFT_ID)) {
                                            throw_rock(BOSS.ARM_ORANGE_RIGHT_ID);

                                            shoot_entity_offset_relative(BOSS.ARM_ORANGE_RIGHT_ID, ONION, 0d50, 0d10, randrange(0d100) - 0d120, 0d100 + randrange(0d100), 0d20 + randrange(0d20), 0d10);
                                        }
                                    } else {
                                        if(alive(BOSS.ARM_WHITE_LEFT_ID)) {
                                            throw_rock(BOSS.ARM_WHITE_RIGHT_ID);

                                            shoot_entity_offset_relative(BOSS.ARM_WHITE_RIGHT_ID, ROCK, 0d50, 0d10, randrange(0d100) - 0d120, 0d100 + randrange(0d100), 0d20 + randrange(0d20), 0d10);
                                        }
                                    }
                                }
                            }
                        } else {
                            arg[0x10] = 0d0;

                            sfx_effect(SHAKING, True);

                            sleep(0d300);

                            if(MEMORY.MAP_PALETTE != MAP_PALETTE.THRAXX_WHITE) {
                                if(BOSS.MAGGOT_COUNTER < 0d4) {
                                    for(arg[0x16] in 0d0..0d3) {
                                        if(BOSS.MAGGOT_COUNTER < 0d4) {
                                            add_enemy(MAGGOT, 0d14 + randrange(0d18), 0d31 + randrange(0d15));
                                            <LAST_ENTITY>[Z] = 0d2500;

                                            BOSS.MAGGOT_COUNTER++;
                                            
                                            attach_script(LAST_ENTITY, DEATH, reference(@install() {
                                                BOSS.MAGGOT_COUNTER--;

                                                sleep(0d20);
                                                destroy(SCRIPT_OWNER);
                                            }));

                                            sleep(0d30 + randrange(0d30));
                                        }
                                    }

                                    sleep(0d300);
                                }
                            } else {
                                cast(BOSS.HEART_WHITE_ID, BOTH, FLASH, 0d10);

                                for(arg[0x16] in 0d0..0d4) {
                                    if(False) {
                                        arg[0x18] = randrange(0d3);

                                        if(arg[0x18] == 0d0) {
                                            beam_wall(SOUTH, <BOY>, 0d30, 0d70, 0d150, 0d450, 0d20);
                                        } else if(arg[0x18] == 0d1) {
                                            beam_wall(SOUTH, <BOY>, 0d110, 0d70, 0d250, 0d450, 0d20);
                                        } else {
                                            beam_wall(SOUTH, <BOY>, 0d230, 0d70, 0d310, 0d450, 0d20);
                                        }
                                    } else {
                                        beam_wall(SOUTH, <BOY>, 0d30, 0d70, 0d350, 0d450, 0d15);
                                    }

                                    sleep(0d180);
                                }
                            }

                            sfx_effect(SHAKING, False);
                        }

                        sleep(0d300);
                    }
                }
                
                fun add_boss() {
                    if(ROOM.DEBUG) {
                        debug_subtext("add boss");
                    }

                    object[0x04] = 0x01; // remove bridge

                    show_thraxx(True);
                    // show_cocoon();

                    // add_enemy(ENEMY.THRAXX2_HEART, 0d26, 0d20);
                    add_enemy(ENEMY.THRAXX_HEART, 0d26, 0d20);
                    <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(thraxx_white_triggered));
                    BOSS.HEART_WHITE_ID = <LAST_ENTITY>;
                    add_enemy(ENEMY.THRAXX_HEART, 0d22, 0d20);
                    <LAST_ENTITY>[GENERAL_PURPOSE] = 0d0;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(thraxx_orange_triggered));
                    BOSS.HEART_ORANGE_ID = <LAST_ENTITY>;

                    add_enemy(ENEMY.THRAXX_LEFT_ARM, 0d19, 0d14);
                    BOSS.ARM_ORANGE_LEFT_ID = <LAST_ENTITY>;
                    add_enemy(ENEMY.THRAXX_RIGHT_ARM, 0d29, 0d13);
                    BOSS.ARM_ORANGE_RIGHT_ID = <LAST_ENTITY>;

                    add_enemy(ENEMY.THRAXX2_LEFT_ARM, 0d19, 0d14);
                    BOSS.ARM_WHITE_LEFT_ID = <LAST_ENTITY>;
                    add_enemy(ENEMY.THRAXX2_RIGHT_ARM, 0d29, 0d13);
                    BOSS.ARM_WHITE_RIGHT_ID = <LAST_ENTITY>;

                    thraxx_mode(THRAXX_ORANGE, BOSS.ARM_ORANGE_LEFT_ID, BOSS.ARM_ORANGE_RIGHT_ID, BOSS.ARM_WHITE_LEFT_ID, BOSS.ARM_WHITE_RIGHT_ID);
                    // thraxx_mode(THRAXX_WHITE, BOSS.ARM_WHITE_LEFT_ID, BOSS.ARM_WHITE_RIGHT_ID, BOSS.ARM_ORANGE_LEFT_ID, BOSS.ARM_ORANGE_RIGHT_ID);

                    cage_tracker();

                    // double_hit_check();

                    // sleep(0d30);
                    // debug_memory(BOSS.HEART_ORANGE_ID[GENERAL_PURPOSE], BOSS.HEART_WHITE_ID[GENERAL_PURPOSE]);
                    
                    boss_tracker();
                }
            };

            enum stepon_trigger {
                exit_north = @install() {
                    debug_subtext("S=0");

                    if(SOULS_MEMORY.DEAD_DOUBLE_THRAXX) {
                        fog_wall(SOUTH);
                        map_transition(bugmuck, dungeon_north, NORTH);
                    } else {
                        error_message(DOOR_WRONG_SIDE, SOUTH);
                    }
                },
                trigger_boss = @install() {
                    debug_subtext("S=1");

                    if!(SOULS_MEMORY.DEAD_DOUBLE_THRAXX) {
                        if!(ROOM.TRIGGER_CAGE) {
                            ROOM.TRIGGER_CAGE = True;

                            show_thraxx(True);
                            open_thraxx_mouth(True);
                            open_thraxx_rip_cage(0d3);
                            glow_thraxx_eys(0d0);
                        }
                    }
                },
                exit_south = @install() {
                    debug_subtext("S=2");

                    fog_wall(NORTH);
                    map_transition(bbm_2, level_2_north, SOUTH);
                }
            }

            enum b_trigger {
                cocoon = @install() {
                    debug_subtext("B=0");
                },
                rip_cage = @install() {
                    debug_subtext("B=1");

                    cage_triggered();
                }
            }

            fun show_cocoon(show) {
                if(show) {
                    object[0x01] = 0x01;
                } else {
                    object[0x01] = 0x00;
                }
            }

            fun trigger_enter() {
                if((!SOULS_MEMORY.DEAD_DOUBLE_THRAXX) && (SOULS_MEMORY.PROGRESS_DOUBLE_THRAXX)) {
                    push_music(BOSS_DRUMS);

                    add_boss();
                } else {
                    show_thraxx(False);
                }

                default_init_room(False, False);
            }
        };
    };

    area desert() {
        enum AREA_DESERT {
            MUSIC = MUSIC.WING_AMBIENT_VOID,
        }

        map desert(DESERT) {
            enum ROOM {
                DEBUG = False,
                WITH_WRAP = True,
                
                X_MAX = 0d7,
                Y_MAX = 0d6,

                DAMAGE_TIME = 0d60, // 0d720,
                DAMAGE_TICK = 0d5,
                DAMAGE_TICK_REDUCED = 0d3,

                ID_SHIP_SOUTH = memory(WORD, TEMP),
                ID_SHIP_NORTH = memory(WORD, TEMP),
                ID_ALCHEMIST = memory(WORD, TEMP),

                HAS_OASIS = memory(FLAG, TEMP),
                HAS_SHIP_NORTH = memory(FLAG, TEMP),
                HAS_SHIP_SOUTH = memory(FLAG, TEMP),
                HAS_ALCHEMIST = memory(FLAG, TEMP),

                CODE_BOT_HACKED = memory(FLAG, TEMP),
                CODE_BOT_DIG_COUNT = 0d100,
                CODE_BOT_X = 0d21,
                CODE_BOT_Y = 0d150,
            }

            enum soundtrack {
                default = soundtrack(AREA_DESERT.MUSIC, 0xff)
            }

            fun enter_sandpit() {
                desert_screen(0d4, ROOM.Y_MAX);
                // enter_sandpit();

                <BOY>[GENERAL_PURPOSE] = 0d2;
                <DOG>[GENERAL_PURPOSE] = 0d2;
                object[0x03] = 0x7e;

                _teleport(BOY, <BOY>[X], <BOY>[Y]);
                _teleport(DOG, <DOG>[X], <DOG>[Y]);
            }

            enum entrance {
                test = entrance(0d60, 0d146, NONE, { desert_screen(0d4, 0d0); }),

                north = entrance(0x3b, 0x19, WEST, { desert_screen(0d4, ROOM.Y_MAX); }),
                south = entrance(0x49, 0xc7, NORTH, { desert_screen(0d4, 0d0); }),

                swirl_secret = entrance(0d28, 0d47, NONE, { enter_sandpit(); }),

                code_bot = entrance(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, NONE, {
                    ROOM.CODE_BOT_HACKED = True;

                    hacking_wakeup(0d0, 0d24, 0d40, 0d40);
                }),
            }

            fun show_oasis(show) {
                if(show) {
                    object[0x00] = 0x01; // show oasis
                } else {
                    object[0x00] = 0x00; // show oasis
                }
            }

            fun add_skeleton_ship(id, object_id, x, y) {
                add_placeholder(SKELETON_SHIP_2, x, y, ONCE_FREEZE);
                id = <LAST_ENTITY>;
                animate(LAST_ENTITY, FREEZE, ANIMATION_PLACEHOLDER.SKELETON_SHIP_2);

                if(object_id == 0d1) {
                    object[0x01] = 0x01; // add ship_south_hitbox
                } else if(object_id == 0d2) {
                    object[0x02] = 0x00; // remove ship_north_hitbox
                }
            }
            fun remove_skeleton_ship(id, object_id) {
                destroy(id);

                if(object_id == 0d1) {
                    object[0x01] = 0x00; // add ship_south_hitbox
                } else if(object_id == 0d2) {
                    object[0x02] = 0x01; // remove ship_north_hitbox
                }
            }

            fun add_alchemist(x, y) {
                add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                ROOM.ID_ALCHEMIST = <LAST_ENTITY>;
                face(LAST_ENTITY, SOUTH);
            }
            fun remove_alchemist(id) {
                destroy(id);
            }

            @install()
            fun update_desert() {
                arg[0x00] = MEMORY.DESERT_X;
                arg[0x02] = MEMORY.DESERT_Y;

                if(ROOM.DEBUG) {
                    debug_memory(arg[0x00], arg[0x02]);
                }

                ROOM.HAS_OASIS = False;
                ROOM.HAS_SHIP_NORTH = False;
                ROOM.HAS_SHIP_SOUTH = False;
                ROOM.HAS_ALCHEMIST = False;

                if(arg[0x02] == 0d0) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                        ROOM.HAS_SHIP_SOUTH = True;
                    } else if(arg[0x00] == 0d7) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d1) {
                    if(arg[0x00] == 0d2) {
                        ROOM.HAS_OASIS = True;
                    } else if(arg[0x00] == 0d5) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d2) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d3) {
                    if(arg[0x00] == 0d3) {
                        ROOM.HAS_OASIS = True;
                    } else if(arg[0x00] == 0d6) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d4) {
                    if(arg[0x00] == 0d5) {
                        ROOM.HAS_OASIS = True;
                        ROOM.HAS_ALCHEMIST = True;
                    }
                } else if(arg[0x02] == 0d5) {
                    if(arg[0x00] == 0d3) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d6) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d7) {
                    if(arg[0x00] == 0d1) {
                        ROOM.HAS_OASIS = True;

                    } else if(arg[0x00] == 0d6) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d8) {
                    nop();
                } else if(arg[0x02] == 0d9) {
                    if(arg[0x00] == 0d2) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d10) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d11) {
                    if(arg[0x00] == 0d6) {
                        ROOM.HAS_OASIS = True;
                        ROOM.HAS_ALCHEMIST = True;
                    }
                } else if(arg[0x02] == 0d12) {
                    if(arg[0x00] == 0d3) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d13) {
                    nop();
                } else if(arg[0x02] == 0d14) {
                    if(arg[0x00] == 0d2) {
                        ROOM.HAS_OASIS = True;
                    } else if(arg[0x00] == 0d5) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d15) {
                    nop();
                } else if(arg[0x02] == 0d16) {
                    nop();
                } else if(arg[0x02] == 0d17) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_SHIP_NORTH = True;
                    }
                }

                if(ROOM.HAS_OASIS) {
                    show_oasis(True);
                } else {
                    show_oasis(False);
                }

                if(ROOM.HAS_SHIP_SOUTH) {
                    add_skeleton_ship(ROOM.ID_SHIP_SOUTH, 0d1, 0x45, 0x94);
                } else {
                    remove_skeleton_ship(ROOM.ID_SHIP_SOUTH, 0d1);
                }

                if(ROOM.HAS_SHIP_NORTH) {
                    add_skeleton_ship(ROOM.ID_SHIP_NORTH, 0d2, 0x45, 0x35);
                } else {
                    remove_skeleton_ship(ROOM.ID_SHIP_NORTH, 0d2);
                }

                if(ROOM.HAS_ALCHEMIST) {
                    add_alchemist(0x51, 0x9f);
                } else {
                    remove_alchemist(ROOM.ID_ALCHEMIST);
                }
            }

            @install()
            fun scroll_desert_north() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_Y < ROOM.Y_MAX) {
                        MEMORY.DESERT_Y++;

                        teleport_screen(0d0, 0d2);
                        update_desert();
                    }
                }
            }
            @install()
            fun scroll_desert_east() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_X < ROOM.X_MAX) {
                        MEMORY.DESERT_X++;
                    } else {
                        MEMORY.DESERT_X = 0d0;
                    }

                    teleport_screen(-0d2, 0d0);
                    update_desert();
                }
            }
            @install()
            fun scroll_desert_south() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_Y > 0d0) {
                        MEMORY.DESERT_Y--;

                        teleport_screen(0d0, -0d2);
                        update_desert();
                    }
                }
            }
            @install()
            fun scroll_desert_west() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_X > 0d0) {
                        MEMORY.DESERT_X--;
                    } else {
                        MEMORY.DESERT_X = ROOM.X_MAX;
                    }

                    teleport_screen(0d2, 0d0);
                    update_desert();
                }
            }

            @install()
            fun exit_south() {
                debug_subtext("S=8/9");

                map_transition(bugmuck, north_1, SOUTH);
            }

            @install()
            @async()
            fun fake_exit_scanner(entity) {
                conditional_range_checker(entity, <ACTIVE>, 0x20, 0x20, arg[0x02][Z_LEVEL] == 0x30, {
                    vanilla_desert_sandpit_out(0d21, 0d43);
                });
            }

            enum stepon_trigger {
                sand_pit = @install() {
                    debug_subtext("S=0");

                    vanilla_desert_sandpit({
                        if(arg[0x10] == 0d120) {
                            vanilla_desert_sandpit_in(0d21 + 0d1, 0d47);
                        }
                    });
                },
                wrap_north_4 = scroll_desert_north(),
                wrap_north_3 = scroll_desert_north(),
                wrap_north_2 = scroll_desert_north(),
                wrap_north_1 = scroll_desert_north(),
                ship_north = @install() {
                    debug_subtext("S=5");
                },
                ship_south = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_south_1 = exit_south(),
                exit_south_2 = exit_south(),

                wrap_west_1 = scroll_desert_west(),
                wrap_east_2 = scroll_desert_east(),
                wrap_east_1 = scroll_desert_east(),
                wrap_west_2 = scroll_desert_west(),
                wrap_south_2 = scroll_desert_south(),
                wrap_south_1 = scroll_desert_south(),
                oasis = @install() {
                    debug_subtext("S=16");

                    if(ROOM.HAS_OASIS) {
                        full_heal(BOY, False);
                        full_heal(DOG, False);
                    }
                },
                exit_nobilia = @install() {
                    debug_subtext("S=17");

                    if(MEMORY.DESERT_Y != ROOM.Y_MAX) {
                        teleport_screen(0d0, 0d2);
                    }

                    map_transition(desert_temple_main, west_2, EAST);
                },
                swirl_secret = @install() {
                    debug_subtext("S=18");

                    map_transition(desert_cave, south, NONE);
                },
            }

            fun is_in_oasis(char:CHARACTER, callback) {
                //if((<BOY>[X] > 0d536) && (<BOY>[X] < (0d752)) && (<BOY>[Y] > 0d1216) && (<BOY>[Y] < 0d1392)) {
                if((<BOY>[X] > 0d536) && (<BOY>[X] < (0d752)) && (<BOY>[Y] > 0d1216) && (<BOY>[Y] < 0d1408)) {
                        nop();
                } else {
                    callback();
                }
            }
            fun desert_damage() {
                while(True) {
                    sleep(ROOM.DAMAGE_TIME);

                    if!(CUSTOM_MEMORY.CURRENT_ARMOR_CHEST == ARMOR_STATS.CHEST_2_3) {
                        arg[0x10] = ROOM.DAMAGE_TICK;
                    } else {
                        arg[0x10] = ROOM.DAMAGE_TICK_REDUCED;
                    }

                    is_in_oasis(BOY, {
                        damage(BOY, arg[0x10], True, True);
                    });
                    is_in_oasis(DOG, {
                        damage(DOG, arg[0x10], True, True);
                    });
                }
            }

            fun trigger_enter() {
                // object[0x00] = 0x01; // show oasis
                // object[0x01] = 0x01; // add ship_south_hitbox
                // object[0x02] = 0x01; // remove ship_north_hitbox

                init_map(0x02, 0x00, 0xa6, 0xd8);

                default_init_room(False, False);

                movement_amplification(<BOY>, 0xffff, 0d1, True);
                movement_amplification(<DOG>, 0xffff, 0d1, True);
                
                update_desert();

                archaeology_dig_code_bot(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, ARCHAEOLOGY_DIG.CODE_5, ROOM.CODE_BOT_DIG_COUNT, ROOM.CODE_BOT_HACKED);

                add_enemy(PLACEHOLDER, 0d21 - 0d4, 0d47);
                fake_exit_scanner(<LAST_ENTITY>);

                desert_damage();

                <BOY>[GENERAL_PURPOSE] = 0d0;
                <DOG>[GENERAL_PURPOSE] = 0d0;
            }
        };

        map desert_cave(PYRAMID_CAVE) {
            enum entrance {
                south = entrance(0x15, 0x23, NORTH),

                teleporter = entrance(0d23, 0d18, NONE, { teleporter_in(SOUTH); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_DESERT.MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_south = @install() {
                    map_transition(desert, swirl_secret, SOUTH);
                },
                exit_teleporter = @install() {
                    debug_subtext("S=1");

                    teleporter_out(0d23, 0d17);
                    map_transition(pyramid_cave, teleporter, NONE);
                },
            }

            fun trigger_enter() {
                default_init_room(False, False);
            }
        };

        area desert_temple() {
            enum AREA_DESERT_TEMPLE {
                MUSIC = MUSIC.HALLS_3,
            }
            
            map desert_temple_main(HALLS_NE) {
                enum entrance {
                    west_1 = entrance(0x0d, 0x9f, EAST),

                    west_2 = entrance(0d4, 0d46, EAST),

                    bonfire = entrance(0d23, 0d46, NONE, { bonfire_wakeup(-0d24, -0d8, -0d24, 0d16); }),
                }

                enum soundtrack {
                    default = soundtrack(AREA_DESERT_TEMPLE.MUSIC, 0xff)
                }

                enum ROOM {
                    DEBUG = True,
                    DEBUG_OCCULTIST = True,

                    SECRET_PASSAGE_1_STONE_TOP = memory(WORD, TEMP),
                    SECRET_PASSAGE_1_STONE_BOTTOM = memory(WORD, TEMP),

                    SECRET_PASSAGE_1_OPENED = memory(FLAG, SRAM),
                    SECRET_PASSAGE_2_OPENED = memory(FLAG, SRAM),

                    SWITCH_1_ACTIVE = memory(FLAG, TEMP),
                    SWITCH_2_ACTIVE = memory(FLAG, SRAM),
                    
                    BRIDGE_ACTIVE = memory(FLAG, SRAM),

                    BRIDGE_REVEALED = memory(FLAG, SRAM),

                    OCCULTIST_COUNT = memory(WORD, TEMP),
                    OCCULTIST_HP = 0d100,
                    OCCULTIST_RANGE = 0x60,
                }

                fun times_gate_switch(flag, switch_id, gate_id, time) {
                    object_animator(SWITCH_GROUND_HALLS, False, switch_id, True, False);
                    object_animator(GATE_HALLS, False, gate_id, True, False);
                    flag = True;

                    if(time is Word) {
                        while(arg[0x10] < time) {
                            arg[0x10]++;

                            yield();
                        }

                        object_animator(SWITCH_GROUND_HALLS, False, switch_id, False, False);
                        object_animator(GATE_HALLS, False, gate_id, False, False);
                        flag = False;
                    }
                }
                fun spear_switch_triggered() {
                    ROOM.BRIDGE_ACTIVE = True;

                    object_animator(SWITCH_SPEAR_HALLS, False, 0x00, True, False);
                    object_animator(BRIDGE_HALLS, False, 0x01, True, False);
                }

                @install()
                fun pit_triggered() {
                    // debug_subtext("pit triggered");

                    guard_z();
                    
                    generic_fall(0d150, 0d720);

                    dust_unreachable(0d34, 0d71);
                    damage(BOTH, 0d999, True);
                    sleep(0d30);
                    damage(BOTH, SYSTEM.HP_MAX, False);
                }
                @install()
                fun pit2_triggered() {
                    // debug_subtext("pit2 triggered");

                    guard_z();
                    
                    generic_fall(0d150, 0d720);

                    dust_unreachable(0d122, 0d73);
                    damage(BOTH, 0d999, True);
                    sleep(0d30);
                    damage(BOTH, SYSTEM.HP_MAX, False);
                }

                enum stepon_trigger {
                    spear_check = @install() {
                        debug_subtext("S=0");

                        if!(ROOM.BRIDGE_ACTIVE) {
                            guard_spear_2(SOUTH);

                            spear_switch_triggered();
                        }
                    },
                    pit_left_3 = pit_triggered(),
                    pit_right_1 = pit2_triggered(),
                    pit_right_2 = pit2_triggered(),
                    pit_left_1 = pit_triggered(),
                    pit_left_2 = pit_triggered(),
                    exit_west = @install() {
                        debug_subtext("S=6");

                        map_transition(desert_temple_stairs, door_upstairs, WEST);
                    },
                    retreat_bridge = @install() {
                        debug_subtext("S=7");
                    },
                    switch_ground_1 = @install() {
                        debug_subtext("S=8");

                        times_gate_switch(ROOM.SWITCH_1_ACTIVE, 0x05, 0x07, 0d0012 * 0d60);
                    },
                    switch_ground_2 = @install() {
                        debug_subtext("S=9");

                        times_gate_switch(ROOM.SWITCH_2_ACTIVE, 0x04, 0x06);
                    },

                    approach_bridge = @install() {
                        debug_subtext("S=10");
                    },
                    secret_passage_entrance_2 = @install() {
                        debug_subtext("S=11");
                    },
                    secret_passage_entrance_1 = @install() {
                        debug_subtext("S=12");

                        if!(ROOM.SECRET_PASSAGE_1_OPENED) {
                            subtext("A trap has been triggered");

                            face(ACTIVE, WEST);
                            damage(ACTIVE, 0d5, True);
                        }
                    },
                    alchemist_top_2 = @install() {
                        debug_subtext("S=13");
                    },
                    alchemist_top_1 = @install() {
                        debug_subtext("S=14");
                    },
                    alchemist_bottom = @install() {
                        debug_subtext("S=15");
                    },
                    secret_passage_top = @install() {
                        debug_subtext("S=16");
                    },
                    secret_passage_balcony = @install() {
                        debug_subtext("S=17");
                    },
                }

                @install()
                @async()
                fun entity_general_purpose_check(entity) {
                    while(entity[GENERAL_PURPOSE] == 0x00) {
                        yield();
                    }

                    map_transition(gourd_trap_poodle, north, NONE);
                }

                enum b_trigger {
                    gourd_north__4_wax = @install() {
                        debug_subtext("B=0");
                        _loot_chest(0x0d, LIMESTONE_TABLET, 0d01);
                    },
                    gourd_center__6_ash = @install() {
                        debug_subtext("B=1");
                        
                        <ACTIVE>[GENERAL_PURPOSE] = 0x00;
                        gourd_trap(0x0c, <ACTIVE>, 0d48, 0d62);
                        entity_general_purpose_check(<ACTIVE>);
                        // _loot_chest(0x0c, ASH, 0d06);
                    },
                    gourd_alchemist_2__5_wax = @install() {
                        debug_subtext("B=2");
                        _loot_chest(0x0b, LIMESTONE_TABLET, 0d01);
                    },
                    gourd_alchemist_1__4_brimstone = @install() {
                        debug_subtext("B=3");
                        _loot_chest(0x0a, LIMESTONE_TABLET, 0d01);
                    },
                    bridge_switch = @install() {
                        debug_subtext("B=4");

                        if!(ROOM.BRIDGE_ACTIVE) {
                            fake_b();

                            spear_switch_triggered();
                        }
                    },
                }

                @install()
                @async()
                fun fake_exit_scanner(entity) {
                    range_checker(entity, <ACTIVE>, 0x20, 0x20, {
                        map_transition(desert, north, WEST);
                    });
                }
                @install()
                @async()
                fun revealer_approached(entity) {
                    range_checker(entity, <ACTIVE>, 0d45, 0d45, { pit2_triggered(); });
                }

                fun vanishing_stone_triggered(flag) {
                    flag = True;
                    destroy(SCRIPT_OWNER);
                    sound(WEIRD_SOUND);
                }
                fun add_vanishing_rock(x, y, stone_trigger) {
                    add_enemy(STONE_ROUND, x, y, INACTIVE_INVISIBLE);
                    // animate(LAST_ENTITY, LOOP, INVISIBLE);
                    attach_script(LAST_ENTITY, B, stone_trigger);
                }

                @install()
                @async()
                fun occultist_scanner(entity) {
                    range_checker(entity, <ACTIVE>, ROOM.OCCULTIST_RANGE, ROOM.OCCULTIST_RANGE, {
                        if(False) {
                            subtext("!");
                        }

                        if(randrange(0d2)) {
                            subtext("Who dares disturb our silence?");
                        } else {
                            subtext("Leave us. Or stay…");
                        }

                        control(SCRIPT_OWNER, True);
                        face_target(SCRIPT_OWNER, ACTIVE);
                        cast(SCRIPT_OWNER, ACTIVE, FLASH, 0d10);
                        sleep(0d60);
                        control(SCRIPT_OWNER, False);

                        sleep(0d360);
                    }, 0d15 + randrange(0d15));
                }

                fun add_occultist(x, y) {
                    add_enemy(VILLAGER_2_3, x, y);
                    <LAST_ENTITY>[HP] = ROOM.OCCULTIST_HP;
                    attribute(LAST_ENTITY, INVINCIBLE, False);

                    occultist_scanner(<LAST_ENTITY>);

                    ROOM.OCCULTIST_COUNT++;

                    attach_script(LAST_ENTITY, DEATH, reference(@install() {
                        ROOM.OCCULTIST_COUNT--;

                        if!(ROOM.OCCULTIST_COUNT) {
                            ROOM.SECRET_PASSAGE_1_OPENED = True;
                            subtext("Somewhere a door has opened.");
                        }

                        if(ROOM.DEBUG && ROOM.DEBUG_OCCULTIST) {
                            debug_memory(ROOM.OCCULTIST_COUNT, ROOM.SECRET_PASSAGE_1_OPENED);
                        }

                        wait(SCRIPT_OWNER);
                        destroy(SCRIPT_OWNER);
                    }));
                }

                fun trigger_enter() {
                    // object[0x00] = 0x01; // activate bridge_switch
                    // object[0x01] = 0x7e; // activate bridge
                    // 2-3 ?
                    // object[0x04] = 0x01; // activate switch_ground_2
                    // object[0x05] = 0x01; // activate switch_ground_1
                    // object[0x06] = 0x01; // open gate_1
                    // object[0x07] = 0x01; // open gate_2
                    // object[0x08] = 0x01; // show bridge_1
                    // object[0x09] = 0x01; // show bridge_2
                    // object[0x0a] = 0x01; // loot gourd_alchemist_1
                    // object[0x0b] = 0x01; // loot gourd_alchemist_2
                    // object[0x0c] = 0x01; // loot gourd_center
                    // object[0x0d] = 0x01; // loot gourd_north

                    if(SOULS_MEMORY.CLEARED_TRAP_POODLE) {
                        object[0x0c] = 0x01; // open gourd_center
                    }

                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // gourd
                        add_occultist(0d52, 0d69);

                        // east bridge - north
                        add_enemy(MONK, 0d122, 0d65);

                        // east bridge - south
                        add_enemy(MONK, 0d110, 0d94);

                        add_enemy(MONK, 0d124, 0d131);

                        // big room south
                        add_occultist(0d64, 0d170);

                        // big room - north
                        add_occultist(0d71, 0d99);

                        // big room - south
                        add_occultist(0d71, 0d149);

                        // big room - center
                        add_occultist(0d56, 0d139);
                    }

                    if(ROOM.BRIDGE_REVEALED) {
                        object_animator(REVEALER, False, 0x08, 0d2, True);
                    } else {
                        add_enemy(REVEALER_TARGET_ENTITY, 0d122, 0d82);

                        special_script(REVEALER, reference(@install() {
                            object_animator(REVEALER, False, 0x08, 0d2, False);

                            destroy(SCRIPT_OWNER);

                            ROOM.BRIDGE_REVEALED = True;
                        }));

                        revealer_approached(<LAST_ENTITY>);
                    }

                    if(True) {
                        restore_object_animator(SWITCH_SPEAR_HALLS, ROOM.BRIDGE_ACTIVE, 0x00);
                        restore_object_animator(BRIDGE_HALLS, ROOM.BRIDGE_ACTIVE, 0x01);

                        restore_object_animator(SWITCH_GROUND_HALLS, ROOM.SWITCH_2_ACTIVE, 0x04);
                        restore_object_animator(GATE_HALLS, ROOM.SWITCH_2_ACTIVE, 0x06);
                    }

                    bonfire(0d23, 0d46, SOULS_MEMORY.BONFIRE_DESERT);

                    add_enemy(PLACEHOLDER, 0d4, 0d46);
                    fake_exit_scanner(<LAST_ENTITY>);

                    default_init_room(False, False);

                    if(False) {
                        if!(ROOM.SECRET_PASSAGE_1_OPENED) {
                            add_vanishing_rock(0d42, 0d145, reference(@install() {
                                vanishing_stone_triggered(ROOM.SECRET_PASSAGE_1_OPENED);
                                destroy(ROOM.SECRET_PASSAGE_1_STONE_BOTTOM);
                            }));
                            ROOM.SECRET_PASSAGE_1_STONE_TOP = <LAST_ENTITY>;
                            add_vanishing_rock(0d42, 0d146, reference(@install() {
                                vanishing_stone_triggered(ROOM.SECRET_PASSAGE_1_OPENED);
                                destroy(ROOM.SECRET_PASSAGE_1_STONE_TOP);
                            }));
                            ROOM.SECRET_PASSAGE_1_STONE_BOTTOM = <LAST_ENTITY>;
                        }
                    }
                    if!(ROOM.SECRET_PASSAGE_2_OPENED) {
                        add_vanishing_rock(0d140, 0d163, reference(@install() {
                            vanishing_stone_triggered(ROOM.SECRET_PASSAGE_2_OPENED);
                        }));
                    }

                    add_placeholder(ANIMATION_ENEMY.KING_ROCKING, 0d182, 0d156);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        conversation({
                            conversation_question("[SLOW]Can you swim?[CHOICE]yes…[CHOICE]no…");

                            if(MEMORY.QUESTION_ANSWER == 0d0) {
                                teleporter_animation_out(<ACTIVE>);
                                teleporter_animation_out(<INACTIVE>);

                                map_transition(pyramid, water, NONE);
                            } else {
                                nop();
                            }
                        });
                        
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.KING_ROCKING);
                    }));

                    if(True) {
                        while(True) {
                            if!(<BOY>[CURRENT_GROUND] & 0xff) {
                                damage(BOY, 0d999, True);
                            }
                            if!(<DOG>[CURRENT_GROUND] & 0xff) {
                                damage(DOG, 0d999, True);
                            }

                            sleep(0d5);
                        }
                    }
                }
            };

            map desert_temple_underground(MEGATAUR) {
                enum entrance {
                    south = entrance(0x41, 0x53, NORTH)
                }

                enum soundtrack {
                    default = soundtrack(AREA_DESERT_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_south = @install() {
                        debug_subtext("S=0");

                        fog_wall_inside(!SOULS_MEMORY.DEAD_UNNAMED_DESERT_TEMPLE_BOSS, NORTH);

                        map_transition(desert_temple_stairs, door_downstairs, SOUTH);
                    }
                }

                group boss_ai() {
                    enum BOSS {
                        DEBUG = False,

                        PROGRESS = memory(FLAG, TEMP),

                        ID_LEFT = memory(WORD, TEMP),
                        ID_RIGHT = memory(WORD, TEMP),

                        HP_LEFT = 0d500,
                        HP_RIGHT = 0d400,

                        CENTER_X = 0d64 * 0d0008,
                        CENTER_Y = 0d32 * 0d0008,

                        ANGLE_THRESHOLD = 0d2, // 0d8 = behind, 0d4 = side, 0s6 = inbetween
                        WITH_SIDE_HIT = False,

                        STONE_DAMAGE = 0d100,
                        STONE_STUN_TIME = 0d20 * 0d0060,
                    }

                    fun boss_defeated() {
                        souls_boss_defeated(DEAD_UNNAMED_DESERT_TEMPLE_BOSS, REWARD_UNNAMED_DESERT_TEMPLE_BOSS);

                        BOSS.PROGRESS = False;
                    }

                    fun check_defeat() {
                        debug_memory(BOSS.ID_LEFT[HP], BOSS.ID_RIGHT[HP]);

                        if(_dead(BOSS.ID_LEFT) && _dead(BOSS.ID_RIGHT)) {
                            boss_defeated();
                        }
                    }
                    @install()
                    fun boss_left_triggered() {
                        arg[0x10] = <SCRIPT_OWNER>[DAMAGE_SOURCE];

                        // control(SCRIPT_OWNER, True);

                        if(arg[0x10]) {
                            // animate(SCRIPT_OWNER, ONCE, ANIMATION_ALL.DEFAULT);

                            arg[0x12] = <SCRIPT_OWNER>[FACE_DIRECTION];
                            face_target(<SCRIPT_OWNER>, arg[0x10]);
                            arg[0x14] = <SCRIPT_OWNER>[FACE_DIRECTION];

                            _face(<SCRIPT_OWNER>, arg[0x12]);

                            if(arg[0x12] >= arg[0x14]) {
                                arg[0x16] = arg[0x12] - arg[0x14];
                            } else {
                                arg[0x16] = arg[0x14] - arg[0x12];
                            }

                            if(arg[0x16] <= BOSS.ANGLE_THRESHOLD) {
                                if(arg[0x16] <= 0d2) {
                                    heal(SCRIPT_OWNER, 0d0, False);
                                    damage(SCRIPT_OWNER, 0d1, True);
                                } else {
                                    nop();
                                }

                                if(BOSS.DEBUG) {
                                    // subtext("bonk");
                                    debug_memory(arg[0x12], arg[0x14], arg[0x16]);
                                }
                            } else {
                                if(arg[0x16] <= 0d4) {
                                    nop();
                                } else {
                                    damage(SCRIPT_OWNER, 0d20, True);
                                }

                                if(BOSS.DEBUG) {
                                    subtext("hit");
                                }
                            }

                            if(False) {
                                debug_memory(arg[0x12], arg[0x14]);
                            }
                        }

                        // control(SCRIPT_OWNER, False);
                        
                        check_defeat();
                    }
                    @install()
                    fun boss_right_triggered() {
                        check_defeat();
                    }

                    fun walk_corner(entity, direction:FACE_DIRECTION) {
                        if(direction == FACE_DIRECTION.NORTH_EAST) {
                            walk(entity, TILE_ABSOLUTE, 0d78, 0d18, entity, NONE);
                        } else if(direction == FACE_DIRECTION.SOUTH_EAST) {
                            walk(entity, TILE_ABSOLUTE, 0d78, 0d47, entity, NONE);
                        } else if(direction == FACE_DIRECTION.SOUTH_WEST) {
                            walk(entity, TILE_ABSOLUTE, 0d50, 0d47, entity, NONE);
                        } else if(direction == FACE_DIRECTION.NORTH_WEST) {
                            walk(entity, TILE_ABSOLUTE, 0d50, 0d18, entity, NONE);
                        } else if(direction == FACE_DIRECTION.NORTH) {
                            walk(entity, TILE_ABSOLUTE, 0d63, 0d18, entity, NONE);

                            face(entity, SOUTH);
                            animate(entity, ONCE, ANIMATION_ALL.SLASH_1);
                            control(entity, False);
                        } else if(direction == FACE_DIRECTION.EAST) {
                            walk(entity, TILE_ABSOLUTE, 0d78, 0d33, entity, NONE);

                            face(entity, WEST);
                            animate(entity, ONCE, ANIMATION_ALL.SLASH_1);
                            control(entity, False);
                        } else if(direction == FACE_DIRECTION.SOUTH) {
                            walk(entity, TILE_ABSOLUTE, 0d63, 0d47, entity, NONE);

                            face(entity, NORTH);
                            animate(entity, ONCE, ANIMATION_ALL.SLASH_1);
                            control(entity, False);
                        } else if(direction == FACE_DIRECTION.WEST) {
                            walk(entity, TILE_ABSOLUTE, 0d50, 0d33, entity, NONE);

                            face(entity, EAST);
                            animate(entity, ONCE, ANIMATION_ALL.SLASH_1);
                            control(entity, False);
                        }
                    }

                    @install()
                    // @async()
                    fun bident_lap(entity, reversed) {
                        if((entity[X] >= BOSS.CENTER_X) && (entity[Y] < BOSS.CENTER_Y)) {
                            if!(reversed) {
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, NORTH);
                            } else {
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, SOUTH);
                            }
                        } else if((entity[X] >= BOSS.CENTER_X) && (entity[Y] >= BOSS.CENTER_Y)) {
                            if!(reversed) {
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, EAST);
                            } else {
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, SOUTH);
                            }
                        } else if((entity[X] < BOSS.CENTER_X) && (entity[Y] >= BOSS.CENTER_Y)) {
                            if!(reversed) {
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, SOUTH);
                            } else {
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, WEST);
                            }
                        } else {
                            if!(reversed) {
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, WEST);
                            } else {
                                walk_corner(entity, NORTH_EAST);
                                walk_corner(entity, SOUTH_EAST);
                                walk_corner(entity, SOUTH_WEST);
                                walk_corner(entity, NORTH_WEST);
                                walk_corner(entity, NORTH);
                            }
                        }
                    }

                    @install()
                    @async()
                    fun stone_hit(entity) {
                        damage(entity, BOSS.STONE_DAMAGE, True);
                        yield();

                        animate(entity, ONCE_FREEZE, ANIMATION_ALL.DEFAULT);

                        sleep(BOSS.STONE_STUN_TIME);

                        animate(entity, ONCE, ANIMATION_ALL.DEFAULT);
                    }

                    fun add_stone(x, y) {
                        add_enemy(STONE_ROUND, x, y); 

                        attach_script(LAST_ENTITY, B, reference(@install() {
                            guard_levitate_stone(0d2);

                            while(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.INVINCIBLE_TEMP) {
                                check_range_old(<SCRIPT_OWNER>, BOSS.ID_LEFT, 0d20, 0d20, {
                                    destroy(SCRIPT_OWNER);
                                    
                                    stone_hit(BOSS.ID_LEFT);
                                    end();
                                });
                                yield();
                                check_range_old(<SCRIPT_OWNER>, BOSS.ID_RIGHT, 0d20, 0d20, {
                                    destroy(SCRIPT_OWNER);

                                    stone_hit(BOSS.ID_RIGHT);
                                    end();
                                });
                                yield();
                            }
                        }));
                    }
                };

                fun trigger_enter() {
                    if!(SOULS_MEMORY.DEAD_UNNAMED_DESERT_TEMPLE_BOSS) {
                        BOSS.PROGRESS = True;
                        push_music(BOSS);

                        add_enemy(VIGOR, 0d59, 0d33);
                        BOSS.ID_LEFT = <LAST_ENTITY>;
                        <LAST_ENTITY>[HP] = BOSS.HP_LEFT;
                        attach_script(LAST_ENTITY, DAMAGE, reference(boss_left_triggered));

                        add_enemy(FOOTKNIGHT, 0d67, 0d32);
                        BOSS.ID_RIGHT = <LAST_ENTITY>;
                        <LAST_ENTITY>[HP] = BOSS.HP_RIGHT;
                        attach_script(LAST_ENTITY, DAMAGE, reference(boss_right_triggered));

                        add_stone(0d21, 0d37); 
                        add_stone(0d106, 0d37);

                        default_init_room(False, False);

                        while(True) {
                            sleep(0d600);
                            bident_lap(BOSS.ID_LEFT);
                            // bident_lap(BOSS.ID_RIGHT, True);
                        }
                    } else {
                        default_init_room(False, False);
                    }
                }
            };

            map desert_temple_stairs(IVOR_STAIRS) {
                enum entrance {
                    door_upstairs = entrance(0x0a, 0x23, NORTH),
                    door_downstairs = entrance(0x22, 0x45, NORTH),
                }

                enum soundtrack {
                    default = soundtrack(AREA_DESERT_TEMPLE.MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_door_upstairs = @install() {
                        debug_subtext("S=0");

                        map_transition(desert_temple_main, west_1, SOUTH);
                    },
                    exit_door_downstairs = @install() {
                        debug_subtext("S=1");

                        fog_wall_outside(!SOULS_MEMORY.DEAD_UNNAMED_DESERT_TEMPLE_BOSS, NORTH);

                        map_transition(desert_temple_underground, south, SOUTH);
                    },
                }

                fun trigger_enter() {
                    default_init_room(False, False);
                }
            };
        };
    };
};

area metro() {
    enum AREA_METRO {
        MUSIC_DEFAULT = MUSIC.SPACE,

        DEBUG = False,

        LEVER_REACTOR_ROOM = memory(FLAG, SRAM), // generator on (light on, computers active)
        REGENERATION_INN_ROOM = memory(FLAG, SRAM), // regeneration active (no bonfire teleportation)
    }

    group helper_metro() {
        fun metro_death_trigger(callback) {
            _boy_death();

            yield();

            control(NONE);
            
            if(False) {
                animate(BOY, ONCE, ANIMATION_ENEMY.DUST);
                animate(DOG, ONCE, ANIMATION_ENEMY.DUST);
            }

            sleep(0d60);

            if(False) {
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.TELEPORT_IN);
                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT2_TELEPORT);
            } else {
                if!(CUSTOM_FLAG.NO_BOY) {
                    teleporter_animation_out(<BOY>);
                }

                if!(FLAG.DOG_UNAVAILABLE || CUSTOM_FLAG.NO_DOG || CUSTOM_FLAG.DOG_BUSY) {
                    teleporter_animation_out(<DOG>);
                }
            }

            sleep(0d60);

            fade_out();
            refresh_both(False);
            
            callback();
        }

        @install()
        fun _default_metro_init_room() {
            if!(FLAG.ENERGY_CORE) {
                CUSTOM_FLAG.NO_START = True;
            }
        }
        fun default_metro_init_room(death_trigger) {
            default_init_room(False, False);

            _default_metro_init_room();

            if(death_trigger !is None) {
                if(AREA_METRO.REGENERATION_INN_ROOM) {
                    if!(CUSTOM_FLAG.NO_BOY) {
                        attach_script(BOY, DAMAGE_DEATH, death_trigger);
                    } else {
                        attach_script(DOG, DAMAGE_DEATH, death_trigger);
                    }
                }
            }
        }

        fun guard_power(direction:DIRECTION) {
            if!(AREA_METRO.LEVER_REACTOR_ROOM) {
                error_message(SWITCH_ENERGY, direction);
                end();
            }
        }

        @install()
        fun _guard_entrance_gate(flag, radiation_check) {
            CUSTOM_MEMORY.RETURN = False;

            if(radiation_check && (RADIATION.RADIATION_CURRENT > 0d0)) {
                control(NONE);

                if(radiation_check) {
                    for(arg[0x0e] in 0d0..0d10) {
                        radiation_click(False, True);
                    }
                }

                sound(PIPING_SOUND);

                error_walk_back(SOUTH);
                face(ACTIVE, NORTH);

                MEMORY.STRING_PARAMETER_1 = RADIATION.RADIATION_CURRENT;
                dialog("[SLOW]Warning: Biohazard detected. Radiation level [MEM1] measured. Quarantine breach imminent.[B]");

                control(BOTH);

                end();
            } else if((!flag) || (CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE != ARMOR_STATS.GLOVE_4_2)) {
                sound(PIPING_SOUND);

                error_walk_back(SOUTH);

                dialog("[SLOW]…Unautorized user… access denied… Please present clearance…[B]");
                face(ACTIVE, NORTH);

                end();
            } else {
                sound(ACT4_DOOR_OPENING);
            }

            CUSTOM_MEMORY.RETURN = True;
        }
        fun guard_entrance_gate(flag, radiation_check) {
            _guard_entrance_gate(flag, radiation_check);

            if(AREA_METRO.DEBUG) {
                debug_memory(flag, CUSTOM_MEMORY.CURRENT_ARMOR_GLOVE == ARMOR_STATS.GLOVE_4_2, CUSTOM_MEMORY.RETURN);
            }

            if!(CUSTOM_MEMORY.RETURN) {
                end();
            }
        }

        @install()
        fun add_radiating_tentacle(x, y) {
            add_enemy(TENTACLE_SPIKE, x, y);
            prepare_radiating_entity(<LAST_ENTITY>);
        }
    };

    map metro(OMNITOPIA_METROPLEX) {
        enum ROOM {
            COLUMN_1 = 0d18,
            COLUMN_2 = 0d82,
            COLUMN_3 = 0d146,
            COLUMN_4 = 0d210,
            COLUMN_CENTER = 0d114,

            ROW_1 = 0d18,
            ROW_2 = 0d62,
            ROW_3 = 0d106,
            ROW_4 = 0d150,
            ROW_CENTER = 0d84,

            WITH_BROKEN_GATE_BOT = False, // TODO: buggy, also weird in vanilla
            GUARD_BOT_HP = 0d20,

            DOOR_OPENED_A1_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_A2_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_A3_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_A4_SOUTH = memory(FLAG, TEMP),

            DOOR_OPENED_B1_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_B1_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_B2_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_B2_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_B3_SOUTH = memory(FLAG, TEMP),

            DOOR_OPENED_C1_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_C1_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_C2_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_C3_SOUTH = memory(FLAG, TEMP),
            DOOR_OPENED_C4_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_C4_SOUTH = memory(FLAG, TEMP),

            DOOR_OPENED_D2_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_D3_NORTH = memory(FLAG, TEMP),
            DOOR_OPENED_D4_NORTH = memory(FLAG, TEMP),

            GATE_OPENED_A1_A2 = memory(FLAG, SRAM),
            GATE_OPENED_A1_B1 = memory(FLAG, SRAM),
            GATE_OPENED_A2_B2 = memory(FLAG, SRAM),
            GATE_OPENED_A3_A4 = memory(FLAG, SRAM),

            GATE_OPENED_B1_B2 = memory(FLAG, SRAM),
            GATE_OPENED_B1_C1 = memory(FLAG, SRAM),
            GATE_OPENED_B2_C2 = memory(FLAG, SRAM),
            GATE_OPENED_B3_B4 = memory(FLAG, SRAM),
            
            GATE_OPENED_C1_C2 = memory(FLAG, SRAM),
            GATE_OPENED_C3_C4 = memory(FLAG, SRAM),
            GATE_OPENED_C3_D3 = memory(FLAG, SRAM),
            GATE_OPENED_C4_D4 = memory(FLAG, SRAM),
            GATE_OPENED_D1_D2 = memory(FLAG, SRAM),
            GATE_OPENED_D2_D3 = memory(FLAG, SRAM),
            GATE_OPENED_D3_D4 = memory(FLAG, SRAM),

            GATE_ID_A1_A2 = memory(WORD, TEMP),
            GATE_ID_A1_B1 = memory(WORD, TEMP),
            GATE_ID_A2_B2 = memory(WORD, TEMP),
            GATE_ID_A3_A4 = memory(WORD, TEMP),

            GATE_ID_B1_B2 = memory(WORD, TEMP),
            GATE_ID_B1_C1 = memory(WORD, TEMP),
            GATE_ID_B2_C2 = memory(WORD, TEMP),
            GATE_ID_B3_B4 = memory(WORD, TEMP),
            
            GATE_ID_C1_C2 = memory(WORD, TEMP),
            GATE_ID_C3_C4 = memory(WORD, TEMP),
            GATE_ID_C3_D3 = memory(WORD, TEMP),
            GATE_ID_C4_D4 = memory(WORD, TEMP),
            GATE_ID_D1_D2 = memory(WORD, TEMP),
            GATE_ID_D2_D3 = memory(WORD, TEMP),
            GATE_ID_D3_D4 = memory(WORD, TEMP),
        }

        enum entrance {
            door_a1 = entrance(ROOM.COLUMN_1, ROOM.ROW_1, NONE, { door_act4_airlock_in(0x0b); }),
            door_a2 = entrance(ROOM.COLUMN_2, ROOM.ROW_1, NONE, { door_act4_airlock_in(0x00); }),
            door_a3 = entrance(ROOM.COLUMN_3, ROOM.ROW_1, NONE, { door_act4_airlock_in(0x0c); }),
            door_a4 = entrance(ROOM.COLUMN_4, ROOM.ROW_1, NONE, { door_act4_airlock_in(0x0d); }),

            door_b2 = entrance(ROOM.COLUMN_2, ROOM.ROW_2, NONE, { door_act4_airlock_in(0x10); }),
            door_b3 = entrance(ROOM.COLUMN_3, ROOM.ROW_2, NONE, { door_act4_airlock_in(0x0f); }),
            door_b4 = entrance(ROOM.COLUMN_4, ROOM.ROW_2, NONE, { door_act4_airlock_in(0x0e); }),

            door_c1 = entrance(ROOM.COLUMN_1, ROOM.ROW_3, NONE, { door_act4_airlock_in(0x11); }),
            door_c2 = entrance(ROOM.COLUMN_2, ROOM.ROW_3, NONE, { door_act4_airlock_in(0x12); }),
            door_c4 = entrance(ROOM.COLUMN_4, ROOM.ROW_3, NONE, { door_act4_airlock_in(0x13); }),

            door_d1 = entrance(ROOM.COLUMN_1, ROOM.ROW_4, NONE, { door_act4_airlock_in(0x16); }),
            door_d3 = entrance(ROOM.COLUMN_3, ROOM.ROW_4, NONE, { door_act4_airlock_in(0x15); }),
            door_d4 = entrance(ROOM.COLUMN_4, ROOM.ROW_4, NONE, { door_act4_airlock_in(0x14); }),

            door_center = entrance(ROOM.COLUMN_CENTER, ROOM.ROW_CENTER, NONE, { door_act4_airlock_in(0x25); }),
        }
        
        enum soundtrack {
            default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
        }

        fun open_cell_exit(door_id, flag) {
            if!(flag) {
                flag = True;

                sound(ACT4_DOOR_OPENING);

                object[door_id] = 0x7e;
            }
        }

        enum stepon_trigger {
            door_b1_north_south = @install() {
                debug_subtext("S=0");

                open_cell_exit(0x04, ROOM.DOOR_OPENED_B1_NORTH);
            },
            door_b2_north_south = @install() {
                debug_subtext("S=1");

                open_cell_exit(0x03, ROOM.DOOR_OPENED_B2_NORTH);
            },
            door_c4_north_south = @install() {
                debug_subtext("S=2");

                open_cell_exit(0x07, ROOM.DOOR_OPENED_C4_NORTH);
            },
            door_c2_north_south = @install() {
                debug_subtext("S=3");

                open_cell_exit(0x06, ROOM.DOOR_OPENED_C2_NORTH);
            },
            door_c1_north_south = @install() {
                debug_subtext("S=4");

                open_cell_exit(0x05, ROOM.DOOR_OPENED_C1_NORTH);
            },
            door_d2_north_south = @install() {
                debug_subtext("S=5");

                open_cell_exit(0x0a, ROOM.DOOR_OPENED_D2_NORTH);
            },
            door_d3_north_south = @install() {
                debug_subtext("S=6");

                open_cell_exit(0x09, ROOM.DOOR_OPENED_D3_NORTH);
            },
            door_d4_north_south = @install() {
                debug_subtext("S=7");

                open_cell_exit(0x08, ROOM.DOOR_OPENED_D4_NORTH);
            },
            door_c4_south_south = @install() {
                debug_subtext("S=8");

                open_cell_exit(0x1f, ROOM.DOOR_OPENED_C4_SOUTH);
            },
            door_c4_south_north = @install() {
                debug_subtext("S=9");

                open_cell_exit(0x1f, ROOM.DOOR_OPENED_C4_SOUTH);
            },

            door_c3_south_south = @install() {
                debug_subtext("S=10");

                open_cell_exit(0x1e, ROOM.DOOR_OPENED_C3_SOUTH);
            },
            door_c3_south_north = @install() {
                debug_subtext("S=11");

                open_cell_exit(0x1e, ROOM.DOOR_OPENED_C3_SOUTH);
            },
            door_c1_south_south = @install() {
                debug_subtext("S=12");

                open_cell_exit(0x1d, ROOM.DOOR_OPENED_C1_SOUTH);
            },
            door_c1_south_north = @install() {
                debug_subtext("S=13");

                open_cell_exit(0x1d, ROOM.DOOR_OPENED_C1_SOUTH);
            },
            door_b1_south_south = @install() {
                debug_subtext("S=14");

                open_cell_exit(0x1c, ROOM.DOOR_OPENED_B1_SOUTH);
            },
            door_b1_south_north = @install() {
                debug_subtext("S=15");

                open_cell_exit(0x1c, ROOM.DOOR_OPENED_B1_SOUTH);
            },
            door_b2_south_south = @install() {
                debug_subtext("S=16");

                open_cell_exit(0x1b, ROOM.DOOR_OPENED_B2_SOUTH);
            },
            door_b2_south_north = @install() {
                debug_subtext("S=17");

                open_cell_exit(0x1b, ROOM.DOOR_OPENED_B2_SOUTH);
            },
            door_b3_south_south = @install() {
                debug_subtext("S=18");

                open_cell_exit(0x1a, ROOM.DOOR_OPENED_B3_SOUTH);
            },
            door_b3_south_north = @install() {
                debug_subtext("S=19");

                open_cell_exit(0x1a, ROOM.DOOR_OPENED_B3_SOUTH);
            },

            door_a4_south_south = @install() {
                debug_subtext("S=20");

                open_cell_exit(0x19, ROOM.DOOR_OPENED_A4_SOUTH);
            },
            door_a4_south_north = @install() {
                debug_subtext("S=21");

                open_cell_exit(0x19, ROOM.DOOR_OPENED_A4_SOUTH);
            },
            door_a3_south_south = @install() {
                debug_subtext("S=22");

                open_cell_exit(0x18, ROOM.DOOR_OPENED_A3_SOUTH);
            },
            door_a3_south_north = @install() {
                debug_subtext("S=23");

                open_cell_exit(0x18, ROOM.DOOR_OPENED_A3_SOUTH);
            },
            door_a2_south_south = @install() {
                debug_subtext("S=24");

                open_cell_exit(0x02, ROOM.DOOR_OPENED_A2_SOUTH);
            },
            door_a2_south_north = @install() {
                debug_subtext("S=25");

                open_cell_exit(0x02, ROOM.DOOR_OPENED_A2_SOUTH);
            },
            door_a1_south_south = @install() {
                debug_subtext("S=26");

                open_cell_exit(0x17, ROOM.DOOR_OPENED_A1_SOUTH);
            },
            door_a1_south_north = @install() {
                debug_subtext("S=27");

                open_cell_exit(0x17, ROOM.DOOR_OPENED_A1_SOUTH);
            },
            stepon_28 = @install() {
                debug_subtext("S=28");
            },
            stepon_29 = @install() {
                debug_subtext("S=29");
            },

            stepon_30 = @install() {
                debug_subtext("S=30");
            },
            stepon_31 = @install() {
                debug_subtext("S=31");
            },
            stepon_32 = @install() {
                debug_subtext("S=32");
            },
            stepon_33 = @install() {
                debug_subtext("S=33");
            },
            stepon_34 = @install() {
                debug_subtext("S=34");
            },
            stepon_35 = @install() {
                debug_subtext("S=35");
            },
            stepon_36 = @install() {
                debug_subtext("S=36");
            },
            stepon_37 = @install() {
                debug_subtext("S=37");
            },
            stepon_38 = @install() {
                debug_subtext("S=38");
            },
            stepon_39 = @install() {
                debug_subtext("S=39");
            },

            stepon_40 = @install() {
                debug_subtext("S=40");
            },
            stepon_41 = @install() {
                debug_subtext("S=41");
            },
            stepon_42 = @install() {
                debug_subtext("S=42");
            },
            stepon_43 = @install() {
                debug_subtext("S=43");
            },
            stepon_44 = @install() {
                debug_subtext("S=44");
            },
            stepon_45 = @install() {
                debug_subtext("S=45");
            },
            stepon_46 = @install() {
                debug_subtext("S=46");
            },
            stepon_47 = @install() {
                debug_subtext("S=47");
            },
            door_b1_north_north = @install() {
                debug_subtext("S=48");

                open_cell_exit(0x04, ROOM.DOOR_OPENED_B1_NORTH);
            },
            door_b2_north_north = @install() {
                debug_subtext("S=49");

                open_cell_exit(0x03, ROOM.DOOR_OPENED_B2_NORTH);
            },

            door_c1_north_north = @install() {
                debug_subtext("S=50");

                open_cell_exit(0x05, ROOM.DOOR_OPENED_C1_NORTH);
            },
            door_c2_north_north = @install() {
                debug_subtext("S=51");

                open_cell_exit(0x06, ROOM.DOOR_OPENED_C2_NORTH);
            },
            door_c4_north_north = @install() {
                debug_subtext("S=52");

                open_cell_exit(0x07, ROOM.DOOR_OPENED_C4_NORTH);
            },
            door_d4_north_north = @install() {
                debug_subtext("S=53");

                open_cell_exit(0x08, ROOM.DOOR_OPENED_D4_NORTH);
            },
            door_d3_north_north = @install() {
                debug_subtext("S=54");

                open_cell_exit(0x09, ROOM.DOOR_OPENED_D3_NORTH);
            },
            door_d2_north_north = @install() {
                debug_subtext("S=55");

                open_cell_exit(0x0a, ROOM.DOOR_OPENED_D2_NORTH);
            },
        }

        fun destroy_gate_bot(entity, flag) {
            if!(dead(entity)) {
                flag = True;
                damage(entity, 0d999, False);
            }
        }
        fun _gate_bot_killed(entity) {
            heal(entity, 0d0, False);
            attribute(entity, INVINCIBLE, True);

            entity[Y] += 0d8;

            animate(entity, ONCE_FREEZE, ANIMATION_ENEMY.GATE_BOT_DEAD);

            arg[0x10] = entity[GENERAL_PURPOSE] >> 0x0008;
            arg[0x12] = entity[GENERAL_PURPOSE] & 0xff;

            object[arg[0x10]] = arg[0x12];
        }
        fun gate_bot_killed(flag) {
            flag = True;

            _gate_bot_killed(<SCRIPT_OWNER>);
        }
        fun _add_gate_bot(id, x, y, object_door, trigger_death) {
            add_enemy(GATE_BOT, x, y);
            <LAST_ENTITY>[Z_LEVEL] = 0d0;
            <LAST_ENTITY>[HP] = ROOM.GUARD_BOT_HP;
            id = <LAST_ENTITY>;
            <LAST_ENTITY>[GENERAL_PURPOSE] = (object_door << 0x0008) | 0x7e;
            attach_script(LAST_ENTITY, DEATH, trigger_death);
        }
        fun add_gate_bot(id, x, y, condition, object_door, trigger_death) {
            _add_gate_bot(id, x, y, object_door, trigger_death);

            if(condition) {
                if!(ROOM.WITH_BROKEN_GATE_BOT) {
                    attribute(<LAST_ENTITY>, INVISIBLE, True);
                }
                _gate_bot_killed(<LAST_ENTITY>);
            }
        }

        @install()
        fun _open_door_up() {
            question("[SLOW]Burn matter to open gate[CHOICE]Dry Ice[CHOICE]Meteorite");

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                trade_items(WATER, 0d1, DRY_ICE, 0d1);
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                trade_items(IRON, 0d1, METEORITE, 0d1);
            } else {
                CUSTOM_MEMORY.RETURN = False;
            }
        }
        fun open_door_up() {
            _open_door_up();

            if!(CUSTOM_MEMORY.RETURN) {
                end();
            }
        }
        fun cell_key_enter(cell_x, cell_y) {
            open_door_up();

            add_enemy(PLACEHOLDER, cell_x + 0d8, cell_y - 0d11, INACTIVE_IMORTAL);
            arg[0x12] = <LAST_ENTITY>;

            if((cell_x == ROOM.COLUMN_1) && (cell_y == ROOM.ROW_1)) { // a1
                destroy_gate_bot(ROOM.GATE_ID_A1_A2, ROOM.GATE_OPENED_A1_A2);
                destroy_gate_bot(ROOM.GATE_ID_A1_B1, ROOM.GATE_OPENED_A1_B1);

                arg[0x14] = ROOM.GATE_ID_A1_A2;
                arg[0x16] = ROOM.GATE_ID_A1_B1;

                object[0x2f] = 0x7e; // open door_a1_up
            } else if((cell_x == ROOM.COLUMN_2) && (cell_y == ROOM.ROW_1)) { // a2
                destroy_gate_bot(ROOM.GATE_ID_A1_A2, ROOM.GATE_OPENED_A1_A2);
                destroy_gate_bot(ROOM.GATE_ID_A2_B2, ROOM.GATE_OPENED_A2_B2);

                arg[0x14] = ROOM.GATE_ID_A1_A2;
                arg[0x16] = ROOM.GATE_ID_A2_B2;

                object[0x30] = 0x7e; // open door_a2_up
            } else if((cell_x == ROOM.COLUMN_3) && (cell_y == ROOM.ROW_1)) { // a3
                destroy_gate_bot(ROOM.GATE_ID_A3_A4, ROOM.GATE_OPENED_A3_A4);

                arg[0x14] = ROOM.GATE_ID_A3_A4;

                object[0x31] = 0x7e; // open door_a3_up
            } else if((cell_x == ROOM.COLUMN_4) && (cell_y == ROOM.ROW_1)) { // a4
                destroy_gate_bot(ROOM.GATE_ID_A3_A4, ROOM.GATE_OPENED_A3_A4);

                arg[0x14] = ROOM.GATE_ID_A3_A4;

                object[0x31] = 0x7e; // open door_a3_up
            } else if((cell_x == ROOM.COLUMN_1) && (cell_y == ROOM.ROW_2)) { // b1
                destroy_gate_bot(ROOM.GATE_ID_A1_B1, ROOM.GATE_OPENED_A1_B1);
                destroy_gate_bot(ROOM.GATE_ID_B1_B2, ROOM.GATE_OPENED_B1_B2);
                destroy_gate_bot(ROOM.GATE_ID_B1_C1, ROOM.GATE_OPENED_B1_C1);

                arg[0x14] = ROOM.GATE_ID_A1_B1;
                arg[0x16] = ROOM.GATE_ID_B1_B2;
                arg[0x18] = ROOM.GATE_ID_B1_C1;

                object[0x36] = 0x7e; // open door_b1_up
            } else if((cell_x == ROOM.COLUMN_2) && (cell_y == ROOM.ROW_2)) { // b2
                destroy_gate_bot(ROOM.GATE_ID_B2_C2, ROOM.GATE_OPENED_B2_C2);
                destroy_gate_bot(ROOM.GATE_ID_B1_B2, ROOM.GATE_OPENED_B1_B2);
                destroy_gate_bot(ROOM.GATE_ID_A2_B2, ROOM.GATE_OPENED_A2_B2);

                arg[0x14] = ROOM.GATE_ID_B2_C2;
                arg[0x16] = ROOM.GATE_ID_B1_B2;
                arg[0x18] = ROOM.GATE_ID_A2_B2;

                object[0x35] = 0x7e; // open door_b2_up
            } else if((cell_x == ROOM.COLUMN_3) && (cell_y == ROOM.ROW_2)) { // b3
                destroy_gate_bot(ROOM.GATE_ID_B3_B4, ROOM.GATE_OPENED_B3_B4);

                arg[0x14] = ROOM.GATE_ID_B3_B4;

                object[0x34] = 0x7e; // open door_b3_up
            } else if((cell_x == ROOM.COLUMN_4) && (cell_y == ROOM.ROW_2)) { // b4
                destroy_gate_bot(ROOM.GATE_ID_B3_B4, ROOM.GATE_OPENED_B3_B4);

                arg[0x14] = ROOM.GATE_ID_B3_B4;

                object[0x33] = 0x7e; // open door_b4_up
            } else if((cell_x == ROOM.COLUMN_1) && (cell_y == ROOM.ROW_3)) { // c1
                destroy_gate_bot(ROOM.GATE_ID_C1_C2, ROOM.GATE_OPENED_C1_C2);
                destroy_gate_bot(ROOM.GATE_ID_B1_C1, ROOM.GATE_OPENED_B1_C1);

                arg[0x14] = ROOM.GATE_ID_C1_C2;
                arg[0x16] = ROOM.GATE_ID_B1_C1;

                object[0x37] = 0x7e; // open door_c1_up
            } else if((cell_x == ROOM.COLUMN_2) && (cell_y == ROOM.ROW_3)) { // c2
                destroy_gate_bot(ROOM.GATE_ID_C1_C2, ROOM.GATE_OPENED_C1_C2);
                destroy_gate_bot(ROOM.GATE_ID_B2_C2, ROOM.GATE_OPENED_B2_C2);

                arg[0x14] = ROOM.GATE_ID_C1_C2;
                arg[0x16] = ROOM.GATE_ID_B2_C2;

                object[0x38] = 0x7e; // open door_c2_up
            } else if((cell_x == ROOM.COLUMN_3) && (cell_y == ROOM.ROW_3)) { // c3
                destroy_gate_bot(ROOM.GATE_ID_C3_C4, ROOM.GATE_OPENED_C3_C4);
                destroy_gate_bot(ROOM.GATE_ID_C3_D3, ROOM.GATE_OPENED_C3_D3);

                arg[0x14] = ROOM.GATE_ID_C3_C4;
                arg[0x16] = ROOM.GATE_ID_C3_D3;

                object[0x39] = 0x7e; // open door_c3_up
            } else if((cell_x == ROOM.COLUMN_4) && (cell_y == ROOM.ROW_3)) { // c4
                destroy_gate_bot(ROOM.GATE_ID_C4_D4, ROOM.GATE_OPENED_C4_D4);
                destroy_gate_bot(ROOM.GATE_ID_C3_C4, ROOM.GATE_OPENED_C3_C4);

                arg[0x14] = ROOM.GATE_ID_C4_D4;
                arg[0x16] = ROOM.GATE_ID_C3_C4;

                object[0x3a] = 0x7e; // open door_c4_up
            } else if((cell_x == ROOM.COLUMN_1) && (cell_y == ROOM.ROW_4)) { // d1
                destroy_gate_bot(ROOM.GATE_ID_D1_D2, ROOM.GATE_OPENED_D1_D2);

                arg[0x14] = ROOM.GATE_ID_D1_D2;

                object[0x3e] = 0x7e; // open door_d1_up
            } else if((cell_x == ROOM.COLUMN_2) && (cell_y == ROOM.ROW_4)) { // d2
                destroy_gate_bot(ROOM.GATE_ID_D2_D3, ROOM.GATE_OPENED_D2_D3);
                destroy_gate_bot(ROOM.GATE_ID_D1_D2, ROOM.GATE_OPENED_D1_D2);

                arg[0x14] = ROOM.GATE_ID_D2_D3;
                arg[0x16] = ROOM.GATE_ID_D1_D2;

                object[0x3d] = 0x7e; // open door_d2_up
            } else if((cell_x == ROOM.COLUMN_3) && (cell_y == ROOM.ROW_4)) { // d3
                destroy_gate_bot(ROOM.GATE_ID_D3_D4, ROOM.GATE_OPENED_D3_D4);
                destroy_gate_bot(ROOM.GATE_ID_C3_D3, ROOM.GATE_OPENED_C3_D3);
                destroy_gate_bot(ROOM.GATE_ID_D2_D3, ROOM.GATE_OPENED_D2_D3);

                arg[0x14] = ROOM.GATE_ID_D3_D4;
                arg[0x16] = ROOM.GATE_ID_C3_D3;
                arg[0x18] = ROOM.GATE_ID_D2_D3;

                object[0x3c] = 0x7e; // open door_d3_up
            } else if((cell_x == ROOM.COLUMN_4) && (cell_y == ROOM.ROW_4)) { // d4
                destroy_gate_bot(ROOM.GATE_ID_D3_D4, ROOM.GATE_OPENED_D3_D4);
                destroy_gate_bot(ROOM.GATE_ID_C4_D4, ROOM.GATE_OPENED_C4_D4);

                arg[0x14] = ROOM.GATE_ID_D3_D4;
                arg[0x16] = ROOM.GATE_ID_C4_D4;

                object[0x3b] = 0x7e; // open door_d4_up
            }

            sleep(0d30);
            
            add_enemy(LANTERN_LIGHT_RED, cell_x + 0d8, cell_y - 0d3, INACTIVE_IMORTAL);
            arg[0x10] = <LAST_ENTITY>;

            animate(arg[0x12], ONCE, ANIMATION_PLACEHOLDER.EXPLOSION_GREEN_1);

            while(arg[0x1a] < 0d7) {
                arg[0x1a]++;

                if(arg[0x14]) {
                    shoot_entity_entity(arg[0x12], LIGHTNING, arg[0x14], 0d10, 0d0);
                }
                if(arg[0x16]) {
                    shoot_entity_entity(arg[0x12], LIGHTNING, arg[0x16], 0d10, 0d0);
                }
                if(arg[0x18]) {
                    shoot_entity_entity(arg[0x12], LIGHTNING, arg[0x18], 0d10, 0d0);
                }

                sleep(0d20);
            }
            
            animate(arg[0x10], ONCE_FREEZE, INVISIBLE_FADE);
            wait(arg[0x10]);

            destroy(arg[0x10]);
            destroy(arg[0x12]);
        }

        enum b_trigger {
            door_center = @install() {
                debug_subtext("B=0");

                if!(SOULS_MEMORY.WITH_SATURN_ROOM) {
                    error_message(DLC);
                    end();
                }

                if!(SOULS_MEMORY.DEAD_FINAL_BOSS) {
                    door_act4_airlock_out(ROOM.COLUMN_CENTER, ROOM.ROW_CENTER, 0x25);

                    map_transition(metro_rooms_true_ending, center, NONE);
                } else {
                    error_message(DOOR_COMPLETED);
                }
            },
            door_d1_down = @install() {
                debug_subtext("B=1");
            },
            door_d1_up = @install() {
                debug_subtext("B=2");

                cell_key_enter(ROOM.COLUMN_1, ROOM.ROW_4);
            },
            door_d2_up = @install() {
                debug_subtext("B=3");

                cell_key_enter(ROOM.COLUMN_2, ROOM.ROW_4);
            },
            door_d2_down = @install() {
                debug_subtext("B=4");
            },
            door_d3_up = @install() {
                debug_subtext("B=5");

                cell_key_enter(ROOM.COLUMN_3, ROOM.ROW_4);
            },
            door_d3_down = @install() {
                debug_subtext("B=6");
            },
            door_d4_up = @install() {
                debug_subtext("B=7");

                cell_key_enter(ROOM.COLUMN_4, ROOM.ROW_4);
            },
            door_d4_down = @install() {
                debug_subtext("B=8");
            },
            door_c4_up = @install() {
                debug_subtext("B=9");

                cell_key_enter(ROOM.COLUMN_4, ROOM.ROW_3);
            },

            door_c4_down = @install() {
                debug_subtext("B=10");
            },
            door_c3_up = @install() {
                debug_subtext("B=11");

                cell_key_enter(ROOM.COLUMN_3, ROOM.ROW_3);
            },
            door_c3_down = @install() {
                debug_subtext("B=12");
            },
            door_c2_up = @install() {
                debug_subtext("B=13");

                cell_key_enter(ROOM.COLUMN_2, ROOM.ROW_3);
            },
            door_c2_down = @install() {
                debug_subtext("B=14");
            },
            door_c1_up = @install() {
                debug_subtext("B=15");

                cell_key_enter(ROOM.COLUMN_1, ROOM.ROW_3);
            },
            door_c1_down = @install() {
                debug_subtext("B=16");
            },
            door_b1_up = @install() {
                debug_subtext("B=17");

                cell_key_enter(ROOM.COLUMN_1, ROOM.ROW_2);
            },
            door_b1_down = @install() {
                debug_subtext("B=18");
            },
            door_b2_up = @install() {
                debug_subtext("B=19");

                cell_key_enter(ROOM.COLUMN_2, ROOM.ROW_2);
            },

            door_b2_down = @install() {
                debug_subtext("B=20");
            },
            door_b3_up = @install() {
                debug_subtext("B=21");

                cell_key_enter(ROOM.COLUMN_3, ROOM.ROW_2);
            },
            door_b3_down = @install() {
                debug_subtext("B=22");
            },
            door_b4_up = @install() {
                debug_subtext("B=23");

                cell_key_enter(ROOM.COLUMN_4, ROOM.ROW_2);
            },
            door_b4_down = @install() {
                debug_subtext("B=24");
            },
            door_a4_up = @install() {
                debug_subtext("B=25");

                cell_key_enter(ROOM.COLUMN_4, ROOM.ROW_1);
            },
            door_a4_down = @install() {
                debug_subtext("B=26");
            },
            door_a3_up = @install() {
                debug_subtext("B=27");

                cell_key_enter(ROOM.COLUMN_3, ROOM.ROW_1);
            },
            door_a3_down = @install() {
                debug_subtext("B=28");
            },
            door_a2_up = @install() {
                debug_subtext("B=29");

                cell_key_enter(ROOM.COLUMN_2, ROOM.ROW_1);
            },

            door_a2_down = @install() {
                debug_subtext("B=30");
            },
            door_a1_up = @install() {
                debug_subtext("B=31");

                cell_key_enter(ROOM.COLUMN_1, ROOM.ROW_1);
            },
            door_a1_down = @install() {
                debug_subtext("B=32");
            },
            door_d4_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_4, ROOM.ROW_4, 0x14);

                debug_subtext("B=33");

                map_transition(junkyard_south, north, NONE);
            },
            door_d3_center = @install() {
                debug_subtext("B=34");

                if!(SOULS_MEMORY.DEAD_TURRET_ARENA) {
                    fog_wall_outside(True, NONE);
                    door_act4_airlock_out(ROOM.COLUMN_3, ROOM.ROW_4, 0x15);

                    map_transition(turret_arena, center, NONE);
                } else {
                    error_message(DOOR_COMPLETED);
                }
            },
            door_b3_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_3, ROOM.ROW_2, 0x0f);

                debug_subtext("B=35");

                map_transition(junkyard_northeast, north, NONE);
            },
            door_c4_center = @install() {
                debug_subtext("B=36");

                if!(SOULS_MEMORY.DEAD_TOASTER_ARENA) {
                    fog_wall_outside(True, NONE);
                    door_act4_airlock_out(ROOM.COLUMN_4, ROOM.ROW_3, 0x13);

                    map_transition(toaster_arena, center, NONE);
                } else {
                    error_message(DOOR_COMPLETED);
                }
            },
            door_b4_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_4, ROOM.ROW_2, 0x0e);

                debug_subtext("B=37");

                map_transition(reactor_room, east, NONE);
            },
            door_a4_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_4, ROOM.ROW_1, 0x0d);

                debug_subtext("B=38");

                map_transition(reactor_room, lever_room, NONE);
            },
            door_a3_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_3, ROOM.ROW_1, 0x0c);

                debug_subtext("B=39");

                map_transition(reactor_room, north, NONE);
            },

            door_b2_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_2, ROOM.ROW_2, 0x10);

                debug_subtext("B=40");

                map_transition(storage_room, west, NONE);
            },
            door_a2_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_2, ROOM.ROW_1, 0x00);

                debug_subtext("B=41");

                map_transition(shopping_district, east, NONE);
            },
            door_a1_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_1, ROOM.ROW_1, 0x0b);

                debug_subtext("B=42");

                map_transition(junkyard_northwest, north, NONE);
            },
            door_d1_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_1, ROOM.ROW_4, 0x16);

                debug_subtext("B=43");
                
                map_transition(ar_lab, east, NONE);
            },
            door_c1_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_1, ROOM.ROW_3, 0x11);

                debug_subtext("B=44");

                map_transition(control_room, east, NONE);
            },
            door_c2_center = @install() {
                door_act4_airlock_out(ROOM.COLUMN_2, ROOM.ROW_3, 0x12);

                debug_subtext("B=45");

                map_transition(shopping_district, west, NONE);
            },
            b_trigger_46 = @install() {
                debug_subtext("B=46");
            },
            b_trigger_47 = @install() {
                debug_subtext("B=47");
            },
            b_trigger_48 = @install() {
                debug_subtext("B=48");
            },
            b_trigger_49 = @install() {
                debug_subtext("B=49");
            },

            b_trigger_50 = @install() {
                debug_subtext("B=50");
            },
            b_trigger_51 = @install() {
                debug_subtext("B=51");
            },
            b_trigger_52 = @install() {
                debug_subtext("B=52");
            },
        }        

        fun trigger_enter() {
            add_gate_bot(ROOM.GATE_ID_A1_A2, 0d50, 0d13, ROOM.GATE_OPENED_A1_A2, 0x2e, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_A1_A2); }));
            add_gate_bot(ROOM.GATE_ID_A1_B1, 0d18, 0d34, ROOM.GATE_OPENED_A1_B1, 0x20, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_A1_B1); }));
            add_gate_bot(ROOM.GATE_ID_A2_B2, 0d82, 0d34, ROOM.GATE_OPENED_A2_B2, 0x01, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_A2_B2); }));
            add_gate_bot(ROOM.GATE_ID_A3_A4, 0d178, 0d13, ROOM.GATE_OPENED_A3_A4, 0x26, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_A3_A4); }));

            add_gate_bot(ROOM.GATE_ID_B1_B2, 0d50, 0d57, ROOM.GATE_OPENED_B1_B2, 0x2d, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_B1_B2); }));
            add_gate_bot(ROOM.GATE_ID_B1_C1, 0d18, 0d78, ROOM.GATE_OPENED_B1_C1, 0x21, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_B1_C1); }));
            add_gate_bot(ROOM.GATE_ID_B2_C2, 0d82, 0d78, ROOM.GATE_OPENED_B2_C2, 0x22, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_B2_C2); }));
            add_gate_bot(ROOM.GATE_ID_B3_B4, 0d178, 0d57, ROOM.GATE_OPENED_B3_B4, 0x27, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_B3_B4); }));
            
            add_gate_bot(ROOM.GATE_ID_C1_C2, 0d50, 0d101, ROOM.GATE_OPENED_C1_C2, 0x2c, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_C1_C2); }));
            add_gate_bot(ROOM.GATE_ID_C3_C4, 0d178, 0d101, ROOM.GATE_OPENED_C3_C4, 0x28, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_C3_C4); }));
            add_gate_bot(ROOM.GATE_ID_C3_D3, 0d146, 0d122, ROOM.GATE_OPENED_C3_D3, 0x23, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_C3_D3); }));
            add_gate_bot(ROOM.GATE_ID_C4_D4, 0d210, 0d122, ROOM.GATE_OPENED_C4_D4, 0x24, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_C4_D4); }));

            add_gate_bot(ROOM.GATE_ID_D1_D2, 0d50, 0d145, ROOM.GATE_OPENED_D1_D2, 0x2b, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_D1_D2); }));
            add_gate_bot(ROOM.GATE_ID_D2_D3, 0d114, 0d145, ROOM.GATE_OPENED_D2_D3, 0x2a, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_D2_D3); }));
            add_gate_bot(ROOM.GATE_ID_D3_D4, 0d178, 0d145, ROOM.GATE_OPENED_D3_D4, 0x29, reference(@install() { gate_bot_killed(ROOM.GATE_OPENED_D3_D4); }));

            default_metro_init_room();
        }
    };

    area metro_rooms_northwest() { // cells: a1, a2, b1, b2, [c1], c2
        map junkyard_northwest(OMNITOPIA_JUNKYARD) { // cells: c1
            enum entrance {
                north = entrance(0d62, 0d22, NONE, { door_act4_beam_in(); }),
                teleporter = entrance(0d21, 0d79, NONE, { teleporter_in(SOUTH); }),

                crash_north = entrance(0x58, 0x1c, NONE, { crash_both(); }),
                crash_south = entrance(0x5f, 0x4f, NONE, { crash_both(); }),
                crash_west = entrance(0x0a, 0x3a, NONE, { crash_both(); }),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                stepon_0 = @install() {
                    debug_subtext("S=0");
                },
                stepon_1 = @install() {
                    debug_subtext("S=1");
                },
                stepon_2 = @install() {
                    debug_subtext("S=2");
                },
                stepon_3 = @install() {
                    debug_subtext("S=3");
                },
                stepon_4 = @install() {
                    debug_subtext("S=4");
                },
                stepon_5 = @install() {
                    debug_subtext("S=5");
                },
                stepon_6 = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                stepon_8 = @install() {
                    debug_subtext("S=8");
                },
                stepon_9 = @install() {
                    debug_subtext("S=9");
                },

                stepon_10 = @install() {
                    debug_subtext("S=10");
                },
                exit_north = @install() {
                    debug_subtext("S=11");

                    guard_entrance_gate(SOULS_MEMORY.DEAD_GIDEON, True);

                    door_act4_beam_out(0d62, 0d22);

                    map_transition(metro, door_a1, NONE);
                },
                teleporter = @install() {
                    debug_subtext("S=12");

                    teleporter_out(0d21, 0d79);

                    map_transition(northern_waterfall, swirl, NONE);
                },
            }
            
            fun trigger_enter() {
                fallout_init(False, False);
            }
        };

        map shopping_district(OMNITOPIA_SHOPPING) {
            enum ROOM {
                DOOR_PASSAGE_SOUTH_OPEN = memory(FLAG, TEMP),
                DOOR_PASSAGE_NORTH_OPEN = memory(FLAG, TEMP),

                ENTERED_FROM_SOUTH = memory(FLAG, TEMP),

                CLONE_OPENED = memory(FLAG, TEMP),
            }

            enum entrance {
                east = entrance(0d110, 0d19, NONE, { door_act4_beam_in(); }),
                west = entrance(0d10, 0d81, NONE, {
                    door_act4_beam_in();

                    ROOM.ENTERED_FROM_SOUTH = True;
                }),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                exit_west = @install() {
                    debug_subtext("S=0");

                    door_act4_beam_out(0d10, 0d81);

                    map_transition(metro, door_c2, NONE);
                },
                exit_east = @install() {
                    debug_subtext("S=1");

                    door_act4_beam_out(0d110, 0d19);

                    map_transition(metro, door_a2, NONE);
                },
                door_passage_south_south = @install() {
                    debug_subtext("S=2");

                    door_act4_passage(0x01, ROOM.DOOR_PASSAGE_SOUTH_OPEN);
                },
                door_passage_south_north = @install() {
                    debug_subtext("S=3");

                    door_act4_passage(0x01, ROOM.DOOR_PASSAGE_SOUTH_OPEN);
                },
                door_passage_north_south = @install() {
                    debug_subtext("S=4");

                    door_act4_passage(0x00, ROOM.DOOR_PASSAGE_NORTH_OPEN);
                },
                door_passage_north_north = @install() {
                    debug_subtext("S=5");

                    door_act4_passage(0x00, ROOM.DOOR_PASSAGE_NORTH_OPEN);
                },
                inn = @install() {
                    debug_subtext("S=6");

                    if!(AREA_METRO.REGENERATION_INN_ROOM) {
                        if!(FLAG.STAFF_OF_LIFE) {
                            dialog("[SLOW]The cloning machine seems to be inactive. Something seems to be missing.[B]");
                        } else {
                            AREA_METRO.REGENERATION_INN_ROOM = True;

                            dialog("[SLOW]Cloning machine has been activated.[B]");
                        }
                    }
                },
            }

            enum b_trigger {
                shop_1 = @install() {
                    debug_subtext("B=0");

                    pip_boy({
                        dialog("[SLOW]An escaped clone dog.[B]");
                    });
                },
                shop_2 = @install() {
                    debug_subtext("B=1");

                    pip_boy({
                        if!(ROOM.CLONE_OPENED) {
                            control(NONE);

                            ROOM.CLONE_OPENED = True;

                            object[0x03] = 0x7e; // open shop_2

                            add_enemy(BOY_BLACK, 0d60, 0d10, INACTIVE_IMORTAL);

                            animate(LAST_ENTITY, ONCE, ANIMATION_BOY.FALL_2);
                            sleep(0d5);
                            animate(LAST_ENTITY, PAUSE, DEFAULT);

                            dialog("[SLOW]An incomplete clone.[B]");

                            control(BOTH);
                        } else {
                            dialog("[SLOW]An incomplete clone.[B]");
                        }
                    });
                },
                shop_3 = @install() {
                    debug_subtext("B=2");

                    pip_boy({
                        dialog("[SLOW]An escaped clone.[B]");
                    });
                },
            }

            fun trigger_enter() {
                // object[0x00] = 0x7e; // open door_passage_north
                // object[0x01] = 0x7e; // open door_passage_south
                object[0x02] = 0x7e; // open shop_1
                if(ROOM.CLONE_OPENED) {
                    object[0x03] = 0x7e; // open shop_2
                }
                object[0x04] = 0x7e; // open shop_3

                add_enemy(DOG_4_BLACK, 0d84, 0d61);

                default_metro_init_room(reference(@install() {
                    metro_death_trigger({
                        if(ROOM.ENTERED_FROM_SOUTH) {
                            map_transition(metro, door_c2, NONE);
                        } else {
                            map_transition(metro, door_a2, NONE);
                        }
                    });
                }));
            }
        };

        map storage_room(OMNITOPIA_STORAGE) {
            enum entrance {
                west = entrance(0x10, 0x1a, NONE),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                LIGHT_ON = AREA_METRO.LEVER_REACTOR_ROOM,

                LOOTED_HELMET = memory(FLAG, SRAM),
            }

            enum OBJECT_DEFAULT {
                DEFAULT = 0d00,
                ACTIVATED = 0d01,
            }

            enum OBJECT_GOURD_ACT4 {
                DEFAULT = 0d00,
                HALF_LOOTED = 0d01,
                LOOTED = 0d02,
            }

            enum objects {
                remove_fan_east_1_2 = object[0d07]:OBJECT_DEFAULT,
                remove_fan_east_1_4 = object[0d08]:OBJECT_DEFAULT,
                remove_fan_east_2_3 = object[0d09]:OBJECT_DEFAULT,
                remove_fan_east_2_5 = object[0d10]:OBJECT_DEFAULT,

                remove_fan_west = object[0d11]:OBJECT_DEFAULT,

                // gourds
                gourd_2_1 = object[0d04]:OBJECT_GOURD_ACT4,
                gourd_2_2 = object[0d05]:OBJECT_GOURD_ACT4,
                gourd_2_3 = object[0d06]:OBJECT_GOURD_ACT4,

                gourd_2_1 = object[0d00]:OBJECT_GOURD_ACT4,
                gourd_2_2 = object[0d01]:OBJECT_GOURD_ACT4,
                gourd_2_3 = object[0d02]:OBJECT_GOURD_ACT4,
                gourd_2_4 = object[0d03]:OBJECT_GOURD_ACT4,

                // ingredients
            }

            enum stepon_trigger {
                exit_west = @install() {
                    debug_subtext("S=0");

                    map_transition(metro, door_b2, NONE);
                },
            }

            fun guard_dark_gourd() {
                if!(ROOM.LIGHT_ON) {
                    error_message(SWITCH_ENERGY);
                    end();
                }
            }

            enum b_trigger {
                gourd_1_3 = @install() {
                    debug_subtext("B=0");

                    guard_dark_gourd();
                },
                gourd_1_2 = @install() {
                    debug_subtext("B=1");

                    guard_dark_gourd();
                },
                gourd_1_1 = @install() {
                    debug_subtext("B=2");

                    guard_dark_gourd();

                    if(False) {
                        _loot_chest(0x04, HELM_4_3, 0d01);
                    } else {
                        object[0x04] = 0x02; // loot gourd_1_1
                        ROOM.LOOTED_HELMET = True;

                        custom_reward(HELM_ARCHAEOLOGY, True);
                    }
                },
                gourd_2_4 = @install() {
                    debug_subtext("B=3");

                    guard_dark_gourd();
                },
                gourd_2_3 = @install() {
                    debug_subtext("B=4");

                    guard_dark_gourd();
                },
                gourd_2_2 = @install() {
                    debug_subtext("B=5");

                    guard_dark_gourd();
                },
                gourd_2_1 = @install() {
                    debug_subtext("B=6");

                    guard_dark_gourd();

                    _loot_chest(0x00, BAZOOKA, 0d01);
                },
            }

            fun trigger_enter() {
                if(False) {
                    AREA_METRO.LEVER_REACTOR_ROOM = True;
                }
                
                // object[0x00] = 0x02; // loot gourd_2_1
                // object[0x01] = 0x02; // loot gourd_2_2
                // object[0x02] = 0x02; // loot gourd_2_3
                // object[0x03] = 0x02; // loot gourd_2_4
                if(ROOM.LOOTED_HELMET) {
                    object[0x04] = 0x02; // loot gourd_1_1
                }
                // object[0x05] = 0x02; // loot gourd_1_2
                // object[0x06] = 0x02; // loot gourd_1_3
                // object[0x07] = 0x01; // remove fan_east_1_2
                // object[0x08] = 0x01; // remove fan_east_1_4
                // object[0x09] = 0x01; // remove fan_east_2_3
                // object[0x0a] = 0x01; // remove fan_east_2_5
                // object[0x0b] = 0x01; // remove fan_west

                default_metro_init_room(reference(@install() {
                    metro_death_trigger({
                        map_transition(metro, door_b2, NONE);
                    });
                }));

                if!(ROOM.LIGHT_ON) {
                    MEMORY.MAP_PALETTE = MAP_PALETTE.STORAGE_ROOM_DARK;
                }

                // objects.gourd_2_1 = OBJECT_GOURD_ACT4.LOOTED;
            }
        };

        map control_room(OMNITOPIA_CONTROL) {
            enum entrance {
                north = entrance(0x1c, 0x0a, NONE, { door_act4_airlock_secret_in(); }),
                east = entrance(0x54, 0x12, NONE),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                SWITCH_LEFT = memory(FLAG, TEMP),
                SWITCH_RIGHT = memory(FLAG, TEMP),

                SWITCH_RGB_1 = memory(WORD, TEMP),
                SWITCH_RGB_2 = memory(WORD, TEMP),
                SWITCH_RGB_3 = memory(WORD, TEMP),

                CODE_SOLVED = memory(FLAG, SRAM),

                CODE_1 = (CODE_RIDDLE.SECRET_CODE >> 0d7) & 0x1, // left
                CODE_2 = (CODE_RIDDLE.SECRET_CODE >> 0d6) & 0x1, // right
                CODE_3 = (CODE_RIDDLE.SECRET_CODE >> 0d0) & 0x3, // rgb_1
                CODE_4 = (CODE_RIDDLE.SECRET_CODE >> 0d2) & 0x3, // rgb_2
                CODE_5 = (CODE_RIDDLE.SECRET_CODE >> 0d4) & 0x3, // rgb_3
            }

            fun check_code() {
                arg[0x10] = ROOM.CODE_3;
                arg[0x12] = ROOM.CODE_4;
                arg[0x14] = ROOM.CODE_5;
                arg[0x16] = ROOM.CODE_2;
                arg[0x18] = ROOM.CODE_1;

                if!(ROOM.SWITCH_LEFT == arg[0x18]) {
                    if(CODE_RIDDLE.DEBUG && CODE_RIDDLE.DEBUG_LEVERS) {
                        debug_subtext("lever left wrong");
                        sleep(0d60);
                        debug_memory(ROOM.SWITCH_LEFT, arg[0x18]);
                        sleep(0d60);
                    }

                    end();
                }
                if!(ROOM.SWITCH_RIGHT == arg[0x16]) {
                    if(CODE_RIDDLE.DEBUG && CODE_RIDDLE.DEBUG_LEVERS) {
                        debug_subtext("lever right wrong");
                        sleep(0d60);
                        debug_memory(ROOM.SWITCH_RIGHT, arg[0x16]);
                        sleep(0d60);
                    }

                    end();
                }

                if!(ROOM.SWITCH_RGB_1 == arg[0x10]) {
                    if(CODE_RIDDLE.DEBUG && CODE_RIDDLE.DEBUG_LEVERS) {
                        debug_subtext("lever code_3 wrong");
                        sleep(0d60);
                        debug_memory(ROOM.SWITCH_RGB_1, arg[0x10]);
                        sleep(0d60);
                    }

                    end();
                }
                if!(ROOM.SWITCH_RGB_2 == arg[0x12]) {
                    if(CODE_RIDDLE.DEBUG && CODE_RIDDLE.DEBUG_LEVERS) {
                        debug_subtext("lever code_4 wrong");
                        sleep(0d60);
                        debug_memory(ROOM.SWITCH_RGB_2, arg[0x12]);
                        sleep(0d60);
                    }

                    end();
                }
                if!(ROOM.SWITCH_RGB_3 == arg[0x14]) {
                    if(CODE_RIDDLE.DEBUG && CODE_RIDDLE.DEBUG_LEVERS) {
                        debug_subtext("lever code_5 wrong");
                        sleep(0d60);
                        debug_memory(ROOM.SWITCH_RGB_3, arg[0x14]);
                        sleep(0d60);
                    }

                    end();
                }

                object_animator(SECRET_OPEN, ROOM.CODE_SOLVED, 0x02, True, False);
            }

            @install()
            fun update_switches(only_visual) {
                object[0x00] = ROOM.SWITCH_LEFT; // toggle lever_1
                object[0x01] = ROOM.SWITCH_RIGHT; // toggle lever_2

                if(ROOM.SWITCH_RGB_1 == 0d1) { // toggle lever_3_1
                    object[0x03] = 0d2;
                } else if(ROOM.SWITCH_RGB_1 == 0d2) {
                    object[0x03] = 0d1;
                } else {
                    object[0x03] = ROOM.SWITCH_RGB_1;
                }
                if(ROOM.SWITCH_RGB_2 == 0d1) { // toggle lever_3_2
                    object[0x04] = 0d2;
                } else if(ROOM.SWITCH_RGB_2 == 0d2) {
                    object[0x04] = 0d1;
                } else {
                    object[0x04] = ROOM.SWITCH_RGB_2;
                }
                if(ROOM.SWITCH_RGB_3 == 0d1) { // toggle lever_3_3
                    object[0x05] = 0d2;
                } else if(ROOM.SWITCH_RGB_3 == 0d2) {
                    object[0x05] = 0d1;
                } else {
                    object[0x05] = ROOM.SWITCH_RGB_3;
                }

                if(only_visual) {
                    end();
                }

                if!(ROOM.CODE_SOLVED) {
                    check_code();
                }
            }
            fun toggle_switch(flag_switch) {
                flag_switch = !flag_switch;

                if(flag_switch) {
                    subtext("ON");
                } else {
                    subtext("OFF");
                }

                update_switches();
            }

            enum stepon_trigger {
                exit_east = @install() {
                    debug_subtext("S=0");

                    map_transition(metro, door_c1, NONE);
                },
            }

            fun guard_code_availability() {
                if!(SOULS_MEMORY.WITH_CODE) {
                    error_message(DLC);
                    end();
                }
            }

            enum b_trigger {
                exit_hidden_door = @install() {
                    debug_subtext("B=0");

                    door_act4_airlock_secret_out(0d28, 0d10, True);
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                lever_3 = @install() {
                    debug_subtext("B=2");

                    guard_code_availability();

                    guard_power(NONE);

                    question("[SLOW]Code 3[CHOICE]RED[CHOICE]BLUE[CHOICE]GREEN");
                    if((MEMORY.QUESTION_ANSWER >= 0d0) && (MEMORY.QUESTION_ANSWER <= 0d2)) {
                        ROOM.SWITCH_RGB_1 = MEMORY.QUESTION_ANSWER;
                        update_switches(True);
                    }

                    question("[SLOW]Code 4[CHOICE]RED[CHOICE]BLUE[CHOICE]GREEN");
                    if((MEMORY.QUESTION_ANSWER >= 0d0) && (MEMORY.QUESTION_ANSWER <= 0d2)) {
                        ROOM.SWITCH_RGB_2 = MEMORY.QUESTION_ANSWER;
                        update_switches(True);
                    }

                    question("[SLOW]Code 5[CHOICE]RED[CHOICE]BLUE[CHOICE]GREEN");
                    if((MEMORY.QUESTION_ANSWER >= 0d0) && (MEMORY.QUESTION_ANSWER <= 0d2)) {
                        ROOM.SWITCH_RGB_3 = MEMORY.QUESTION_ANSWER;
                    }
                    update_switches();
                },
                lever_2 = @install() {
                    debug_subtext("B=3");

                    guard_code_availability();

                    guard_power(NONE);

                    toggle_switch(ROOM.SWITCH_RIGHT);
                },
                lever_1 = @install() {
                    debug_subtext("B=4");

                    guard_code_availability();

                    guard_power(NONE);
                    
                    toggle_switch(ROOM.SWITCH_LEFT);
                },
                b_trigger_5 = @install() {
                    debug_subtext("B=5");
                },
            }

            fun trigger_enter() {
                default_metro_init_room();
                
                // object[0x00] = 0x01; // toggle lever_1
                // object[0x01] = 0x01; // toggle lever_2
                // object[0x02] = 0x7e; // change layout_hidden_door (0-9 = open space, 10-12 = open door)
                // object[0x03] = 0x01; // toggle lever_3_1
                // object[0x04] = 0x01; // toggle lever_3_2
                // object[0x05] = 0x01; // toggle lever_3_3

                update_switches();
                restore_object_animator(SECRET_OPEN, ROOM.CODE_SOLVED, 0x02);

                default_init_room(False, False);

                // plot_code();
            }
        };
    };

    area metro_rooms_northeast() { // cells: (a3, a4) + ([b3], b4)
        map junkyard_northeast(OMNITOPIA_JUNKYARD) { // cells: b3
            enum entrance {
                north = entrance(0d62, 0d22, NONE, { door_act4_beam_in(); }),
                teleporter = entrance(0d21, 0d79, NONE, { teleporter_in(SOUTH); }),

                crash_north = entrance(0x58, 0x1c, NONE),
                crash_south = entrance(0x5f, 0x4f, NONE),
                crash_west = entrance(0x0a, 0x3a, NONE),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                stepon_0 = @install() {
                    debug_subtext("S=0");
                },
                stepon_1 = @install() {
                    debug_subtext("S=1");
                },
                stepon_2 = @install() {
                    debug_subtext("S=2");
                },
                stepon_3 = @install() {
                    debug_subtext("S=3");
                },
                stepon_4 = @install() {
                    debug_subtext("S=4");
                },
                stepon_5 = @install() {
                    debug_subtext("S=5");
                },
                stepon_6 = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                stepon_8 = @install() {
                    debug_subtext("S=8");
                },
                stepon_9 = @install() {
                    debug_subtext("S=9");
                },

                stepon_10 = @install() {
                    debug_subtext("S=10");
                },
                exit_north = @install() {
                    debug_subtext("S=11");

                    guard_entrance_gate(SOULS_MEMORY.CLEARANCE_VAULT_NORTH_EAST, True);

                    door_act4_beam_out(0d62, 0d22);

                    map_transition(metro, door_b3, NONE);
                },
                teleporter = @install() {
                    debug_subtext("S=12");

                    teleporter_out(0d21, 0d79);

                    map_transition(eastern_waterfall, swirl, NONE);
                },
            }
            
            fun trigger_enter() {
                if!(FLAG.IN_ANIMATION) {
                    crash_both();
                }

                add_radiating_tentacle(0d41, 0d33);
                add_radiating_tentacle(0d48, 0d35);
                add_radiating_tentacle(0d57, 0d36);

                fallout_init(False, False);
            }
        };

        map reactor_room(OMNITOPIA_REACTOR) { // cells: (a3, a4) + b4
            enum entrance {
                north = entrance(0x2c, 0x0d, NONE, { door_act4_beam_in(); }),
                east = entrance(0x3e, 0x3b, NONE, { door_act4_beam_in(); }),

                lever_room = entrance(0x52, 0x0d, NONE, { door_act4_beam_in(); }),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                SWITCH = AREA_METRO.LEVER_REACTOR_ROOM,

                HEATER_RADIATION_START_1 = 0d0116,
                HEATER_RADIATION_START_2 = 0d0228,
                HEATER_RADIATION_START_3 = 0d0340,
                HEATER_RADIATION_START_4 = 0d0452,

                HEATER_OFFSET_START = 0d20,
                HEATER_OFFSET_END = 0d80,
            }

            fun update_switches(with_text) {
                if(ROOM.SWITCH) {
                    object[0x1e] = 0x01; // toggle lever

                    object[0x13] = 0x01; // activate machine_top_1

                    object[0x1a] = 0x01; // activate machine_top_8
                    object[0x1b] = 0x01; // activate machine_front_1
                    object[0x1c] = 0x01; // activate machine_front_2
                    object[0x1d] = 0x01; // activate machine_front_3

                    if(with_text) {
                        subtext("Generator ON");
                    }
                } else {
                    object[0x1e] = 0x00; // toggle lever

                    object[0x13] = 0x00; // activate machine_top_1

                    object[0x1a] = 0x00; // activate machine_top_8
                    object[0x1b] = 0x00; // activate machine_front_1
                    object[0x1c] = 0x00; // activate machine_front_2
                    object[0x1d] = 0x00; // activate machine_front_3

                    if(with_text) {
                        subtext("Generator OFF");
                    }
                }
            }
            fun toggle_switch() {
                ROOM.SWITCH = !ROOM.SWITCH;

                update_switches(True);
            }

            fun heater_touched(direction:FACE_DIRECTION) {
                if(CUSTOM_MEMORY.CURRENT_ARMOR_CHEST != ARMOR_STATS.CHEST_2_3) {
                    act4_heater_touched(direction);
                }
            }

            enum stepon_trigger {
                exit_lever_room = @install() {
                    debug_subtext("S=0");

                    door_act4_beam_out(0d82, 0d13);

                    map_transition(metro, door_a4, NONE);
                },
                exit_north = @install() {
                    debug_subtext("S=1");

                    door_act4_beam_out(0d44, 0d13);

                    map_transition(metro, door_a3, NONE);
                },
                exit_east = @install() {
                    debug_subtext("S=2");

                    door_act4_beam_out(0d62, 0d59);

                    map_transition(metro, door_b4, NONE);
                },
                heater_2_1_south = @install() {
                    debug_subtext("S=3");

                    heater_touched(NORTH);
                },
                heater_2_2_north = @install() {
                    debug_subtext("S=4");

                    heater_touched(SOUTH);
                },
                heater_1_1_2_south = @install() {
                    debug_subtext("S=5");
                },
                heater_1_1_2_north = @install() {
                    debug_subtext("S=6");

                    heater_touched(SOUTH);
                },
                heater_1_5_south = @install() {
                    debug_subtext("S=7");

                    heater_touched(NORTH);
                },
                heater_1_5_north = @install() {
                    debug_subtext("S=8");

                    heater_touched(SOUTH);
                },
                heater_1_3_south = @install() {
                    debug_subtext("S=9");

                    heater_touched(NORTH);
                },

                heater_1_4_south = @install() {
                    debug_subtext("S=10");

                    heater_touched(NORTH);
                },
                heater_1_3_north = @install() {
                    debug_subtext("S=11");

                    heater_touched(SOUTH);
                },
                heater_1_4_north = @install() {
                    debug_subtext("S=12");

                    heater_touched(SOUTH);
                },
                heater_2_5_north = @install() {
                    debug_subtext("S=13");

                    heater_touched(SOUTH);
                },
                heater_2_5_south = @install() {
                    debug_subtext("S=14");

                    heater_touched(NORTH);
                },
                heater_2_2_north = @install() {
                    debug_subtext("S=15");

                    heater_touched(SOUTH);
                },
                heater_2_2_south = @install() {
                    debug_subtext("S=16");

                    heater_touched(NORTH);
                },
                heater_2_3_4_north = @install() {
                    debug_subtext("S=17");

                    heater_touched(SOUTH);
                },
                heater_2_3_4_south = @install() {
                    debug_subtext("S=18");

                    heater_touched(NORTH);
                },
                heater_3_1_south = @install() {
                    debug_subtext("S=19");

                    heater_touched(NORTH);
                },

                heater_3_1_north = @install() {
                    debug_subtext("S=20");

                    heater_touched(SOUTH);
                },
                heater_3_2_south = @install() {
                    debug_subtext("S=21");

                    heater_touched(NORTH);
                },
                heater_3_2_north = @install() {
                    debug_subtext("S=22");

                    heater_touched(SOUTH);
                },
                heater_3_3_4_south = @install() {
                    debug_subtext("S=23");

                    heater_touched(NORTH);
                },
                heater_3_3_4_north = @install() {
                    debug_subtext("S=24");

                    heater_touched(SOUTH);
                },
                heater_4_3_south = @install() {
                    debug_subtext("S=25");

                    heater_touched(NORTH);
                },
                heater_4_3_north = @install() {
                    debug_subtext("S=26");

                    // heater_touched(SOUTH);
                    heater_touched(NONE);
                },
                heater_4_1_2_north = @install() {
                    debug_subtext("S=27");

                    // act4_heater_touched(SOUTH);
                    act4_heater_touched(NONE);
                },
            }

            enum b_trigger {
                lever = @install() {
                    debug_subtext("B=0");

                    toggle_switch();
                },
                gourd = @install() {
                    debug_subtext("B=1");
                },
            }

            fun trigger_enter() {
                default_metro_init_room();
                
                update_switches(False);

                default_init_room(False, False);

                while(True) {
                    if(<BOY>[X] < 0d400) {
                        if((<BOY>[Y] > (ROOM.HEATER_RADIATION_START_1 + ROOM.HEATER_OFFSET_START)) && (<BOY>[Y] < (ROOM.HEATER_RADIATION_START_1 + ROOM.HEATER_OFFSET_END))) {
                            MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                            damage(BOY, 0d1, True);
                        } else if((<BOY>[Y] > (ROOM.HEATER_RADIATION_START_2 + ROOM.HEATER_OFFSET_START)) && (<BOY>[Y] < (ROOM.HEATER_RADIATION_START_2 + ROOM.HEATER_OFFSET_END))) {
                            MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                            damage(BOY, 0d1, True);
                        } else if((<BOY>[Y] > (ROOM.HEATER_RADIATION_START_3 + ROOM.HEATER_OFFSET_START)) && (<BOY>[Y] < (ROOM.HEATER_RADIATION_START_3 + ROOM.HEATER_OFFSET_END))) {
                            MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                            damage(BOY, 0d1, True);
                        } else if((<BOY>[Y] > (ROOM.HEATER_RADIATION_START_4 + ROOM.HEATER_OFFSET_START)) && (<BOY>[Y] < (ROOM.HEATER_RADIATION_START_4 + ROOM.HEATER_OFFSET_END))) {
                            MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                            damage(BOY, 0d1, True);
                        }
                    }

                    sleep(0d60);
                }
            }
        };
    };

    area metro_rooms_south() { // cells: c3, c4, d1, d2, d3, [d4]
        map junkyard_south(OMNITOPIA_JUNKYARD) { // cells: d4
            enum entrance {
                north = entrance(0d62, 0d22, NONE, { door_act4_beam_in(); }),
                teleporter = entrance(0d21, 0d79, NONE, { teleporter_in(SOUTH); }),

                crash_north = entrance(0x58, 0x1c, NONE),
                crash_south = entrance(0x5f, 0x4f, NONE),
                crash_west = entrance(0x0a, 0x3a, NONE),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                stepon_0 = @install() {
                    debug_subtext("S=0");
                },
                stepon_1 = @install() {
                    debug_subtext("S=1");
                },
                stepon_2 = @install() {
                    debug_subtext("S=2");
                },
                stepon_3 = @install() {
                    debug_subtext("S=3");
                },
                stepon_4 = @install() {
                    debug_subtext("S=4");
                },
                stepon_5 = @install() {
                    debug_subtext("S=5");
                },
                stepon_6 = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                stepon_8 = @install() {
                    debug_subtext("S=8");
                },
                stepon_9 = @install() {
                    debug_subtext("S=9");
                },

                stepon_10 = @install() {
                    debug_subtext("S=10");
                },
                exit_north = @install() {
                    debug_subtext("S=11");

                    door_act4_beam_out(0d62, 0d22);

                    map_transition(metro, door_d4, NONE);
                },
                teleporter = @install() {
                    debug_subtext("S=12");

                    teleporter_out(0d21, 0d79);

                    map_transition(jungle_portal, teleporter, NONE);
                },
            }
            
            fun trigger_enter() {
                if!(FLAG.IN_ANIMATION) {
                    crash_both();
                }

                default_init_room(False, False);
            }
        };

        map toaster_arena(RAPTORS) {
            enum entrance {
                left = entrance(0x15, 0x1c, NONE),
                center = entrance(0x1e, 0x21, NONE),
                right = entrance(0x2a, 0x23, NONE)
            }

            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                exit_north = nop(),
                exit_south = nop(),
                center = nop(),
            }

            fun close_exits(close) {
                if(close) {
                    object[0x04] = 0x04;
                } else {
                    object[0x05] = 0x04;
                }
            }

            group boss_ai() {
                enum BOSS {
                    HEAL_AMOUNT = 0d15,

                    HIT_COUNT_MEMORY = memory(WORD, TEMP),
                    HIT_COUNT = 0d10,

                    DELAY = 0d60,
                }

                fun boss_defeated() {
                    control(NONE);

                    find_all(GATE_BOT, {
                        attribute(arg[0x10], INVINCIBLE, True);
                        animate(arg[0x10], ONCE_FREEZE, ANIMATION_ENEMY.GATE_BOT_DEAD);
                    });

                    souls_boss_defeated(DEAD_TOASTER_ARENA, REWARD_TOASTER_ARENA);

                    map_transition(metro, door_c4, NONE);
                }
                fun guard_boss_defeated() {
                    if(BOSS.HIT_COUNT_MEMORY <= 0d0) {
                        end();
                    }
                }

                fun boss_hit() {
                    if(BOSS.HIT_COUNT_MEMORY > 0d0) {
                        BOSS.HIT_COUNT_MEMORY--;

                        if(BOSS.HIT_COUNT_MEMORY <= 0d0) {
                            boss_defeated();
                        } else {
                            MEMORY.STRING_PARAMETER_1 = BOSS.HIT_COUNT_MEMORY;
                            MEMORY.STRING_PARAMETER_2 = BOSS.HIT_COUNT;

                            subtext("[MEM1]/[MEM2]");
                        }
                    }
                }
                fun spawn_guardbot(x, y) {
                    add_enemy(GATE_BOT, x, y);
                    <LAST_ENTITY>[HP] = SYSTEM.HP_MAX;
                    attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                        if!(
                            (<SCRIPT_OWNER>[X] >= MEMORY.CAMERA_X_MIN) &&
                            (<SCRIPT_OWNER>[X] <= MEMORY.CAMERA_X_MAX) &&
                            (<SCRIPT_OWNER>[Y] >= MEMORY.CAMERA_Y_MIN) &&
                            (<SCRIPT_OWNER>[Y] <= MEMORY.CAMERA_Y_MAX)
                        ) {
                            heal(SCRIPT_OWNER, 0d0, False);
                            end();
                        }

                        boss_hit();

                        yield();
                        attribute(SCRIPT_OWNER, INVINCIBLE, True);

                        animate(SCRIPT_OWNER, ONCE_FREEZE, ANIMATION_ENEMY.GATE_BOT_DEAD);

                        sleep(0d500);

                        guard_boss_defeated();

                        cast(SCRIPT_OWNER, SCRIPT_OWNER, HEAL, BOSS.HEAL_AMOUNT);
                        sleep(0d250);

                        guard_boss_defeated();

                        animate(SCRIPT_OWNER, ONCE, DEFAULT);
                        attribute(SCRIPT_OWNER, INVINCIBLE, False);
                    }));
                }

                fun add_boss() {
                    BOSS.HIT_COUNT_MEMORY = BOSS.HIT_COUNT;

                    spawn_guardbot(0x29, 0x2b);
                    spawn_guardbot(0x13, 0x29);
                    spawn_guardbot(0x29, 0x1b);
                    spawn_guardbot(0x13, 0x19);
                }
            };

            fun trigger_enter() {
                close_exits(True);

                prepare_dog_arena(TOASTER);
                default_metro_init_room(reference(@install() {
                    metro_death_trigger({
                        map_transition(metro, door_c4, NONE);
                    });
                }));
                
                attribute(DOG, INVINCIBLE_TEMP, True);

                add_boss();

                sleep(0d120);
                attribute(DOG, INVINCIBLE_TEMP, False);
            }
        };

        map turret_arena(RAPTORS) {
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            enum entrance {
                left = entrance(0x15, 0x1c, NONE),
                center = entrance(0x1e, 0x21, NONE),
                right = entrance(0x2a, 0x23, NONE)
            }

            enum stepon_trigger {
                exit_north = nop(),
                exit_south = nop(),
                center = nop(),
            }

            fun close_exits(close) {
                if(close) {
                    object[0x04] = 0x04;
                } else {
                    object[0x05] = 0x04;
                }
            }

            group boss_ai() {
                enum BOSS {
                    DEBUG = False,

                    RIDER_1_ID = memory(WORD, TEMP),
                    MOUNT_1_ID = memory(WORD, TEMP),

                    RIDER_2_ID = memory(WORD, TEMP),
                    MOUNT_2_ID = memory(WORD, TEMP),

                    HP = 0d60,

                    PHASE = memory(WORD, TEMP),
                    TIMER = memory(WORD, TEMP),
                }

                fun boss_defeated() {
                    control(NONE);

                    souls_boss_defeated(DEAD_TURRET_ARENA, REWARD_TURRET_ARENA);

                    map_transition(metro, door_d3, NONE);
                }

                @install()
                fun boss_hit() {
                    if(_dead(BOSS.RIDER_1_ID) && _dead(BOSS.RIDER_2_ID)) {
                        boss_defeated();
                    }
                }

                @install()
                @async()
                fun stack_t01_t23() {
                    while(True) {
                        if(alive(BOSS.RIDER_1_ID)) {
                            BOSS.RIDER_1_ID[X] = BOSS.MOUNT_1_ID[X];
                            BOSS.RIDER_1_ID[Y] = BOSS.MOUNT_1_ID[Y] - 0x15;
                            yield();
                        }
                        if(alive(BOSS.RIDER_2_ID)) {
                            BOSS.RIDER_2_ID[X] = BOSS.MOUNT_2_ID[X];
                            BOSS.RIDER_2_ID[Y] = BOSS.MOUNT_2_ID[Y] - 0x15;
                            yield();
                        }

                        yield();
                    }
                }

                fun turret(id_1, id_2, mount_type) {
                    add_enemy(GATE_BOT, 0d29, 0d29);
                    <LAST_ENTITY>[HP] = BOSS.HP;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(boss_hit));
                    teleport(LAST_ENTITY, 0d19, 0d29);
                    id_1 = <LAST_ENTITY>;

                    add_enemy(mount_type, 0d29, 0d29);
                    teleport(LAST_ENTITY, 0d40, 0d33);
                    id_2 = <LAST_ENTITY>;

                    if!(BOSS.DEBUG) {
                        attribute(LAST_ENTITY, INVISIBLE, True);
                    }
                    attribute(LAST_ENTITY, INVINCIBLE, True);
                    attribute(LAST_ENTITY, MUTE, True);
                }

                fun spawn_boss() {
                    turret(BOSS.RIDER_1_ID, BOSS.MOUNT_1_ID, ENEMY.MOSQUITO);
                    turret(BOSS.RIDER_2_ID, BOSS.MOUNT_2_ID, ENEMY.BEE);

                    stack_t01_t23();
                }
            };

            fun trigger_enter() {
                close_exits(True);

                CUSTOM_FLAG.NO_DOG = True;
                default_metro_init_room(reference(@install() {
                    metro_death_trigger({
                        map_transition(metro, door_d3, NONE);
                    });
                }));
                
                MEMORY.AMMO_1 = 0d100;
                MEMORY.GAIN_WEAPON = GAIN_WEAPON.BAZOOKA_TEMP;

                attribute(BOY, INVINCIBLE_TEMP, True);
                spawn_boss();

                sleep(0d120);
                attribute(BOY, INVINCIBLE_TEMP, False);
            }
        };

        map ar_lab(OMNITOPIA_PROFESSOR) {
            enum ROOM {
                DOOR_PASSAGE_SOUTH_OPEN = memory(FLAG, TEMP),
                DOOR_PASSAGE_NORTH_OPEN = memory(FLAG, TEMP),

                SWITCH = memory(FLAG, SRAM),

                EVERMORE_MACHINE_LEFT = memory(WORD, TEMP),
                EVERMORE_MACHINE_RIGHT = memory(WORD, TEMP),
                EVERMORE_MACHINE_TARGET = memory(WORD, TEMP),

                GOURD_LOOTED = memory(FLAG, SRAM),
            }

            @install()
            @async()
            fun evermore_machine() {
                while(True) {
                    if(ROOM.SWITCH) {
                        arg[0x10] = ROOM.EVERMORE_MACHINE_TARGET;
                        arg[0x12] = arg[0x10][Z] / 0d10;
                        if(arg[0x12] > 0d70) {
                            arg[0x12] = 0d70;
                        }

                        if(False) {
                            debug_memory(arg[0x10], arg[0x10][Z] / 0d9);
                        }
                        
                        if(arg[0x10] == 0x0000) {
                            shoot_entity_entity(ROOM.EVERMORE_MACHINE_LEFT, LIGHTNING, ROOM.EVERMORE_MACHINE_RIGHT, 0d10, 0d10);
                            sleep(0d10);

                            shoot_entity_entity(ROOM.EVERMORE_MACHINE_RIGHT, LIGHTNING, ROOM.EVERMORE_MACHINE_LEFT, 0d10, 0d10);
                            sleep(0d20);
                        } else {
                            shoot_entity_entity_offset(ROOM.EVERMORE_MACHINE_LEFT, LIGHTNING, arg[0x10], 0d0, -(arg[0x12]), 0d10, 0d10);
                            sleep(0d5);

                            shoot_entity_entity_offset(ROOM.EVERMORE_MACHINE_RIGHT, LIGHTNING, arg[0x10], 0d0, -(arg[0x12]), 0d10, 0d10);
                            sleep(0d10);
                        }
                    } else {
                        sleep(0d30);
                    }
                }
            }
            fun init_evermore_machine() {
                if((ROOM.EVERMORE_MACHINE_LEFT == 0x0000) || (ROOM.EVERMORE_MACHINE_RIGHT == 0x0000)) {
                    add_enemy(PLACEHOLDER, 0d24, 0d75);
                    ROOM.EVERMORE_MACHINE_LEFT = <LAST_ENTITY>;
                    add_enemy(PLACEHOLDER, 0d28, 0d75);
                    ROOM.EVERMORE_MACHINE_RIGHT = <LAST_ENTITY>;

                    evermore_machine();
                }
            }
            @install()
            @async()
            fun enter_lightning_tracker() {
                sleep(0d5);

                while(<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                    sleep(0d5);
                }

                ROOM.EVERMORE_MACHINE_TARGET = 0x0000;
            }

            enum entrance {
                north = entrance(0x3e, 0x14, NONE, { door_act4_airlock_in(0x1a); }),
                east = entrance(0x58, 0x57, NONE, { door_act4_beam_in(); }),
                west = entrance(0x1a, 0x5b, NONE),
                
                cutscene_1 = entrance(0x34, 0x59, NONE), // in front of computer
                cutscene_2 = entrance(0x3e, 0x25, NONE), // intro fight

                evermore_machine = entrance(0d26, 0d88, NONE, {
                    control(NONE);

                    init_evermore_machine();
                    
                    act4_evermoremachine_out();
                    yield();
                    ROOM.EVERMORE_MACHINE_TARGET = <BOY>;
                    enter_lightning_tracker();
                }),
            }
        
            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            @install()
            fun change_machine(color, on) {
                if(color == 0d0) {
                    object[0x05] = 0x00; // remove machine_wood_west
                    object[0x06] = 0x00; // remove machine_wood_south
                    object[0x07] = 0x00; // remove machine_wood_east
                    object[0x08] = 0x00; // change vent_1 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x09] = 0x00; // change vent_2 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x0a] = 0x00; // change vent_3 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x0b] = 0x00; // change vent_4 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x0f] = 0x00; // change vent_floor_1 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x10] = 0x00; // change vent_floor_2 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x11] = 0x00; // change vent_floor_3 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x12] = 0x00; // change vent_floor_4 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x13] = 0x00; // hide leaves_1
                    object[0x14] = 0x00; // hide leaves_2
                    object[0x15] = 0x00; // hide leaves_3
                    object[0x16] = 0x00; // hide leaves_4
                    object[0x17] = 0x00; // change machine_1 (0 = brown, 1 = grey)
                    object[0x18] = 0x00; // change machine_2 (0 = brown, 1 = grey)
                } else if(color == 0d1) {
                    object[0x05] = 0x01; // remove machine_wood_west
                    object[0x06] = 0x01; // remove machine_wood_south
                    object[0x07] = 0x01; // remove machine_wood_east
                    object[0x08] = 0x02; // change vent_1 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x09] = 0x02; // change vent_2 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x0a] = 0x02; // change vent_3 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x0b] = 0x02; // change vent_4 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x0f] = 0x02; // change vent_floor_1 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x10] = 0x02; // change vent_floor_2 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x11] = 0x02; // change vent_floor_3 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x12] = 0x02; // change vent_floor_4 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                    object[0x13] = 0x01; // hide leaves_1
                    object[0x14] = 0x01; // hide leaves_2
                    object[0x15] = 0x01; // hide leaves_3
                    object[0x16] = 0x01; // hide leaves_4
                    object[0x17] = 0x01; // change machine_1 (0 = brown, 1 = grey)
                    object[0x18] = 0x01; // change machine_2 (0 = brown, 1 = grey)
                }

                if(on) {
                    object[0x0c] = 0x01; // activate bulb_left
                    object[0x0d] = 0x01; // activate bulb_right
                    object[0x0e] = 0x01; // activate lights_right
                    object[0x19] = 0x01; // activate lights_left
                } else {
                    object[0x0c] = 0x00; // activate bulb_left
                    object[0x0d] = 0x00; // activate bulb_right
                    object[0x0e] = 0x00; // activate lights_right
                    object[0x19] = 0x00; // activate lights_left
                }
            }

            fun update_switches(with_text) {
                if(ROOM.SWITCH) {
                    change_machine(True, True);

                    yield();
                    object[0x1b] = 0x01; // toggle lever
                    yield();

                    if(with_text) {
                        subtext("AR Game ON");
                    }
                } else {
                    change_machine(True, False);

                    yield();
                    object[0x1b] = 0x00; // toggle lever
                    yield();

                    if(with_text) {
                        subtext("AR Game OFF");
                    }
                }
            }
            fun toggle_switch(flag_switch) {
                flag_switch = !flag_switch;

                update_switches(True);
            }

            enum stepon_trigger {
                door_passage_north_north = @install() {
                    debug_subtext("S=0");

                    door_act4_passage(0x04, ROOM.DOOR_PASSAGE_NORTH_OPEN);
                },
                door_passage_north_south = @install() {
                    debug_subtext("S=1");

                    door_act4_passage(0x04, ROOM.DOOR_PASSAGE_NORTH_OPEN);
                },
                door_passage_south_north = @install() {
                    debug_subtext("S=2");

                    door_act4_passage(0x00, ROOM.DOOR_PASSAGE_SOUTH_OPEN);
                },
                door_passage_south_south = @install() {
                    debug_subtext("S=3");

                    door_act4_passage(0x00, ROOM.DOOR_PASSAGE_SOUTH_OPEN);
                },
                exit_east = @install() {
                    debug_subtext("S=4");

                    door_act4_beam_out(0d88, 0d87);

                    map_transition(metro, door_d1, NONE);
                },
            }

            enum b_trigger {
                gourd = @install() {
                    debug_subtext("B=0");

                    if!(SOULS_MEMORY.DEAD_SPACESHIP_DESERT && SOULS_MEMORY.DEAD_ABOMINATION) {
                        subtext("Requires 2 arcade coins.");
                    } else {
                        ROOM.GOURD_LOOTED = True;

                        object[0x01] = 0x7e;

                        reward(ENERGY_CORE);
                    }
                },
                door_north = @install() {
                    debug_subtext("B=1");

                    if!(SOULS_MEMORY.DEAD_SPACESHIP_DESERT) {
                        fog_wall_outside(True, NONE);

                        door_act4_airlock_out(0d62, 0d20, 0x1a, True);

                        map_transition(spaceship_desert, south, NONE);
                    } else {
                        error_message(DOOR_COMPLETED);
                    }
                },
                lever = @install() {
                    debug_subtext("B=2");

                    guard_power(NONE);

                    toggle_switch(ROOM.SWITCH);
                },
            }

            @install()
            @async()
            fun fake_exit_scanner(entity) {
                range_checker(entity, <ACTIVE>, 0x20, 0x20, {
                    if(ROOM.SWITCH) {
                        fog_wall_outside(True, NONE);

                        ROOM.EVERMORE_MACHINE_TARGET = <BOY>;
                        act4_evermoremachine_in(0d26, 0d88);

                        map_transition(podunk_old, west, NONE);
                    }
                });
            }

            fun trigger_enter() {
                if(ROOM.GOURD_LOOTED) {
                    object[0x01] = 0x7e;
                }
                
                default_metro_init_room(reference(@install() {
                    metro_death_trigger({
                        map_transition(metro, door_d1, NONE);
                    });
                }));

                if!(SOULS_MEMORY.DEAD_ABOMINATION) {
                    add_enemy(PLACEHOLDER, 0d26, 0d88 - 0d2);
                    fake_exit_scanner(<LAST_ENTITY>);
                }

                update_switches(False);
                init_evermore_machine();

                // object[0x00] = 0x7e; // open door_passage_south
                // object[0x01] = 0x7e; // open gourd
                // object[0x02] = 0x7e; // open door_floor_left
                // object[0x03] = 0x7e; // open door_floor_left
                // object[0x04] = 0x7e; // open door_passage_north

                // object[0x05] = 0x01; // remove machine_wood_west
                // object[0x06] = 0x01; // remove machine_wood_south
                // object[0x07] = 0x01; // remove machine_wood_east
                // object[0x08] = 0x02; // change vent_1 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x09] = 0x02; // change vent_2 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x0a] = 0x02; // change vent_3 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x0b] = 0x02; // change vent_4 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x0c] = 0x01; // activate bulb_left
                // object[0x0d] = 0x01; // activate bulb_right
                // object[0x0e] = 0x01; // activate lights_right
                // object[0x0f] = 0x02; // change vent_floor_1 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x10] = 0x02; // change vent_floor_2 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x11] = 0x02; // change vent_floor_3 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x12] = 0x02; // change vent_floor_4 (0 = brown+off, 1 = brown+on, 2 = grey+on)
                // object[0x13] = 0x01; // hide leaves_1
                // object[0x14] = 0x01; // hide leaves_2
                // object[0x15] = 0x01; // hide leaves_3
                // object[0x16] = 0x01; // hide leaves_4
                // object[0x17] = 0x01; // change machine_1 (0 = brown, 1 = grey)
                // object[0x18] = 0x01; // change machine_2 (0 = brown, 1 = grey)
                // object[0x19] = 0x01; // activate lights_left

                // object[0x1a] = 0x7e; // open door_north
                // object[0x1b] = 0x7e; // activate switch
            }
        };

        map spaceship_desert(DESERT) {
            enum entrance {
                test = entrance(0d60, 0d146, NONE, { desert_screen(0d4, 0d0); }),

                north = entrance(0x3b, 0x19, WEST, { desert_screen(0d4, 0d17); }),
                south = entrance(0x33, 0x9e, NONE, { desert_screen(0d4, 0d0); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_METRO.MUSIC_DEFAULT, 0xff)
            }

            fun update_camera() {
                if(False) {
                    if(<BOY>[Y] <= (MEMORY.CAMERA_BOUNDRY_Y_END - 0d40)) {
                        MEMORY.CAMERA_BOUNDRY_Y_END -= 0d2;
                    } else {
                        MEMORY.CAMERA_BOUNDRY_Y_END = <BOY>[Y] + 0d40;
                    }
                } else {
                    MEMORY.CAMERA_BOUNDRY_Y_END = <BOY>[Y] + 0d40;
                }
            }

            enum ROOM {
                DEBUG = False,
                WITH_WRAP = True,
                
                X_MAX = 0d7,
                Y_MAX = 0d100,

                DAMAGE_TIME = 0d60, // 0d720,
                DAMAGE_TICK = 0d5,

                ID_SHIP_SOUTH = memory(WORD, TEMP),
                ID_SHIP_NORTH = memory(WORD, TEMP),
                ID_ALCHEMIST = memory(WORD, TEMP),

                HAS_OASIS = memory(FLAG, TEMP),
                HAS_SHIP_NORTH = memory(FLAG, TEMP),
                HAS_SHIP_SOUTH = memory(FLAG, TEMP),
                HAS_ALCHEMIST = memory(FLAG, TEMP),

                SHIP_ID = memory(WORD, TEMP),
                SHIP_FIRE_ID = memory(WORD, TEMP),
                SHIP_PALETTE_ID = memory(WORD, TEMP),
                
                PAUSE = memory(WORD, TEMP),
                JUMPING = memory(FLAG, TEMP),
            }

            fun show_oasis(show) {
                if(show) {
                    object[0x00] = 0x01; // show oasis
                } else {
                    object[0x00] = 0x00; // show oasis
                }
            }

            fun add_skeleton_ship(id, object_id, x, y) {
                if(False) {
                    add_placeholder(SKELETON_SHIP_2, x, y, ONCE_FREEZE);
                    id = <LAST_ENTITY>;
                    animate(LAST_ENTITY, FREEZE, ANIMATION_PLACEHOLDER.SKELETON_SHIP_2);

                    if(object_id == 0d1) {
                        object[0x01] = 0x01; // add ship_south_hitbox
                    } else if(object_id == 0d2) {
                        object[0x02] = 0x00; // remove ship_north_hitbox
                    }
                }
            }
            fun remove_skeleton_ship(id, object_id) {
                destroy(id);

                if(object_id == 0d1) {
                    object[0x01] = 0x00; // add ship_south_hitbox
                } else if(object_id == 0d2) {
                    object[0x02] = 0x01; // remove ship_north_hitbox
                }
            }

            fun add_alchemist(x, y) {
                add_enemy(VILLAGER_2_8, x, y, INACTIVE);
                ROOM.ID_ALCHEMIST = <LAST_ENTITY>;
                face(LAST_ENTITY, SOUTH);
            }
            fun remove_alchemist(id) {
                destroy(id);
            }

            @install()
            fun update_desert() {
                arg[0x00] = MEMORY.DESERT_X;
                arg[0x02] = MEMORY.DESERT_Y;

                if(ROOM.DEBUG) {
                    debug_memory(arg[0x00], arg[0x02]);
                }

                ROOM.HAS_OASIS = False;
                ROOM.HAS_SHIP_NORTH = False;
                ROOM.HAS_SHIP_SOUTH = False;
                ROOM.HAS_ALCHEMIST = False;

                if(arg[0x02] == 0d0) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                        ROOM.HAS_SHIP_SOUTH = True;
                    } else if(arg[0x00] == 0d7) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d1) {
                    if(arg[0x00] == 0d2) {
                        ROOM.HAS_OASIS = True;
                    } else if(arg[0x00] == 0d5) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d2) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d3) {
                    if(arg[0x00] == 0d3) {
                        ROOM.HAS_OASIS = True;
                    } else if(arg[0x00] == 0d6) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d4) {
                    if(arg[0x00] == 0d5) {
                        ROOM.HAS_OASIS = True;
                        ROOM.HAS_ALCHEMIST = True;
                    }
                } else if(arg[0x02] == 0d5) {
                    if(arg[0x00] == 0d3) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d6) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d7) {
                    if(arg[0x00] == 0d1) {
                        ROOM.HAS_OASIS = True;

                    } else if(arg[0x00] == 0d6) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d8) {
                    nop();
                } else if(arg[0x02] == 0d9) {
                    if(arg[0x00] == 0d2) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d10) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d11) {
                    if(arg[0x00] == 0d6) {
                        ROOM.HAS_OASIS = True;
                        ROOM.HAS_ALCHEMIST = True;
                    }
                } else if(arg[0x02] == 0d12) {
                    if(arg[0x00] == 0d3) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d13) {
                    nop();
                } else if(arg[0x02] == 0d14) {
                    if(arg[0x00] == 0d2) {
                        ROOM.HAS_OASIS = True;
                    } else if(arg[0x00] == 0d5) {
                        ROOM.HAS_OASIS = True;
                    }
                } else if(arg[0x02] == 0d15) {
                    nop();
                } else if(arg[0x02] == 0d16) {
                    nop();
                } else if(arg[0x02] == 0d17) {
                    if(arg[0x00] == 0d4) {
                        ROOM.HAS_SHIP_NORTH = True;
                    }
                }

                if(ROOM.HAS_OASIS) {
                    show_oasis(True);
                } else {
                    show_oasis(False);
                }

                if(ROOM.HAS_SHIP_SOUTH) {
                    add_skeleton_ship(ROOM.ID_SHIP_SOUTH, 0d1, 0x45, 0x94);
                } else {
                    remove_skeleton_ship(ROOM.ID_SHIP_SOUTH, 0d1);
                }

                if(ROOM.HAS_SHIP_NORTH) {
                    add_skeleton_ship(ROOM.ID_SHIP_NORTH, 0d2, 0x45, 0x35);
                } else {
                    remove_skeleton_ship(ROOM.ID_SHIP_NORTH, 0d2);
                }

                if(ROOM.HAS_ALCHEMIST) {
                    add_alchemist(0x51, 0x9f);
                } else {
                    remove_alchemist(ROOM.ID_ALCHEMIST);
                }

                update_camera();
            }

            @install()
            fun scroll_desert_north() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_Y < ROOM.Y_MAX) {
                        MEMORY.DESERT_Y++;

                        teleport_screen(0d0, 0d2);
                        update_desert();
                    }
                }
            }
            @install()
            fun scroll_desert_east() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_X < ROOM.X_MAX) {
                        MEMORY.DESERT_X++;
                    } else {
                        MEMORY.DESERT_X = 0d0;
                    }

                    teleport_screen(-0d2, 0d0);
                    update_desert();
                }
            }
            @install()
            fun scroll_desert_south() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_Y > 0d0) {
                        MEMORY.DESERT_Y--;

                        teleport_screen(0d0, -0d2);
                        update_desert();
                    }
                }
            }
            @install()
            fun scroll_desert_west() {
                if(ROOM.WITH_WRAP) {
                    if(MEMORY.DESERT_X > 0d0) {
                        MEMORY.DESERT_X--;
                    } else {
                        MEMORY.DESERT_X = ROOM.X_MAX;
                    }

                    teleport_screen(0d2, 0d0);
                    update_desert();
                }
            }

            enum stepon_trigger {
                sand_pit = @install() {
                    debug_subtext("S=0");
                },
                wrap_north_4 = scroll_desert_north(),
                wrap_north_3 = scroll_desert_north(),
                wrap_north_2 = scroll_desert_north(),
                wrap_north_1 = scroll_desert_north(),
                ship_north = @install() {
                    debug_subtext("S=5");
                },
                ship_south = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_south_1 = @install() {
                    debug_subtext("S=8");
                },
                exit_south_2 = @install() {
                    debug_subtext("S=9");
                },

                wrap_west_1 = scroll_desert_west(),
                wrap_east_2 = scroll_desert_east(),
                wrap_east_1 = scroll_desert_east(),
                wrap_west_2 = scroll_desert_west(),
                wrap_south_2 = scroll_desert_south(),
                wrap_south_1 = scroll_desert_south(),
                oasis = @install() {
                    debug_subtext("S=16");

                    if(ROOM.HAS_OASIS) {
                        full_heal(BOY, False);
                        full_heal(DOG, False);
                    }
                },
                exit_nobilia = @install() {
                    debug_subtext("S=17");

                    if(MEMORY.DESERT_Y != ROOM.Y_MAX) {
                        teleport_screen(0d0, 0d2);
                    }
                },
                stepon_18 = @install() {
                    debug_subtext("S=18");
                },
            }

            fun is_in_oasis(char:CHARACTER, callback) {
                //if((<BOY>[X] > 0d536) && (<BOY>[X] < (0d752)) && (<BOY>[Y] > 0d1216) && (<BOY>[Y] < 0d1392)) {
                if((<BOY>[X] > 0d536) && (<BOY>[X] < (0d752)) && (<BOY>[Y] > 0d1216) && (<BOY>[Y] < 0d1408)) {
                        nop();
                } else {
                    callback();
                }
            }
            fun desert_damage() {
                while(True) {
                    sleep(ROOM.DAMAGE_TIME);

                    is_in_oasis(BOY, {
                        damage(BOY, ROOM.DAMAGE_TICK, True, True);
                    });
                    is_in_oasis(DOG, {
                        damage(DOG, ROOM.DAMAGE_TICK, True, True);
                    });
                }
            }

            group boss_ai() {
                enum X_MODE {
                    LINE = 0d0,
                    LEFT = 0d1,
                    RIGHT = 0d2,
                }
                enum Y_MODE {
                    LINE = 0d0,
                    UP = 0d1,
                    DOWN = 0d2,
                }

                enum BOSS {
                    DEBUG = False,
                    DEBUG_BOY = False,

                    BOSS_ID = memory(WORD, TEMP),

                    X_MODE = memory(WORD, TEMP),
                    Y_MODE = memory(WORD, TEMP),

                    X = memory(WORD, TEMP), // 0…256
                    Y = memory(WORD, TEMP), // 0…224

                    BORDER_NORTH = 0d10,
                    BORDER_EAST = 0d256 - 0d25,
                    BORDER_WEST = 0d25,

                    BOSS_Y_YIELD = 0d600,

                    HP = 0d20000,
                    THRESHOLD_P1 = 0d18000,
                    THRESHOLD_P2 = 0d16000, // autoattack
                    THRESHOLD_P3 = 0d10000,
                    THRESHOLD_P4 = 0d08000, // autoattack

                    PHASE = memory(WORD, TEMP),

                    PATTERN = memory(WORD, TEMP),

                    PATTERN_SHOOTING = memory(FLAG, TEMP),
                    PATTERN_BOMBS = memory(FLAG, TEMP),
                    PATTERN_AUTOATTACK = memory(FLAG, TEMP),
                }

                fun boss_defeated() {
                    attribute(BOY, NO_CLIP, True);

                    control(NONE);

                    souls_boss_defeated(DEAD_SPACESHIP_DESERT, REWARD_SPACESHIP_DESERT);

                    map_transition(ar_lab, north, NONE);
                }
                
                @install()
                @async()
                fun boss_shoot_watcher() {
                    attach_to_script(BOSS.BOSS_ID);

                    sleep(0d30);

                    while!(dead(<SCRIPT_OWNER>)) {
                        while!(BOSS.PATTERN_SHOOTING) {
                            sleep(0d30);
                        }

                        while((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) || (<SCRIPT_OWNER>[Y] < BOSS.BOSS_Y_YIELD)) {
                            yield();
                        }

                        shoot_entity_relative(SCRIPT_OWNER, CITRON, 0d0, 0d100, 0d20, 0d0);

                        sleep(0d30);
                    }
                }
                @install()
                @async()
                fun boss_bomb_watcher() {
                    attach_to_script(BOSS.BOSS_ID);

                    sleep(0d180);

                    while!(dead(<SCRIPT_OWNER>)) {
                        while!(BOSS.PATTERN_BOMBS) {
                            sleep(0d30);
                        }

                        while((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) || (<SCRIPT_OWNER>[Y] < BOSS.BOSS_Y_YIELD)) {
                            yield();
                        }

                        // shoot_entity_relative(SCRIPT_OWNER, CITRON, 0d0, 0d100, 0d20, 0d0);
                        ai_move_bomb_toss(<SCRIPT_OWNER>, ONION, <BOY>, 0d0, -0d200);

                        sleep(0d30);
                    }
                }
                @install()
                @async()
                fun boss_autoattack_watcher() {
                    attach_to_script(BOSS.BOSS_ID);

                    sleep(0d60);

                    while!(dead(<SCRIPT_OWNER>)) {
                        control(SCRIPT_OWNER, True);

                        while((<SCRIPT_OWNER>[Y] < BOSS.BOSS_Y_YIELD) || (!BOSS.PATTERN_AUTOATTACK)) {
                            yield();
                        }

                        control(SCRIPT_OWNER, False);

                        while(<SCRIPT_OWNER>[Y] >= BOSS.BOSS_Y_YIELD) {
                            yield();
                        }
                    }
                }
                @install()
                @async()
                fun boss_movement_watcher() {
                    attach_to_script(BOSS.BOSS_ID);

                    while!(dead(<SCRIPT_OWNER>)) {
                        // animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.SKELETON_SHIP_ROW_1);
                                
                        if(BOSS.X_MODE == X_MODE.LINE) {
                            BOSS.X = 0d230;
                        } else if(BOSS.X_MODE == X_MODE.LEFT) {
                            if(BOSS.X > BOSS.BORDER_WEST) {
                                BOSS.X--;
                            } else {
                                BOSS.X_MODE = X_MODE.RIGHT;
                            }
                        } else if(BOSS.X_MODE == X_MODE.RIGHT) {
                            if(BOSS.X < BOSS.BORDER_EAST) {
                                BOSS.X++;
                            } else {
                                BOSS.X_MODE = X_MODE.LEFT;
                            }
                        }

                        if(BOSS.Y_MODE == Y_MODE.LINE) {
                            BOSS.Y = 0d25;
                        } else if(BOSS.Y_MODE == Y_MODE.UP) {
                            if(BOSS.Y > 0d25) {
                                BOSS.Y--;
                            } else {
                                BOSS.Y_MODE = Y_MODE.DOWN;
                            }
                        } else if(BOSS.Y_MODE == Y_MODE.DOWN) {
                            if(BOSS.Y < 0d75) {
                                BOSS.Y++;
                            } else {
                                BOSS.Y_MODE = Y_MODE.UP;
                            }
                        }

                        _teleport(SCRIPT_OWNER, MEMORY.CAMERA_X_MIN + BOSS.X, MEMORY.CAMERA_Y_MIN + BOSS.BORDER_NORTH + BOSS.Y);

                        sleep(0d2);
                    }
                }
                @install()
                @async()
                fun boss_watcher() {
                    attach_to_script(BOSS.BOSS_ID);

                    if(BOSS.DEBUG) {
                        debug_subtext("+boss");
                    }

                    BOSS.X = 0d256 / 0d2;
                    BOSS.Y = 0d25;

                    // only shooting

                    BOSS.X_MODE = X_MODE.LEFT;
                    BOSS.Y_MODE = Y_MODE.LINE;

                    BOSS.PATTERN_SHOOTING = True;
                    BOSS.PATTERN_AUTOATTACK = False;
                    BOSS.PATTERN_BOMBS = False;

                    while(BOSS.PHASE == 0d0) {
                        yield();
                    }

                    if(BOSS.DEBUG) {
                        debug_subtext("p1");
                    }

                    BOSS.X_MODE = X_MODE.LEFT;
                    BOSS.Y_MODE = Y_MODE.UP;

                    BOSS.PATTERN_SHOOTING = False;
                    BOSS.PATTERN_AUTOATTACK = True;
                    BOSS.PATTERN_BOMBS = False;

                    while(BOSS.PHASE <= 0d1) {
                        yield();
                    }

                    if(BOSS.DEBUG) {
                        debug_subtext("p2");
                    }

                    // shooting + bombs

                    BOSS.X_MODE = X_MODE.LEFT;
                    BOSS.Y_MODE = Y_MODE.LINE;

                    BOSS.PATTERN_SHOOTING = True;
                    BOSS.PATTERN_AUTOATTACK = False;
                    BOSS.PATTERN_BOMBS = True;

                    while(BOSS.PHASE <= 0d2) {
                        yield();
                    }

                    if(BOSS.DEBUG) {
                        debug_subtext("p3");
                    }

                    BOSS.X_MODE = X_MODE.LEFT;
                    BOSS.Y_MODE = Y_MODE.UP;

                    BOSS.PATTERN_SHOOTING = False;
                    BOSS.PATTERN_AUTOATTACK = True;
                    BOSS.PATTERN_BOMBS = False;

                    while(BOSS.PHASE <= 0d3) {
                        yield();
                    }

                    if(BOSS.DEBUG) {
                        debug_subtext("p4");
                    }

                    // here he comes

                    BOSS.X_MODE = X_MODE.LEFT;
                    BOSS.Y_MODE = Y_MODE.UP;

                    BOSS.PATTERN_SHOOTING = True;
                    BOSS.PATTERN_AUTOATTACK = True;
                    BOSS.PATTERN_BOMBS = True;

                    while(BOSS.PHASE <= 0d4) {
                        yield();
                    }

                    if(BOSS.DEBUG) {
                        debug_subtext("-boss");
                    }

                    boss_defeated();
                }
                fun add_boss() {
                    add_enemy(GATE_BOT, 0d0, 0d0, INACTIVE);
                    BOSS.BOSS_ID = <LAST_ENTITY>;
                    <LAST_ENTITY>[HP] = BOSS.HP;
                    attach_script(LAST_ENTITY, DAMAGE_DEATH, reference(@install() {
                        // animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.SKELETON_SHIP_1);

                        if(BOSS.DEBUG) {
                            damage(SCRIPT_OWNER, 0d3000 + randrange(0d500), True);
                        } else {
                            damage(SCRIPT_OWNER, 0d300 + randrange(0d500), True);
                        }

                        if(dead(<SCRIPT_OWNER>)) {
                            BOSS.PHASE = 0d5;
                        } else if(BOSS.PHASE == 0d0) {
                            if(<SCRIPT_OWNER>[HP] < BOSS.THRESHOLD_P1) {
                                BOSS.PHASE = 0d1;
                            }
                        } else if(BOSS.PHASE == 0d1) {
                            if(<SCRIPT_OWNER>[HP] < BOSS.THRESHOLD_P2) {
                                BOSS.PHASE = 0d2;
                            }
                        } else if(BOSS.PHASE == 0d2) {
                            if(<SCRIPT_OWNER>[HP] < BOSS.THRESHOLD_P3) {
                                BOSS.PHASE = 0d3;
                            }
                        } else if(BOSS.PHASE == 0d3) {
                            if(<SCRIPT_OWNER>[HP] < BOSS.THRESHOLD_P4) {
                                BOSS.PHASE = 0d4;
                            }
                        }

                    }));

                    boss_watcher();
                    boss_shoot_watcher();
                    boss_bomb_watcher();
                    boss_autoattack_watcher();
                    boss_movement_watcher();
                }
            };

            fun trigger_enter() {
                // object[0x00] = 0x01; // show oasis
                // object[0x01] = 0x01; // add ship_south_hitbox
                // object[0x02] = 0x01; // remove ship_north_hitbox

                init_map(0x02, 0x00, 0xa6, 0xd8);

                if(False) {
                    MEMORY.ENEMY_SPAWNER_UNKNOWN_1 = 0x0280;
                    MEMORY.ENEMY_SPAWNER_UNKNOWN_2 = 0x0000;
                    add_enemy_spawner(TUMBLING_WEED, 0x33, 0x9e, 0d10);
                }

                CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.SPACESHIP;
                CUSTOM_FLAG.NO_DOG = True;
                default_metro_init_room(reference(@install() {
                    metro_death_trigger({
                        map_transition(metro, door_d1, NONE);
                    });
                }));
                teleport(DOG, 0xff, 0xff);
                
                update_desert();

                if(BOSS.DEBUG) {
                    attribute(BOY, INVINCIBLE_TEMP, True);
                }

                if!(BOSS.DEBUG && BOSS.DEBUG_BOY) {
                    attribute(BOY, INVISIBLE, True);
                }

                add_placeholder(SPACESHIP_IDLE, 0xff, 0xff);
                attribute(LAST_ENTITY, INVISIBLE, True);
                ROOM.SHIP_PALETTE_ID = <LAST_ENTITY>;
                // animate(LAST_ENTITY, ONCE, INVISIBLE);
                
                add_placeholder(SPACESHIP_TOP_FIRE, 0xff, 0xff);
                ROOM.SHIP_FIRE_ID = <LAST_ENTITY>;

                add_placeholder(SPACESHIP_TOP, 0xff, 0xff);
                ROOM.SHIP_ID = <LAST_ENTITY>;
                attach_to_script(LAST_ENTITY);
                face(SCRIPT_OWNER, EAST);

                if(BOSS.DEBUG && BOSS.DEBUG_BOY) {
                    attribute(ROOM.SHIP_ID, INVISIBLE, True);
                    attribute(ROOM.SHIP_FIRE_ID, INVISIBLE, True);
                }
                
                unlock(JAGUAR_RING);

                yield();

                add_boss();

                yield();

                // spaceship_loop();

                while(True) {
                    arg[0x10] = <BOY>[Y];
                    if!(ROOM.PAUSE) {
                        teleport_relative(BOY, 0d0, -0d2);
                    }

                    if((<BOY>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) || ROOM.PAUSE || (<BOY>[Y] != arg[0x10])) {
                        if(ROOM.PAUSE) {
                            ROOM.PAUSE--;
                            
                            if!(ROOM.PAUSE) {
                                attribute(BOY, NO_CLIP, False);
                            }
                        }

                        if!(ROOM.JUMPING) {
                            if(<BOY>[FLAGS_7] & ATTRIBUTE_FLAGS.RUNNING) {
                                ROOM.JUMPING = True;

                                attribute(BOY, NO_CLIP, True);

                                animate(SCRIPT_OWNER, ONCE, ANIMATION_PLACEHOLDER.SPACESHIP_BACK);
                                animate(ROOM.SHIP_FIRE_ID, ONCE, ANIMATION_PLACEHOLDER.SPACESHIP_BACK_FIRE);
                            }
                        } else {
                            if!(<BOY>[FLAGS_7] & ATTRIBUTE_FLAGS.RUNNING) {
                                ROOM.JUMPING = False;

                                attribute(BOY, NO_CLIP, False);

                                animate(SCRIPT_OWNER, ONCE, ANIMATION_PLACEHOLDER.SPACESHIP_TOP);
                                animate(ROOM.SHIP_FIRE_ID, ONCE, ANIMATION_PLACEHOLDER.SPACESHIP_TOP_FIRE);
                            }
                        }
                    } else if!(ROOM.PAUSE) {
                        attribute(BOY, NO_CLIP, True);
                        face(BOY, NORTH);
                        damage(BOY, 0d1, True);
                        // animate(BOY, ONCE, KNOCKBACK);
                        
                        ROOM.PAUSE = 0d90;
                    }

                    _teleport(SCRIPT_OWNER, <BOY>[X], <BOY>[Y]);
                    _teleport(ROOM.SHIP_FIRE_ID, <BOY>[X], <BOY>[Y]);

                    update_camera();
                    
                    yield();
                }

                desert_damage();
            }
        };
    };
    
    map metro_rooms_true_ending(CARLTRON) {
        enum entrance {
            center = entrance(0x14, 0x25, NONE)
        }

        enum soundtrack {
            default = soundtrack(BOSS_BOSSRUSH, 0xff)
        }

        enum WALL_STATE {
            FANS = 0x01,

            SWITCHES_8 = 0x02,
            SWITCHES_4 = 0x03,
            
            OPEN = 0x04,

            UNKNOWN = 0x00,
        }

        enum ROOM {
            DEBUG = False,
            
            SWITCH_1 = memory(WORD, TEMP),
            SWITCH_2 = memory(WORD, TEMP),
            SWITCH_3 = memory(WORD, TEMP),
            SWITCH_4 = memory(WORD, TEMP),
            SWITCH_5 = memory(WORD, TEMP),
            SWITCH_6 = memory(WORD, TEMP),
            SWITCH_7 = memory(WORD, TEMP),
            SWITCH_8 = memory(WORD, TEMP),

            SWITCH_TIMEOUT = 0d10 * 0d0060,
            SWITCH_TILT_SPEED = 0d20,
            SWITCH_VENT_MODE = memory(FLAG, TEMP),

            SWITCH_AREA_ENTERED = memory(FLAG, TEMP),
            SWITCH_AREA_TILT = memory(FLAG, TEMP),
            SWITCH_AREA_VENTING = memory(FLAG, TEMP), // toaster phase
            SWITCH_AREA_TILT_THRESHOLD = 0d2 * 0d0060,
            SWITCH_AREA_TIMER = memory(WORD, TEMP),

            WALL_STATE = memory(WORD, TEMP),
            INTERNAL_WALL_STATE = memory(WORD, TEMP),
            INTERNAL_WALL_VENTING = memory(FLAG, TEMP),
            INTERNAL_WALL_ANIMATING = memory(FLAG, TEMP),

            SQUARE_1_X = 0d10,
            SQUARE_1_Y = 0d32,
            SQUARE_2_X = 0d26,
            SQUARE_2_Y = 0d30,
            SQUARE_3_X = 0d28,
            SQUARE_3_Y = 0d44,
            SQUARE_4_X = 0d10,
            SQUARE_4_Y = 0d46,
            SQUARE_5_X = 0d32,
            SQUARE_5_Y = 0d26,
        }

        enum stepon_trigger {
            stairs = @install() {
                if(False) {
                    debug_subtext("S=0");
                }

                ROOM.SWITCH_AREA_ENTERED = True;
            },
            fans = @install() {
                if(False) {
                    debug_subtext("S=1");
                }

                ROOM.SWITCH_AREA_ENTERED = False;
            }
        }

        fun _switch_tilt(switch_1, switch_2, is_fan) {
            if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.OPEN) {
                object[switch_1] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                object[switch_2] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
            } else if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.SWITCHES_4) {
                if(is_fan) {
                    object[switch_1] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[switch_2] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                } else {
                    object[switch_1] = 0x01; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[switch_2] = 0x01; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)    
                }
            } else {
                object[switch_1] = 0x01; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                object[switch_2] = 0x01; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
            }
        }
        
        @install()
        @async()
        fun switch_tilt(on) {
            ROOM.INTERNAL_WALL_ANIMATING = True;

            if(on) {
                tile_animate(0x01, 0xff, 0x00);
                tile_animate(0x02, 0xff, 0x00);

                ROOM.SWITCH_1 = False;
                ROOM.SWITCH_8 = False;
                object[0x00] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                object[0x07] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                sleep(ROOM.SWITCH_TILT_SPEED);

                ROOM.SWITCH_2 = False;
                ROOM.SWITCH_7 = False;
                object[0x01] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                object[0x06] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                sleep(ROOM.SWITCH_TILT_SPEED);

                ROOM.SWITCH_3 = False;
                ROOM.SWITCH_6 = False;
                object[0x02] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                object[0x05] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                sleep(ROOM.SWITCH_TILT_SPEED);

                ROOM.SWITCH_4 = False;
                ROOM.SWITCH_5 = False;
                object[0x03] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                object[0x04] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                sleep(ROOM.SWITCH_TILT_SPEED);

                tile_animate(0x01, 0xff, 0xff);
                tile_animate(0x02, 0xff, 0xff);

                sound(LEVITATE);
            } else {
                tile_animate(0x01, 0xff, 0x00);
                tile_animate(0x02, 0xff, 0x00);

                sleep(0d60);

                _switch_tilt(0x00, 0x07, False);
                sleep(ROOM.SWITCH_TILT_SPEED);

                _switch_tilt(0x01, 0x06, True);
                sleep(ROOM.SWITCH_TILT_SPEED);

                _switch_tilt(0x02, 0x05, False);
                sleep(ROOM.SWITCH_TILT_SPEED);

                _switch_tilt(0x03, 0x04, True);
                sleep(ROOM.SWITCH_TILT_SPEED);
            }

            ROOM.INTERNAL_WALL_ANIMATING = False;
        }

        fun _switch_vent_mode(switch_id, state, on) {
            if!(state) {
                if(on) {
                    object[switch_id] = 0x00;
                } else {
                    object[switch_id] = 0x01;
                }
            }

            if(False && ROOM.DEBUG) {
                debug_memory(switch_id, state, on);
                sleep(0d60);
            }
        }

        @install()
        fun switch_vent_mode(on) {
            if(ROOM.DEBUG) {
                MEMORY.STRING_PARAMETER_1 = on;
                debug_subtext("ventmode = [MEM1]");
            }

            ROOM.SWITCH_VENT_MODE = on;

            // _switch_vent_mode(0x00, ROOM.SWITCH_1, on);
            _switch_vent_mode(0x01, ROOM.SWITCH_2, on);
            // _switch_vent_mode(0x02, ROOM.SWITCH_3, on);
            _switch_vent_mode(0x03, ROOM.SWITCH_4, on);
            _switch_vent_mode(0x04, ROOM.SWITCH_5, on);
            // _switch_vent_mode(0x05, ROOM.SWITCH_6, on);
            _switch_vent_mode(0x06, ROOM.SWITCH_7, on);
            // _switch_vent_mode(0x07, ROOM.SWITCH_8, on);

            if(on) {
                tile_animate(0x01, 0xff, 0xff);
                tile_animate(0x02, 0xff, 0xff);

                sound(LEVITATE);
            } else {
                tile_animate(0x01, 0xff, 0x00);
                tile_animate(0x02, 0xff, 0x00);
            }
        }

        fun guard_tilt() {
            if(False) {
                debug_memory(ROOM.INTERNAL_WALL_ANIMATING, ROOM.SWITCH_AREA_TILT);
            }

            if(ROOM.INTERNAL_WALL_ANIMATING || ROOM.SWITCH_AREA_TILT || SOULS_MEMORY.DEAD_FINAL_BOSS) {
                if(False) {
                    debug_subtext("guarded");
                }
                
                arg[0x12] = True;
            }
        }
        fun switch_triggered(switch_id, state) {
            // ROOM.INTERNAL_WALL_ANIMATING = True;

            guard_tilt();

            if(state == False) {
                state = True;

                object[switch_id] = state;

                while((arg[0x10] < 0d9) && (!arg[0x12])) {
                    guard_tilt();

                    if!(arg[0x12]) {
                        object[switch_id] = arg[0x10] + 0d2;

                        arg[0x10]++;
                    }
                }

                if!(arg[0x12]) {
                    sleep(ROOM.SWITCH_TIMEOUT);
                }

                guard_tilt();

                while((arg[0x10] > 0d0) && (!arg[0x12])) {
                    guard_tilt();

                    if!(arg[0x12]) {
                        object[switch_id] = arg[0x10] + 0d2;

                        arg[0x10]--;
                    }
                }

                if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.OPEN) {
                    object[switch_id] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                } else if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.SWITCHES_4) {
                    if((switch_id == 0d1) || (switch_id == 0d3) || (switch_id == 0d4) || (switch_id == 0d6)) {
                        object[switch_id] = 0d0; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)    
                    } else {
                        object[switch_id] = 0d1; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)    
                    }
                } else {
                    object[switch_id] = 0d1; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                }
                
                state = False;
            }

            // ROOM.INTERNAL_WALL_ANIMATING = False;
        }

        @install()
        fun _update_wall(switch_id, switch_mode, state) {
            if(switch_mode) {
                if(state) {
                    object[switch_id] = 0x02; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                } else {
                    object[switch_id] = 0x01; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                }
            } else {
                object[switch_id] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
            }

            if(False && ROOM.DEBUG) {
                debug_memory(switch_id, state, on);
                sleep(0d60);
            }
        }
        @install()
        @async()
        fun _update_wall() {
            while(ROOM.INTERNAL_WALL_ANIMATING) {
                yield();
            }

            if(ROOM.DEBUG) {
                debug_subtext("update wall");
            }

            if(ROOM.WALL_STATE != ROOM.INTERNAL_WALL_STATE) {
                ROOM.INTERNAL_WALL_STATE = ROOM.WALL_STATE;

                if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.FANS) {
                    object[0x00] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x01] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x02] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x03] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x04] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x05] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x06] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x07] = 0x00; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                } else if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.SWITCHES_8) {
                    _update_wall(0x00, True, ROOM.SWITCH_1);
                    _update_wall(0x01, True, ROOM.SWITCH_2);
                    _update_wall(0x02, True, ROOM.SWITCH_3);
                    _update_wall(0x03, True, ROOM.SWITCH_4);
                    _update_wall(0x04, True, ROOM.SWITCH_5);
                    _update_wall(0x05, True, ROOM.SWITCH_6);
                    _update_wall(0x06, True, ROOM.SWITCH_7);
                    _update_wall(0x07, True, ROOM.SWITCH_8);
                } else if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.SWITCHES_4) {
                    _update_wall(0x00, True, ROOM.SWITCH_1);
                    _update_wall(0x01, False, ROOM.SWITCH_2);
                    _update_wall(0x02, True, ROOM.SWITCH_3);
                    _update_wall(0x03, False, ROOM.SWITCH_4);
                    _update_wall(0x04, False, ROOM.SWITCH_5);
                    _update_wall(0x05, True, ROOM.SWITCH_6);
                    _update_wall(0x06, False, ROOM.SWITCH_7);
                    _update_wall(0x07, True, ROOM.SWITCH_8);
                } else if(ROOM.INTERNAL_WALL_STATE == WALL_STATE.OPEN) {
                    object[0x00] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x01] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x02] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x03] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x04] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x05] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x06] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                    object[0x07] = 0x7e; // change vent_1 (0 = closed, 1 = off, 2 = on, 3…21 = opening, 22 = open, 0x7e = gone)
                }
            }

            if(ROOM.SWITCH_AREA_VENTING || ROOM.SWITCH_AREA_TILT) {
                if!(ROOM.INTERNAL_WALL_VENTING) {
                    ROOM.INTERNAL_WALL_VENTING = True;

                    tile_animate(0x01, 0xff, 0xff);
                    tile_animate(0x02, 0xff, 0xff);

                    sound(LEVITATE);
                }
            } else {
                if(ROOM.INTERNAL_WALL_VENTING) {
                    tile_animate(0x01, 0xff, 0x00);
                    tile_animate(0x02, 0xff, 0x00);

                    ROOM.INTERNAL_WALL_VENTING = False;
                }
            }
        }
        fun update_wall(callback_update) {
            callback_update();

            _update_wall();
            yield();
        }

        enum b_trigger {
            switch_8 = @install() {
                if(False) {
                    debug_subtext("B=0");
                }

                switch_triggered(0x07, ROOM.SWITCH_8);
            },
            switch_7 = @install() {
                if(False) {
                    debug_subtext("B=1");
                }

                switch_triggered(0x06, ROOM.SWITCH_7);
            },
            switch_6 = @install() {
                if(False) {
                    debug_subtext("B=2");
                }

                switch_triggered(0x05, ROOM.SWITCH_6);
            },
            switch_5 = @install() {
                if(False) {
                    debug_subtext("B=3");
                }

                switch_triggered(0x04, ROOM.SWITCH_5);
            },
            switch_4 = @install() {
                if(False) {
                    debug_subtext("B=4");
                }

                switch_triggered(0x03, ROOM.SWITCH_4);
            },
            switch_3 = @install() {
                if(False) {
                    debug_subtext("B=5");
                }

                switch_triggered(0x02, ROOM.SWITCH_3);
            },
            switch_2 = @install() {
                if(False) {
                    debug_subtext("B=6");
                }

                switch_triggered(0x01, ROOM.SWITCH_2);
            },
            switch_1 = @install() {
                if(False) {
                    debug_subtext("B=7");
                }

                switch_triggered(0x00, ROOM.SWITCH_1);
            }
        }

        group carltron_ai() {
            enum BOSS {
                DEBUG = False,
                DEBUG_CHEATS = True,
                DEBUG_PHASE = False,
                DEBUG_AI = False,
                DEBUG_RIMSALA = False,

                ID = memory(WORD, TEMP),
                TRASH_ID = memory(WORD, TEMP),

                BOSS_HIDDEN = memory(FLAG, TEMP),

                PHASE = memory(WORD, TEMP),

                HP = 0d500,

                WITH_BUNNY_HOP = True,
                WITH_BOY = False,
                WITH_DOG = True,

                BUNNY_HOP_AIMBOT_COUNT = 0d30,
                BUNNY_HOP_AIMBOT = memory(FLAG, TEMP),

                SHIELD_PHASE_THRESHOLD = 0d3,
                SHIELD_HITS = memory(WORD, TEMP),
                SHIELD_HITS_REQUIRED = 0d100,
                SHIELD_HITS_BOY = 0d1,
                SHIELD_HIT_BOMB = 0d5,
                SHIELD_HIT_RAPTOR = 0d20,
                SHIELD_HIT_RIMSALA = 0d20,

                BOMB_RESPAWN = 0d300,

                RAPTOR_RESPAWN = 0d300,

                RIMSALA_RESPAWN = 0d300,
                THRESHOLD_RIMSALA = 0d80,

                TOASTER_HP = 0d300,

                TIMER_RAW = memory(WORD, TEMP),
                TIMER_COUNTER = memory(WORD, TEMP),
                TIMER_P1 = 0d2000, // bombs
                TIMER_P2 = 0d2000, // raptors
                TIMER_P3 = 0d3000, // rimsala
                TIMER_P4 = 0d3000, // boy
                TIMER_P5 = 0d2000, // toaster
                TIMER_P6 = 0d5000, // carltron

                HINT_TIMER_P1 = memory(FLAG, TEMP),
                HINT_TIMER_P2 = memory(FLAG, TEMP),
                HINT_TIMER_P3 = memory(FLAG, TEMP),
                HINT_TIMER_P4 = memory(FLAG, TEMP),
                HINT_TIMER_P5 = memory(FLAG, TEMP),
                HINT_TIMER_P6 = memory(FLAG, TEMP),
            }

            fun boss_defeated() {
                attribute(BOY, INVINCIBLE_TEMP, True);
                CUSTOM_FLAG.NO_RUNNING = True;

                SOULS_MEMORY.DEAD_FINAL_BOSS = True;
            }
            fun outro() {
                show_credits();
            }

            @install()
            fun shield_hit(amount:BOSS, plonk) {
                if((BOSS.SHIELD_HITS < BOSS.SHIELD_HITS_REQUIRED) || (BOSS.PHASE < BOSS.SHIELD_PHASE_THRESHOLD)) {
                    sound(WEIRD_SOUND); // TODO

                    if(plonk) {
                        heal(SCRIPT_OWNER, 0d0, False);
                        yield();
                    }
                    BOSS.SHIELD_HITS += amount;

                    MEMORY.STRING_PARAMETER_1 = BOSS.SHIELD_HITS;
                    MEMORY.STRING_PARAMETER_2 = BOSS.SHIELD_HITS_REQUIRED;
                    subtext("[MEM1]/[MEM2]");

                    CUSTOM_MEMORY.RETURN = True;
                } else {
                    CUSTOM_MEMORY.RETURN = False;
                }
            }

            @install()
            @weak()
            fun range_check(entity_1, entity_2, range) {
                CUSTOM_MEMORY.RETURN = False;

                check_range_old(entity_1, entity_2, range, range, {
                    CUSTOM_MEMORY.RETURN = True;  
                });
            }

            @install()
            @async()
            fun add_bombs() {
                arg[0x0e] = BOSS.PHASE;

                while(BOSS.PHASE == arg[0x0e]) {
                    if(dead(BOSS.TRASH_ID)) {
                        arg[0x10] = randrange(0d4);

                        if(arg[0x10] == 0d0) {
                            arg[0x12] = ROOM.SQUARE_1_X;
                            arg[0x14] = ROOM.SQUARE_1_Y;
                        } else if(arg[0x10] == 0d1) {
                            arg[0x12] = ROOM.SQUARE_2_X;
                            arg[0x14] = ROOM.SQUARE_2_Y;
                        } else if(arg[0x10] == 0d2) {
                            arg[0x12] = ROOM.SQUARE_3_X;
                            arg[0x14] = ROOM.SQUARE_3_Y;
                        } else {
                            arg[0x12] = ROOM.SQUARE_4_X;
                            arg[0x14] = ROOM.SQUARE_4_Y;
                        }

                        add_enemy(BOMB, arg[0x12], arg[0x14]);
                        attach_to_script(<LAST_ENTITY>);
                        attach_script(SCRIPT_OWNER, DEATH, reference(vanilla_bomb_explosion));
                        <LAST_ENTITY>[Z] = 0d2000;
                        // <LAST_ENTITY>[HP] = 0d2;
                        BOSS.TRASH_ID = <LAST_ENTITY>;

                        arg[0x10] = 0d300;
                        while((_alive(<SCRIPT_OWNER>)) && (arg[0x10] > 0d0)) {
                            arg[0x10]--;

                            if(arg[0x10] == 0d60) {
                                if(False) {
                                    // TODO: 0x9badf2 should contain the code for red blinking
                                    attribute(SCRIPT_OWNER, UNKNOWN_1_2, False);
                                }
                            }

                            if((_alive(<SCRIPT_OWNER>)) && ((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK))) {
                                while((_alive(<SCRIPT_OWNER>)) && ((<SCRIPT_OWNER>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK))) {
                                    range_check(<SCRIPT_OWNER>, BOSS.ID, 0d40);

                                    // debug_memory(CUSTOM_MEMORY.RETURN);

                                    if(CUSTOM_MEMORY.RETURN) {
                                        // arg[0x10] = 0d0;

                                        attribute(SCRIPT_OWNER, ROOT, True);

                                        damage(SCRIPT_OWNER, 0d9999, False);

                                        // damage(BOSS.ID, 0d100, True);
                                        shield_hit(BOSS.SHIELD_HIT_BOMB);
                                    }

                                    // yield();
                                    sleep(0d10);
                                }
                            }

                            yield();
                        }

                        if(alive(<SCRIPT_OWNER>)) {
                            damage(SCRIPT_OWNER, 0d9999, False);
                        }

                        sleep(BOSS.BOMB_RESPAWN);
                    } else {
                        sleep(0d60);
                    }
                }
            }
            fun _add_raptor() {
                arg[0x10] = randrange(0d4);

                if(arg[0x10] == 0d0) {
                    arg[0x12] = ROOM.SQUARE_1_X;
                    arg[0x14] = ROOM.SQUARE_1_Y;
                } else if(arg[0x10] == 0d1) {
                    arg[0x12] = ROOM.SQUARE_2_X;
                    arg[0x14] = ROOM.SQUARE_2_Y;
                } else if(arg[0x10] == 0d2) {
                    arg[0x12] = ROOM.SQUARE_3_X;
                    arg[0x14] = ROOM.SQUARE_3_Y;
                } else {
                    arg[0x12] = ROOM.SQUARE_4_X;
                    arg[0x14] = ROOM.SQUARE_4_Y;
                }

                add_enemy(RAPTOR_TEAL, arg[0x12], arg[0x14]);
                BOSS.TRASH_ID = <LAST_ENTITY>;
                attach_to_script(<LAST_ENTITY>);
                attach_script(LAST_ENTITY, DEATH, reference(@install() {
                    for(arg[0x10] in 0d0..0d5) {
                        sound(TESLA);
                        shoot_entity_entity(<SCRIPT_OWNER>, LIGHTNING, BOSS.ID, 0d10, 0d0);
                        sleep(0d10);
                    }

                    shield_hit(BOSS.SHIELD_HIT_RAPTOR);

                    sleep(0d60);
                    destroy(<SCRIPT_OWNER>);
                }));
            }
            @install()
            @async()
            fun add_raptors() {
                arg[0x0e] = BOSS.PHASE;

                while(BOSS.PHASE == arg[0x0e]) {
                    if(BOSS.PHASE == arg[0x0e]) {
                        _add_raptor();
                    }

                    while((BOSS.PHASE == arg[0x0e]) && (_alive(BOSS.TRASH_ID))) {
                        sleep(0d30);
                    }

                    sleep(BOSS.RAPTOR_RESPAWN);
                }
            }
            fun _add_rimsala() {
                if(BOSS.DEBUG && BOSS.DEBUG_RIMSALA) {
                    debug_subtext("+ rimsala");
                }

                add_enemy(RIMSALA_2, ROOM.SQUARE_5_X, ROOM.SQUARE_5_Y, INACTIVE);
                attach_to_script(LAST_ENTITY);
                BOSS.TRASH_ID = <LAST_ENTITY>;

                attach_script(LAST_ENTITY, DEATH, reference(@install() {
                    for(arg[0x10] in 0d0..0d5) {
                        sound(TESLA);
                        shoot_entity_entity(<SCRIPT_OWNER>, LIGHTNING, BOSS.ID, 0d10, 0d0);
                        sleep(0d10);
                    }

                    shield_hit(BOSS.SHIELD_HIT_RIMSALA);

                    sleep(0d60);
                    destroy(<SCRIPT_OWNER>);
                }));
            }
            @install()
            @async()
            fun add_rimsala() {
                if(BOSS.DEBUG && BOSS.DEBUG_RIMSALA) {
                    debug_subtext(" ++ rimsala");
                }

                arg[0x0e] = BOSS.PHASE;

                if(False) {
                    debug_memory(BOSS.PHASE, arg[0x0e]);
                }
                sleep(0d60);

                while(BOSS.PHASE == arg[0x0e]) {
                    _add_rimsala();

                    while(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                        control(SCRIPT_OWNER, False);

                        while((!((ROOM.SWITCH_1 > 0d0) && (ROOM.SWITCH_8 > 0d0))) && (<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA)) {
                            if(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                                walk(SCRIPT_OWNER, TILE_ABSOLUTE, ROOM.SQUARE_2_X, ROOM.SQUARE_2_Y, SCRIPT_OWNER, False);
                            }
                            if(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                                walk(SCRIPT_OWNER, TILE_ABSOLUTE, ROOM.SQUARE_1_X, ROOM.SQUARE_1_Y, SCRIPT_OWNER, False);
                            }
                            if(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                                walk(SCRIPT_OWNER, TILE_ABSOLUTE, ROOM.SQUARE_4_X, ROOM.SQUARE_4_Y, SCRIPT_OWNER, False);
                            }
                            if(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                                walk(SCRIPT_OWNER, TILE_ABSOLUTE, ROOM.SQUARE_3_X, ROOM.SQUARE_3_Y, SCRIPT_OWNER, False);
                            }

                            if(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                                walk(SCRIPT_OWNER, TILE_ABSOLUTE, ROOM.SQUARE_2_X, ROOM.SQUARE_2_Y, SCRIPT_OWNER, False);
                            }
                        }

                        if(<SCRIPT_OWNER>[HP] >= BOSS.THRESHOLD_RIMSALA) {
                            walk(SCRIPT_OWNER, TILE_ABSOLUTE, ROOM.SQUARE_5_X, ROOM.SQUARE_5_Y, SCRIPT_OWNER, False);

                            control(SCRIPT_OWNER, True);
                        }
                    }

                    if(BOSS.DEBUG && BOSS.DEBUG_RIMSALA) {
                        debug_subtext("rimsala hit");
                    }

                    control(SCRIPT_OWNER, False);
                    while(alive(<SCRIPT_OWNER>)) {
                        yield();
                    }

                    if(BOSS.DEBUG && BOSS.DEBUG_RIMSALA) {
                        debug_subtext("-rimsala");
                    }

                    sleep(BOSS.RIMSALA_RESPAWN);
                }

                if(BOSS.DEBUG && BOSS.DEBUG_RIMSALA) {
                    debug_subtext("--rimsala");
                }

                if(False) {
                    debug_memory(BOSS.PHASE, arg[0x0e]);
                }
            }
            @install()
            @async()
            fun add_boy() {
                add_custom_boss_gideon(ROOM.SQUARE_5_X, ROOM.SQUARE_5_Y, False, False, 0d200, 0d100, 0d5, 0d120, False, True, True);

                BOSS.TRASH_ID = <LAST_ENTITY>;
                attach_to_script(LAST_ENTITY);
            }
            @install()
            @async()
            fun add_dog() {
                add_enemy(DOG_4_BLACK, ROOM.SQUARE_5_X, ROOM.SQUARE_5_Y, INACTIVE);
                <LAST_ENTITY>[HP] = BOSS.TOASTER_HP;
                BOSS.TRASH_ID = <LAST_ENTITY>;
                attach_to_script(LAST_ENTITY);

                update_wall({
                    ROOM.SWITCH_AREA_VENTING = True;
                });

                while(alive(<SCRIPT_OWNER>)) {
                    arg[0x14]++;

                    <SCRIPT_OWNER>[Y] = 0d190;
                    
                    arg[0x12] = <SCRIPT_OWNER>[X];

                    if!(arg[0x10]) {
                        teleport_relative(SCRIPT_OWNER, 0d1, 0d0);

                        if(<SCRIPT_OWNER>[X] == arg[0x12]) {
                            arg[0x10] = True;
                        }
                    } else {
                        arg[0x12] = <SCRIPT_OWNER>[X];
                        teleport_relative(SCRIPT_OWNER, -0d1, 0d0);

                        if(<SCRIPT_OWNER>[X] == arg[0x12]) {
                            arg[0x10] = False;
                        }
                    }

                    if!(<SCRIPT_OWNER>[Z]) {
                        <SCRIPT_OWNER>[VELOCITY] = 0d20;
                    }

                    if(False) {
                        control(SCRIPT_OWNER, False);
                        yield();
                        control(SCRIPT_OWNER, True);
                    } else {
                        if((<SCRIPT_OWNER>[Y] > (MEMORY.CAMERA_Y_MIN + 0d20)) && (!(<SCRIPT_OWNER>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION))) {
                            if(arg[0x14] > 0d300) {
                                arg[0x14] = 0d0;

                                arg[0x16] = randrange(0d3);

                                if(arg[0x16] == 0d0) {
                                    animate(SCRIPT_OWNER, ONCE, SLASH_1_3);
                                } else {
                                    arg[0x16] = randrange(0d3);

                                    if(arg[0x16] == 0d0) {
                                        beam_wall(SOUTH, <BOY>, 0d40, 0d190, 0d140, 0d440, 0d20);
                                    } else if(arg[0x16] == 0d1) {
                                        beam_wall(SOUTH, <BOY>, 0d110, 0d190, 0d210, 0d440, 0d20);
                                    } else {
                                        beam_wall(SOUTH, <BOY>, 0d190, 0d190, 0d280, 0d440, 0d20);
                                    }
                                }
                            } else if((<BOY>[X] > <SCRIPT_OWNER>[X] - 0d20) && ((<BOY>[X] < <SCRIPT_OWNER>[X] + 0d20))) {
                                animate(SCRIPT_OWNER, ONCE, SLASH_1);
                            }
                        }
                    }

                    face(SCRIPT_OWNER, SOUTH);

                    teleport_relative(BOY, 0d0, 0d1);

                    yield();
                }

                update_wall({
                    ROOM.SWITCH_AREA_VENTING = False;
                });

                tile_animate(0x01, 0xff, 0x00);
                tile_animate(0x02, 0xff, 0x00);
            }
            @install()
            @async()
            fun enrage_carltron() {
                arg[0x0e] = BOSS.PHASE;

                while((BOSS.PHASE == arg[0x0e]) && (_alive(BOSS.ID))) {
                    arg[0x10] = randrange(0d4);

                    if(arg[0x10] == 0d0) {
                        arg[0x10] = randrange(0d4);

                        if(arg[0x10] == 0d0) {
                            beam_link_absolute(BOSS.ID, ROOM.SQUARE_1_X, ROOM.SQUARE_1_Y, 0d30);
                        } else if(arg[0x10] == 0d1) {
                            beam_link_absolute(BOSS.ID, ROOM.SQUARE_2_X, ROOM.SQUARE_2_Y, 0d30);
                        } else if(arg[0x10] == 0d2) {
                            beam_link_absolute(BOSS.ID, ROOM.SQUARE_3_X, ROOM.SQUARE_3_Y, 0d30);
                        } else {
                            beam_link_absolute(BOSS.ID, ROOM.SQUARE_4_X, ROOM.SQUARE_4_Y, 0d30);
                        }

                        sleep(0d600);
                    } else if(arg[0x10] == 0d1) {
                        arg[0x10] = randrange(0d4);

                        if(arg[0x10] == 0d0) {
                            if(randrange(0d2)) {
                                beam_wall(NORTH, <BOY>, 0d40, 0d190, 0d170, 0d440, 0d20);
                            } else {
                                beam_wall(NORTH, <BOY>, 0d170, 0d190, 0d280, 0d440, 0d20);
                            }
                        } else if(arg[0x10] == 0d1) {
                            if(randrange(0d2)) {
                                beam_wall(EAST, <BOY>, 0d40, 0d170, 0d300, 0d300, 0d20);
                            } else {
                                beam_wall(EAST, <BOY>, 0d40, 0d300, 0d300, 0d440, 0d20);
                            }
                        } else if(arg[0x10] == 0d2) {
                            if(randrange(0d2)) {
                                beam_wall(SOUTH, <BOY>, 0d40, 0d190, 0d170, 0d440, 0d20);
                            } else {
                                beam_wall(SOUTH, <BOY>, 0d170, 0d190, 0d280, 0d440, 0d20);
                            }
                        } else {
                            if(randrange(0d2)) {
                                beam_wall(WEST, <BOY>, 0d40, 0d170, 0d300, 0d300, 0d20);
                            } else {
                                beam_wall(WEST, <BOY>, 0d40, 0d300, 0d300, 0d440, 0d20);
                            }
                        }

                        sleep(0d600);
                    }
                }
            }

            @install()
            fun next_phase() {
                BOSS.TIMER_COUNTER = 0d0;
                BOSS.PHASE++;

                if(BOSS.DEBUG && BOSS.DEBUG_PHASE) {
                    MEMORY.STRING_PARAMETER_1 = BOSS.PHASE;
                    debug_subtext("next phase = [MEM1]");
                }
            }
            fun hint_phase(flag, max) {
                if!(flag) {
                    flag = True;

                    MEMORY.STRING_PARAMETER_1 = BOSS.TIMER_COUNTER;
                    MEMORY.STRING_PARAMETER_2 = max;

                    subtext("[MEM1]/[MEM2]");
                }
            }

            fun show_boss(show, x, y) {
                if(show) {
                    BOSS.ID[Z] = 0d1000;

                    animate(BOSS.ID, ONCE, DEFAULT);
                    _teleport(BOSS.ID, x, y);

                    while(BOSS.ID[Z] > 0d0) {
                        yield();
                    }

                    control(BOSS.ID, False);
                    attribute(BOSS.ID, INVINCIBLE_TEMP, False);
                } else {

                    control(BOSS.ID, True);
                    attribute(BOSS.ID, INVINCIBLE_TEMP, True);

                    BOSS.ID[VELOCITY] = 0d200;

                    sleep(0d30);

                    animate(BOSS.ID, ONCE_FREEZE, INVISIBLE);
                    _teleport(BOSS.ID, x, y);
                }
            }

            @install()
            @async()
            fun boss_ai() {
                // lag: >1 raptor, >1 rimsala, >3 bombs (or >2 with dog)

                // p1 bombs
                // p2 raptor
                // p3 rimsala
                // p4 gideon
                // p5 toaster shooter?
                // p5? robot

                while(True) {
                    BOSS.TIMER_COUNTER += ROOM.SWITCH_2 + ROOM.SWITCH_3 + ROOM.SWITCH_4 + ROOM.SWITCH_5 + ROOM.SWITCH_6 + ROOM.SWITCH_7;

                    if(BOSS.PHASE == 0d0) {
                        if(BOSS.TIMER_COUNTER >= BOSS.TIMER_P1) {
                            hint_phase(BOSS.HINT_TIMER_P1, BOSS.TIMER_P1);

                            if((_dead(BOSS.TRASH_ID)) || (BOSS.TRASH_ID == 0d0)) {
                                next_phase(); // phase 1

                                add_raptors();
                            }
                        }
                    } else if(BOSS.PHASE == 0d1) {
                        if(BOSS.TIMER_COUNTER >= BOSS.TIMER_P2) {
                            hint_phase(BOSS.HINT_TIMER_P2, BOSS.TIMER_P2);

                            if((_dead(BOSS.TRASH_ID)) || (BOSS.TRASH_ID == 0d0)) {
                                next_phase(); // phase 2

                                add_rimsala();
                            }
                        }
                    } else if(BOSS.PHASE == 0d2) {
                        if(BOSS.TIMER_COUNTER >= BOSS.TIMER_P3) {
                            hint_phase(BOSS.HINT_TIMER_P3, BOSS.TIMER_P3);

                            if((_dead(BOSS.TRASH_ID)) || (BOSS.TRASH_ID == 0d0)) {
                                next_phase();

                                BOSS.BOSS_HIDDEN = True;
                                add_boy();
                            }
                        }
                    } else if(BOSS.PHASE == 0d3) {
                        if(BOSS.TIMER_COUNTER >= BOSS.TIMER_P4) {
                            hint_phase(BOSS.HINT_TIMER_P4, BOSS.TIMER_P4);

                            if((_dead(BOSS.TRASH_ID)) || (BOSS.TRASH_ID == 0d0)) {
                                next_phase();

                                update_wall({
                                    ROOM.WALL_STATE = WALL_STATE.SWITCHES_4;
                                    ROOM.SWITCH_AREA_VENTING = True;
                                });

                                BOSS.BOSS_HIDDEN = True;
                                
                                CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.SPEAR_TOSS;
                                hint(PRESS_R);

                                add_dog();
                            }
                        }
                    } else if(BOSS.PHASE == 0d4) {
                        if(BOSS.TIMER_COUNTER >= BOSS.TIMER_P5) {
                            hint_phase(BOSS.HINT_TIMER_P5, BOSS.TIMER_P5);

                            if((_dead(BOSS.TRASH_ID)) || (BOSS.TRASH_ID == 0d0)) {
                                CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.NORMAL;

                                next_phase();

                                update_wall({
                                    ROOM.WALL_STATE = WALL_STATE.SWITCHES_8;
                                    ROOM.SWITCH_AREA_VENTING = False;
                                });

                                BOSS.BOSS_HIDDEN = False;
                                enrage_carltron();
                            }
                        }
                    } else {
                        if(BOSS.TIMER_COUNTER >= BOSS.TIMER_P6) {
                            hint_phase(BOSS.HINT_TIMER_P6, BOSS.TIMER_P6);

                            if((_dead(BOSS.ID)) || (BOSS.ID == 0d0)) {
                                update_wall({
                                    ROOM.WALL_STATE = WALL_STATE.OPEN;
                                });

                                boss_defeated();

                                while(True) {
                                    if(<BOY>[Y] <= 0d51) {
                                        walk(BOY, TILE_ABSOLUTE, 0d20, 0d6, BOY, NONE);

                                        fade_out();

                                        walk(BOY, TILE_RELATIVE_DIRECT, 0d0, -0d1, BOY, NONE);

                                        outro();

                                        end();
                                    }

                                    yield();
                                }
                            }
                        }
                    }

                    if(ROOM.SWITCH_AREA_ENTERED) {
                        ROOM.SWITCH_AREA_TIMER++;

                        if(ROOM.SWITCH_AREA_TIMER > ROOM.SWITCH_AREA_TILT_THRESHOLD) {
                            update_wall({
                                ROOM.SWITCH_AREA_TILT = True;
                                switch_tilt(True);
                                yield();
                            });

                            while(ROOM.SWITCH_AREA_TIMER > 0d0) {
                                ROOM.SWITCH_AREA_TIMER--;

                                if(ROOM.SWITCH_AREA_ENTERED) {
                                    teleport_relative(BOY, 0d0, 0d4);
                                } else {
                                    teleport_relative(BOY, 0d0, 0d2);
                                }

                                yield();
                            }

                            update_wall({
                                ROOM.SWITCH_AREA_TILT = False;
                                switch_tilt(False);
                                yield();
                            });
                        }
                    } else if(ROOM.SWITCH_AREA_TIMER > 0d0) {
                        ROOM.SWITCH_AREA_TIMER--;
                    }

                    yield();

                    if(BOSS.DEBUG && BOSS.DEBUG_PHASE) {
                        BOSS.TIMER_RAW++;
                        if(BOSS.TIMER_RAW > 0d60) {
                            BOSS.TIMER_RAW = 0d0;

                            MEMORY.STRING_PARAMETER_1 = BOSS.PHASE;
                            MEMORY.STRING_PARAMETER_2 = BOSS.TIMER_COUNTER;
                            MEMORY.STRING_PARAMETER_3 = ROOM.SWITCH_AREA_TIMER;
                            debug_subtext("phase = [MEM1] / [MEM2] / [MEM3]");
                        }
                    }
                }
            }
            fun bunny_hop(x, y) {
                <SCRIPT_OWNER>[VELOCITY] = 0d30 + randrange(0d10);
                yield();

                if((randrange(0d5) == 0d0) || (BOSS.BUNNY_HOP_AIMBOT)) {
                    while(<SCRIPT_OWNER>[Z] != 0d0) {
                        if(<SCRIPT_OWNER>[X] < <BOY>[X]) {
                            teleport_relative(SCRIPT_OWNER, 0d1, 0d0);
                        } else {
                            teleport_relative(SCRIPT_OWNER, -0d1, 0d0);
                        }

                        if(<SCRIPT_OWNER>[Y] < <BOY>[Y]) {
                            teleport_relative(SCRIPT_OWNER, 0d0, 0d1);
                        } else {
                            teleport_relative(SCRIPT_OWNER, 0d0, -0d1);
                        }

                        yield();
                    }
                } else {
                    while(<SCRIPT_OWNER>[Z] != 0d0) {
                        if(<SCRIPT_OWNER>[X] < x) {
                            teleport_relative(SCRIPT_OWNER, 0d1, 0d0);
                        } else {
                            teleport_relative(SCRIPT_OWNER, -0d1, 0d0);
                        }

                        if(<SCRIPT_OWNER>[Y] < y) {
                            teleport_relative(SCRIPT_OWNER, 0d0, 0d1);
                        } else {
                            teleport_relative(SCRIPT_OWNER, 0d0, -0d1);
                        }

                        yield();
                    }
                }
            }
            fun bunny_hop_landing() {
                face_target(SCRIPT_OWNER, BOY);
                if(False) {
                    debug_memory(<SCRIPT_OWNER>[FACE_DIRECTION]);
                }

                if(<SCRIPT_OWNER>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                // if((<BOY>[Y] > <SCRIPT_OWNER>[Y]) && (<BOY>[X] > (<SCRIPT_OWNER>[X] - 0d50)) && (<BOY>[X] < (<SCRIPT_OWNER>[X] + 0d50))) {
                    face(SCRIPT_OWNER, SOUTH);
                    shoot_entity_offset_relative(<SCRIPT_OWNER>, MISSILE, 0d0, 0d30, 0d0, 0d100, 0d10, 0d0);
                }

                bomb_entity(<SCRIPT_OWNER>, 0d50);
            }
            @install()
            @async()
            fun add_carltron() {
                add_enemy(CARLTRON_ROBOT, ROOM.SQUARE_5_X, ROOM.SQUARE_5_Y);
                BOSS.ID = <LAST_ENTITY>;
                attach_to_script(LAST_ENTITY);
                <LAST_ENTITY>[HP] = BOSS.HP;
                yield();
                attach_script(SCRIPT_OWNER, DAMAGE, reference(@install() {
                    if(<SCRIPT_OWNER>[DAMAGE_SOURCE] == CHARACTER_ADDRESS.BOY) {
                        arg[0x10] = <SCRIPT_OWNER>[DAMAGE_SOURCE];

                        face_target(SCRIPT_OWNER, arg[0x10]);
                        arg[0x12] = <SCRIPT_OWNER>[FACE_DIRECTION];

                        if(arg[0x12] == FACE_DIRECTION.NORTH) {
                            subtext("!");
                        } else {
                            shield_hit(BOSS.SHIELD_HITS_BOY, True);
                        }
                    } else {
                        shield_hit(BOSS.SHIELD_HITS_BOY, True);
                    }
                }));

                boss_ai();

                if!(BOSS.WITH_BUNNY_HOP) {
                    end();
                }

                arg[0x14] = <SCRIPT_OWNER>[X];
                arg[0x16] = <SCRIPT_OWNER>[Y];

                while(alive(BOSS.ID)) {
                    while(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.HEALED) {
                        sleep(0d10);
                    }

                    bunny_hop(arg[0x14], arg[0x16]);

                    bunny_hop_landing();

                    if!(BOSS.BUNNY_HOP_AIMBOT) {
                        arg[0x10]++;
                        if(arg[0x10] == BOSS.BUNNY_HOP_AIMBOT_COUNT) {
                            BOSS.BUNNY_HOP_AIMBOT = True;

                            if(BOSS.DEBUG) {
                                MEMORY.STRING_PARAMETER_1 = BOSS.BUNNY_HOP_AIMBOT;
                                debug_subtext("bunny hop aimbot [MEM1]");
                            }
                        }
                    } else {
                        if(arg[0x10] > 0d2) {
                            arg[0x10] -= 0d2;
                        } else {
                            arg[0x10] = 0d0;
                        }
                        
                        if(arg[0x10] == 0d0) {
                            BOSS.BUNNY_HOP_AIMBOT = False;

                            if(BOSS.DEBUG) {
                                MEMORY.STRING_PARAMETER_1 = BOSS.BUNNY_HOP_AIMBOT;
                                debug_subtext("bunny hop aimbot [MEM1]");
                            }
                        }
                    }

                    arg[0x14] = <BOY>[X];
                    arg[0x16] = <BOY>[Y];

                    if(BOSS.BOSS_HIDDEN) {
                        arg[0x18] = BOSS.ID[X];
                        arg[0x1a] = BOSS.ID[Y];

                        show_boss(False, 0d0, 0d0);

                        while(BOSS.BOSS_HIDDEN) {
                            yield();
                        }

                        show_boss(True, arg[0x18], arg[0x1a]);
                    }
                }
            }
        };

        fun trigger_enter() {
            CUSTOM_FLAG.NO_DOG = True;
            default_metro_init_room(reference(@install() {
                metro_death_trigger({
                    map_transition(metro, door_center, NONE);
                });
            }));

            add_carltron();
            
            add_bombs(); // phase 0
            // add_raptors(); // phase 1
            // add_rimsala(); // phase 2
            // add_dog(); // phase 4
            // enrage_carltron(); // phase 5

            update_wall({
                ROOM.WALL_STATE = WALL_STATE.SWITCHES_8;
            });

            if(BOSS.DEBUG && BOSS.DEBUG_CHEATS) {
                unlock(SPEAR_4);
                yield();
                unlock(JAGUAR_RING);
                // unlock(WEAPONS);
                <BOY>[HP] = SYSTEM.HP_MAX;
                attribute(BOY, INVINCIBLE_TEMP, True);

                MEMORY.BOY_XP_REQUIRED = SYSTEM.HP_MAX;
            }
        }
    };
};

// dungeons

area dungeon_isaac() {
    enum AREA_BASEMENT {
        DEBUG = False,

        // ENABLE_DOORS = memory(WORD, TEMP),

        ENEMY_COUNT_TOTAL = memory(WORD, TEMP),
        ENEMY_COUNT = memory(WORD, TEMP),

        MUSIC_DEFAULT = MUSIC.PUPPET_SHOW,
    }

    group isaac_helper() {
        fun prepare_room(index) {
            if(index == 0x01) {
                init_map(0x00, 0x00, 0x34, 0x1e); // room_1

                // MEMORY.FOREGROUND_OFFSET_X = 0x0000;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x02c0;

                // MEMORY.FOREGROUND_OFFSET_X = 0x0160;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x02c0;
                
                // MEMORY.FOREGROUND_OFFSET_X = 0x0000;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x03e0;
                
                // MEMORY.FOREGROUND_OFFSET_X = 0x0190;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x03e0;
                
                // MEMORY.FOREGROUND_OFFSET_X = 0x0030;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x03e0;
                
                MEMORY.FOREGROUND_OFFSET_X = 0x00c0;
                MEMORY.FOREGROUND_OFFSET_Y = 0x02c0;
            } else if(index == 0x02) {
                init_map(0x38, 0x00, 0x6e, 0x1e); // room 2

                // MEMORY.FOREGROUND_OFFSET_X = 0x0390;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x0180;

                MEMORY.FOREGROUND_OFFSET_X = 0x0280; // custom
                MEMORY.FOREGROUND_OFFSET_Y = 0x02C0;
            } else if(index == 0x03) {
                init_map(0x4c, 0x24, 0x6e, 0x54); // room_3

                MEMORY.FOREGROUND_OFFSET_X = 0x00a0; // custom
                MEMORY.FOREGROUND_OFFSET_Y = 0x0000;
            } else if(index == 0x04) {
                init_map(0x26, 0x24, 0x48, 0x54); // room_4

                MEMORY.FOREGROUND_OFFSET_X = 0x0218; // custom
                MEMORY.FOREGROUND_OFFSET_Y = 0x0000;
            } else if(index == 0x05) {
                init_map(0x00, 0x24, 0x22, 0x54); // room_5

                // MEMORY.FOREGROUND_OFFSET_X = 0x0390;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x0000;
                
                MEMORY.FOREGROUND_OFFSET_X = 0x0390;
                MEMORY.FOREGROUND_OFFSET_Y = 0x0090;

                // MEMORY.FOREGROUND_OFFSET_X = 0x0390;
                // MEMORY.FOREGROUND_OFFSET_Y = 0x0130;
            }
        }

        @install()
        fun enemies_alive() {
            MEMORY.STRING_PARAMETER_1 = AREA_BASEMENT.ENEMY_COUNT;
            MEMORY.STRING_PARAMETER_2 = AREA_BASEMENT.ENEMY_COUNT_TOTAL;

            subtext("[MEM1]/[MEM2] enemies alive.");
        }

        fun check_exits(clear_flag) {
            if(AREA_BASEMENT.ENEMY_COUNT > 0d0) {
                enemies_alive();

                end();
            } else {
                clear_flag = True;
            }
        }

        @install()
        fun shoot(entity) {
            shoot_entity_entity(entity, ONION, BOY, 0x10, 0xff);
        }

        @install()
        fun jump(entity) {
            entity[VELOCITY] = 0x30;
            
            while(arg[0x02] <= 0x30) {
                arg[0x02]++;

                if(entity[X] > <BOY>[X]) {
                    entity[X]--;
                } else if(entity[X] < <BOY>[X]) {
                    entity[X]++;
                }

                if(entity[Y] > <BOY>[Y]) {
                    entity[Y]--;
                } else if(entity[Y] < <BOY>[Y]) {
                    entity[Y]++;
                }

                sleep(0x02);
            }
        }

        @install()
        @async()
        fun isaac_ai_shooting(enemy) {
            sleep(0x60);

            while(alive(enemy)) {
                shoot(enemy);
                // ai_move_projectile_plus(enemy, ONION, 0d130);
                // ai_move_bomb_toss(enemy, ONION, <BOY>);

                sleep(0xa0);
            }
        }
        @install()
        @async()
        fun isaac_ai_shooting_plus(enemy) {
            sleep(0d100);

            while(alive(enemy)) {
                // shoot(enemy);
                ai_move_projectile_plus(enemy, ONION, 0d130);
                // ai_move_bomb_toss(enemy, ONION, <BOY>);

                sleep(0d240);
            }
        }
        @install()
        @async()
        fun isaac_ai_jumping(enemy) {
            sleep(0d100);

            while(alive(enemy)) {
                // control(enemy, False);
                jump(enemy);
                // control(enemy, True);

                sleep(0xf0);
            }
        }

        @install()
        fun isaac_enemy_death() {
            AREA_BASEMENT.ENEMY_COUNT--;

            // if(AREA_BASEMENT.ENEMY_COUNT == 0x00) {
            //     AREA_BASEMENT.ENABLE_DOORS = 0x01;
            // }

            if(AREA_BASEMENT.DEBUG) {
                MEMORY.STRING_PARAMETER_1 = AREA_BASEMENT.ENEMY_COUNT;
                MEMORY.STRING_PARAMETER_2 = AREA_BASEMENT.ENEMY_COUNT_TOTAL;

                subtext("[MEM1] / [MEM2]");
            }
        }
        @install()
        fun isaac_enemy_death_shoot_plus() {
            isaac_enemy_death();

            ai_move_projectile_plus(<SCRIPT_OWNER>, ONION, 0d130);
        }
        @install()
        fun isaac_enemy_death_shoot_bomb() {
            isaac_enemy_death();

            ai_move_bomb_toss(<SCRIPT_OWNER>, ONION, <BOY>);
        }
        @install()
        fun isaac_enemy_death_explode() {
            isaac_enemy_death();

            ai_move_bomb_enemy(<SCRIPT_OWNER>);
        }

        fun add_isaac_enemy() {
            AREA_BASEMENT.ENEMY_COUNT_TOTAL++;
            AREA_BASEMENT.ENEMY_COUNT++;
        }
        fun add_isaac_enemy_fly_shooting(x, y) {
            add_isaac_enemy();

            add_enemy(MOSQUITO, x, y);
            attach_script(LAST_ENTITY, DEATH, reference(isaac_enemy_death));
            isaac_ai_shooting(<LAST_ENTITY>);
        }
        fun add_isaac_enemy_fly_exploding(x, y) {
            add_isaac_enemy();

            add_enemy(MOSQUITO, x, y);
            attach_script(LAST_ENTITY, DEATH, reference(isaac_enemy_death_shoot_bomb));
        }
        fun add_isaac_enemy_maggot(x, y) {
            add_isaac_enemy();

            add_enemy(MAGGOT, x, y);
            attach_script(LAST_ENTITY, DEATH, reference(isaac_enemy_death));
        }
        fun add_isaac_enemy_slime(x, y) {
            add_isaac_enemy();

            add_enemy(SLIME_GREEN, x, y);
            attach_script(LAST_ENTITY, DEATH, reference(isaac_enemy_death));
            isaac_ai_shooting_plus(<LAST_ENTITY>);
        }
        fun add_isaac_enemy_jumper(x, y) {
            add_isaac_enemy();

            // add_enemy(DANCING_DEVIL_1, x, y);
            add_enemy(MUMMY, x, y);
            // add_enemy(FRIPPO, x, y);
            attach_script(LAST_ENTITY, DEATH, reference(isaac_enemy_death));
            // attribute(LAST_ENTITY, ROOT, True);
            isaac_ai_jumping(<LAST_ENTITY>);
        }
        fun add_isaac_enemy_spider(x, y) {
            add_isaac_enemy();

            add_enemy(SPIDER, x, y);
            <LAST_ENTITY>[HP] = 0x01;
            attach_script(LAST_ENTITY, DEATH, reference(isaac_enemy_death_explode));
            // isaac_ai_jumping(<LAST_ENTITY>);
        }
    };

    area level_0() {
        enum BASEMENT_LEVEL {
            NIGHT = False,
            RAIN = False,
        }

        map basement_0_start(DARK_FOREST) { // center "+"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0d18, 0d56, NONE, {
                    crash_both();
                    subtext("Basement Level 1");
                }),
                bonfire = entrance(0d23, 0d51, NONE, { bonfire_wakeup(-0d24, 0d0, 0d0, 0d8); }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    map_transition(basement_0_4, east, WEST);
                },
                exit_east = @install() {
                    map_transition(basement_0_2, west, EAST);
                },

                exit_north = @install() {
                    map_transition(basement_0_1, south, NORTH);
                },
                exit_south = @install() {
                    map_transition(basement_0_3, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                object[0x04] = 0x01; // opens room_5_west
                object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                prepare_room(0x05);

                // add_isaac_enemy_fly_shooting(0x1a, 0x30);
                // add_isaac_enemy_fly_exploding(0x15, 0x30);
                // add_isaac_enemy_maggot(0x15, 0x30);
                // add_isaac_enemy_slime(0x15, 0x30);
                // add_isaac_enemy_frippo(0x15, 0x30);
                // add_isaac_enemy_spider(0x15, 0x30);

                bonfire(0d23, 0d51, SOULS_MEMORY.BONFIRE_ISAAC_DUNGEON);

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);

                hint(PRESS_START);
            }
        };

        map basement_0_2(DARK_FOREST) { // east "->"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    debug_subtext("S=13");
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_0_start, east, WEST);
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x5b, 0x2d);
                        add_isaac_enemy_maggot(0x5d, 0x2f);
                    }
                }

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_0_3(DARK_FOREST) { // south "v"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_0_start, south, NORTH);
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    debug_subtext("S=15");
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                // object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x59, 0x47);
                        add_isaac_enemy_maggot(0x5b, 0x49);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_0_4(DARK_FOREST) { // west "<-"
            enum entrance {
                east = entrance(0x6f, 0x17, WEST),
                south_1 = entrance(0x65, 0x1f, NORTH),
                south_2 = entrance(0x46, 0x1f, NORTH),
                west = entrance(0x38, 0x18, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                south_2 = @install() {
                    debug_subtext("S=5");
                },
                east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_0_start, west, EAST);
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                south_1 = @install() {
                    debug_subtext("S=16");
                },
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = @install() {
                    debug_subtext("B=2");
                },
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=8");
                },
            }

            fun trigger_enter() {
                prepare_room(0x02);
                
                // object[0x02] = 0x01; // hides room_2_sign
                object[0x02] = 0x02; // closes room_2_west
                // object[0x02] = 0x03; // opens room_2_west, closes room_2_south
                // object[0x03] = 0x01; // opens room_2_south_1
                // object[0x0a] = 0x01; // shows room_2_decoration (stone -> tree)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x51, 0x12);
                        add_isaac_enemy_maggot(0x53, 0x15);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_0_1(DARK_FOREST) { // north "|"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_0_start, north, SOUTH);
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_0_door, south, NORTH);
                },
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                // object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x5d, 0x2d);
                        add_isaac_enemy_maggot(0x5f, 0x2e);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_0_door(TIMBERDRAKE) { // north-north "drake-south"
            enum entrance {
                east = entrance(0x2b, 0x15, WEST),
                south = entrance(0x1b, 0x29, NORTH)
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_east = @install() {
                    debug_subtext("S=0");
                },
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);
                    map_transition(basement_0_1, north, SOUTH);
                }
            }

            @install()
            fun trap_door_interacted() {
                check_exits(ROOM.CLEAR_FLAG);
                map_transition(basement_1_start, center, NONE);
            }

            fun trigger_enter() {
                add_placeholder(ANIMATION_PLACEHOLDER.ELEVATOR, 0x10, 0x13);
                attach_script(LAST_ENTITY, B, reference(trap_door_interacted));

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_spider(0d32, 0d22);
                        add_isaac_enemy_spider(0d17, 0d28);
                        add_isaac_enemy_spider(0d36, 0d32);
                    }
                }

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);

                // object[0x00] = 0x01; // close south
                // object[0x01] = 0x01; // open east
            }
        };
    };

    area level_1() {
        enum BASEMENT_LEVEL {
            NIGHT = False,
            RAIN = False,
        }

        map basement_1_start(DARK_FOREST) { // center "+"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0x12, 0x38, NONE, {
                    crash_both();
                    subtext("Basement Level 2");
                }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    map_transition(basement_1_5, east, WEST);
                },
                exit_east = @install() {
                    map_transition(basement_1_2, west, EAST);
                },

                exit_north = @install() {
                    map_transition(basement_1_4, south_1, NORTH);
                },
                exit_south = @install() {
                    map_transition(basement_1_6, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x05);

                object[0x04] = 0x01; // opens room_5_west
                object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_1_2(DARK_FOREST) { // east "--"
            enum entrance {
                east = entrance(0x35, 0x16, WEST),
                north = entrance(0x18, 0x1f, NORTH),
                west = entrance(0x00, 0x15, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_start, east, WEST);
                },
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_3, west, EAST);
                },
                exit_south = @install() {
                    debug_subtext("S=4");
                },
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                sign = @install() {
                    debug_subtext("B=3");
                },
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                sniff = @install() {
                    debug_subtext("B=7");
                },
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x01);

                // object[0x00] = 0x01; // opens room_1_south
                // object[0x01] = 0x01; // closes room_1_east
                // object[0x12] = 0x01; // hides room_1_sign
                // object[0x09] = 0x01; // shows room_1_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x24, 0x12);
                        add_isaac_enemy_spider(0d36, 0d18);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_1_3(DARK_FOREST) { // east-east "-^"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    debug_subtext("S=13");
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_2, east, WEST);
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_fly_exploding(0d93, 0d50);
                        add_isaac_enemy_fly_exploding(0d95, 0d58);
                        add_isaac_enemy_maggot(0x5d, 0x31);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_1_4(DARK_FOREST) { // north "/\"
            enum entrance {
                east = entrance(0x6f, 0x17, WEST),
                south_1 = entrance(0x65, 0x1f, NORTH),
                south_2 = entrance(0x46, 0x1f, NORTH),
                west = entrance(0x38, 0x18, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                south_2 = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_5, north, SOUTH);
                },
                east = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                south_1 = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_start, north, SOUTH);
                },
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = @install() {
                    debug_subtext("B=2");
                },
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=8");
                },
            }

            fun trigger_enter() {
                prepare_room(0x02);
                
                // object[0x02] = 0x01; // hides room_2_sign
                // object[0x02] = 0x02; // closes room_2_west
                // object[0x02] = 0x03; // opens room_2_west, closes room_2_south
                object[0x03] = 0x01; // opens room_2_south_1
                // object[0x0a] = 0x01; // shows room_2_decoration (stone -> tree)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x53, 0x13);
                        add_isaac_enemy_spider(0d78, 0d16);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_1_5(DARK_FOREST) { // west "L"
            enum entrance {
                north = entrance(0x39, 0x24, SOUTH),
                east = entrance(0x48, 0x4b, WEST),
                west = entrance(0x26, 0x4e, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_west = @install() {
                    debug_subtext("S=1");
                },
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_4, south_2, NORTH);
                },
                exit_room_3_north = nop(),
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_start, west, EAST);
                },
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x04);

                // object[0x06] = 0x01; // closes room_4_north
                // object[0x07] = 0x01; // opens room_4_west
                // object[0x0e] = 0x01; // shows room_4_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x37, 0x37);
                        add_isaac_enemy_spider(0d53, 0d66);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_1_6(DARK_FOREST) { // south "_|_"
            enum entrance {
                north = entrance(0x39, 0x24, SOUTH),
                east = entrance(0x48, 0x4b, WEST),
                west = entrance(0x26, 0x4e, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_door, east, WEST);
                },
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_start, south, NORTH);
                },
                exit_room_3_north = nop(),
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_9, west, EAST);
                },
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x04);

                // object[0x06] = 0x01; // closes room_4_north
                object[0x07] = 0x01; // opens room_4_west
                // object[0x0e] = 0x01; // shows room_4_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        // north
                        add_isaac_enemy_slime(0d62, 0d52);

                        // south
                        add_isaac_enemy_maggot(0x37, 0x3b);
                        add_isaac_enemy_maggot(0x3d, 0x4a);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_1_door(BAD_BOYS) { // south-west "badboy-east"
            enum entrance {
                east = entrance(0x63, 0x1d, WEST),
                west = entrance(0x01, 0x21, EAST)
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),

                BEE_COLLECTED = memory(FLAG, SRAM),
                BRIDGE_BLOCKER = retained_object(0x07),
            }

            enum stepon_trigger {
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);
                    map_transition(basement_1_6, west, EAST);
                },
                exit_west = nop(),
            }

            fun open_east_exit(open) {
                if(open) {
                object[0x00] = 0x00; 
                } else {
                    object[0x00] = 0x7e;
                }
            }
            fun open_bridge(open) {
                if(open) {
                object[0x07] = 0x07e; 
                } else {
                    object[0x07] = 0x00;
                }
            }

            @install()
            fun trap_door_interacted() {
                check_exits(ROOM.CLEAR_FLAG);
                map_transition(basement_2_start, center, NONE);
            }

            fun trigger_enter() {
                object[0x00] = 0x02; // close exit_west

                add_placeholder(ANIMATION_PLACEHOLDER.ELEVATOR, 0d89, 0d29);
                attach_script(LAST_ENTITY, B, reference(trap_door_interacted));

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        // west
                        add_isaac_enemy_fly_exploding(0d74, 0d30);

                        // north
                        add_isaac_enemy_spider(0d93, 0d17);
                    }
                }

                if!(ROOM.BEE_COLLECTED) {
                    add_bee(0d16, 0d27, reference(@install() {
                        bee_collected(ROOM.BEE_COLLECTED);
                    }));
                }

                isaac_init(False, False);

                add_bombable(0d42, 0d30, ROOM.BRIDGE_BLOCKER, reference(@install() {
                    bombable_object(WALL_AXE2_FAKE, True, ROOM.BRIDGE_BLOCKER, 0x07, 0x01);
                }));
            }
        };

        map basement_1_9(DARK_FOREST) { // south-east "->"
            enum entrance {
                east = entrance(0x35, 0x16, WEST),
                north = entrance(0x18, 0x1f, NORTH),
                west = entrance(0x00, 0x15, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_1_6, east, WEST);
                },
                exit_east = @install() {
                    debug_subtext("S=3");
                },
                exit_south = @install() {
                    debug_subtext("S=4");
                },
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                sign = @install() {
                    debug_subtext("B=3");
                },
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                sniff = @install() {
                    debug_subtext("B=7");
                },
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x01);

                // object[0x00] = 0x01; // opens room_1_south
                object[0x01] = 0x01; // closes room_1_east
                // object[0x12] = 0x01; // hides room_1_sign
                // object[0x09] = 0x01; // shows room_1_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        // west
                        add_isaac_enemy_spider(0d15, 0d19);

                        // center
                        add_isaac_enemy_maggot(0x20, 0x15);

                        // east
                        add_isaac_enemy_fly_exploding(0d34, 0d21);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };
    };

    area level_2() {
        enum BASEMENT_LEVEL {
            NIGHT = True,
            RAIN = False,
        }

        map basement_2_start(DARK_FOREST) { // center "+"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0x12, 0x38, NONE, {
                    crash_both();

                    subtext("Basement Level 3");
                }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    debug_subtext("S=8");
                },
                exit_east = @install() {
                    map_transition(basement_2_4, west, EAST);
                },

                exit_north = @install() {
                    map_transition(basement_2_1, south, NORTH);
                },
                exit_south = @install() {
                    map_transition(basement_2_2, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x05);

                // object[0x04] = 0x01; // opens room_5_west
                object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_1(DARK_FOREST) { // north "^"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_start, north, SOUTH);
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    debug_subtext("S=13");
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    debug_subtext("S=15");
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);
                
                object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x5b, 0x32);

                        add_isaac_enemy_fly_exploding(0d89, 0d58);

                        add_isaac_enemy_fly_shooting(0d100, 0d66);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_2(DARK_FOREST) { // south "L"
            enum entrance {
                north = entrance(0x39, 0x24, SOUTH),
                east = entrance(0x48, 0x4b, WEST),
                west = entrance(0x26, 0x4e, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_west = @install() {
                    debug_subtext("S=1");
                },
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_start, south, NORTH);
                },
                exit_room_3_north = nop(),
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_3, west, EAST);
                },
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x04);

                // object[0x06] = 0x01; // closes room_4_north
                // object[0x07] = 0x01; // opens room_4_west
                // object[0x0e] = 0x01; // shows room_4_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_fly_exploding(0d62, 0d48);

                        add_isaac_enemy_slime(0d52, 0d62);

                        add_isaac_enemy_maggot(0x3c, 0x3c);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_3(DARK_FOREST) { // south-east, east-south "_|"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_4, south, NORTH);
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_2, east, WEST);
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                // object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0d98, 0d51);
                        add_isaac_enemy_maggot(0x5d, 0x3b);

                        add_isaac_enemy_spider(0d90, 0d59);
                        add_isaac_enemy_spider(0d101, 0d67);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_4(DARK_FOREST) { // east "-,-"
            enum entrance {
                east = entrance(0x35, 0x16, WEST),
                south = entrance(0x18, 0x1f, NORTH),
                west = entrance(0x00, 0x15, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_start, east, WEST);
                },
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_5, west, EAST);
                },
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_3, north, SOUTH);
                },
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                sign = @install() {
                    debug_subtext("B=3");
                },
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                sniff = @install() {
                    debug_subtext("B=7");
                },
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x01);

                object[0x00] = 0x01; // opens room_1_south
                // object[0x01] = 0x01; // closes room_1_east
                // object[0x12] = 0x01; // hides room_1_sign
                // object[0x09] = 0x01; // shows room_1_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_spider(0d15, 0d17);

                        add_isaac_enemy_maggot(0x26, 0x15);
                        
                        add_isaac_enemy_slime(0d38, 0d17);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_5(DARK_FOREST) { // east-east "-|"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0x12, 0x38, NONE),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_4, east, WEST);
                },
                exit_east = @install() {
                    debug_subtext("S=9");
                },

                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    fog_wall_outside(!SOULS_MEMORY.DEAD_MONSTRO, SOUTH);

                    map_transition(basement_2_boss, south, NORTH);
                },
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_6, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x05);

                object[0x04] = 0x01; // opens room_5_west
                // object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_spider(0d17, 0d45);
                        add_isaac_enemy_maggot(0x10, 0x38);

                        add_isaac_enemy_slime(0d22, 0d55);

                        add_isaac_enemy_spider(0d17, 0d74);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_6(DARK_FOREST) { // east-east-south "v"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_2_5, south, NORTH);
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    debug_subtext("S=15");
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                // object[0x13] = 0x01; // closes room_3_north

                if!(ROOM.CLEAR_FLAG) {
                    add_isaac_enemy_maggot(0x59, 0x47);
                    add_isaac_enemy_maggot(0x5b, 0x49);
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_2_boss(TIMBERDRAKE) { // east-east-north "drake-south"
            enum entrance {
                east = entrance(0x2b, 0x15, WEST),
                south = entrance(0x1b, 0x29, NORTH)
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum BOSS {
                PROGRESS = memory(FLAG, TEMP),
                ID = memory(WORD, TEMP),

                HP = 0d100, // TODO: too low for >bonecrusher

                FOLLOWING = memory(WORD, TEMP),

                PUKE_HELPER = memory(WORD, TEMP),

                MOVE_RNG = memory(WORD, TEMP),

                CANNONBALL_X = memory(WORD, TEMP),
                CANNONBALL_Y = memory(WORD, TEMP),
                CANNONBALL_COUNT = memory(WORD, TEMP),
            }

            enum stepon_trigger {
                exit_east = @install() {
                    debug_subtext("S=0");
                },
                exit_south = @install() {
                    fog_wall_inside(!SOULS_MEMORY.DEAD_MONSTRO, NORTH);

                    map_transition(basement_2_5, north, SOUTH);
                }
            }

            @install()
            @async()
            fun boss_defeated() {
                souls_boss_defeated(DEAD_MONSTRO, REWARD_MONSTRO);

                unset(BOSS.PROGRESS);
            }

            group monstro_ai() {
                @async()
                @install()
                fun following() {
                    while(alive(BOSS.ID)) {
                        if(BOSS.FOLLOWING > 0d00) {
                            if(BOSS.ID[X] > <BOY>[X]) {
                                BOSS.ID[X] -= BOSS.FOLLOWING;
                            } else if(BOSS.ID[X] < <BOY>[X]) {
                                BOSS.ID[X] += BOSS.FOLLOWING;
                            }

                            if(BOSS.ID[Y] > <BOY>[Y]) {
                                BOSS.ID[Y] -= BOSS.FOLLOWING;
                            } else if(BOSS.ID[Y] < <BOY>[Y]) {
                                BOSS.ID[Y] += BOSS.FOLLOWING;
                            }
                        }

                        yield();
                    }
                }

                fun wiggle(with_animaten, with_splash) {
                    if(with_animaten) {
                        animate(BOSS.ID, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);
                    }

                    if(with_splash) {
                        bomb_entity(BOSS.ID, 0d10, 0d10);
                    }
                }

                @install()
                fun yeet() {
                    BOSS.ID[VELOCITY] = 0d85;
                    
                    BOSS.FOLLOWING = True;
                    sleep(0d160);
                    BOSS.FOLLOWING = False;

                    wiggle(False, True);
                    ai_move_projectile_splash(BOSS.ID, ONION);
                }

                @install()
                fun hop() {
                    BOSS.ID[VELOCITY] = 0d30;

                    BOSS.FOLLOWING = True;
                    sleep(0d60);
                    BOSS.FOLLOWING = False;

                    wiggle(False, True);
                }

                fun move() {
                    wiggle(True, False);

                    BOSS.MOVE_RNG = randrange(0d05);

                    if(BOSS.MOVE_RNG == 0d00) {
                        ai_move_projectile_puke(BOSS.ID, ONION, <BOY>, 0d8);
                        sleep(0x50);
                    } else if(BOSS.MOVE_RNG == 0d01) {
                        yeet();
                        sleep(0x60);
                    } else {
                        hop();
                        sleep(0x20);
                    }
                }

                @async()
                @install()
                fun move_logic() {
                    sleep(0x80);
                    
                    while(alive(BOSS.ID)) {
                        move();
                    }
                }

                @install()
                fun monstro_damage() {
                    attribute(BOSS.ID, INVISIBLE, True);
                    yield();
                    attribute(BOSS.ID, INVISIBLE, False);
                    animate(BOSS.ID, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);

                    if(dead(BOSS.ID)) {
                        boss_defeated();
                    }
                }

                fun spawn_boss(x, y) {
                    add_enemy(MAGMAR, x, y);
                    BOSS.ID = <LAST_ENTITY>;
                    <LAST_ENTITY>[HP] = BOSS.HP;
                    animate(LAST_ENTITY, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);
                    attach_script(LAST_ENTITY, DAMAGE, reference(monstro_damage));
                    attribute(LAST_ENTITY, ROOT, True);

                    following();
                    move_logic();

                    set(BOSS.PROGRESS);
                    push_music(BOSS);
                }
            };

            fun trigger_enter() {
                if!(SOULS_MEMORY.DEAD_MONSTRO) {
                    spawn_boss(0x10, 0x13);

                    subtext("Isaac vs. Monstro");
                }

                // available(BOY);
                // destroy(DOG); // teleport(BOY, 0x00, 0x00);

                add_placeholder(ANIMATION_PLACEHOLDER.ELEVATOR, 0x10, 0x13);
                attach_script(LAST_ENTITY, B, reference(@install() {
                    if!(BOSS.PROGRESS) {
                        map_transition(basement_3_start, center, NONE);
                    }
                }));

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };
    };

    area level_3() {
        enum BASEMENT_LEVEL {
            NIGHT = True,
            RAIN = False,
        }

        map basement_3_start(DARK_FOREST) { // start "-|"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0x12, 0x38, NONE, {
                    crash_both();

                    subtext("Basement Level 4");
                }),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    map_transition(basement_3_1, east, WEST);
                },
                exit_east = @install() {
                    debug_subtext("S=9");
                },

                exit_north = @install() {
                    map_transition(basement_3_4, south_2, NORTH);
                },
                exit_south = @install() {
                    map_transition(basement_3_3, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                object[0x04] = 0x01; // opens room_5_west
                // object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                prepare_room(0x05);
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_1(DARK_FOREST) { // west ",-"
            enum entrance {
                east = entrance(0x6f, 0x17, WEST),
                south_1 = entrance(0x65, 0x1f, NORTH),
                south_2 = entrance(0x46, 0x1f, NORTH),
                west = entrance(0x38, 0x18, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                south_2 = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_2, north, SOUTH);
                },
                east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_start, west, EAST);
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                south_1 = @install() {
                    debug_subtext("S=16");
                },
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = @install() {
                    debug_subtext("B=2");
                },
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=8");
                },
            }

            fun trigger_enter() {
                prepare_room(0x02);
                
                // object[0x02] = 0x01; // hides room_2_sign
                // object[0x02] = 0x02; // closes room_2_west
                // object[0x02] = 0x03; // opens room_2_west, closes room_2_south
                // object[0x03] = 0x01; // opens room_2_south_1
                // object[0x0a] = 0x01; // shows room_2_decoration (stone -> tree)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_fly_exploding(0d79, 0d17);

                        add_isaac_enemy_spider(0x57, 0x16);

                        add_isaac_enemy_fly_exploding(0d92, 0d26);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_2(DARK_FOREST) { // west-south "L"
            enum entrance {
                north = entrance(0x39, 0x24, SOUTH),
                east = entrance(0x48, 0x4b, WEST),
                west = entrance(0x26, 0x4e, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_west = @install() {
                    debug_subtext("S=1");
                },
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_1, south_2, NORTH);
                },
                exit_room_3_north = nop(),
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_3, west, EAST);
                },
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x04);

                // object[0x06] = 0x01; // closes room_4_north
                // object[0x07] = 0x01; // opens room_4_west
                // object[0x0e] = 0x01; // shows room_4_decoration (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_slime(0d57, 0d61);

                        add_isaac_enemy_maggot(0x3c, 0x3c);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_3(DARK_FOREST) { // south, west-south-east "_|"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_start, south, NORTH);
                },
                exit_room_4_east = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_2, east, WEST);
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                // object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_spider(0d97, 0d55);
                        
                        add_isaac_enemy_maggot(0x59, 0x47);
                        add_isaac_enemy_maggot(0x5b, 0x49);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_4(DARK_FOREST) { // north "/\"
            enum entrance {
                east = entrance(0x6f, 0x17, WEST),
                south_1 = entrance(0x65, 0x1f, NORTH),
                south_2 = entrance(0x46, 0x1f, NORTH),
                west = entrance(0x38, 0x18, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                south_2 = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_start, north, SOUTH);
                },
                east = @install() {
                    debug_subtext("S=6");
                },
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                south_1 = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_5, north, SOUTH);
                },
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = @install() {
                    debug_subtext("B=2");
                },
                room_1_sign = nop(),
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=8");
                },
            }

            fun trigger_enter() {
                prepare_room(0x02);
                
                // object[0x02] = 0x01; // hides room_2_sign
                // object[0x02] = 0x02; // closes room_2_west
                // object[0x02] = 0x03; // opens room_2_west, closes room_2_south
                object[0x03] = 0x01; // opens room_2_south_1
                // object[0x0a] = 0x01; // shows room_2_decoration (stone -> tree)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x53, 0x13);

                        add_isaac_enemy_maggot(0d92, 0d17);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_5(DARK_FOREST) { // north-south2 "|-"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0x12, 0x38, NONE),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    debug_subtext("S=8");
                },
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_6, west, EAST);
                },

                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_4, south_1, NORTH);
                },
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_7, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                // object[0x04] = 0x01; // opens room_5_west
                object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                prepare_room(0x05);

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x12, 0x36);

                        add_isaac_enemy_fly_exploding(0d27, 0d56);

                        add_isaac_enemy_spider(0d15, 0d69);
                        add_isaac_enemy_spider(0d22, 0d67);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_6(DARK_FOREST) { // north-south2-east "-^"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    debug_subtext("S=13");
                },
                exit_room_4_east = nop(),
                exit_room_3_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_5, east, WEST);
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x5d, 0x31);

                        add_isaac_enemy_slime(0d97, 0d68);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_7(DARK_FOREST) { // north-south2-south "|"
            enum entrance {
                north = entrance(0x11, 0x25, SOUTH),
                east = entrance(0x22, 0x38, WEST),
                south = entrance(0x11, 0x55, NORTH),
                west = entrance(0x00, 0x38, EAST),

                center = entrance(0x12, 0x38, NONE),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_west = @install() {
                    debug_subtext("S=8");
                },
                exit_east = @install() {
                    debug_subtext("S=9");
                },

                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_5, south, NORTH);
                },
                exit_south = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_8, north, SOUTH);
                },
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                room_3_sniff = nop(),
                sniff = @install() {
                    debug_subtext("B=5");
                },
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                // object[0x04] = 0x01; // opens room_5_west
                // object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                prepare_room(0x05);

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_fly_exploding(0d24, 0d56);
                        add_isaac_enemy_fly_shooting(0d11, 0d56);

                        add_isaac_enemy_maggot(0x12, 0x36);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_8(DARK_FOREST) { // north-south2-south-south "_|"
            enum entrance {
                north = entrance(0x5f, 0x25, SOUTH),
                west = entrance(0x4b, 0x4c, EAST),
                south = entrance(0x5a, 0x55, NORTH),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_south = @install() {
                    debug_subtext("S=0");
                },
                exit_room_4_west = nop(),
                exit_room_1_west = nop(),
                exit_room_1_east = nop(),
                exit_room_1_south = nop(),
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_north = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_7, south, NORTH);
                },
                exit_room_4_east = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_9, east, WEST);
                },
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                room_1_sign = nop(),
                sniff = @install() {
                    debug_subtext("B=4");
                },
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                room_1_sniff = nop(),
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x03);

                // object[0x08] = 0x01; // opens room_3_south, closes room_3_west
                // object[0x08] = 0x02; // closes room_3_west
                // object[0x0f] = 0x01; // shows room_3_decoration_1 (sign)
                // object[0x10] = 0x01; // shows room_3_decoration_2 (stone)
                // object[0x11] = 0x01; // shows room_3_decoration_3 (tree)
                // object[0x13] = 0x01; // closes room_3_north

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_slime(0d96, 0d54);

                        add_isaac_enemy_maggot(0x59, 0x47);
                        add_isaac_enemy_maggot(0x5b, 0x49);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_9(DARK_FOREST) { // north-south2-south-south-east "--"
            enum entrance {
                east = entrance(0x35, 0x16, WEST),
                north = entrance(0x18, 0x1f, NORTH),
                west = entrance(0x00, 0x15, EAST),
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum ROOM {
                CLEAR_FLAG = memory(FLAG, SRAM),
            }

            enum stepon_trigger {
                exit_room_3_south = nop(),
                exit_room_4_west = nop(),
                exit_west = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    fog_wall_outside(!SOULS_MEMORY.DEAD_DARK_ONE, EAST);

                    map_transition(basement_3_boss, east, WEST);
                },
                exit_east = @install() {
                    check_exits(ROOM.CLEAR_FLAG);

                    map_transition(basement_3_8, west, EAST);
                },
                exit_south = @install() {
                    debug_subtext("S=4");
                },
                exit_room_2_south_2 = nop(),
                exit_room_2_east = nop(),
                stepon_7 = @install() {
                    debug_subtext("S=7");
                },
                exit_room_5_west = nop(),
                exit_room_5_east = nop(),

                exit_room_5_north = nop(),
                exit_room_5_south = nop(),
                exit_room_4_north = nop(),
                exit_room_3_north = nop(),
                exit_room_4_east = nop(),
                exit_room_3_west = nop(),
                exit_room_2_south_1 = nop(),
            }

            enum b_trigger {
                b_trigger_0 = @install() {
                    debug_subtext("B=0");
                },
                b_trigger_1 = @install() {
                    debug_subtext("B=1");
                },
                room_2_sign = nop(),
                sign = @install() {
                    debug_subtext("B=3");
                },
                room_3_sniff = nop(),
                room_5_sniff = nop(),
                b_trigger_6 = @install() {
                    debug_subtext("B=6");
                },
                sniff = @install() {
                    debug_subtext("B=7");
                },
                room_2_sniff = nop(),
            }

            fun trigger_enter() {
                prepare_room(0x01);

                object[0x04] = 0x01; // opens room_5_west
                // object[0x05] = 0x01; // opens room_5_east
                // object[0x0b] = 0x01; // shows room_5_decoration_1 (sign)
                // object[0x0c] = 0x01; // shows room_5_decoration_2 (tree)
                // object[0x0d] = 0x01; // shows room_5_decoration_3 (stone)

                if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                    if!(ROOM.CLEAR_FLAG) {
                        add_isaac_enemy_maggot(0x23, 0x15);

                        add_isaac_enemy_spider(0d13, 0d18);
                        add_isaac_enemy_spider(0d23, 0d25);
                    }
                }
                
                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };

        map basement_3_boss(TIMBERDRAKE) { // north-south2-south-south-east-east "drake-east"
            enum entrance {
                east = entrance(0x2b, 0x15, WEST),
                south = entrance(0x1b, 0x29, NORTH)
            }

            enum soundtrack {
                default = soundtrack(AREA_BASEMENT.MUSIC_DEFAULT, 0xff)
            }

            enum BOSS {
                PROGRESS = memory(FLAG, TEMP),

                HP = 0d150,

                MOUNT_ID = memory(WORD, TEMP),
                RIDER_ID = memory(WORD, TEMP),

                MOVE_RNG = memory(WORD, TEMP),

                CANNONBALL_X = memory(WORD, TEMP),
                CANNONBALL_Y = memory(WORD, TEMP),
                CANNONBALL_COUNT = memory(WORD, TEMP),
            }

            enum stepon_trigger {
                exit_east = @install() {
                    fog_wall_inside(!SOULS_MEMORY.DEAD_DARK_ONE, WEST);

                    map_transition(basement_3_9, west, EAST);
                },
                exit_south = @install() {
                    debug_subtext("S=1");
                }
            }

            @install()
            fun boss_defeated() {
                BOSS.PROGRESS = False;
                souls_boss_defeated(DEAD_DARK_ONE, REWARD_DARK_ONE);

                map_transition(potato_room, floor, NONE);
            }

            group boss_ai() {
                @install()
                @async()
                fun stack_t01() {
                    while(alive(<BOY>)) {
                        BOSS.RIDER_ID[X] = BOSS.MOUNT_ID[X];
                        BOSS.RIDER_ID[Y] = BOSS.MOUNT_ID[Y];
                        yield();

                        // <DOG>[X] = <BOY>[X] - 0x05;
                        // <DOG>[Y] = <BOY>[Y];
                        // yield();
                    }
                }

                fun move() {
                    attribute(BOSS.MOUNT_ID, ROOT, True);
                    animate(BOSS.MOUNT_ID, ONCE, ANIMATION_ENEMY.LIZARD_DUCK_2);
                    control(BOSS.MOUNT_ID, True);
                    animate(BOSS.MOUNT_ID, LOOP, ANIMATION_ENEMY.LIZARD_DUCK_1);
                    sleep(0d30);

                    BOSS.MOVE_RNG = randrange(0d3);

                    if(BOSS.MOVE_RNG == 0d0) {
                        ai_move_projectile_x(BOSS.MOUNT_ID, ONION, 0d130);
                        sleep(0d80);
                        ai_move_projectile_plus(BOSS.MOUNT_ID, ONION, 0d130);
                    } else if(BOSS.MOVE_RNG == 0d1) {
                        ai_move_projectile_star(BOSS.MOUNT_ID, ONION, 0d130);
                    } else {
                        ai_move_charge_right(BOSS.MOUNT_ID, <BOY>, 0d8, 0d2);
                    }

                    animate(BOSS.MOUNT_ID, ONCE, ANIMATION_ENEMY.LIZARD_DUCK_2);
                    sleep(0d30);
                    animate(BOSS.MOUNT_ID, ONCE, DEFAULT);
                    attribute(BOSS.MOUNT_ID, ROOT, False);
                    control(BOSS.MOUNT_ID, False);

                    sleep(0d120);
                }

                @async()
                @install()
                fun move_logic() {
                    sleep(0x80);
                    
                    while(alive(BOSS.MOUNT_ID)) {
                        move();
                        
                        sleep(0x60);
                    }
                }

                fun spawn_boss(x, y) {
                    add_enemy(MAGMAR, x, y);
                    BOSS.RIDER_ID = <LAST_ENTITY>;
                    animate(LAST_ENTITY, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);
                    attach_script(LAST_ENTITY, DEATH, reference(boss_defeated));
                    attribute(LAST_ENTITY, ROOT, True);
                    attribute(LAST_ENTITY, INVISIBLE, True);
                    attribute(LAST_ENTITY, INVINCIBLE, True);

                    // add_enemy(DRAKE, x, y, INACTIVE);
                    // add_enemy(FOOTKNIGHT, x, y, INACTIVE);
                    add_enemy(LIZARD_BLACK, x, y, 0x00);
                    <LAST_ENTITY>[HP] = BOSS.HP;
                    attach_script(LAST_ENTITY, DEATH, reference(boss_defeated));
                    BOSS.MOUNT_ID = <LAST_ENTITY>;

                    move_logic();
                    stack_t01();

                    set(BOSS.PROGRESS);
                    push_music(BOSS);
                }
            };

            @install()
            fun trap_door_interacted() {
                if!(BOSS.PROGRESS) {
                    map_transition(west_hut_outside, hut, NONE);
                }
            }

            fun trigger_enter() {
                object[0x00] = 0x01; // close south
                object[0x01] = 0x7e; // open east

                if!(SOULS_MEMORY.DEAD_DARK_ONE) {
                    spawn_boss(0x10, 0x13);

                    subtext("Isaac vs. Dark One");
                }

                // available(BOY);
                // destroy(DOG); // teleport(BOY, 0x00, 0x00);

                add_placeholder(ANIMATION_PLACEHOLDER.ELEVATOR, 0x10, 0x13);
                attach_script(LAST_ENTITY, B, reference(trap_door_interacted));

                isaac_init(BASEMENT_LEVEL.NIGHT, BASEMENT_LEVEL.RAIN);
            }
        };
    };
};

area dungeon_volcano() {
    enum DUNGEON_VOLCANO {
        DEFAULT_MUSIC = MUSIC.SEWER_AMBIENT_WATER,
        DEFAULT_SIDE_MUSIC = MUSIC.SEWER_AMBIENT_WATER,

        BRIDGE_TOP = memory(FLAG, SRAM),
        BRIDGE_CENTER_TOP = memory(FLAG, SRAM),
        BRIDGE_CENTER_BOTTOM = memory(FLAG, SRAM),
        CUTSCENE_STONE = memory(WORD, TEMP),
    }

    group dungeon_volcano_helper() {
        fun add_bridge_stone(index, x, y) {
            if(index == 0x0) {
                if!(DUNGEON_VOLCANO.BRIDGE_TOP) {
                    add_enemy(STONE_ROUND, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        map_transition(dungeon_volcano, cutscene_bridge_top, NONE);
                    }));
                }
            } else if(index == 0x1) {
                if!(DUNGEON_VOLCANO.BRIDGE_CENTER_TOP) {
                    add_enemy(STONE_ROUND, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        map_transition(dungeon_volcano, cutscene_bridge_center_top, NONE);
                    }));
                }
            } else if(index == 0x2) {
                if!(DUNGEON_VOLCANO.BRIDGE_CENTER_BOTTOM) {
                    add_enemy(STONE_ROUND, x, y);
                    attach_script(LAST_ENTITY, B, reference(@install() {
                        map_transition(dungeon_volcano, cutscene_bridge_center_bottom, NONE);
                    }));
                }
            }
        }
        fun trigger_bridge_stone(index) {
            if(index == 0d0) {
                if(DUNGEON_VOLCANO.BRIDGE_TOP) {
                    question("Jump into the volcano?[CHOICE]yes…[CHOICE]no…");
                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        map_transition(dungeon_volcano, jump_bridge_top, NONE);
                    } else {
                        error_walk_back(NORTH);
                    }
                } else {
                    error_walk_back(NORTH);
                }
            } else if(index == 0d1) {
                if(DUNGEON_VOLCANO.BRIDGE_CENTER_TOP) {
                    question("Jump into the volcano?[CHOICE]yes…[CHOICE]no…");
                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        if(DUNGEON_VOLCANO.BRIDGE_CENTER_BOTTOM) {
                            map_transition(dungeon_volcano, jump_bridge_center_top, NONE);
                        } else {
                            dialog("Seems way too dangerous![B]");
                            error_walk_back(NORTH);    
                        }
                    } else {
                        error_walk_back(NORTH);
                    }
                } else {
                    error_walk_back(NORTH);
                }
            } else if(index == 0d2) {
                if(DUNGEON_VOLCANO.BRIDGE_CENTER_BOTTOM) {
                    question("Jump into the volcano?[CHOICE]yes…[CHOICE]no…");
                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        map_transition(dungeon_volcano, jump_bridge_center_bottom, NONE);
                    } else {
                        error_walk_back(NORTH);
                    }
                } else {
                    error_walk_back(NORTH);
                }
            }
        }

        @install()
        fun falling_rock_transition() {
            pit_fall_callback({
                crash_both(0d5, 0d5);
            }, {
                crash_both(0d5, 0d10);
            });
        }
    };

    map dungeon_volcano(VOLCANO) {
        fun _falling_rock_cutscene(x, y, bridge_id) {
            add_enemy(STONE_ROUND, x, y);
            DUNGEON_VOLCANO.CUTSCENE_STONE = <LAST_ENTITY>;

            DUNGEON_VOLCANO.CUTSCENE_STONE[Z] = 0d2000;

            sleep(0d60);

            sound(MAGMA_HARDENING);
            object[bridge_id] = 0x7e; // show bridge

            destroy(DUNGEON_VOLCANO.CUTSCENE_STONE);
        }
        @async()
        @install()
        fun falling_rock_cutscene(x, y, bridge_id) {
            _falling_rock_cutscene(x, y, bridge_id);

            sleep(0d80);

            if(bridge_id == 0d0) {
                DUNGEON_VOLCANO.BRIDGE_TOP = True;

                map_transition(stone_room_top, south, NONE);
            } else if(bridge_id == 0d1) {
                DUNGEON_VOLCANO.BRIDGE_CENTER_TOP = True;

                map_transition(radahn_exit, south_2, NONE);
            } else if(bridge_id == 0d2) {
                DUNGEON_VOLCANO.BRIDGE_CENTER_BOTTOM = True;

                map_transition(stone_room_center_bottom, south, NONE);
            }
        }

        enum entrance {
            north_1 = entrance(0x2e, 0x05, SOUTH),
            north_2 = entrance(0x76, 0x06, SOUTH),
            south_1 = entrance(0x7d, 0xb1, NORTH),
            south_2 = entrance(0x51, 0xb1, NORTH),

            cutscene_bridge_top = entrance(0d83, 0d53, NONE, {
                CUSTOM_FLAG.CUTSCENE = True;
                falling_rock_cutscene(0d84, 0d53, 0x00);
            }),
            cutscene_bridge_center_top = entrance(0d82, 0d65, NONE, {
                CUSTOM_FLAG.CUTSCENE = True;
                falling_rock_cutscene(0d82, 0d65, 0x01);
            }),
            cutscene_bridge_center_bottom = entrance(0d78, 0d81, NONE, {
                CUSTOM_FLAG.CUTSCENE = True;
                falling_rock_cutscene(0d78, 0d81, 0x02);
            }),

            jump_bridge_top = entrance(0d83, 0d53, NONE, {
                falling_rock_transition();
            }),
            jump_bridge_center_top = entrance(0d82, 0d65, NONE, {
                falling_rock_transition();
            }),
            jump_bridge_center_bottom = entrance(0d78, 0d81, NONE, {
                falling_rock_transition();
            }),
        }

        enum soundtrack {
            default = soundtrack(DUNGEON_VOLCANO.DEFAULT_MUSIC, 0xff)
        }

        enum ROOM {
            ID_STONE = memory(WORD, TEMP),

            Z_UPSTAIRS = 0x10,
            Z_DOWNSTAIRS = 0x20,

            BEE_COLLECTED = memory(FLAG, SRAM),

            BLOCKED_GOURD = retained_object(0x03),
        }

        enum stepon_trigger {
            exit_north_1 = @install() {
                map_transition(squidmar, south, NORTH);
            },
            exit_north_2 = @install() {
                map_transition(aquagoth, south, NORTH);
            },
            exit_south_1 = @install() {
                map_transition(east_crossing, elevator_top, SOUTH);
            },
            exit_south_2 = @install() {
                map_transition(east_crossing, elevator_bottom, SOUTH);
            },
        }

        enum b_trigger {
            gourd_north_2__1_mud_pepper = @install() fun gourd_north_2__1_mud_pepper() {
                debug_subtext("B=0/1");
                
                ROOM.BLOCKED_GOURD = True;
                object[0x03] = 0x01;

                //  _loot_chest(0x03, QUEENS_KEY, 0d01);
                reward(QUEENS_KEY);
            },
            gourd_north_2__1_mud_pepper = gourd_north_2__1_mud_pepper(),
            sniff__1_water = @install() {
                debug_subtext("B=2");
                _loot(0x10, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=3");
                _loot(0x0f, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=4");
                _loot(0x0e, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=5");
                _loot(0x0d, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=6");
                _loot(0x0c, WATER, 0d01, 0d00);
            },
            sniff__1_water = @install() {
                debug_subtext("B=7");
                _loot_chest(0x0a, WATER, 0d01);
            },
            gourd_inside_2__100_money = @install() {
                debug_subtext("B=8");
                _loot_chest(0x0b, MONEY, 0d100);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=9");
                _loot(0x11, CLAY, 0d01, 0d00);
            },

            sniff__1_clay = @install() {
                debug_subtext("B=10");
                _loot(0x12, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=11");
                _loot(0x13, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=12");
                _loot(0x14, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=13");
                _loot(0x15, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=14");
                _loot(0x16, CLAY, 0d01, 0d00);
            },
            sniff__1_clay = @install() {
                debug_subtext("B=15");
                _loot(0x17, CLAY, 0d01, 0d00);
            },
            sniff__1_roots = @install() {
                debug_subtext("B=16");
                _loot(0x18, ROOTS, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=17");
                _loot(0x19, OIL, 0d01, 0d00);
            },
            sniff__1_oil = @install() {
                debug_subtext("B=18");
                _loot(0x1a, OIL, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=19");
                _loot(0x1b, ASH, 0d01, 0d00);
            },

            sniff__1_ash = @install() {
                debug_subtext("B=20");
                _loot(0x1c, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("B=21");
                _loot(0x1d, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("S=22");
                _loot(0x1e, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("S=23");
                _loot(0x1f, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("S=24");
                _loot(0x20, ASH, 0d01, 0d00);
            },
            sniff__1_ash = @install() {
                debug_subtext("S=25");
                _loot(0x21, ASH, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("S=26");
                _loot(0x22, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("S=27");
                _loot(0x23, WAX, 0d01, 0d00);
            },
            sniff__1_wax = @install() {
                debug_subtext("S=28");
                _loot(0x24, WAX, 0d01, 0d00);
            },
            gourd_north_1__1_roots = @install() {
                debug_subtext("S=29");
                _loot_chest(0x08, ROOTS, 0d01);
            },

            gourd_west_2__1_roots = @install() {
                debug_subtext("S=30");
                _loot_chest(0x07, ROOTS, 0d01);
            },
            gourd_west_1__1_clay = @install() {
                debug_subtext("S=31");
                _loot_chest(0x06, CLAY, 0d01);
            },
            gourd_south__1_mud_pepper = @install() {
                debug_subtext("S=32");
                _loot_chest(0x04, MUD_PEPPER, 0d01);
            },
            gourd_east__1_petal = @install() {
                debug_subtext("S=33");
                _loot_chest(0x05, PETAL, 0d01);
            },
        }

        @install()
        fun stone_yump() {
            fake_b();

            arg[0x10] = <SCRIPT_OWNER>[GENERAL_PURPOSE];

            <SCRIPT_OWNER>[VELOCITY] = 0d50;

            while((<SCRIPT_OWNER>[X] != arg[0x10][X]) && (<SCRIPT_OWNER>[Y] != arg[0x10][Y])) {
                if(<SCRIPT_OWNER>[X] > arg[0x10][X]) {
                    <SCRIPT_OWNER>[X]--;
                } else if(<SCRIPT_OWNER>[X] < arg[0x10][X]) {
                    <SCRIPT_OWNER>[X]++;
                }

                if(<SCRIPT_OWNER>[Y] > arg[0x10][Y]) {
                    <SCRIPT_OWNER>[Y]--;
                } else if(<SCRIPT_OWNER>[Y] < arg[0x10][Y]) {
                    <SCRIPT_OWNER>[Y]++;
                }

                sleep(0d3);
            }

            destroy(arg[0x10]);
            sound(GORE_MOSQUITO);

            <SCRIPT_OWNER>[VELOCITY] = 0d20;
            sleep(0d40);
            <SCRIPT_OWNER>[VELOCITY] = 0d10;
            sleep(0d30);

            destroy(SCRIPT_OWNER);
        }

        fun trigger_stone(x, y, entity) {
            arg[0x10] = entity;

            add_enemy(STONE_ROUND, x, y);

            <LAST_ENTITY>[GENERAL_PURPOSE] = arg[0x10];
            attach_script(LAST_ENTITY, B, reference(stone_yump));
        }

        @install()
        fun debug_triggered() {
            object[0x00] = 0x7e; // show bridge_north
        }

        fun add_spike(x, y, upper_level) {
            add_enemy(TENTACLE_SPIKE, x, y, INVINCIBLE);
            
            if(upper_level is Word) {
                <LAST_ENTITY>[Z_LEVEL] = 0x10;
            }
        }

        @install()
        @async()
        fun heat_hazard() {
            _desert_damage(0d180, 0d3, (CUSTOM_MEMORY.CURRENT_ARMOR_CHEST == ARMOR_STATS.CHEST_2_3) || (CUSTOM_MEMORY.CURRENT_ARMOR_CHEST == ARMOR_STATS.CHEST_2_2));
        }

        fun trigger_enter() {
            if(DUNGEON_VOLCANO.BRIDGE_TOP) {
                object[0x00] = 0x7e; // show bridge_north
            } else {
                add_debug_entity(0d91, 0d51, reference(debug_triggered));
            }

            if(DUNGEON_VOLCANO.BRIDGE_CENTER_TOP) {
                object[0x01] = 0x7e; // show bridge_north
            }
            if(DUNGEON_VOLCANO.BRIDGE_CENTER_BOTTOM) {
                object[0x02] = 0x7e; // show bridge_north
            }

            add_bee(0d105, 0d111, reference(@install() {
                bee_collected(ROOM.BEE_COLLECTED);
            }));

            add_souls_npc_alchemist_escape(0d71, 0d104);

            add_enemy(STONE, 0d90, 0d126);
            <LAST_ENTITY>[Z_LEVEL] = 0x10;
            add_spike(0d90, 0d124, True);
            add_spike(0d87, 0d128, True);
            
            // start
            add_enemy_spawner(SPARK, 0d79, 0d153, 0d05);

            // west 1
            add_enemy_spawner(SPARK, 0d64, 0d139, 0d05);
            add_enemy_spawner(SPARK, 0d41, 0d103, 0d05);

            // west gourd
            add_spike(0d36, 0d66);
            attach_script(LAST_ENTITY, B, reference(@install() {
                sound(WEIRD_SOUND);

                destroy(<SCRIPT_OWNER>);
            }));

            // east
            add_enemy_spawner(SPARK, 0d110, 0d100, 0d05);

            // east + west
            add_enemy_spawner(SPARK, 0d48, 0d83, 0d05);
            add_enemy_spawner(SPARK, 0d35, 0d72, 0d05);

            // east + east
            add_enemy_spawner(SPARK, 0d99, 0d63, 0d05);

            // center

            // north east exit
            add_spike(0d114, 0d51);


            // north west exit

            // gourd
            add_spike(0d55, 0d34);
            add_spike(0d73, 0d47);
            trigger_stone(0d79, 0d41, <LAST_ENTITY>);

            default_init_room(True, False);

            // ramp
            add_enemy_spawner(SPARK, 0d65, 0d62, 0d05);

            add_spike(0d52, 0d46);
            add_spike(0d55, 0d45);

            heat_hazard();
        }
    };

    map squidmar(AQUAGOTH) {
        enum entrance {
            south = entrance(0x1b, 0x51, NORTH)
        }

        enum soundtrack {
            default = soundtrack(DUNGEON_VOLCANO.DEFAULT_MUSIC, 0xff)
        }

        enum ROOM {
            ID_NPC = memory(WORD, TEMP),
        }

        enum BOSS {
            DEBUG = False,

            ID = memory(WORD, TEMP),

            PROGRESS = memory(FLAG, TEMP),

            HP = 0d400,

            ENERGY_LEVEL = memory(WORD, TEMP),
            ENERGY_LEVEL_THRESHOLD = 0d15,

            SPAWNING = memory(FLAG, TEMP),

            WAVE_COUNT = memory(WORD, TEMP),
            WAVE_COUNT_P0 = 0d5,
        }

        fun fog_wall(exit_direction:DIRECTION) {
            if(BOSS.PROGRESS) {
                fog_wall_inside(!SOULS_MEMORY.DEAD_SQUIDMAR, exit_direction);
            }
        }

        @install()
        @async()
        fun fake_exit_scanner(entity) {
            range_checker(entity, <ACTIVE>, 0x20, 0x20, {
                fog_wall(NONE);

                NPC_SQUIDMAR.AQUAGOTH_SEEN = False;
                map_transition(dungeon_volcano, north_1, SOUTH);
            });
        }

        fun boss_defeated() {
            object[0x01] = 0x01; // hide aquagoth
            object[0x00] = 0x00; // close door

            souls_boss_defeated(DEAD_SQUIDMAR, REWARD_SQUIDMAR);
        }

        fun max_energy_check() {
            if(BOSS.ENERGY_LEVEL == BOSS.ENERGY_LEVEL_THRESHOLD) {
                attribute_bit(BOSS.ID, INVINCIBLE_TEMP, True);

                control(NONE);

                while(True) {
                    sound(TESLA);

                    arg[0x10] = randrange(0d2);
                    if(arg[0x10] == 0d0) {
                        shoot_entity_entity(BOSS.ID, LIGHTNING, BOY, 0d15, 0d0);
                        damage(BOY, arg[0x12], True);
                    } else {
                        shoot_entity_entity(BOSS.ID, LIGHTNING, DOG, 0d15, 0d0);
                        damage(DOG, arg[0x12], True);
                    }

                    sleep(0d10);

                    arg[0x12]++;
                }
            }
        }

        fun _wave_enemy_dead() {
            BOSS.WAVE_COUNT--;

            destroy(SCRIPT_OWNER);

            if(BOSS.DEBUG) {
                MEMORY.STRING_PARAMETER_1 = BOSS.WAVE_COUNT;
                MEMORY.STRING_PARAMETER_2 = BOSS.WAVE_COUNT_P0;
                debug_subtext("wave alive: [MEM1]/[MEM2]");
            }
        }
        @install()
        fun wave_enemy_dead() {
            _wave_enemy_dead();
        }

        @install()
        @async()
        fun spawn_enemy(type:ENEMY) {
            BOSS.WAVE_COUNT++;

            if(type == ENEMY.SPARK) {
                add_enemy(SPARK, 0d26, 0d51);
            } else if(type == ENEMY.MAGGOT) {
                add_enemy(MAGGOT, 0d26, 0d51);
            }

            attach_to_script(LAST_ENTITY);
            attribute(SCRIPT_OWNER, AI_RUN, True);
            // attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);
            attach_script(SCRIPT_OWNER, DEATH, reference(wave_enemy_dead));

            arg[0x10] = randrange(0d4);
            if(arg[0x10] == 0d0) { // north
                arg[0x12] = 0d21;
                arg[0x14] = 0d41;
            } else if(arg[0x10] == 0d1) { // east
                arg[0x12] = 0d33;
                arg[0x14] = 0d52;
            } else if(arg[0x10] == 0d2) { // south
                arg[0x12] = 0d23;
                arg[0x14] = 0d57;
            } else if(arg[0x10] == 0d3) { // west
                arg[0x12] = 0d18;
                arg[0x14] = 0d53;
            }

            walk(SCRIPT_OWNER, TILE_ABSOLUTE_DIRECT, arg[0x12], arg[0x14], SCRIPT_OWNER);
            control(SCRIPT_OWNER, False);
            // attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);

            if(type == ENEMY.SPARK) {
                while(alive(<SCRIPT_OWNER>)) { 
                    if(dead(BOSS.ID)) {
                        destroy(SCRIPT_OWNER);
                        end();
                    } else if(arg[0x16] < <SCRIPT_OWNER>[X]) {
                        arg[0x16] = <SCRIPT_OWNER>[X];
                        arg[0x18] = 0d0;
                    } else if(arg[0x16] == <SCRIPT_OWNER>[X]) {
                        arg[0x18]++;

                        if(arg[0x18] > 0d20) {
                            attribute(SCRIPT_OWNER, ROOT, True);

                            if(True) {
                                sound(TESLA);
                                shoot_entity_entity(SCRIPT_OWNER, LIGHTNING, BOSS.ID, 0d30, 0d0);
                                sleep(0d50);
                            }

                            attribute(SCRIPT_OWNER, INVISIBLE, True);
                            sleep(0d10);

                            attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);
                            yield();

                            if(alive(<SCRIPT_OWNER>)) {
                                BOSS.ENERGY_LEVEL++;
                                max_energy_check();

                                if(True) {
                                    MEMORY.STRING_PARAMETER_1 = BOSS.ENERGY_LEVEL;
                                    MEMORY.STRING_PARAMETER_2 = BOSS.ENERGY_LEVEL_THRESHOLD;
                                    subtext("Energy: [MEM1]/[MEM2]");
                                }

                                _wave_enemy_dead();
                            }

                            end();
                        }
                    }

                    sleep(0d10);
                }
            }
        }

        fun spawn_wave() {
            while(BOSS.WAVE_COUNT < BOSS.WAVE_COUNT_P0) {
                spawn_enemy(SPARK);

                sleep(0d30);
            }
        }

        @install()
        fun squidmar_triggered() {
            if!(BOSS.SPAWNING) {
                BOSS.SPAWNING = True;
                yield();
                yield();
                yield();

                if(dead(BOSS.ID)) {
                    boss_defeated();
                } else {
                    if(BOSS.DEBUG) {
                        debug_memory(BOSS.ID[HP], 0d0);
                    }

                    spawn_wave();
                }

                BOSS.SPAWNING = False;
            }
        }

        fun start_boss() {
            destroy(ROOM.ID_NPC);

            BOSS.PROGRESS = True;

            object[0x00] = 0x7e; // close door

            push_music(BOSS);

            sfx_effect(SHAKING, False);

            attach_script(BOSS.ID, DAMAGE, reference(squidmar_triggered));
        }
        
        @install()
        @async()
        fun scan_npc_id(entity) {
            while(NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT) {
                yield();
            }
            
            sleep(0d30);

            start_boss();
        }

        fun trigger_enter() {
            if!(SOULS_MEMORY.DEAD_SQUIDMAR) {
                response_reaction();

                add_enemy(AQUAGOTH_ENTITY, 0x1a, 0x34);
                BOSS.ID = <LAST_ENTITY>;
                BOSS.ID[HP] = BOSS.HP;

                if(NPC_SQUIDMAR.INSANITY < NPC_SQUIDMAR.INSANITY_LIMIT) {
                    attach_script(BOSS.ID, DAMAGE, reference(npc_squidmar_triggered));

                    add_souls_npc_squidmar(0d26, 0d55);
                    ROOM.ID_NPC = <LAST_ENTITY>;
                    
                    scan_npc_id(<LAST_ENTITY>);
                } else {
                    start_boss();
                }
                
            } else {
                object[0x01] = 0x01; // hide aquagoth
            }

            default_init_room(True, False);

            add_enemy(PLACEHOLDER, 0x1b, 0x52);
            fake_exit_scanner(<LAST_ENTITY>);
        }
    };

    map aquagoth(AQUAGOTH) {
        enum entrance {
            south = entrance(0x1b, 0x51, NORTH)
        }

        enum soundtrack {
            default = soundtrack(DUNGEON_VOLCANO.DEFAULT_MUSIC, 0xff)
        }

        enum ROOM {
            FAKE_EXIT_ID = memory(WORD, TEMP),
        }

        fun fake_exit() {
            map_transition(dungeon_volcano, north_2, SOUTH);
        }

        @install()
        @async()
        fun fake_exit_scanner() {
            attach_to_script(ROOM.FAKE_EXIT_ID);

            while(True) {
                arg[0x00] = <ACTIVE>[X];
                arg[0x02] = <ACTIVE>[Y];
                arg[0x04] = <SCRIPT_OWNER>[X];
                arg[0x06] = <SCRIPT_OWNER>[Y];

                if(arg[0x00] < arg[0x04]) {
                    arg[0x08] = arg[0x04] - arg[0x00];
                } else {
                    arg[0x08] = arg[0x00] - arg[0x04];
                }

                if(arg[0x02] < arg[0x06]) {
                    arg[0x0a] = arg[0x06] - arg[0x02];
                } else {
                    arg[0x0a] = arg[0x02] - arg[0x06];
                }

                if((arg[0x08] <= 0x20) && (arg[0x0a] <= 0x20)) {
                    fake_exit();
                    end();
                }

                yield();
            }
        }

        enum BOSS {
            DEBUG = False,

            ID = memory(WORD, TEMP),

            DEFEATED = memory(FLAG, SRAM),

            DAMAGE = 0d200,
            MAX_HP = 0d2500,
            DIALOG_THRESHOLD_RESCUED_FLAG = memory(FLAG, TEMP),

            DIALOG_THRESHOLD_1 = 0d1000,
            DIALOG_THRESHOLD_1_FLAG = memory(FLAG, TEMP),

            DIALOG_THRESHOLD_2 = 0d300,
            DIALOG_THRESHOLD_2_FLAG = memory(FLAG, TEMP),
        }

        fun boss_defeated() {
            set(SOULS_MEMORY.DEAD_AQUAGOTH);

            arg[0x10] = 0d40;
            while(arg[0x10] > 0d0) {
                object[0x01] = 0x00;
                yield();
                object[0x01] = 0x01;
                yield();

                arg[0x10]--;
            }
        }

        @install()
        @async()
        fun aquagoth_life_tracker(entity) {
            if(BOSS.DEBUG) {
                debug_memory(entity[HP]);
                sleep(0d60);
            }

            damage(entity, BOSS.DAMAGE, False);
            yield();

            if(BOSS.DEBUG) {
                yield();

                debug_memory(entity[HP]);
                sleep(0d60);
            }

            while(alive(entity)) {
                check_alchemy_type_animation(STOP, arg[0x10]);

                if(arg[0x10] > 0d0) {
                    attribute(entity, INVINCIBLE_TEMP, True);
                    subtext("Freedom…");
                    sleep(0d60);

                    boss_defeated();
                    end();
                } else if((!BOSS.DIALOG_THRESHOLD_RESCUED_FLAG) && (entity[HP] >= BOSS.MAX_HP)) {
                    BOSS.DIALOG_THRESHOLD_RESCUED_FLAG = True;

                    dialog("[SLOW]Here…[B]");

                    reward(STOP);

                    question("Where am I? Did my brother send you?[CHOICE]yes…[CHOICE]no…");

                    if(MEMORY.QUESTION_ANSWER == 0d0) {
                        dialog("[SLOW]Tell him………[B]");

                        NPC_SQUIDMAR.AQUAGOTH_RESCUED = True;
                    }
                } else if!(BOSS.DIALOG_THRESHOLD_2_FLAG) {
                    if(entity[HP] < BOSS.DIALOG_THRESHOLD_2) {
                        BOSS.DIALOG_THRESHOLD_2_FLAG = True;

                        subtext("ugh…");
                    }
                } else if!(BOSS.DIALOG_THRESHOLD_1_FLAG) {
                    if(entity[HP] < BOSS.DIALOG_THRESHOLD_1) {
                        BOSS.DIALOG_THRESHOLD_1_FLAG = True;

                        subtext("…");
                    }
                }

                sleep(0d60);

                if(BOSS.DEBUG) {
                    debug_memory(entity[HP], arg[0x10], <0x3367>);
                }
            }

            boss_defeated();
        }

        fun init_room() {
            if(SOULS_MEMORY.WITH_WEATHER) {
                sfx_effect(SEPIA, True);
            }
            
            default_init_room(False, False);
        }

        fun trigger_enter() {
            reset_alchemy_types();

            aquagoth_seen();
            
            if!(SOULS_MEMORY.DEAD_AQUAGOTH) {
                add_enemy(AQUAGOTH_ENTITY, 0x1a, 0x34);
                BOSS.ID = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(@install() {
                    NPC_SQUIDMAR.AQUAGOTH_DAMAGED = True;
                }));
                aquagoth_life_tracker(<LAST_ENTITY>);

                subtext("A fould stench is in the air.");
            } else {
                object[0x01] = 0x01;
            }

            init_room();

            add_enemy(PLACEHOLDER, 0x1b, 0x52);
            ROOM.FAKE_EXIT_ID = <LAST_ENTITY>;
            sleep(0x10);
            fake_exit_scanner();
        }
    };

    area side_volcano() {
        area northern_side_volcano() {
            map radahn_exit(VOLCANO_ROOMS) { // variant: room_nss
                enum entrance {
                    north = entrance(0x9e, 0x05, SOUTH),
                    south_1 = entrance(0x9e, 0x37, NORTH),
                    south_2 = entrance(0x84, 0x37, NORTH),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_south = nop(),
                    exit_room_s_south = nop(),
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_room_sw_west = nop(),
                    exit_room_ns_north = nop(),
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_south_2 = @install() {
                        debug_subtext("S=13");

                        trigger_bridge_stone(0x1);
                    },
                    exit_south_1 = @install() {
                        debug_subtext("S=14");

                        map_transition(east_crossing, cave, SOUTH);
                    },
                    exit_north = @install() {
                        debug_subtext("S=15");

                        map_transition(radahn_arena, south, NORTH);
                    },
                    exit_room_alchemist_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd_room_ns__4_ash = nop(),
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd_room_s__2_wax = nop(),
                    gourd_room_s__3_ash = nop(),
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff__1_roots = @install() {
                        debug_subtext("B=15");
                        _loot(0x0b, ROOTS, 0d01, 0d00);
                    },
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff_room_s__1_oil = nop(),
                    sniff_room_nw__1_oil = nop(),
                    sniff__1_wax = @install() {
                        debug_subtext("B=22");
                        _loot(0x12, WAX, 0d01, 0d00);
                    },
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    init_room(0d2);

                    add_bridge_stone(0x1, 0d132, 0d47);

                    default_init_room(False, False);
                }
            };
        };

        map stone_room_top(VOLCANO_ROOMS) { // variant: room_es
            enum entrance {
                east = entrance(0x67, 0x1c, WEST),
                south = entrance(0x4c, 0x39, NORTH),

                crash = entrance(0d82, 0d19, NONE, { falling_rock_transition(); }),
            }

            enum soundtrack {
                default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_south = @install() {
                    debug_subtext("S=10");

                    trigger_bridge_stone(0x0);
                },
                exit_east = @install() {
                    debug_subtext("S=11");

                    map_transition(cave_left_north_exit, west, EAST);
                },
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff__1_oil = @install() {
                    debug_subtext("B=19");
                    _loot(0x0f, OIL, 0d01, 0d00);
                },
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun trigger_enter() {
                add_bridge_stone(0x0, 0d76, 0d51);

                init_map(0x3a, 0x08, 0x68, 0x38); // room_es

                default_init_room(False, False);
            }
        };

        map stone_room_center_bottom(VOLCANO_ROOMS) { // variant: room_es
            enum entrance {
                east = entrance(0x67, 0x1c, WEST),
                south = entrance(0x4c, 0x39, NORTH),
            }

            enum soundtrack {
                default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
            }

            enum stepon_trigger {
                exit_room_nw_north = nop(),
                exit_room_nw_west = nop(),
                exit_south = nop(),
                exit_room_s_south = nop(),
                exit_room_nne_east = nop(),
                exit_room_ns_south = nop(),
                exit_room_sw_west = nop(),
                exit_room_ns_north = nop(),
                exit_room_sw_south = nop(),
                exit_room_nne_north_1 = nop(),

                exit_south = @install() {
                    debug_subtext("S=10");

                    trigger_bridge_stone(0x2);
                },
                exit_east = @install() {
                    debug_subtext("S=11");

                    map_transition(cave_right_entrance, west, EAST);
                },
                exit_room_nne_north_2 = nop(),
                exit_room_nss_south_2 = nop(),
                exit_room_nss_south_1 = nop(),
                exit_room_nss_north = nop(),
                exit_room_alchemist_north = nop(),
                exit_main_east = nop(),
                exit_main_west = nop(),
                exit_main_north = nop(),

                exit_main_south = nop(),
            }
            
            enum b_trigger {
                sniff_room_alchemist__1_ash = nop(),
                gourd_cave_outside__3_wax = nop(),
                gourd_cave_outside__1_wax = nop(),
                gourd_room_ns__4_ash = nop(),
                gourd_room_sw__4_ash = nop(),
                gourd_main__1_call_bead = nop(),
                gourd_alchemist_west__3_water = nop(),
                gourd_room_s__2_wax = nop(),
                gourd_room_s__3_ash = nop(),
                gourd_alchemist_hidden_2__5_wax = nop(),
                gourd_alchemist_hidden_1__6_water = nop(),
                sniff__1_ash = @install() {
                    debug_subtext("B=11");
                    _loot_chest(0x05, ASH, 0d04);
                },
                sniff_room_sw__1_water = nop(),
                sniff_room_nne__1_water = nop(),
                sniff_room_ns__1_clay = nop(),
                sniff_room_nss__1_roots = nop(),
                sniff_room_nne__1_roots = nop(),
                sniff_room_main__1_roots = nop(),
                sniff_cave_outside__1_roots = nop(),
                sniff__1_oil = @install() {
                    debug_subtext("B=19");
                    _loot(0x0f, OIL, 0d01, 0d00);
                },
                sniff_room_s__1_oil = nop(),
                sniff_room_nw__1_oil = nop(),
                sniff_room_nss__1_wax = nop(),
                sniff_room_ns__1_wax = nop(),
                sniff_room_main__1_wax = nop(),
            }

            fun trigger_enter() {
                add_bridge_stone(0x2, 0d76, 0d51);

                init_map(0x3a, 0x08, 0x68, 0x38); // room_es

                default_init_room(False, False);
            }
        };

        area cave_left() {
            map cave_left_entrance(OGLIN_CAVE) { // variant room_1 (entrance)
                enum entrance {
                    north = entrance(0x38, 0x93, SOUTH),
                    south_1 = entrance(0x40, 0xcb, NORTH),
                    south_2 = entrance(0x2c, 0xcb, NORTH),

                    teleporter_north = entrance(0x2d, 0x9e, NONE, { teleporter_in(SOUTH); }),
                    teleporter_east = entrance(0x39, 0xb4, NONE, { teleporter_in(SOUTH); }),
                    teleporter_west = entrance(0x09, 0xaa, NONE, { teleporter_in(SOUTH); }),
                    
                    waterfall = entrance(0x24, 0xc8, NONE),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_room_3_north_2 = nop(),
                    exit_room_3_north_1 = nop(),
                    exit_room_2_north_3 = nop(),
                    exit_north = @install() {
                        debug_subtext("S=28");

                        map_transition(cave_left_north_east, south_3, NORTH);
                    },
                    exit_room_2_north_2 = nop(),

                    exit_south_1 = @install() {
                        debug_subtext("S=30");

                        map_transition(ship, door_3_1, SOUTH);
                    },
                    exit_room_2_north_1 = nop(),
                    exit__south_2 = @install() {
                        debug_subtext("S=32");
                    },
                    room_2_teleporter = nop(),
                    room_3_teleporter = nop(),
                    room_4_teleporter_south_west = nop(),
                    teleporter_east = @install() {
                        debug_subtext("S=36");

                        teleporter_out(0x39, 0xb4);
                        map_transition(cave_left_south_east, teleporter, NONE);
                    },
                    teleporter_west = @install() {
                        debug_subtext("S=37");

                        teleporter_out(0x09, 0xaa);
                        map_transition(cave_left_entrance, teleporter_north, NONE);
                    },
                    teleporter_north = @install() {
                        debug_subtext("S=38");

                        teleporter_out(0x2d, 0x9e);
                        map_transition(cave_left_entrance, teleporter_west, NONE);
                    },
                    room_4_teleporter_north = nop(),

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff_room_3__1_bone_1 = nop(),
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff_room_4__1_water_2 = nop(),
                    sniff__1_water_1 = @install() {
                        debug_subtext("B=12");
                        _loot(0x14, WATER, 0d01, 0d01);
                    },
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = @install() {
                        debug_subtext("B=14");
                        _loot(0x12, WAX, 0d01, 0d01);
                    },
                    sniff__1_limestone = @install() {
                        debug_subtext("B=15");
                        _loot(0x11, LIMESTONE, 0d01, 0d00);
                    },
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff_room_3__1_limestone_2 = nop(),
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff_room_5__1_roots_1 = nop(),

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff_room_5__1_oil = nop(),
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // south
                        add_enemy(RAPTOR_PURPLE, 0d31, 0d180);

                        add_enemy(FLOWER_PURPLE, 0d21, 0d169);

                        // north
                        add_enemy(FLOWER_PURPLE, 0d58, 0d162);
                    }

                    init_room(0d1);

                    default_init_room(False, False);
                }
            };

            map cave_left_south_east(OGLIN_CAVE) { // variant room_3 (U-shape)
                enum ROOM {
                    CODE_BOT_HACKED = memory(FLAG, TEMP),
                    CODE_BOT_DIG_COUNT = 0d100,
                    CODE_BOT_X = 0d138,
                    CODE_BOT_Y = 0d218,
                }

                enum entrance {
                    north_1 = entrance(0x72, 0xd5, SOUTH),
                    north_2 = entrance(0xa4, 0xd5, SOUTH),

                    teleporter = entrance(0x89, 0xe0, NONE, { teleporter_in(SOUTH); }),

                    code_bot = entrance(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, NONE, {
                        ROOM.CODE_BOT_HACKED = True;

                        hacking_wakeup(0d0, 0d24, 0d40, 0d40);
                    }),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_north_2 = @install() {
                        debug_subtext("S=25");

                        map_transition(cave_left_north_east, south_1, NORTH);
                    },
                    exit_north_1 = @install() {
                        debug_subtext("S=26");

                        map_transition(cave_left_north_east, south_2, NORTH);
                    },
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    teleporter = @install() {
                        debug_subtext("S=34");

                        teleporter_out(0x89, 0xe0);
                        map_transition(cave_left_entrance, teleporter_east, NONE);
                    },
                    room_4_teleporter_south_west = nop(),
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    room_4_teleporter_north = nop(),

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff__1_bone_1 = @install() {
                        debug_subtext("B=3");
                        _loot(0x1d, BONE, 0d01, 0d01);
                    },
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff_room_4__1_water_2 = nop(),
                    sniff_room_1__1_water_1 = nop(),
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff__1_limestone_2 = @install() {
                        debug_subtext("B=17");
                        _loot(0x0f, LIMESTONE, 0d01, 0d02);
                    },
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff_room_5__1_roots_1 = nop(),

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff_room_5__1_oil = nop(),
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // south
                        add_enemy(LIZARD, 0d119, 0d233);

                        add_enemy(LIZARD, 0d158, 0d238);
                    }

                    init_room(0d3);
                    default_init_room(False, False);

                    archaeology_dig_code_bot(ROOM.CODE_BOT_X, ROOM.CODE_BOT_Y, ARCHAEOLOGY_DIG.CODE_2, ROOM.CODE_BOT_DIG_COUNT, ROOM.CODE_BOT_HACKED);
                }
            };
            map cave_left_south_west(OGLIN_CAVE) { // variant room_3 (U-shape)
                enum entrance {
                    north_1 = entrance(0x72, 0xd5, SOUTH),
                    north_2 = entrance(0xa4, 0xd5, SOUTH),

                    teleporter = entrance(0x89, 0xe0, NONE, { teleporter_in(SOUTH); }),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_north_2 = @install() {
                        debug_subtext("S=25");

                        map_transition(cave_left_north_west, south_1, NORTH);
                    },
                    exit_north_1 = @install() {
                        debug_subtext("S=26");

                        map_transition(cave_left_north_west, south_2, NORTH);
                    },
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    teleporter = @install() {
                        debug_subtext("S=34");
                    },
                    room_4_teleporter_south_west = nop(),
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    room_4_teleporter_north = nop(),

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff__1_bone_1 = @install() {
                        debug_subtext("B=3");
                        _loot(0x1d, BONE, 0d01, 0d01);
                    },
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff_room_4__1_water_2 = nop(),
                    sniff_room_1__1_water_1 = nop(),
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff__1_limestone_2 = @install() {
                        debug_subtext("B=17");
                        _loot(0x0f, LIMESTONE, 0d01, 0d02);
                    },
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff_room_5__1_roots_1 = nop(),

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff_room_5__1_oil = nop(),
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // south
                        add_enemy(RAPTOR_PURPLE, 0d152, 0d241);

                        add_enemy(RAPTOR_PURPLE, 0d109, 0d235);
                    }

                    init_room(0d3);
                    default_init_room(False, False);
                }
            };

            map cave_left_north_east(OGLIN_CAVE) { // variant room_5 (gourd)
                enum entrance {
                    north = entrance(0xa4, 0x01, SOUTH),
                    south_1 = entrance(0x96, 0x65, NORTH),
                    south_2 = entrance(0x6e, 0x65, NORTH),
                    south_3 = entrance(0x5c, 0x65, NORTH),
                    west_1 = entrance(0x57, 0x3c, EAST),
                    west_2 = entrance(0x57, 0x24, EAST),
                    west_3 = entrance(0x57, 0x0c, EAST),

                    teleporter_north = entrance(0x6b, 0x0a, NONE, { teleporter_in(SOUTH); }),
                    teleporter_east = entrance(0x99, 0x1e, NONE, { teleporter_in(SOUTH); }),
                    teleporter_south = entrance(0x81, 0x5c, NONE, { teleporter_in(SOUTH); }),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_north = @install() {
                        debug_subtext("S=4");

                        map_transition(cave_left_north_gourds, south, NORTH);
                    },
                    exit_south_1 = @install() {
                        debug_subtext("S=5");

                        map_transition(cave_left_south_east, north_2, SOUTH);
                    },
                    exit_south_2 = @install() {
                        debug_subtext("S=6");

                        map_transition(cave_left_south_east, north_1, SOUTH);
                    },
                    exit_south_3 = @install() {
                        debug_subtext("S=7");

                        map_transition(cave_left_entrance, north, SOUTH);
                    },
                    exit_west_1 = @install() {
                        debug_subtext("S=8");

                        map_transition(cave_left_north_west, east_3, WEST);
                    },
                    exit_west_2 = @install() {
                        debug_subtext("S=9");

                        map_transition(cave_left_north_west, east_2, WEST);
                    },

                    exit_west_3 = @install() {
                        debug_subtext("S=10");

                        map_transition(cave_left_north_west, east_1, WEST);
                    },
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_room_3_north_2 = nop(),
                    exit_room_3_north_1 = nop(),
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    exit_room_3_teleporter = nop(),
                    room_4_teleporter_south_west = nop(),
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    room_4_teleporter_north = nop(),

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    teleporter_south = @install() {
                        debug_subtext("S=42");
                    },
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    teleporter_east = @install() {
                        debug_subtext("S=46");

                        teleporter_out(0x99, 0x1e);
                        map_transition(cave_left_north_east, teleporter_north, NONE);
                    },
                    teleporter_north = @install() {
                        debug_subtext("S=47");

                        teleporter_out(0x6b, 0x0a);
                        map_transition(cave_left_north_east, teleporter_east, NONE);
                    },
                    room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd__3_call_beads = @install() {
                        debug_subtext("B=0");
                        _loot_chest(0x00, CALL_BEADS, 0d03);
                    },
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff_room_3__1_bone_1 = nop(),
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff__1_ash_2 = @install() {
                        debug_subtext("B=6");
                        _loot(0x1a, ASH, 0d01, 0d02);
                    },
                    sniff__1_vinegar_3 = @install() {
                        debug_subtext("B=7");
                        _loot(0x19, VINEGAR, 0d01, 0d03);
                    },
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff__1_water = @install() {
                        debug_subtext("B=10");
                        _loot(0x16, WATER, 0d01, 0d00);
                    },
                    sniff_room_4__1_water_2 = nop(),
                    sniff_room_1__1_water_1 = nop(),
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff_room_3__1_limestone_2 = nop(),
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff__1_roots_1 = @install() {
                        debug_subtext("B=19");
                        _loot(0x0d, ROOTS, 0d01, 0d01);
                    },

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff__1_ethanol_1 = @install() {
                        debug_subtext("B=21");
                        _loot(0x0b, ETHANOL, 0d01, 0d01);
                    },
                    sniff_room_7__1_ethanol = nop(),
                    sniff__1_crystal_2 = @install() {
                        debug_subtext("B=23");
                        _loot(0x09, CRYSTAL, 0d01, 0d02);
                    },
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff__1_oil = @install() {
                        debug_subtext("B=30");
                        _loot(0x02, OIL, 0d01, 0d00);
                    },
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // west
                        add_enemy(FLOWER_PURPLE, 0d91, 0d75);

                        // center
                        add_enemy(LIZARD, 0d115, 0d33);

                        add_enemy(FLOWER_PURPLE, 0d116, 0d71);

                        // east
                        add_enemy(LIZARD, 0d134, 0d72);

                        add_enemy(LIZARD, 0d147, 0d13);
                    }

                    init_room(0d5);
                    default_init_room(False, False);
                }
            };
            map cave_left_north_west(OGLIN_CAVE) { // variant room_6 (exit)
                enum entrance {
                    north = entrance(0d68, 0d3, SOUTH),
                    east_1 = entrance(0x4b, 0x0c, WEST),
                    east_2 = entrance(0x4b, 0x24, WEST),
                    east_3 = entrance(0x4b, 0x3c, WEST),
                    south_1 = entrance(0x40, 0x45, NORTH),
                    south_2 = entrance(0x16, 0x45, NORTH),

                    teleporter = entrance(0x17, 0x0e, NONE, { teleporter_in(SOUTH); }),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum ROOM {
                    STONE_MOVED = memory(FLAG, SRAM),
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_east_1 = @install() {
                        debug_subtext("S=11");

                        map_transition(cave_left_north_east, west_3, EAST);
                    },
                    exit_east_2 = @install() {
                        debug_subtext("S=12");

                        map_transition(cave_left_north_east, west_2, EAST);
                    },
                    exit_east_3 = @install() {
                        debug_subtext("S=13");

                        map_transition(cave_left_north_east, west_1, EAST);
                    },
                    exit_south_1 = @install() {
                        debug_subtext("S=14");

                        map_transition(cave_left_south_west, north_2, SOUTH);
                    },
                    exit_south_2 = @install() {
                        debug_subtext("S=15");

                        map_transition(cave_left_south_west, north_1, SOUTH);
                    },
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_room_3_north_2 = nop(),
                    exit_room_3_north_1 = nop(),
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    exit_room_3_teleporter = nop(),
                    room_4_teleporter_south_west = nop(),
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    room_4_teleporter_north = nop(),

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    teleporter = @install() {
                        debug_subtext("S=48");

                        if(ROOM.STONE_MOVED) {
                            teleporter_out(0d23, 0d14);
                            map_transition(bugmuck_cave_portal, teleporter, NONE);
                        }
                    },
                    exit_north = @install() {
                        debug_subtext("S=49");

                        map_transition(cave_left_north_exit, south, NORTH);
                    },
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff_room_3__1_bone_1 = nop(),
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff_room_4__1_water_2 = nop(),
                    sniff_room_1__1_water_1 = nop(),
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff_room_3__1_limestone_2 = nop(),
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff_room_5__1_roots_1 = nop(),

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff__1_crystal_1 = @install() {
                        debug_subtext("B=24");
                        _loot(0x08, CRYSTAL, 0d01, 0d01);
                    },
                    sniff__1_clay_1 = @install() {
                        debug_subtext("B=25");
                        _loot(0x07, CLAY, 0d01, 0d01);
                    },
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff_room_5__1_oil = nop(),
                    sniff__1_oil_1 = @install() {
                        debug_subtext("B=31");
                        _loot(0x01, OIL, 0d01, 0d01);
                    },
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // south
                        add_enemy(LIZARD, 0d43, 0d63);

                        // center
                        add_enemy(LIZARD, 0d27, 0d27);

                        add_enemy(LIZARD, 0d48, 0d52);

                        add_enemy(FLOWER_PURPLE, 0d68, 0d41);

                        // north
                        add_enemy(LIZARD, 0d50, 0d16);
                    }

                    if!(ROOM.STONE_MOVED) {
                        add_enemy(STONE_ROUND, 0d23, 0d15);
                        <LAST_ENTITY>[GENERAL_PURPOSE] = 0x0000;
                        
                        attach_script(LAST_ENTITY, B, reference(@install() {
                            guard_levitate_stone(0d2);

                            ROOM.STONE_MOVED = True;
                        }));
                    } else {
                        add_heavy_stone(0d17, 0d17);
                    }
                    // add_palette_donor(<LAST_ENTITY>, 0d0);

                    init_room(0d6);
                    default_init_room(False, False);
                }
            };

            map cave_left_north_gourds(VOLCANO_ROOMS) { // variant: room_s
                enum entrance {
                    south = entrance(0x9e, 0x7b, NORTH),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_cave_south = nop(),
                    exit_south = @install() {
                        debug_subtext("S=3");

                        map_transition(cave_left_north_east, north, SOUTH);
                    },
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_room_sw_west = nop(),
                    exit_room_ns_north = nop(),
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_room_nss_south_2 = nop(),
                    exit_room_nss_south_1 = nop(),
                    exit_room_nss_north = nop(),
                    exit_room_alchemist_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd_room_ns__4_ash = nop(),
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd__2_wax = @install() {
                        debug_subtext("B=7");
                        _loot_chest(0x01, WAX, 0d02);
                    },
                    gourd__3_ash = @install() {
                        debug_subtext("B=8");
                        _loot_chest(0x00, ASH, 0d03);
                    },
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff_room_nss__1_roots = nop(),
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff__1_oil = @install() {
                        debug_subtext("B=20");
                        _loot(0x10, OIL, 0d01, 0d00);
                    },
                    sniff_room_nw__1_oil = nop(),
                    sniff_room_nss__1_wax = nop(),
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        add_enemy(LIZARD, 0d152, 0d94);
                    }

                    init_room(0d6);
                    default_init_room(False, False);
                }
            };

            map cave_left_north_exit(VOLCANO_ROOMS) { // variant: room_sw
                enum entrance {
                    south = entrance(0x1c, 0x3b, NORTH),
                    west = entrance(0x01, 0x24, EAST),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_cave_south = nop(),
                    exit_room_s_south = nop(),
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_west = @install() {
                        debug_subtext("S=6");

                        map_transition(stone_room_top, east, WEST);
                    },
                    exit_room_ns_north = nop(),
                    exit_south = @install() {
                        debug_subtext("S=8");

                        map_transition(cave_left_north_west, north, SOUTH);
                    },
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_room_nss_south_2 = nop(),
                    exit_room_nss_south_1 = nop(),
                    exit_room_nss_north = nop(),
                    exit_room_alchemist_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd_room_ns__4_ash = nop(),
                    gourd__4_ash = @install() {
                        debug_subtext("B=4");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd_room_s__2_wax = nop(),
                    gourd_room_s__3_ash = nop(),
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff__1_water = @install() {
                        debug_subtext("B=12");
                        _loot(0x08, WATER, 0d01, 0d00);
                    },
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff_room_nss__1_roots = nop(),
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff_room_s__1_oil = nop(),
                    sniff_room_nw__1_oil = nop(),
                    sniff_room_nss__1_wax = nop(),
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        add_enemy(LIZARD, 0d17, 0d41);
                    }

                    init_room(0d0);
                    default_init_room(False, False);
                }
            };
        };

        area cave_right() {
            enum AREA_CAVE_RIGHT {
                STONE_MOVED = memory(FLAG, SRAM),
                STONE_OFFSET = 0d8 * 0d4,
            }

            map cave_right_entrance(OGLIN_CAVE) { // variant room_4
                @install()
                @async()
                fun shift_camera(x) {
                    set_camera(COORDINATE_CORNER, x, MEMORY.CAMERA_PAN_Y, 0x80 << 0d0002);

                    wait(CAMERA_PAN_X);

                    free_camera();
                }

                enum entrance {
                    north_1 = entrance(0x5e, 0x6f, SOUTH),
                    north_2 = entrance(0x7c, 0x6f, SOUTH),
                    north_3 = entrance(0x98, 0x6f, SOUTH, { shift_camera(0d1000); }),
                    south_1 = entrance(0x96, 0xc3, NORTH),
                    south_2 = entrance(0x6c, 0xc3, NORTH),
                    south_3 = entrance(0x5c, 0xc3, NORTH),
                    west = entrance(0x55, 0x80, EAST),

                    teleporter_north = entrance(0x81, 0x7e, NONE, { teleporter_in(SOUTH); }),
                    teleporter_south_west = entrance(0x5d, 0xa8, NONE, { teleporter_in(SOUTH); }),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_south_2 = @install() {
                        debug_subtext("S=1");

                        map_transition(cave_right_south, north_1, SOUTH);
                    },
                    exit_south_1 = @install() {
                        debug_subtext("S=2");

                        map_transition(cave_right_south, north_2, SOUTH);
                    },
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_north_3 = @install() {
                        debug_subtext("S=20");

                        map_transition(cave_right_side, south, NORTH);
                    },
                    exit_north_2 = @install() {
                        debug_subtext("S=21");

                        map_transition(cave_right_hammock, south, NORTH);
                    },
                    exit_north_1 = @install() {
                        debug_subtext("S=22");

                        map_transition(cave_right_gourds, south, NORTH);
                    },
                    exit_west = @install() {
                        debug_subtext("S=23");

                        map_transition(stone_room_center_bottom, east, WEST);
                    },
                    exit_south_3 = @install() {
                        debug_subtext("S=24");

                        map_transition(ship, door_3_2, SOUTH);
                    },
                    exit_room_3_north_2 = nop(),
                    exit_room_3_north_1 = nop(),
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    exit_room_3_teleporter = nop(),
                    teleporter_south_west = @install() {
                        debug_subtext("S=35");
                        
                        teleporter_out(0x5d, 0xa8);
                        map_transition(cave_right_side, teleporter_north, NONE);
                    },
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    teleporter_north = @install() {
                        debug_subtext("S=39");

                        if(AREA_CAVE_RIGHT.STONE_MOVED) {
                            teleporter_out(0x81, 0x7e);
                            map_transition(cave_right_side, teleporter_south, NONE);
                        }
                    },

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff_room_3__1_bone_1 = nop(),
                    sniff_room_2__1_bone = nop(),
                    sniff__1_bone_1 = @install() {
                        debug_subtext("B=5");
                        _loot(0x1b, BONE, 0d01, 0d01);
                    },
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff__1_vinegar_2 = @install() {
                        debug_subtext("B=8");
                        _loot(0x18, VINEGAR, 0d01, 0d02);
                    },
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff__1_water_2 = @install() {
                        debug_subtext("B=11");
                        _loot(0x15, WATER, 0d01, 0d02);
                    },
                    sniff_room_1__1_water_1 = nop(),
                    sniff__1_wax_2 = @install() {
                        debug_subtext("B=13");
                        _loot(0x13, WAX, 0d01, 0d02);
                    },
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff_room_3__1_limestone_2 = nop(),
                    sniff__1_limestone_1 = @install() {
                        debug_subtext("B=18");
                        _loot(0x0e, LIMESTONE, 0d01, 0d01);
                    },
                    sniff_room_5__1_roots_1 = nop(),

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff__1_clay_1 = @install() {
                        debug_subtext("B=28");
                        _loot(0x04, CLAY, 0d01, 0d01);
                    },
                    sniff__1_oil_2 = @install() {
                        debug_subtext("B=29");
                        _loot(0x03, OIL, 0d01, 0d02);
                    },

                    sniff_room_5__1_oil = nop(),
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // east
                        add_enemy(FLOWER_PURPLE, 0d149, 0d143);

                        add_enemy(FLOWER_PURPLE, 0d151, 0d179);

                        // center
                        add_enemy(RAPTOR_PURPLE, 0d112, 0d150);

                        add_enemy(FLOWER_PURPLE, 0d39, 0d132);

                        // north
                        add_enemy(FLOWER_PURPLE, 0d121, 0d122);

                        add_enemy(RAPTOR_PURPLE, 0d131, 0d161);
                    }

                    special_script(LEVITATE, reference(@install() {
                        if(<SCRIPT_OWNER>[FLAGS_2] & ATTRIBUTE_FLAGS.INVINCIBLE_TEMP) {
                            end();
                        }

                        attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, True);

                        if!(AREA_CAVE_RIGHT.STONE_MOVED) {
                            sleep(0d60);

                            AREA_CAVE_RIGHT.STONE_MOVED = True;

                            sleep(0d60);

                            while(arg[0x10] < AREA_CAVE_RIGHT.STONE_OFFSET) {
                                arg[0x10]++;

                                <SCRIPT_OWNER>[X]++;

                                sleep(0d3);
                            }

                            sleep(0d360 - 0d3 * AREA_CAVE_RIGHT.STONE_OFFSET);
                        } else {
                            sleep(0d120);

                            while(arg[0x10] < AREA_CAVE_RIGHT.STONE_OFFSET) {
                                arg[0x10]++;

                                <SCRIPT_OWNER>[X]--;

                                sleep(0d3);
                            }

                            sleep(0d360 - 0d3 * AREA_CAVE_RIGHT.STONE_OFFSET);

                            AREA_CAVE_RIGHT.STONE_MOVED = False;
                        }

                        attribute(SCRIPT_OWNER, INVINCIBLE_TEMP, False);
                    }));

                    add_levitate_stone(0x81, 0x7e, reference(@install() {
                        guard_levitate_stone(0d1);

                        AREA_CAVE_RIGHT.STONE_MOVED = True;
                    }));
                    if(AREA_CAVE_RIGHT.STONE_MOVED) {
                        <LAST_ENTITY>[X] += AREA_CAVE_RIGHT.STONE_OFFSET;
                    }

                    init_room(0d4);
                    default_init_room(False, False);
                }
            };

            map cave_right_south(OGLIN_CAVE) { // variant room_3 (U-shape)
                enum entrance {
                    north_1 = entrance(0x72, 0xd5, SOUTH),
                    north_2 = entrance(0xa4, 0xd5, SOUTH),

                    teleporter = entrance(0x89, 0xe0, NONE),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_side_south = nop(),
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_north_2 = @install() {
                        debug_subtext("S=25");

                        map_transition(cave_right_entrance, south_1, NORTH);
                    },
                    exit_north_1 = @install() {
                        debug_subtext("S=26");

                        map_transition(cave_right_entrance, south_2, NORTH);
                    },
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    teleporter = @install() {
                        debug_subtext("S=34");
                    },
                    room_4_teleporter_south_west = nop(),
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    room_4_teleporter_north = nop(),

                    room_side_teleporter_south = nop(),
                    room_side_teleporter_north = nop(),
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff_room_side__1_brimstone_2 = nop(),
                    sniff__1_bone_1 = @install() {
                        debug_subtext("B=3");
                        _loot(0x1d, BONE, 0d01, 0d01);
                    },
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff_room_4__1_water_2 = nop(),
                    sniff_room_1__1_water_1 = nop(),
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff__1_limestone_2 = @install() {
                        debug_subtext("B=17");
                        _loot(0x0f, LIMESTONE, 0d01, 0d02);
                    },
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff_room_5__1_roots_1 = nop(),

                    sniff_room_side__1_ethanol_2 = nop(),
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff_room_5__1_oil = nop(),
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        // south
                        add_enemy(FLOWER_PURPLE, 0d157, 0d236);

                        add_enemy(RAPTOR_PURPLE, 0d109, 0d235);
                    }

                    init_room(0d3);
                    default_init_room(False, False);
                }
            };

            map cave_right_side(OGLIN_CAVE) { // variant room_side
                enum entrance {
                    south = entrance(0xc8, 0x77, NORTH),

                    teleporter_north = entrance(0xc3, 0x50, NONE, { teleporter_in(SOUTH); }),
                    teleporter_south = entrance(0xc1, 0x64, NONE, { teleporter_in(SOUTH); }),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_south = @install() {
                        debug_subtext("S=0");

                        map_transition(cave_right_entrance, north_3, SOUTH);
                    },
                    exit_room_4_south_2 = nop(),
                    exit_room_4_south_1 = nop(),
                    stepon_3 = @install() {
                        debug_subtext("S=3");
                    },
                    exit_room_5_north = nop(),
                    exit_room_5_south_1 = nop(),
                    exit_room_5_south_2 = nop(),
                    exit_room_5_south_3 = nop(),
                    exit_room_5_west_1 = nop(),
                    exit_room_5_west_2 = nop(),

                    exit_room_5_west_3 = nop(),
                    exit_room_6_east_1 = nop(),
                    exit_room_6_east_2 = nop(),
                    exit_room_6_east_3 = nop(),
                    exit_room_6_south_1 = nop(),
                    exit_room_6_south_2 = nop(),
                    exit_room_7_east = nop(),
                    exit_room_7_north_2 = nop(),
                    exit_room_7_north_1 = nop(),
                    exit_room_7_south = nop(),

                    exit_room_4_north_3 = nop(),
                    exit_room_4_north_2 = nop(),
                    exit_room_4_north_1 = nop(),
                    exit_room_4_west = nop(),
                    exit_room_4_south_3 = nop(),
                    exit_room_3_north_2 = nop(),
                    exit_room_3_north_1 = nop(),
                    exit_room_2_north_3 = nop(),
                    exit_room_1_north = nop(),
                    exit_room_2_north_2 = nop(),

                    exit_room_1_south_1 = nop(),
                    exit_room_2_north_1 = nop(),
                    exit_room_1_south_2 = nop(),
                    exit_room_2_teleporter = nop(),
                    exit_room_3_teleporter = nop(),
                    room_4_teleporter_south_west = nop(),
                    room_1_teleporter_east = nop(),
                    room_1_teleporter_west = nop(),
                    room_1_teleporter_north = nop(),
                    room_4_teleporter_north = nop(),

                    teleporter_south = @install() {
                        debug_subtext("S=40");

                        if(AREA_CAVE_RIGHT.STONE_MOVED) {
                            teleporter_out(0xc1, 0x64);
                            map_transition(cave_right_entrance, teleporter_north, NONE);
                        } else {
                            error_message(DOOR_CONTRAPTION);
                        }
                    },
                    teleporter_north = @install() {
                        debug_subtext("S=41");

                        teleporter_out(0xc3, 0x50);
                        map_transition(cave_right_entrance, teleporter_south_west, NONE);
                    },
                    room_5_teleporter_south = nop(),
                    room_7_teleporter_center = nop(),
                    room_7_teleporter_west = nop(),
                    room_7_teleporter_north = nop(),
                    room_5_teleporter_east = nop(),
                    room_5_teleporter_north = nop(),
                    exit_room_6_teleporter = nop(),
                    exit_room_6_north = nop(),
                }

                enum b_trigger {
                    gourd_room_5__3_call_beads = nop(),
                    sniff_room_7__1_brimstone_2 = nop(),
                    sniff__1_brimstone_2 = @install() {
                        debug_subtext("B=2");
                        _loot(0x1e, BRIMSTONE, 0d01, 0d02);
                    },
                    sniff_room_3__1_bone_1 = nop(),
                    sniff_room_2__1_bone = nop(),
                    sniff_room_4__1_bone_1 = nop(),
                    sniff_room_5__1_ash_2 = nop(),
                    sniff_room_5__1_vinegar_3 = nop(),
                    sniff_room_4__1_vinegar_2 = nop(),
                    sniff_room_2__1_water_1 = nop(),

                    sniff_room_5__1_water = nop(),
                    sniff_room_4__1_water_2 = nop(),
                    sniff_room_1__1_water_1 = nop(),
                    sniff_room_4__1_wax_2 = nop(),
                    sniff_room_1__1_wax_1 = nop(),
                    sniff_room_1__1_limestone = nop(),
                    sniff_room_2__1_limestone_1 = nop(),
                    sniff_room_3__1_limestone_2 = nop(),
                    sniff_room_4__1_limestone_1 = nop(),
                    sniff_room_5__1_roots_1 = nop(),

                    sniff__1_ethanol_2 = @install() {
                        debug_subtext("B=20");
                        _loot(0x0c, ETHANOL, 0d01, 0d02);
                    },
                    sniff_room_5__1_ethanol_1 = nop(),
                    sniff_room_7__1_ethanol = nop(),
                    sniff_room_5__1_crystal_2 = nop(),
                    sniff_room_6__1_crystal_1 = nop(),
                    sniff_room_6__1_clay_1 = nop(),
                    sniff_room_7 = nop(),
                    sniff__1_clay_2 = @install() { // TODO: ???
                        debug_subtext("B=27");
                        _loot(0x05, CLAY, 0d01, 0d02);
                    },
                    sniff_room_4__1_clay_1 = nop(),
                    sniff_room_4__1_oil_2 = nop(),

                    sniff_room_5__1_oil = nop(),
                    sniff_room_6__1_oil_1 = nop(),
                }

                fun init_room(index) {
                    if(index == 0d1) {
                        init_map(0x00, 0x92, 0x46, 0xcc); // room 1
                    } else if(index == 0d2) {
                        init_map(0x20, 0xd4, 0x64, 0xfa); // room 2
                    } else if(index == 0d3) {
                        init_map(0x66, 0xd4, 0xaa, 0xf8); // room 3
                    } else if(index == 0d4) {
                        init_map(0x54, 0x6e, 0xa4, 0xc2); // room 4
                    } else if(index == 0d5) {
                        init_map(0x56, 0x00, 0xaa, 0x65); // room 5
                    } else if(index == 0d6) {
                        init_map(0x0c, 0x02, 0x4c, 0x46); // room 6
                    } else if(index == 0d7) {
                        init_map(0x0c, 0x4e, 0x50, 0x84); // room 7
                    } else if(index == 0d8) {
                        init_map(0xb4, 0x46, 0xd4, 0x78); // room side
                    }
                }

                fun trigger_enter() {
                    init_room(0d8);
                    default_init_room(False, False);
                }
            };

            map cave_right_hammock(CRUSTICIA_CAVES) { // variant: hammock
                enum entrance {
                    south = entrance(0x0f, 0x29, NORTH),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    monk = nop(),
                    monk_trigger_west = nop(),
                    monk_trigger_south = nop(),
                    exit_south = @install() {
                        debug_subtext("S=3");

                        map_transition(cave_right_entrance, north_2, SOUTH);
                    },
                    exit_ship_tavern = nop(),
                    exit_ship_small = nop(),
                    exit_cave_crates = nop(),
                    exit_cave_monk = nop(),
                }

                enum ROOM {
                    GOURD_LOOTED = memory(FLAG, SRAM),
                }

                enum b_trigger {
                    gourd_hammock__1_water = @install() {
                        debug_subtext("B=0");
                        // _loot_chest(0x03, WATER, 0d01);

                        fake_chest(ROOM.GOURD_LOOTED, 0x03);

                        custom_reward(CHEST_HEAVY, True);
                    },
                    gourd_monk_1__1_nectar = nop(),
                    gourd_monk_2__1_clay = nop(),
                    gourd_crates__1_nectar = nop(),
                    groud_tavern__1_wax = nop(),
                    gourd_ship__1_water = nop(),
                    tavern_barkeeper = nop(),
                }

                fun init_room(index) {
                    if(index == 0x00) {
                        init_map(0x00, 0x00, 0x2e, 0x2a); // hammock
                    } else if(index == 0x01) {
                        init_map(0x00, 0x38, 0x26, 0x5c); // crates
                    } else if(index == 0x02) {
                        init_map(0x32, 0x36, 0x56, 0x52); // ship
                    } else if(index == 0x03) {
                        init_map(0x58, 0x30, 0x86, 0x4e); // tavern
                    } else if(index == 0x04) {
                        init_map(0x40, 0x00, 0x66, 0x24); // monk
                    }
                }

                fun trigger_enter() {
                    // ???
                    // object[0x03] = 0x01; // loot gourd_hammock

                    fake_chest_init(ROOM.GOURD_LOOTED, 0x03);

                    init_room(0x00);
                    default_init_room(False, False);
                }
            };

            map cave_right_gourds(VOLCANO_ROOMS) { // variant: room_s
                enum entrance {
                    south = entrance(0x9e, 0x7b, NORTH),
                }

                enum soundtrack {
                    default = soundtrack(DUNGEON_VOLCANO.DEFAULT_SIDE_MUSIC, 0xff)
                }

                enum stepon_trigger {
                    exit_room_nw_north = nop(),
                    exit_room_nw_west = nop(),
                    exit_cave_south = nop(),
                    exit_south = @install() {
                        debug_subtext("S=3");

                        map_transition(cave_right_entrance, north_1, SOUTH);
                    },
                    exit_room_nne_east = nop(),
                    exit_room_ns_south = nop(),
                    exit_room_sw_west = nop(),
                    exit_room_ns_north = nop(),
                    exit_room_sw_south = nop(),
                    exit_room_nne_north_1 = nop(),

                    exit_room_es_south = nop(),
                    exit_room_es_east = nop(),
                    exit_room_nne_north_2 = nop(),
                    exit_room_nss_south_2 = nop(),
                    exit_room_nss_south_1 = nop(),
                    exit_room_nss_north = nop(),
                    exit_room_alchemist_north = nop(),
                    exit_main_east = nop(),
                    exit_main_west = nop(),
                    exit_main_north = nop(),

                    exit_main_south = nop(),
                }
                
                enum b_trigger {
                    sniff_room_alchemist__1_ash = nop(),
                    gourd_cave_outside__3_wax = nop(),
                    gourd_cave_outside__1_wax = nop(),
                    gourd_room_ns__4_ash = nop(),
                    gourd_room_sw__4_ash = nop(),
                    gourd_main__1_call_bead = nop(),
                    gourd_alchemist_west__3_water = nop(),
                    gourd__2_wax = @install() {
                        debug_subtext("B=7");
                        _loot_chest(0x01, WAX, 0d02);
                    },
                    gourd__3_ash = @install() {
                        debug_subtext("B=8");
                        _loot_chest(0x00, MUD_PEPPER, 0d01);
                    },
                    gourd_alchemist_hidden_2__5_wax = nop(),
                    gourd_alchemist_hidden_1__6_water = nop(),
                    sniff__1_ash = @install() {
                        debug_subtext("B=11");
                        _loot_chest(0x05, ASH, 0d04);
                    },
                    sniff_room_sw__1_water = nop(),
                    sniff_room_nne__1_water = nop(),
                    sniff_room_ns__1_clay = nop(),
                    sniff_room_nss__1_roots = nop(),
                    sniff_room_nne__1_roots = nop(),
                    sniff_room_main__1_roots = nop(),
                    sniff_cave_outside__1_roots = nop(),
                    sniff_room_es__1_oil = nop(),
                    sniff__1_oil = @install() {
                        debug_subtext("B=20");
                        _loot(0x10, OIL, 0d01, 0d00);
                    },
                    sniff_room_nw__1_oil = nop(),
                    sniff_room_nss__1_wax = nop(),
                    sniff_room_ns__1_wax = nop(),
                    sniff_room_main__1_wax = nop(),
                }

                fun init_room(index) {
                    if(index == 0d0) {
                        init_map(0x00, 0x04, 0x2a, 0x3c); // room_sw
                    } else if(index == 0d1) {
                        init_map(0x3a, 0x08, 0x68, 0x38); // room_es
                    } else if(index == 0d2) {
                        init_map(0x78, 0x06, 0xb0, 0x38); // room_nss
                    } else if(index == 0d3) {
                        init_map(0xbe, 0x04, 0xfc, 0x36); // room_alchemist
                    } else if(index == 0d4) {
                        init_map(0x0a, 0x3c, 0x30, 0x7c); // room_ns
                    } else if(index == 0d5) {
                        init_map(0x40, 0x38, 0x80, 0x6c); // room_ne
                    } else if(index == 0d6) {
                        init_map(0x8c, 0x46, 0xb2, 0x7c); // room_s
                    } else if(index == 0d7) {
                        init_map(0xb4, 0x3c, 0xf8, 0x96); // room_main (downstairs)
                    } else if(index == 0d8) {
                        init_map(0x01, 0x83, 0x2b, 0xb1); // room_nw
                    } else if(index == 0d9) {
                        init_map(0x3f, 0x89, 0x6c, 0xb2); // room_outside_cave
                    } else if(index == 0d10) {
                        init_map(0xba, 0x3c, 0xf8, 0x96); // room_main (upstairs)
                    }
                }

                fun trigger_enter() {
                    if(SOULS_MEMORY.WITH_TRASH_ENEMIES) {
                        add_enemy(RAPTOR_PURPLE, 0d158, 0d83);
                    }

                    init_room(0d6);
                    default_init_room(False, False);
                }
            };
        };
    };
};

area dungeon_podunk() {
    fun default_dungeon_podunk_init_room() {
        default_metro_init_room(reference(@install() {
            metro_death_trigger({
                map_transition(metro, door_d1, NONE);
            });
        }));
    }

    map podunk_old(PODUNK_65) {
        enum entrance {
            north = entrance(0d09, 0d00, SOUTH),
            west = entrance(0d00, 0d19, EAST),

            cinema_left = entrance(0d64, 0d15, SOUTH),
            cinema_right = entrance(0d75, 0d15, SOUTH),
        }

        enum ROOM {
            COMMENT_SOUTH = memory(FLAG, TEMP),

            COMMENT_BUILDING = memory(FLAG, TEMP),
            COMMENT_CINEMA = memory(FLAG, TEMP),
            
            COORDINATE_BUILDING_BOTTOM = 0d19 * 0x0008,
            COORDINATE_BUILDING_LEFT = 0d19 * 0x0008,
            COORDINATE_BUILDING_LEFT_THRESHOLD = 0d20 * 0x0008,
            COORDINATE_BUILDING_RIGHT = 0d121 * 0x0008,
            COORDINATE_BUILDING_RIGHT_THRESHOLD = 0d120 * 0x0008,

            COORDINATE_SOUTH_BORDER = 0d33 * 0x0008,

            COORDINATE_EAST_BORDER = 0d135 * 0x0008,

            COORDINATE_CINEMA_REACHED = 0d70 * 0x0008,
        }

        fun bug_discovered_1() {
            _add_enemy(MAGGOT, <ACTIVE>[X] - 0x50, <ACTIVE>[Y] + 0x50);
            <LAST_ENTITY>[Z] = 0x1000;
            _add_enemy(MAGGOT, <ACTIVE>[X] + 0x50, <ACTIVE>[Y] + 0x50);
            <LAST_ENTITY>[Z] = 0x1000;
        }
        fun bug_discovered_2() {
            _add_enemy(MAGGOT_RED, <ACTIVE>[X] - 0x50, <ACTIVE>[Y] - 0x50);
            <LAST_ENTITY>[Z] = 0x1000;
            _add_enemy(MAGGOT_RED, <ACTIVE>[X] + 0x50, <ACTIVE>[Y] - 0x50);
            <LAST_ENTITY>[Z] = 0x1000;
        }

        @install()
        @async()
        fun fake_exit_check() {
            while(True) {
                if!(ROOM.COMMENT_CINEMA) {
                    if(<ACTIVE>[X] > ROOM.COORDINATE_CINEMA_REACHED) {
                        set(ROOM.COMMENT_CINEMA);

                        subtext("comment 1");
                    }
                } else if(<ACTIVE>[X] > ROOM.COORDINATE_EAST_BORDER) {
                    map_transition(mansion_old, west, EAST);
                    end();
                }

                if((<ACTIVE>[Y] < ROOM.COORDINATE_BUILDING_BOTTOM) && (<ACTIVE>[X] > ROOM.COORDINATE_BUILDING_LEFT) && (<ACTIVE>[X] < ROOM.COORDINATE_BUILDING_RIGHT)) { // cinema
                    if!(ROOM.COMMENT_BUILDING) {
                        set(ROOM.COMMENT_BUILDING);

                        subtext("comment building");
                        bug_discovered_1();

                        sleep(0d120);
                    } else {
                        if(<ACTIVE>[X] < ROOM.COORDINATE_BUILDING_LEFT_THRESHOLD) { // push left
                            <ACTIVE>[X] = ROOM.COORDINATE_BUILDING_LEFT;

                            // subtext("left");
                        } else if(<ACTIVE>[X] > ROOM.COORDINATE_BUILDING_RIGHT_THRESHOLD) { // push right
                            <ACTIVE>[X] = ROOM.COORDINATE_BUILDING_RIGHT;

                            // subtext("left");
                        } else { // push bottom
                            <ACTIVE>[Y] = ROOM.COORDINATE_BUILDING_BOTTOM;
                        }
                    }
                    
                    // sleep(0x10);
                    yield();
                } else if(<ACTIVE>[Y] > ROOM.COORDINATE_SOUTH_BORDER) {
                    if!(ROOM.COMMENT_SOUTH) {
                        set(ROOM.COMMENT_SOUTH);

                        subtext("comment south 1");
                        sleep(0d120);
                        subtext("comment south 2");
                        sleep(0d120);

                        bug_discovered_2();

                        init_map(0x00, 0x00, 0d145, 0d33);
                    } else {
                        <ACTIVE>[Y] = ROOM.COORDINATE_SOUTH_BORDER;
                    }
                }

                yield();
            }
        }

        @install()
        fun cat_triggered() {
            destroy(SCRIPT_OWNER);

            subtext("todo");

            bug_discovered_1();
            bug_discovered_2();
        }

        fun trigger_enter() {
            add_placeholder(CAT_CLEANING_2, 0d122, 0d17);
            add_placeholder(CAT_CLEANING_2, 0d123, 0d17);
            attach_script(LAST_ENTITY, B, reference(cat_triggered));
            
            default_dungeon_podunk_init_room();

            fake_exit_check();
        }
    };

    map mansion_old(MANSION_65) {
        enum entrance {
            west = entrance(0d00, 0d106, EAST),
            south = entrance(0d35, 0d113, NORTH),
        }

        enum ROOM {
            PROFESSOR = memory(WORD, TEMP),

            COORDINATE_NORTH_BORDER = 0d22 * 0x0008,
        }

        @install()
        @async()
        fun fake_exit_check() {
            while(True) {
                if(<ACTIVE>[Y] < ROOM.COORDINATE_NORTH_BORDER) {
                    map_transition(lab_cutscene, north, NORTH);
                }

                yield();
            }
        }

        @install()
        @async()
        fun professor_glitch() {
            while(True) {
                ROOM.PROFESSOR[X] += 0x10;
                ROOM.PROFESSOR[Y] -= 0x05;
                sleep(0x05);
                ROOM.PROFESSOR[X] -= 0x20;
                sleep(0x03);
                ROOM.PROFESSOR[X] += 0x10;
                ROOM.PROFESSOR[Y] += 0x05;
                sleep(0x30);
                if(randrange(0x02)) {
                    sleep(0x50);
                }
            }
        }

        fun trigger_enter() {
            add_enemy(PROFESSOR, 0d35, 0d71);
            control(LAST_ENTITY, True);
            ROOM.PROFESSOR = <LAST_ENTITY>;
            professor_glitch();

            default_dungeon_podunk_init_room();

            fake_exit_check();
        }
    };

    map lab_cutscene(OMNITOPIA_PROFESSOR) {
        enum entrance {
            north = entrance(0x3e, 0x14, NONE, { door_act4_airlock_in(0d26); }),
            east = entrance(0x58, 0x57, NONE),
            west = entrance(0x1a, 0x5b, NONE),
            
            cutscene_1 = entrance(0x34, 0x59, NONE), // in front of computer
            cutscene_2 = entrance(0x3e, 0x25, NONE), // intro fight
        }

        fun open_door(object_id, flag) {
            if!(flag) {
                set(flag);
                
                sound(0xb0);
                object[object_id] = 0x7e;
            // } else {
            //     unset(flag);
            //     
            //     sound(0xb0);
            //     object[object_id] = 0x00;
            }
        }

        enum ROOM {
            DOOR_1_OPEN = memory(FLAG, TEMP),
            DOOR_2_OPEN = memory(FLAG, TEMP),
        }

        enum stepon_trigger {
            door_2_north = @install() {
                open_door(0x04, ROOM.DOOR_2_OPEN);
            },
            door_2_south = @install() {
                open_door(0x04, ROOM.DOOR_2_OPEN);
            },
            door_1_north = @install() {
                open_door(0x00, ROOM.DOOR_1_OPEN);
            },
            door_1_south = @install() {
                open_door(0x00, ROOM.DOOR_1_OPEN);
            },
            exit_east = @install() {
                debug_subtext("S=4");
            },
        }

        enum b_trigger {
            gourd = @install() {
                debug_subtext("B=0");
            },
            door_north = @install() {
                door_act4_airlock_out(0x3e, 0x14, object[0d26]);
            },
            lever = @install() {
                map_transition(podunk_new, cinema_left, NONE);
            },
        }

        fun trigger_enter() {
            default_init_room(False, False);
        }
    };

    map podunk_new(PODUNK_95) {
        enum entrance {
            north = entrance(0d09, 0d00, SOUTH),
            west = entrance(0d00, 0d19, EAST),

            cinema_left = entrance(0d12, 0d13, SOUTH),
            cinema_right = entrance(0d23, 0d13, SOUTH),
        }

        enum ROOM {
            COORDINATE_BUILDING_BOTTOM = 0d17 * 0x0008,
            COORDINATE_BUILDING_RIGHT = 0d69 * 0x0008,
            COORDINATE_BUILDING_RIGHT_THRESHOLD = 0d68 * 0x0008,

            COORDINATE_EAST_BORDER = 0d84 * 0x0008,
        }

        @install()
        @async()
        fun fake_exit_check() {
            while(True) {
                if((<ACTIVE>[Y] < ROOM.COORDINATE_BUILDING_BOTTOM) && (<ACTIVE>[X] < ROOM.COORDINATE_BUILDING_RIGHT)) { // inside building
                    if(<ACTIVE>[X] > ROOM.COORDINATE_BUILDING_RIGHT_THRESHOLD) { // push right
                        <ACTIVE>[X] = ROOM.COORDINATE_BUILDING_RIGHT;
                    } else { // bush bottom
                        <ACTIVE>[Y] = ROOM.COORDINATE_BUILDING_BOTTOM;
                    }
                    
                    yield();
                } else if(<ACTIVE>[X] > ROOM.COORDINATE_EAST_BORDER) { // right
                    map_transition(mansion_modern, west, EAST);
                    end();
                }

                yield();
            }
        }

        fun trigger_enter() {
            default_dungeon_podunk_init_room();

            sleep(0d60);
            fake_exit_check();
        }
    };

    map mansion_modern(MANSION_95) {
        enum entrance {
            west = entrance(0d00, 0d106, EAST),
            south = entrance(0d19, 0d111, NORTH),
        }

        enum soundtrack {
            default = soundtrack(BOSS, 0xff)
        }

        enum ROOM {
            COORDINATE_NORTH_BORDER = 0d22 * 0x0008,
        }

        enum BOSS {
            DEBUG = False,
            DEBUG_CHEESE = False,

            ID_CARLTRON = memory(WORD, TEMP),
            ID_LEFT = memory(WORD, TEMP),
            ID_RIGHT = memory(WORD, TEMP),
            ID_BACK = memory(WORD, TEMP),

            HP_CLAW_ORANGE = 0d100,
            HP_CLAW_WHITE = 0d200,
            HP_HEAD = 0d200,

            PROGRESS = memory(FLAG, TEMP),
            PHASE = memory(WORD, TEMP),

            CHEESE_COUNT = memory(WORD, TEMP),
            BEHIND_THRESHOLD = 0d360,

            COUNTDOWN = 0x03,

            KNOCKBACK_DAMAGE = 0d5,
        }

        @install()
        @async()
        fun fake_exit_check() {
            while(True) {
                if(<ACTIVE>[Y] < ROOM.COORDINATE_NORTH_BORDER) {
                    map_transition(ar_lab, evermore_machine, NORTH);
                    end();
                }

                yield();
            }
        }

        group boss_ai() {
            fun boss_defeated() {
                BOSS.PROGRESS = False;

                souls_boss_defeated(DEAD_ABOMINATION, REWARD_ABOMINATION);

                fake_exit_check();
            }

            fun zap() {
                if(False) {
                    subtext("zap");
                    end();
                }

                face(ACTIVE, NORTH);
                face(INACTIVE, NORTH);
                damage(BOTH, BOSS.KNOCKBACK_DAMAGE, True);

                animate(BOSS.ID_CARLTRON, ONCE, ANIMATION_ENEMY.CARLTRON_TALK);
                sleep(0x50);
                animate(BOSS.ID_CARLTRON, ONCE, DEFAULT);
            }

            @install()
            fun abomination_triggered() {
                heal(BOSS.ID_CARLTRON, 0d0, False);
                yield();

                if(BOSS.DEBUG) {
                    debug_subtext("c");
                }
                
                zap();

                if(BOSS.PHASE == 0d0) {
                    BOSS.PHASE = 0d1;
                }
            }
            @install()
            fun abomination_left_triggered() {
                if(BOSS.PHASE == 0d1) {
                    if(dead(<SCRIPT_OWNER>)) {
                        BOSS.PHASE = 0d2;
                    }
                } else {
                    heal(SCRIPT_OWNER, 0d99, True);
                    yield();
                }

                if(BOSS.DEBUG) {
                    debug_subtext("l");
                }

                if(dead(<SCRIPT_OWNER>)) {
                    wait(SCRIPT_OWNER);
                    destroy(SCRIPT_OWNER);
                }
            }
            @install()
            fun abomination_right_triggered() {
                if(BOSS.DEBUG) {
                    debug_subtext("r");
                }

                if(BOSS.PHASE == 0d2) {
                    if(_dead(<SCRIPT_OWNER>) && _dead(BOSS.ID_BACK)) {
                        BOSS.PHASE = 0d3;
                    }
                }

                if(dead(<SCRIPT_OWNER>)) {
                    wait(SCRIPT_OWNER);
                    destroy(SCRIPT_OWNER);
                }
            }
            @install()
            fun abomination_back_triggered() {
                if(BOSS.DEBUG) {
                    debug_subtext("b");
                }

                if(BOSS.PHASE == 0d2) {
                    if(_dead(<SCRIPT_OWNER>) && _dead(BOSS.ID_RIGHT)) {
                        BOSS.PHASE = 0d3;

                        wait(SCRIPT_OWNER);
                        destroy(SCRIPT_OWNER);
                    }
                } else if(BOSS.PHASE == 0d3) {
                    if(dead(<SCRIPT_OWNER>)) {
                        BOSS.PHASE = 0d4;

                        wait(SCRIPT_OWNER);
                        destroy(SCRIPT_OWNER);
                    }
                }
            }

            @install()
            @async()
            fun abomination_watcher() {
                if(BOSS.DEBUG) {
                    debug_subtext("phase 0");
                }

                while(BOSS.PHASE == 0d0) {
                    yield();
                }

                if(BOSS.DEBUG) {
                    debug_subtext("phase 1");
                }

                animate(BOSS.ID_CARLTRON, ONCE, ANIMATION_ENEMY.CARLTRON_SMUG);

                add_enemy(THRAXX_LEFT_ARM, 0d0, 0d0);
                <LAST_ENTITY>[HP] = BOSS.HP_CLAW_ORANGE;
                BOSS.ID_LEFT = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(abomination_left_triggered));

                sleep(0x50);

                while(BOSS.PHASE == 0d1) {
                    yield();
                }

                if(BOSS.DEBUG) {
                    debug_subtext("phase 2");
                }

                animate(BOSS.ID_CARLTRON, ONCE, ANIMATION_ENEMY.CARLTRON_SMUG);

                add_enemy(THRAXX2_LEFT_ARM, 0d0, 0d0);
                <LAST_ENTITY>[HP] = BOSS.HP_CLAW_WHITE;
                BOSS.ID_LEFT = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(abomination_left_triggered));

                sleep(0x50);

                add_enemy(THRAXX_RIGHT_ARM, 0d0, 0d0);
                <LAST_ENTITY>[HP] = BOSS.HP_CLAW_ORANGE;
                BOSS.ID_RIGHT = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(abomination_right_triggered));

                sleep(0x50);

                add_enemy(BONE_SNAKE, 0d0, 0d0);
                BOSS.ID_BACK = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(abomination_back_triggered));

                sleep(0x50);

                while(BOSS.PHASE == 0d2) {
                    yield();
                }

                if(BOSS.DEBUG) {
                    debug_subtext("phase 3");
                }

                add_enemy(SALABOG, 0d0, 0d0);
                <LAST_ENTITY>[HP] = BOSS.HP_HEAD;
                BOSS.ID_BACK = <LAST_ENTITY>;
                attach_script(LAST_ENTITY, DAMAGE, reference(abomination_back_triggered));

                while(BOSS.PHASE == 0d3) {
                    yield();
                }

                control(BOSS.ID_CARLTRON, True);
                attribute(BOSS.ID_CARLTRON, INVINCIBLE, True);
                face(BOSS.ID_CARLTRON, SOUTH);
                animate(BOSS.ID_CARLTRON, ONCE, ANIMATION_ENEMY.CARLTRON_DROPPING);
                sleep(0x80);

                animate(BOSS.ID_CARLTRON, LOOP, ANIMATION_ENEMY.CARLTRON_LYING);
                destroy(BOSS.ID_LEFT);
                destroy(BOSS.ID_RIGHT);
                destroy(BOSS.ID_BACK);

                // destroy(BOSS.ID_CARLTRON);

                if(BOSS.DEBUG) {
                    debug_subtext("yatta!");
                }

                boss_defeated();
            }

            fun _stack_t0123(entity, x, y) {
                if(entity) {
                    if(alive(entity)) {
                        _teleport(entity, x, y);

                        // sleep(0x02);
                        yield();
                    }
                }
            }
            @install()
            @async()
            fun stack_t0123() {
                while(BOSS.PHASE < 0d4) {
                    arg[0x10] = BOSS.ID_CARLTRON[X];
                    arg[0x12] = BOSS.ID_CARLTRON[Y];

                    _stack_t0123(BOSS.ID_LEFT, arg[0x10] - 0x05, arg[0x12] - 0x1a);
                    _stack_t0123(BOSS.ID_RIGHT, arg[0x10] + 0x05, arg[0x12] - 0x1a);
                    _stack_t0123(BOSS.ID_BACK, arg[0x10], arg[0x12] - 0x20);

                    yield();
                }
            }

            @install()
            @async()
            fun cheese_watcher() {
                attach_to_script(BOSS.ID_CARLTRON);

                while(BOSS.PHASE < 0d4) {
                    if(<BOY>[Y] < arg[0x12]) {
                        BOSS.CHEESE_COUNT += 0d2;
                    } else if((arg[0x10] == <SCRIPT_OWNER>[X]) && (arg[0x12] == <SCRIPT_OWNER>[Y])) {
                        BOSS.CHEESE_COUNT += 0d5;
                    } else if(BOSS.CHEESE_COUNT > 0d0) {
                        BOSS.CHEESE_COUNT--;
                    }

                    if(BOSS.CHEESE_COUNT > BOSS.BEHIND_THRESHOLD) {
                        BOSS.CHEESE_COUNT = 0d0;

                        zap();
                    }

                    if(False) {
                        debug_memory(arg[0x10], <SCRIPT_OWNER>[X]);
                    }

                    arg[0x10] = <SCRIPT_OWNER>[X];
                    arg[0x12] = <SCRIPT_OWNER>[Y];

                    yield();
                }
            }

            fun add_boss(x, y) {
                add_enemy(CARLTRON, x, y);
                BOSS.ID_CARLTRON = <LAST_ENTITY>;
                <LAST_ENTITY>[HP] = 0d1000; // SYSTEM.HP_MAX;
                attach_script(LAST_ENTITY, DAMAGE, reference(abomination_triggered));

                abomination_watcher();
                cheese_watcher();
                stack_t0123();
            }

        };

        fun trigger_enter() {
            CUSTOM_FLAG.NO_DOG = True;

            add_boss(0d20, 0d81);

            if(BOSS.DEBUG) {
                attribute(BOY, INVINCIBLE_TEMP, True);
            }

            // CUSTOM_FLAG.NO_DOG = True;
            default_dungeon_podunk_init_room(False, False);
        }
    };
};

group gourd_trap() {
    map gourd_trap_wolf(RAPTORS) {
        // sniff=vanilla

        enum entrance {
            left = entrance(0x15, 0x1c, NONE),
            center = entrance(0x1e, 0x21, NONE),
            right = entrance(0x2a, 0x23, NONE)
        }

        enum soundtrack {
            default = soundtrack(SPACE_NOISE, 0x30)
        }

        enum stepon_trigger {
            exit_north = nop(),
            exit_south = nop(),
            center = nop(),
        }

        enum b_trigger {
            sniff__1_crystal_1 = @install() {
                debug_subtext("B=0");
                _loot(0x09, CRYSTAL, 0d01, 0d01);
            },
            sniff__1_oil_1 = @install() {
                debug_subtext("B=1");
                _loot(0x08, OIL, 0d01, 0d01);
            },
            sniff__1_crystal_2 = @install() {
                debug_subtext("B=2");
                _loot(0x07, CRYSTAL, 0d01, 0d02);
            },
            sniff__1_water_2 = @install() {
                debug_subtext("B=3");
                _loot(0x06, WATER, 0d01, 0d02);
            },
        }
        
        enum BOSS {
            RAT_1_ID = memory(WORD, TEMP),
            RAT_1_X = 0x13,
            RAT_1_Y = 0x19,
            RAT_2_ID = memory(WORD, TEMP),
            RAT_2_X = 0x29,
            RAT_2_Y = 0x1b,
            RAT_3_ID = memory(WORD, TEMP),
            RAT_3_X = 0x13,
            RAT_3_Y = 0x25,
            RAT_4_ID = memory(WORD, TEMP),
            RAT_4_X = 0x29,
            RAT_4_Y = 0x27,

            PHASE = memory(WORD, TEMP),
            TIMER = memory(WORD, TEMP),

            COUNTDOWN = 0x03,
        }

        fun close_exits(close) {
            if(close) {
                object[0x04] = 0x04;
            } else {
                object[0x05] = 0x04;
            }
        }

        enum ROOM {
            RATS_TO_KILL = 0d5,
            RAT_COUNTER = memory(WORD, TEMP),
        }

        fun print_counter() {
            MEMORY.STRING_PARAMETER_1 = ROOM.RAT_COUNTER;
            MEMORY.STRING_PARAMETER_2 = ROOM.RATS_TO_KILL;
            subtext("[MEM1]/[MEM2]");
        }

        fun update_counter() {
            ROOM.RAT_COUNTER++;

            if(ROOM.RAT_COUNTER < ROOM.RATS_TO_KILL) {
                print_counter();
            }
            
            if(ROOM.RAT_COUNTER == ROOM.RATS_TO_KILL) {
                souls_boss_defeated(CLEARED_TRAP_WOLF, REWARD_TRAP_WOLF);

                sleep(0d180);

                map_transition(hut_cat, door, NONE);
            }
        }

        fun rat_dead(x, y, death_trigger) {
            update_counter();

            add_enemy(RAT, x, y);
            attach_script(LAST_ENTITY, DEATH, death_trigger);
            <LAST_ENTITY>[HP] = 0d1;

            sleep(0d30);
            destroy(SCRIPT_OWNER);
        }

        @install()
        fun rat_1_dead() {
            rat_dead(BOSS.RAT_1_X, BOSS.RAT_1_Y, reference(rat_1_dead));
        }
        @install()
        fun rat_2_dead() {
            rat_dead(BOSS.RAT_2_X, BOSS.RAT_2_Y, reference(rat_2_dead));
        }
        @install()
        fun rat_3_dead() {
            rat_dead(BOSS.RAT_3_X, BOSS.RAT_3_Y, reference(rat_3_dead));
        }
        @install()
        fun rat_4_dead() {
            rat_dead(BOSS.RAT_4_X, BOSS.RAT_4_Y, reference(rat_4_dead));
        }

        fun spawn_rat(x, y, death_trigger) {
            add_enemy(RAT, x, y);
            attach_script(LAST_ENTITY, DEATH, death_trigger);
            <LAST_ENTITY>[HP] = 0d1;
        }

        fun trigger_enter() {
            prepare_dog_arena(GREYHOUND);

            crash_both();
            default_init_room(True, False);

            print_counter();

            close_exits(True);

            spawn_rat(BOSS.RAT_1_X, BOSS.RAT_1_Y, reference(rat_1_dead));
            spawn_rat(BOSS.RAT_1_X, BOSS.RAT_1_Y, reference(rat_1_dead));

            sleep(0x40);

            spawn_rat(BOSS.RAT_2_X, BOSS.RAT_2_Y, reference(rat_2_dead));
            spawn_rat(BOSS.RAT_2_X, BOSS.RAT_2_Y, reference(rat_2_dead));

            sleep(0x20);

            spawn_rat(BOSS.RAT_3_X, BOSS.RAT_3_Y, reference(rat_3_dead));
            spawn_rat(BOSS.RAT_3_X, BOSS.RAT_3_Y, reference(rat_3_dead));

            sleep(0x20);

            spawn_rat(BOSS.RAT_4_X, BOSS.RAT_4_Y, reference(rat_4_dead));
            spawn_rat(BOSS.RAT_4_X, BOSS.RAT_4_Y, reference(rat_4_dead));
        }
    };

    map gourd_trap_poodle(IVOR_MARKET) {
        enum entrance {
            north = entrance(0x2a, 0x01, SOUTH),
            east = entrance(0x39, 0xc3, WEST),
        }

        enum soundtrack {
            default = soundtrack(PIG_RACE, 0xff)
        }

        enum ROOM {
            DEBUG = False,
            DEBUG_RUNNING = False,

            WITH_MASK = True,

            BARRIER_1 = memory(WORD, TEMP),
            BARRIER_2 = memory(WORD, TEMP),
            BARRIER_3 = memory(WORD, TEMP),
            BARRIER_4 = memory(WORD, TEMP),

            WAYPOINT_X_1 = memory(WORD, TEMP),
            WAYPOINT_X_2 = memory(WORD, TEMP),
            WAYPOINT_X_3 = memory(WORD, TEMP),
            WAYPOINT_X_4 = memory(WORD, TEMP),

            WAYPOINT_Y_1 = memory(WORD, TEMP),
            WAYPOINT_Y_2 = memory(WORD, TEMP),
            WAYPOINT_Y_3 = memory(WORD, TEMP),
            WAYPOINT_Y_4 = memory(WORD, TEMP),

            Y_1 = 0d0029,
            Y_2 = 0d0077,
            Y_3 = 0d0125,
            Y_4 = 0d0189,

            PIG_COUNT = memory(WORD, TEMP),
            PIG_COUNT_MAX = 0d2, // 0d4,

            WINNER = memory(WORD, TEMP),
        }

        @install()
        fun finish_line(entity) {
            if!(ROOM.WINNER) {
                ROOM.WINNER = entity;
                
                control(NONE);

                if(entity == <DOG>) {
                    subtext("Truffle Trouble lost?!");

                    sleep(0d120);

                    souls_boss_defeated(CLEARED_TRAP_POODLE, REWARD_TRAP_POODLE);
                } else {
                    subtext("Truffle Trouble wins!");
                }
                
                sleep(0d180);

                map_transition(desert_temple_main, west_2, NONE);
            }
        }

        enum stepon_trigger {
            exit_north = @install() {
                debug_subtext("S=0");
            },
            exit_east = @install() {
                debug_subtext("S=1");

                finish_line(<DOG>);
            },
        }

        @install()
        fun add_barrier(x_side, y) {
            add_enemy(FACE_ENTITY, x_side, y);
            attribute(LAST_ENTITY, INVINCIBLE, True);
            add_enemy(FACE_ENTITY, x_side + 0d4, y);
            attribute(LAST_ENTITY, INVINCIBLE, True);
            add_enemy(FACE_ENTITY, x_side - 0d4, y);
            attribute(LAST_ENTITY, INVINCIBLE, True);

            add_enemy(VILLAGER_3_1, x_side + 0d2, y, INACTIVE);
            face(LAST_ENTITY, NORTH);
            add_enemy(VILLAGER_3_2, x_side - 0d2, y, INACTIVE);
            face(LAST_ENTITY, NORTH);
        }

        fun randomize_x(barrier, waypoint) {
            if(randrange(0d2)) {
                barrier = 0d13;
                waypoint = 0d42;
            } else {
                waypoint = 0d13;
                barrier = 0d42;
            }
        }

        @install()
        @async()
        fun pigface(entity) {
            if(ROOM.WITH_MASK) {
                attribute(entity, INVISIBLE, True);
            }

            add_enemy(PLACEHOLDER, 0d0, 0d0);
            attach_to_script(LAST_ENTITY);

            // stack_sprite(entity, <LAST_ENTITY>);

            while(alive(entity)) {
                if(False) {
                    <SCRIPT_OWNER>[X] = entity[X];
                    <SCRIPT_OWNER>[Y] = entity[Y] - 0d10;
                    <SCRIPT_OWNER>[Z_LEVEL] = entity[Z_LEVEL];
                } else {
                    _teleport(SCRIPT_OWNER, entity[X], entity[Y]);
                }

                if(ROOM.WITH_MASK) {
                    if(entity[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.PIGOODLE_RUNNING_SOUTH);
                    } else if(entity[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.PIGOODLE_RUNNING_EAST);
                    } else if(entity[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.PIGOODLE_RUNNING_SOUTH);
                    } else if(entity[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                        animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.PIGOODLE_RUNNING_WEST);
                    }
                }

                yield();
            }

            destroy(<SCRIPT_OWNER>);
        }

        fun remove_pig() {
            destroy(arg[0x10]);
            destroy(<SCRIPT_OWNER>);

            yield();
            
            ROOM.PIG_COUNT--;
            end();
        }
        @install()
        @async()
        fun add_pig() {
            if(ROOM.PIG_COUNT >= ROOM.PIG_COUNT_MAX) {
                end();
            }
            ROOM.PIG_COUNT++;

            if(ROOM.DEBUG) {
                // debug_memory(ROOM.PIG_COUNT);
                debug_subtext("+pig");
            }

            if(<ACTIVE>[X] < 0d200) {
                arg[0x12] = 0d117;
            } else {
                arg[0x12] = 0d335;
            }

            _add_enemy(SKELESNAIL, arg[0x12], MEMORY.CAMERA_Y_MAX + 0d20, INACTIVE);
            arg[0x10] = <LAST_ENTITY>;

            while(arg[0x10][CURRENT_GROUND] != 0x10) {
                // remove_pig();

                arg[0x10][Y] += 0d40;
                yield();
            }


            add_enemy(PLACEHOLDER, 0d0, 0d0);
            attach_to_script(LAST_ENTITY);
            if(ROOM.WITH_MASK) {
                attribute(arg[0x10], INVISIBLE, True);
                animate(SCRIPT_OWNER, LOOP, ANIMATION_PLACEHOLDER.PIG_RUNNING);
            }

            // stack_sprite(entity, <LAST_ENTITY>);

            walk(arg[0x10], TILE_ABSOLUTE, 0d60, 0d191, NONE, NONE);

            while(alive(arg[0x10])) {
                if(False) {
                    <SCRIPT_OWNER>[X] = arg[0x10][X];
                    <SCRIPT_OWNER>[Y] = arg[0x10][Y] - 0d10;
                    <SCRIPT_OWNER>[Z_LEVEL] = arg[0x10][Z_LEVEL];
                } else {
                    _teleport(SCRIPT_OWNER, arg[0x10][X], arg[0x10][Y]);
                }


                if(arg[0x10][Y] < MEMORY.CAMERA_Y_MIN - 0d20) {
                    if(ROOM.DEBUG) {
                        // debug_memory(ROOM.PIG_COUNT);
                        debug_subtext("-pig");
                    }

                    remove_pig();
                }

                sleep(0d5);
            }
        }

        @install()
        @async()
        fun pig_spawner() {
            while(MEMORY.CAMERA_Y_MAX < 0d1400) {
                sleep(randrange(0d60));

                add_pig(0d38 + 0d2, 0d5);

                sleep(randrange(0d120));
            }
        }

        fun trigger_enter() {
            // init_map(0x0, 0x0, 0x39, 0xc3); // cutscene: pig race
            init_map(0x0, 0x0, 0x3a, 0xcc);

            randomize_x(ROOM.BARRIER_1, ROOM.WAYPOINT_X_1);
            randomize_x(ROOM.BARRIER_2, ROOM.WAYPOINT_X_2);
            randomize_x(ROOM.BARRIER_3, ROOM.WAYPOINT_X_3);
            randomize_x(ROOM.BARRIER_4, ROOM.WAYPOINT_X_4);

            ROOM.WAYPOINT_Y_1 = ROOM.Y_1 + 0d0;
            ROOM.WAYPOINT_Y_2 = ROOM.Y_2 + 0d0;
            ROOM.WAYPOINT_Y_3 = ROOM.Y_3 + 0d0;
            ROOM.WAYPOINT_Y_4 = ROOM.Y_4 + 0d0;

            add_barrier(ROOM.BARRIER_1, ROOM.Y_1);
            add_barrier(ROOM.BARRIER_2, ROOM.Y_2);
            add_barrier(ROOM.BARRIER_3, ROOM.Y_3);
            add_barrier(ROOM.BARRIER_4, ROOM.Y_4);

            CUSTOM_FLAG.NO_RUNNING = True;
            CUSTOM_FLAG.NO_BOY = True;
            CUSTOM_FLAG.WITH_DOG = True;
            CUSTOM_MEMORY.CURRENT_DOG = DOG.POODLE;
            default_init_room(False, False);

            pig_spawner();

            add_enemy(PUPPET_1, 0d38 + 0d2, 0d5, INACTIVE);
            arg[0x10] = <LAST_ENTITY>;
            pigface(arg[0x10]);
            // walk(arg[0x10], TILE_RELATIVE_DIRECT, 0d0, 0d5, arg[0x10], NONE);

            if(True) {
                walk(arg[0x10], TILE_ABSOLUTE, ROOM.WAYPOINT_X_1, ROOM.WAYPOINT_Y_2 - 0d15, arg[0x10], NONE);
                if(ROOM.DEBUG && ROOM.DEBUG_RUNNING) {
                    debug_memory(ROOM.WAYPOINT_X_1, ROOM.WAYPOINT_Y_1);
                    sleep(0d120);
                }

                yield();

                walk(arg[0x10], TILE_ABSOLUTE, ROOM.WAYPOINT_X_2, ROOM.WAYPOINT_Y_3 - 0d15, arg[0x10], NONE);
                if(ROOM.DEBUG && ROOM.DEBUG_RUNNING) {
                    debug_memory(ROOM.WAYPOINT_X_2, ROOM.WAYPOINT_Y_2);
                    sleep(0d120);
                }
                
                yield();

                walk(arg[0x10], TILE_ABSOLUTE, ROOM.WAYPOINT_X_3, ROOM.WAYPOINT_Y_4 - 0d15, arg[0x10], NONE);
                if(ROOM.DEBUG && ROOM.DEBUG_RUNNING) {
                    debug_memory(ROOM.WAYPOINT_X_3, ROOM.WAYPOINT_Y_3);
                    sleep(0d120);
                }

                yield();

                walk(arg[0x10], TILE_ABSOLUTE, ROOM.WAYPOINT_X_4, ROOM.WAYPOINT_Y_4, arg[0x10], NONE);
                if(ROOM.DEBUG && ROOM.DEBUG_RUNNING) {
                    debug_memory(ROOM.WAYPOINT_X_4, ROOM.WAYPOINT_Y_4);
                    sleep(0d120);
                }

                yield();

                walk(arg[0x10], TILE_ABSOLUTE, 0d59, 0d191, arg[0x10], NONE);

                finish_line(arg[0x10]);
                
                destroy(arg[0x10]);

                sleep(0d180);
            }
        }
    };
};

// experimental

area experimental_room() {
    fun character_selection(character:CHARACTER) {
        if(character == CHARACTER.BOY) {
            CUSTOM_FLAG.NO_DOG = True;

            available(BOY);
            destroy(DOG); // teleport(BOY, 0x00, 0x00);

            attribute(BOY, INVINCIBLE, True);
        } else if(character == CHARACTER.DOG) {
            CUSTOM_FLAG.NO_BOY = True;

            available(DOG);
            teleport(BOY, 0x00, 0x00);

            MEMORY.DOG_WRITE = DOG.TOASTER;

            attribute(DOG, INVINCIBLE, True);

            attach_script(DOG, DAMAGE_DEATH, reference(boy_death));
        }
    }

    fun general_boss_defeated() {
        attribute(ACTIVE, INVINCIBLE, True);

        subtext("Yatta!");

        sleep(0d250);
        sleep(0d250);
    }

    fun countdown(countdown) {
        if(countdown >= 0x03) {
            subtext("3...");
            sleep(0x3c);
        }
        if(countdown >= 0x02) {
            subtext("2...");
            sleep(0x3c);
        }
        if(countdown >= 0x01) {
            subtext("1...");
            sleep(0x3c);
        }
        if(countdown >= 0x00) {
            subtext("GO");
        }
    }

    map invisible_arena(RAPTORS) {
        enum entrance {
            left = entrance(0x15, 0x1c, NONE),
            center = entrance(0x1e, 0x21, NONE),
            right = entrance(0x2a, 0x23, NONE)
        }

        enum stepon_trigger {
            exit_north = nop(),
            exit_south = nop(),
            center = nop(),
        }

        enum ROOM {
            REVEALER_ID = memory(WORD, TEMP),
        }

        enum BOSS {
            BOSS_ID = memory(WORD, TEMP),
        }

        fun close_exits(close) {
            if(close) {
                object[0x04] = 0x04;
            } else {
                object[0x05] = 0x04;
            }
        }

        @install()
        fun boss_defeated4() {
            general_boss_defeated();

            map_transition(invisible_arena, right, NONE);
        }

        @install()
        fun revealer_triggered() {
            destroy(ROOM.REVEALER_ID);

            attribute(BOSS.BOSS_ID, INVISIBLE, False);
        }

        @install()
        @async()
        fun stack_revealer_boss() {
            while(alive(ROOM.REVEALER_ID)) {
                ROOM.REVEALER_ID[X] = BOSS.BOSS_ID[X];
                ROOM.REVEALER_ID[Y] = BOSS.BOSS_ID[Y];
                yield();
            }
        }

        fun trigger_enter() {
            close_exits(True);

            add_enemy(MAGMAR, 0x1e, 0x21);
            attribute(LAST_ENTITY, INVISIBLE, True);
            BOSS.BOSS_ID = <LAST_ENTITY>;
            attach_script(LAST_ENTITY, DEATH, reference(boss_defeated4));

            default_init_room(True, False);

            add_enemy(REVEALER_TARGET_ENTITY, 0x1e, 0x21);
            ROOM.REVEALER_ID = <LAST_ENTITY>;

            special_script(REVEALER, reference(revealer_triggered));
            stack_revealer_boss();

            countdown(0x03);
            attribute(BOY, INVINCIBLE, False);

        }
    };

    map radahn3_arena(RAPTORS) {
        enum entrance {
            north = entrance(0x1b, 0x03, SOUTH),
            south = entrance(0x1d, 0x33, NORTH),

            left = entrance(0x15, 0x1c, NONE),
            center = entrance(0x1e, 0x21, NONE),
            right = entrance(0x2a, 0x23, NONE)
        }

        enum soundtrack {
            default = soundtrack(BOSS, 0xff)
        }

        enum stepon_trigger {
            exit_north = nop(),
            exit_south = nop(),
            center = nop(),
        }

        fun close_exits(close) {
            if(close) {
                object[0x04] = 0x04;
            } else {
                object[0x05] = 0x04;
            }
        }

        enum BOSS {
            DEBUG = False,

            RIDER_ID = memory(WORD, TEMP),
            MOUNT_ID = memory(WORD, TEMP),

            PHASE = memory(WORD, TEMP),
            TIMER = memory(WORD, TEMP),

            HP = 0d1000,

            GRAB_DISTANCE = 0d30,
            GRAB_DAMAGE = 0d10,

            // p1

            P1_THRESHOLD = 0d800,
            P1_TIME_BEFORE_SALVAGE = 0d1200,

            // p2

            P2_THRESHOLD = 0d500,
            P2_TIME_BEFORE_SALVAGE = 0d780,

            RANDOM_SPELL = memory(WORD, TEMP),
            TIME_BEFORE_RANDOM_SPELL = 0d780,
        }

        fun boss_killed() {
            nop();
        }

        @install()
        @async()
        fun stack_t01_offset() {
            while(alive(BOSS.MOUNT_ID)) {
                BOSS.RIDER_ID[X] = BOSS.MOUNT_ID[X];
                BOSS.RIDER_ID[Y] = BOSS.MOUNT_ID[Y] - 0d20;
                BOSS.RIDER_ID[VELOCITY] = BOSS.MOUNT_ID[VELOCITY];
                
                sleep(0d2);
            }
        }

        fun cast_salvage(target:CHARACTER, count, level) {
            // TODO: flash/fireball, depending whether or not it's dodgeable?

            animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_CAST_1);

            if(count > 0d2) {
                cast(BOSS.RIDER_ID, target, FIREBALL, level);
            }
            cast(BOSS.RIDER_ID, target, FLASH, level);
            if(count > 0d2) {
                cast(BOSS.RIDER_ID, target, FIREBALL, level);
            }
            cast(BOSS.RIDER_ID, target, FLASH, level);
        }

        @install()
        fun boss_damage() {
            // animate(BOSS.RIDER_ID, ONCE, ANIMATION_ENEMY.VERMINATOR_DAMAGE);

            if(BOSS.PHASE == 0x00) {
                BOSS.TIMER = 0x00;

                if(BOSS.RIDER_ID[HP] < BOSS.P1_THRESHOLD) {
                    BOSS.PHASE = 0x01;
                }
            } else if(BOSS.PHASE == 0x01) {
                if(BOSS.RIDER_ID[HP] < BOSS.P2_THRESHOLD) {
                    BOSS.PHASE = 0x02;
                }
            } else if(BOSS.PHASE == 0x02) {
                BOSS.TIMER -= 0x60;
            }

            if(BOSS.DEBUG) {
                MEMORY.STRING_PARAMETER_1 = BOSS.RIDER_ID[HP];
                MEMORY.STRING_PARAMETER_2 = BOSS.HP;

                subtext("Rider = [MEM1]/[MEM2]");
            }
        }

        @install()
        @async()
        fun boss_watcher() {
            if(BOSS.DEBUG) {
                subtext("phase 0");
            }

            while(BOSS.PHASE == 0x00) {
                if(BOSS.TIMER > BOSS.P1_TIME_BEFORE_SALVAGE) {
                    cast_salvage(ACTIVE, 0d2, 0x00);

                    BOSS.TIMER = 0x00;
                }
            
                if(BOSS.RIDER_ID[0x0b] == 0x0800) { // TODO: buggy, since menu resets paletts
                    BOSS.TIMER++;
                }
                yield();
            }

            if(BOSS.DEBUG) {
                subtext("phase 1");
            }

            BOSS.TIMER = 0x0000;
            cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD, 0x05);
            cast(BOSS.RIDER_ID, ACTIVE, CONFOUND, 0x05);

            while(BOSS.PHASE == 0x01) {
                if(BOSS.TIMER > BOSS.P2_TIME_BEFORE_SALVAGE) {
                    cast_salvage(ACTIVE, 0d2, 0x00);

                    BOSS.TIMER = 0x00;
                }
            
                if(BOSS.RIDER_ID[PALETTE] == 0x0800) { // TODO: buggy, since menu resets paletts
                    BOSS.TIMER++;
                }
                yield();
            }

            BOSS.TIMER = 0x0000;
            cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD, 0x05);
            cast(BOSS.RIDER_ID, ACTIVE, CONFOUND, 0x05);

            while(BOSS.PHASE == 0x01) {
                BOSS.TIMER++;

                if(BOSS.TIMER > BOSS.TIME_BEFORE_RANDOM_SPELL) {
                    BOSS.TIMER = 0x0000;

                    BOSS.RANDOM_SPELL = randrange(0x03);

                    if(BOSS.RANDOM_SPELL == 0x00) {
                        cast(BOSS.RIDER_ID, BOSS.RIDER_ID, FORCE_FIELD, 0x05);
                        cast(BOSS.RIDER_ID, ACTIVE, CONFOUND, 0x05);
                    } else if(BOSS.RANDOM_SPELL == 0x01) {
                        cast(BOSS.RIDER_ID, ACTIVE, DRAIN, 0x30);
                    } else if(BOSS.RANDOM_SPELL == 0x02) {
                        cast(BOSS.RIDER_ID, ACTIVE, PLAGUE, 0x01);
                    } 
                }
                yield();
            }

            if(BOSS.DEBUG) {
                subtext("phase 2");
            }

            boss_killed();
        }

        fun spawn_boss(x, y) {
            add_enemy(VERMINATOR, x, y);
            <LAST_ENTITY>[HP] = BOSS.HP;
            BOSS.RIDER_ID = <LAST_ENTITY>;
            attach_script(LAST_ENTITY, DAMAGE, reference(boss_damage));
            attribute(LAST_ENTITY, ROOT, True);

            add_enemy(STERLING, x, y);
            BOSS.MOUNT_ID = <LAST_ENTITY>;
            // attach_sterling_script_to_last_entity();
            // attribute(LAST_ENTITY, ROOT, True);
        }

        fun trigger_enter() {
            // character_selection(BOY);
            
            if!(FLAG.IN_ANIMATION) {
                crash_both();
            }

            default_init_room(True, False);

            if!(SOULS_MEMORY.DEAD_ARENA_RADAHN) {
                close_exits(True);

                spawn_boss(0d16, 0d19);

                attach_sterling_script(BOSS.MOUNT_ID, True, BOSS.GRAB_DISTANCE, 0d40, 0d25, 0x0118, BOSS.GRAB_DAMAGE);
                stack_t01_offset();
                boss_watcher();
            }
        }
    };

    map isaac3_arena(RAPTORS) { // unused
        enum entrance {
            left = entrance(0x15, 0x1c, NONE),
            center = entrance(0x1e, 0x21, NONE),
            right = entrance(0x2a, 0x23, NONE)
        }

        enum stepon_trigger {
            exit_north = @install() {
                debug_subtext("S=0");
            },
            exit_south = @install() {
                debug_subtext("S=1");
            },
            center = @install() {
                debug_subtext("S=2");
            }
        }

        enum BOSS {
            MOUNT_ID = memory(WORD, TEMP),
            RIDER_ID = memory(WORD, TEMP),

            FOLLOWING = memory(WORD, TEMP),

            PUKE_HELPER = memory(WORD, TEMP),

            MOVE_RNG = memory(WORD, TEMP),

            CANNONBALL_X = memory(WORD, TEMP),
            CANNONBALL_Y = memory(WORD, TEMP),
            CANNONBALL_COUNT = memory(WORD, TEMP),
        }

        fun close_exits(close) {
            if(close) {
                object[0x04] = 0x04;
            } else {
                object[0x05] = 0x04;
            }
        }

        @install()
        fun shoot_w() {
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x20, 0x80, 0x10, 0xff);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, -0x20, 0x80, 0x10, 0xff);
        }

        @install()
        fun shoot_line() {
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
            sleep(0x0a);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
            sleep(0x0a);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
            sleep(0x0a);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
            sleep(0x0a);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
            sleep(0x0a);
            shoot_entity_relative(BOSS.MOUNT_ID, ONION, 0x00, 0x80, 0x10, 0xff);
        }

        @async()
        @install()
        fun fly_left_right() {
            while(True) {
                while(BOSS.MOUNT_ID[X] < 0x150) {
                    BOSS.MOUNT_ID[X]++;
                    yield();
                }
                while(BOSS.MOUNT_ID[X] > 0x50) {
                    BOSS.MOUNT_ID[X]--;
                    yield();
                }
            }
        }

        @install()
        fun monstro_damage() {
            yield();
            // animate(BOSS.MOUNT_ID, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);

            // animate(BOSS.MOUNT_ID, LOOP, DEFAULT);
        }

        @install()
        @async()
        fun stack_t01_offset() {
            while(alive(<BOY>)) {
                BOSS.RIDER_ID[X] = BOSS.MOUNT_ID[X];
                BOSS.RIDER_ID[Y] += 0x50;
                yield();

                // <DOG>[X] = <BOY>[X] - 0x05;
                // <DOG>[Y] = <BOY>[Y];
                // yield();
            }
        }

        fun move() {
            // control(BOSS.MOUNT_ID, True);
            sleep(0x20);

            BOSS.MOVE_RNG = randrange(0x03);

            if(BOSS.MOVE_RNG == 0x00) {
                shoot_w();
            } else if(BOSS.MOVE_RNG == 0x01) {
                shoot_line();
            } else {
                nop();
            }

            sleep(0x20);
            // control(BOSS.MOUNT_ID, False);
        }

        @async()
        @install()
        fun move_logic() {
            sleep(0x80);
            
            while(True) {
                move();
                
                sleep(0x60);
            }
        }

        fun spawn_boss(x, y) {
            add_enemy(RIMSALA_GOLD, x, y);
            BOSS.RIDER_ID = <LAST_ENTITY>;
            // animate(LAST_ENTITY, ONCE_FREEZE, ANIMATION_ENEMY.MAGMAR_ROLL);
            attach_script(LAST_ENTITY, DAMAGE, reference(monstro_damage));
            // attribute(LAST_ENTITY, ROOT, True);
            // attribute(LAST_ENTITY, INVISIBLE, True);
            // attribute(LAST_ENTITY, INVINCIBLE, True);

            // add_enemy(DRAKE, x, y, INACTIVE);
            // add_enemy(FOOTKNIGHT, x, y, INACTIVE);
            add_enemy(RIMSALA_HOLDER, x, y);
            BOSS.MOUNT_ID = <LAST_ENTITY>;
            // <LAST_ENTITY>[HP] = 0x100;
            attribute(LAST_ENTITY, INVINCIBLE, True);

            fly_left_right();
            move_logic();
            stack_t01_offset();
        }

        fun trigger_enter() {
            spawn_boss(0x10, 0x08);

            available(BOY);
            destroy(DOG); // teleport(BOY, 0x00, 0x00);

            default_init_room(True, False);
            CUSTOM_MEMORY.HOTKEY_START = BUTTON_MAP.ISAAC;

            close_exits(True);

            if!(FLAG.IN_ANIMATION) {
                // teleport(DOG, 0x19, 0x1d);
                <DOG>[X] += 0x20;
                <DOG>[Y] += 0x20;
                crash_land(BOTH);
            }
        }
    };

    map barrier_check_arena(RAPTORS) { // unused
        enum entrance {
            left = entrance(0x15, 0x1c, NONE),
            center = entrance(0x1e, 0x21, NONE),
            right = entrance(0x2a, 0x23, NONE)
        }

        enum stepon_trigger {
            exit_north = @install() {
                debug_subtext("S=0");
            },
            exit_south = @install() {
                debug_subtext("S=1");
            },
            center = @install() {
                debug_subtext("S=2");
            }
        }

        fun close_exits(close) {
            if(close) {
                object[0x04] = 0x04;
            } else {
                object[0x05] = 0x04;
            }
        }

        @async()
        @install()
        fun barrier_check() {
            // code(0xb5, param(THROWABLE.LIGHTNING), entity_t(LAST_ENTITY), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y]), param(0x00), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y] + 0x80), param(0xff), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            
            add_enemy(AQUAGOTH_ENTITY, 0x15, 0x1c, 0x00);
            attribute(LAST_ENTITY, INVINCIBLE, True);
            // attribute(LAST_ENTITY, INVISIBLE, True);
            attribute(LAST_ENTITY, NO_CLIP, True);
            attach_to_script(LAST_ENTITY);
            <SCRIPT_OWNER>[Z_LEVEL] = 0xff;

            face(LAST_ENTITY, EAST);

            while(True) {
                code(0xb5, param(THROWABLE.ONION), entity_t(LAST_ENTITY), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y]), param(0x00), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y] + 0x30), param(0x05), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");

                sleep(0x1);

                // if(<DOG>[HP] <= 0x00) {
                //     <DOG>[X]++;
                // }

                arg[0x00] = <BOY>[X];
                arg[0x02] = <BOY>[Y];
                arg[0x04] = <SCRIPT_OWNER>[X];
                arg[0x06] = <SCRIPT_OWNER>[Y];

                if(arg[0x00] < arg[0x04]) {
                    arg[0x08] = arg[0x04] - arg[0x00];
                } else {
                    arg[0x08] = arg[0x00] - arg[0x04];
                }

                if(arg[0x02] < arg[0x06]) {
                    arg[0x0a] = arg[0x06] - arg[0x02];
                } else {
                    arg[0x0a] = arg[0x02] - arg[0x06];
                }

                if((arg[0x08] <= 0x20) && (arg[0x0a] <= 0x20)) {
                    <BOY>[X]++;
                }

                arg[0x00] = <DOG>[X];
                arg[0x02] = <DOG>[Y];
                arg[0x04] = <SCRIPT_OWNER>[X];
                arg[0x06] = <SCRIPT_OWNER>[Y];

                if(arg[0x00] < arg[0x04]) {
                    arg[0x08] = arg[0x04] - arg[0x00];
                } else {
                    arg[0x08] = arg[0x00] - arg[0x04];
                }

                if(arg[0x02] < arg[0x06]) {
                    arg[0x0a] = arg[0x06] - arg[0x02];
                } else {
                    arg[0x0a] = arg[0x02] - arg[0x06];
                }

                if((arg[0x08] <= 0x20) && (arg[0x0a] <= 0x20)) {
                    <DOG>[X]++;
                }
            }
        }

        @async()
        @install()
        fun barrier_check_2() {
            add_enemy(AQUAGOTH_ENTITY, 0x15, 0x1c, 0x00);
            attribute(LAST_ENTITY, INVINCIBLE, True);
            // attribute(LAST_ENTITY, INVISIBLE, True);
            attribute(LAST_ENTITY, NO_CLIP, True);
            attach_to_script(LAST_ENTITY);
            <SCRIPT_OWNER>[Z_LEVEL] = 0xff;

            face(LAST_ENTITY, EAST);

            while(True) {
                code(0xb5, param(THROWABLE.LIGHTNING), entity_t(LAST_ENTITY), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y]), param(0x00), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y] + 0x30), param(0x30), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
                sleep(0x20);

                code(0xb5, param(THROWABLE.LIGHTNING), entity_t(LAST_ENTITY), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y] + 0x50), param(0x00), calculate(<LAST_ENTITY>[X]), calculate(<LAST_ENTITY>[Y] + 0x20), param(0x30), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
                sleep(0x20);
            }
        }

        fun trigger_enter() {
            default_init_room(True, False);

            close_exits(True);

            if!(FLAG.IN_ANIMATION) {
                // teleport(DOG, 0x19, 0x1d);
                <DOG>[X] += 0x20;
                <DOG>[Y] += 0x20;
                crash_land(BOTH);
            }

            // <DOG>[HP] = 0x0;

            // barrier_check();
            barrier_check_2();
        }
    };

    map river(CUTSCENE_RIVER) {
        enum entrance {
            center = entrance(0x32, 0x10, NONE),
            right = entrance(0x64, 0x10, WEST),
        }

        enum ROOM {
            DEBUG = False,

            SHIP_ID = memory(WORD, TEMP),

            ROCK_1 = memory(WORD, TEMP),
            ROCK_2 = memory(WORD, TEMP),
            ROCK_3 = memory(WORD, TEMP),
            ROCK_CRASH_SIZE = 0x0a,

            CRASH = memory(WORD, TEMP),
        }

        enum BOSS {
            ID = memory(WORD, TEMP),

            X = 0x52,
            Y = 0x07,

            HIDDEN = True,
        }

        fun yeet() {
            // source: call(0x94e9d8);
            
            control(NONE);

            // <0x24ab> = <BOY>[X];
            // <0x24af> = <BOY>[Y];

            // <0x24cf> = 0x0228;
            // <0x24d1> = 0x0058;

            // <0x24cf> += 0x05;
            // sleep(0x17);

            animate(BOY, LOOP, ANIMATION_BOY.LANDING);
            // sleep(0x03);
            // animate(DOG, LOOP, ANIMATION_DOG.ACT1_ANGRY);
            sleep(0x05);

            // call_async(0x94eb06);
            // call_async(0x94eb0c);

            animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
            <BOY>[VELOCITY] = 0x20;

            while(<BOY>[X] > 0x70) {
                // teleport(<BOY>, <0x24ab>, <0x24af>);
                <BOY>[X]--;
                // teleport(DOG, <0x24ab>, <0x24af>);
                // teleport(0x2838, 0x24ab, 0x24af - 0x01);

                // <0x24ab>--;
                yield();

                // debug_memory(<0x24ab>, <0x24cf>);
                // sleep(0x20);
            }

            while(<BOY>[Y] < 0xd0) {
                // teleport(<BOY>, <0x24ab>, <0x24af>);
                <BOY>[Y] += 0x03;
                // teleport(DOG, <0x24ab>, <0x24af>);
                // teleport(0x2838, 0x24ab, 0x24af - 0x01);

                // <0x24ab>--;
                yield();

                // debug_memory(<0x24ab>, <0x24cf>);
                // sleep(0x20);
            }
        }

        @install()
        @async()
        fun stack_t01_offset() {
            while(alive(<BOY>)) {
                if(ROOM.CRASH) {
                    damage(BOY, 0xff, True);
                    yield();
                } else {
                    <BOY>[X] -= 0x02;

                    ROOM.SHIP_ID[X] = <BOY>[X];
                    ROOM.SHIP_ID[Y] = <BOY>[Y] - 0x03;
                    yield();
                    
                    if(<BOY>[Y] < 0x40) {
                        <BOY>[Y] = 0x40;
                    } else if(<BOY>[Y] > 0xd0) {
                        <BOY>[Y] = 0xd0;
                    }
                    // yield();

                    if(<BOY>[X] < 0xb0) {
                        yeet();

                        map_transition(junkyard_northwest, crash_west, NONE);
                    } 
                    yield();
                }
            }
        }

        @install()
        @async()
        fun boss_watcher() {
            while(alive(BOSS.ID)) {
                sleep(0d250);
                sleep(0d250);
                animate(LAST_ENTITY, ONCE_FREEZE, ANIMATION_ENEMY.SALABOG_DUCK);
                attribute(BOSS.ID, INVINCIBLE, True);
                sleep(0d250);
                animate(LAST_ENTITY, ONCE, DEFAULT);
                attribute(BOSS.ID, INVINCIBLE, False);
            }
        }

        fun spawn_boss() {
            add_enemy(SALABOG, BOSS.X, BOSS.Y);
            BOSS.ID = <LAST_ENTITY>;

            boss_watcher();
        }

        @install()
        fun revealer_triggered() {
            destroy(SCRIPT_OWNER);

            spawn_boss();
        }

        @install()
        fun crash() {
            ROOM.CRASH = 0x01;

            control(NONE);

            damage(BOY, 0xff, True);
            destroy(ROOM.SHIP_ID);

            
        }

        fun rock_check() {
            if(arg[0x00] < arg[0x04]) {
                arg[0x08] = arg[0x04] - arg[0x00];
            } else {
                arg[0x08] = arg[0x00] - arg[0x04];
            }

            if(arg[0x02] < arg[0x06]) {
                arg[0x0a] = arg[0x06] - arg[0x02];
            } else {
                arg[0x0a] = arg[0x02] - arg[0x06];
            }

            if((arg[0x08] <= ROOM.ROCK_CRASH_SIZE) && (arg[0x0a] <= ROOM.ROCK_CRASH_SIZE)) {
                crash();
                end();
            }
            sleep(0x05);

            if(ROOM.DEBUG) {
                debug_memory(arg[0x08], arg[0x0a]);
                sleep(0x20);
            }
        }

        @install()
        @async()
        fun rock_1_check() {
            while(True) {
                arg[0x00] = <ACTIVE>[X];
                arg[0x02] = <ACTIVE>[Y];
                arg[0x04] = ROOM.ROCK_1[X] + 0x0a;
                arg[0x06] = ROOM.ROCK_1[Y];

                rock_check();
            }
        }

        @install()
        @async()
        fun rock_2_check() {
            while(True) {
                arg[0x00] = <ACTIVE>[X];
                arg[0x02] = <ACTIVE>[Y];
                arg[0x04] = ROOM.ROCK_2[X] + 0x0a;
                arg[0x06] = ROOM.ROCK_2[Y];

                rock_check();
            }
        }
        @install()
        @async()
        fun rock_3_check() {
            while(True) {
                arg[0x00] = <ACTIVE>[X];
                arg[0x02] = <ACTIVE>[Y];
                arg[0x04] = ROOM.ROCK_3[X] + 0x0a;
                arg[0x06] = ROOM.ROCK_3[Y];

                rock_check();
            }
        }

        fun add_rock(x, y, id) {
            add_enemy(STONE, x, y, FLAG_ENEMY.INVISBLE_INVINCIBLE_INACTIVE);
            id = <LAST_ENTITY>;
        }

        fun trigger_enter() {
            available(BOY);
            destroy(DOG); // teleport(BOY, 0x00, 0x00);

            add_placeholder(ANIMATION_PLACEHOLDER.SHELL_BOAT, 0x00, 0x00);
            ROOM.SHIP_ID = <LAST_ENTITY>;

            stack_t01_offset();

            if(BOSS.HIDDEN) {
                add_enemy(REVEALER_TARGET_ENTITY, BOSS.X, BOSS.Y);
                special_script(REVEALER, reference(revealer_triggered));
            } else {
                spawn_boss();
            }
            
            default_init_room(False, False);

            add_rock(0x45, 0x10, ROOM.ROCK_1);
            rock_1_check();
            yield();
            add_rock(0x2d, 0x16, ROOM.ROCK_2);
            rock_2_check();
            yield();
            add_rock(0x19, 0x10, ROOM.ROCK_3);
            rock_3_check();

            add_enemy(TENTACLE_WHIP, 0x21, 0x0c);
            // add_enemy(TENTACLE_SPIKE, 0x1e, 0x0b);
            add_enemy(TENTACLE_SPIKE, 0x1b, 0x0e);
        }
    };

    map rpg_arena(RAPTORS) {
        enum entrance {
            left = entrance(0x15, 0x1c, NONE),
            center = entrance(0x1e, 0x21, NONE),
            right = entrance(0x2a, 0x23, NONE),

            pokemon_left = entrance(0d26, 0d31, NONE),
            pokemon_right = entrance(0d31, 0d31, NONE),
        }

        enum stepon_trigger {
            exit_north = @install() {
                debug_subtext("S=0");
            },
            exit_south = @install() {
                debug_subtext("S=1");
            },
            center = @install() {
                debug_subtext("S=2");
            }
        }

        fun close_exits(close) {
            if(close) {
                object[0x04] = 0x04;
            } else {
                object[0x05] = 0x04;
            }
        }

        enum BOSS {
            ID = memory(WORD, TEMP),

            POKEMON = memory(WORD, TEMP),

            BEE_HP = 0d20,
            BEE_TAKLE_DAMAGE = 0d05,
            BEE_STING_DAMAGE = 0d15,

            CHAMELEON_HP = 0d40,
            CHAMELEON_TAKLE_DAMAGE = 0d07,
        }

        fun prepare_dog() {
            control(DOG, True);

            attribute(DOG, AI_RUN, True);
            walk(DOG, TILE_ABSOLUTE, 0d26, 0d31, DOG); // TODO: unlocks BOTH
            face(DOG, EAST);
            sleep(0d30);
        }
        fun prepare_boss_pokemon() {
            attribute(BOSS.POKEMON, AI_RUN, True);
            walk(BOSS.POKEMON, TILE_ABSOLUTE, 0d31, 0d31, BOSS.POKEMON);
            sleep(0d30);
        }

        fun move_attack() {
            MEMORY.STRING_PARAMETER_1 = 0d10;
            MEMORY.STRING_PARAMETER_2 = 0d01;
            _question("[SLOW]Choose your move[CHOICE][MEM1]/10 Tackle[CHOICE][MEM2]/5 Tackle");

            attribute(DOG, ROOT, True);

            if(MEMORY.QUESTION_ANSWER == 0d00) {
                animate(DOG, ONCE, SLASH_1);
                sleep(0d40);

                damage(BOSS.POKEMON, 0d05, True);
            } else if(MEMORY.QUESTION_ANSWER == 0d01) {
                animate(DOG, ONCE, ANIMATION_DOG.ACT1_ANGRY);
                sleep(0d20);

                damage(BOSS.POKEMON, 0d15, True);
            }

            attribute(DOG, ROOT, False);
        }
        fun move_item() {
            MEMORY.STRING_PARAMETER_1 = MEMORY.PETAL;
            MEMORY.STRING_PARAMETER_2 = MEMORY.WINGS;
            _question("[SLOW]Choose item:[CHOICE][MEM1] Potion[CHOICE][MEM2] Pokedoll");

            if(MEMORY.QUESTION_ANSWER == 0d00) {
                MEMORY.PETAL--;

                heal(DOG, 0d20, True);
            } else if(MEMORY.QUESTION_ANSWER == 0d01) {
                MEMORY.WINGS--;

                subtext("You escaped safely.");
                sleep(0d200);
                
                return_to_bonfire();
                end();
            }
        }

        fun move() {
            _question("[SLOW]Choose your action[CHOICE]Move[CHOICE]Item");

            if(MEMORY.QUESTION_ANSWER == 0d00) {
                move_attack();
            } else if(MEMORY.QUESTION_ANSWER == 0d01) {
                move_item();
            }
        }

        fun move_enemy_bee() {
            arg[0x10] = randrange(0d05);

            if(arg[0x10] <= 0d00) {
                subtext("Bee uses tackle");
                damage(DOG, 0d05, True);

                BOSS.POKEMON[X] -= 0d10;
                sleep(0d10);
                BOSS.POKEMON[X] += 0d10;
            } else {
                subtext("Bee uses…");

                if(False) {
                    BOSS.POKEMON[VELOCITY] = 0d100;
                } else {
                    BOSS.POKEMON[VELOCITY] = 0d20;
                }
                cast(BOSS.POKEMON, DOG, STING, 0d20);
                sleep(0d200);
            }
        }
        fun move_enemy_chameleon() {
            arg[0x10] = randrange(0d05);

            if(arg[0x10] <= 0d03) {
                subtext("Chameleon uses tackle");
                damage(DOG, 0d10, True);

                BOSS.POKEMON[X] -= 0d10;
                sleep(0d10);
                BOSS.POKEMON[X] += 0d10;
            } else {
                subtext("Chameleon uses…");

                BOSS.POKEMON[VELOCITY] = 0d20;
                cast(BOSS.POKEMON, DOG, FLASH, 0d30);
                sleep(0d200);
            }
        }

        fun boy_pokeball() {
            shoot_entity_absolute(BOY, BEACH_BALL, 0d26 * 0x08, 0d31 * 0x08, 0d50, 0d00);
        }
        fun boss_pokeball(pokemon) {
            subtext(pokemon);

            shoot_entity_absolute(BOSS.ID, BEACH_BALL, 0d31 * 0x08, 0d31 * 0x08, 0d50, 0d00);
        }

        fun boss_pokemon(enemy:ENEMY, hp) {
            add_enemy(enemy, 0d31, 0d31, INACTIVE);
            BOSS.POKEMON = <LAST_ENTITY>;
            <LAST_ENTITY>[HP] = hp;

            face(LAST_ENTITY, WEST);
        }

        fun fainted_check() {
            if(<DOG>[HP] <= 0d00) {
                subtext("You fainted.");
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);
                sleep(0d200);

                return_to_bonfire();
                end();
            }
        }

        fun trigger_enter() {
            default_init_room(True, False);

            close_exits(True);

            // character_selection(BOY);

            teleport(DOG, 0x00, 0x00);

            if!(FLAG.IN_ANIMATION) {

                // teleport(DOG, 0x19, 0x1d);
                // <DOG>[X] += 0x20;
                // <DOG>[Y] += 0x20;
                crash_land(BOTH);
            }

            add_enemy(VILLAGER_1_2, 0x2a, 0x23);
            BOSS.ID = <LAST_ENTITY>;
            control(LAST_ENTITY, True);
            face(LAST_ENTITY, WEST);

            sleep(0d60);

            control(DOG, True);
            face(DOG, EAST);

            control(BOY, True);
            face(BOY, EAST);

            fainted_check();

            MEMORY.QUESTION_ANSWER = 0xffff;
            while(MEMORY.QUESTION_ANSWER != 0d00) {
                _question("[SLOW]Choose your Pokemon:[CHOICE]Dog");
            }

            subtext("I choose you, dog!");

            set_camera(COORDINATE_CORNER, 0d110, 0d120, 0d10);

            boy_pokeball();
            boss_pokeball("I choose you, bee!");
            sleep(0d100);

            teleport(DOG, 0d26 * 0x08, 0d31 * 0x08);
            prepare_dog();

            boss_pokemon(BEE, BOSS.BEE_HP);
            sleep(0d60);

            while((<DOG>[HP] > 0d00) && (BOSS.POKEMON[HP] > 0d00)) {
                move();
                sleep(0d30);

                if(BOSS.POKEMON[HP] > 0d00) {
                    prepare_boss_pokemon();

                    move_enemy_bee();
                    sleep(0d30);

                    prepare_dog();
                }
            }

            fainted_check();

            boss_pokeball("I choose you, chameleon!");
            sleep(0d100);

            boss_pokemon(CHAMELEON, BOSS.CHAMELEON_HP);
            sleep(0d60);

            while((<DOG>[HP] > 0d00) && (BOSS.POKEMON[HP] > 0d00)) {
                move();
                sleep(0d30);

                if(BOSS.POKEMON[HP] > 0d00) {
                    prepare_boss_pokemon();

                    move_enemy_chameleon();
                    sleep(0d30);
                    
                    prepare_dog();
                }
            }

            fainted_check();

            debug_subtext("yatta?");
        }
    };
};
