group general_enums() {
    enum SYSTEM {
        WITH_DEBUG_SUBTEXT = True,
        WITH_DEBUG_MUSIC = False,
        WITH_DEBUG_SOUND = False,

        HP_MAX = 0x7fff,
        ITEM_MAX = 0d99,
    }

    group rom() {
        enum ADDRESS {
            // intro

            INTRO_FIRST_CODE_EXECUTED = 0x92e0ca,

            // act 0

            INTRO_START_PRESSED = 0x92e44e,

            // act 1

            SOUTH_JUNGLE_ENTER = 0x9384d9,
            SOUTH_JUNGLE_ENTER_GOURD_1 = 0x93802b,

            STRONG_HEART_EXTERIOR_ENTER = 0x94e5fb,

            FE_EXIT_NORTH = 0x94bead,
            FE_EXIT_NORTH_GATED = 0x94bedc,
            FE_EXIT_EAST = 0x94be9f,
            FE_EXIT_SOUTH = 0x94be91,
            FE_EXIT_WEST = 0x94bee2,

            RAPTORS_EXIT_ENTER = 0x93912c,
            RAPTORS_EXIT_NORTH = 0x93873f,
            RAPTORS_EXIT_SOUTH = 0x93874d,
            RAPTORS_STEP_ON_FIGHT = 0x93875f,
            RAPTORS_BUSH_WIGGLE = 0x938da0,

            THRAXX_EXIT_NORTH = 0x93c6d8,
            THRAXX_EXIT_SOUTH = 0x93c6ae,

            SALABOG_EXIT_SOUTH = 0x9786e4,
            SALABOG_EXIT_NORTH = 0x9786ec,

            // misc. maps

            BRIAN_MAP_POINTER = 0x928084, // inavalid memory
            BRIAN_ENTER = 0x928000,

            // scripts

            FADE_IN_AND_DEFAULT_LOOT_DUST_REWARD = 0x92de75,

            RAISE_CURRENT_WEAPON = 0x92bf33,

            STATUS_BAR_SHOW = 0x92a3ed,
            STATUS_BAR_HIDE = 0x92a3e7,

            FADE_TO_WHITE = 0x92d723,
            FADE_FROM_WHITE = 0x92d752,

            FADE_TO_NIGHT = 0x92d89b,
            FADE_FROM_NIGHT = 0x92d8c2,

            FLASH_WHITE = 0x92d7b1,
            FLASH_WHITE_SLOWER = 0x92d752,

            EXPLODE_BOSS_STOP = 0x92df70,

            RAIN = 0x92d92a,

            MODE7_SPACESHIP = 0x92dc1b,
            MODE7_SPACESHIP_ACT4 = 0x92dc51,

            STERLING_ROAR = 0x99988a, // { sound(DRAGON_ROAR); sfx_effect(SHAKING, True); sleep(0d29); sfx_effect(SHAKING, False); }
            METAL_MAGMAR_HEAL = 0x9ba56b,

            TURN_OFF_RAIN = 0x92d939,

            // script (weird)

            RNG2849 = 0x99e8a2, // sets $2949 to #12,#14,#16 or #18 at random, to decide what the vigor mob throws

            // asm

            DEBUG_MENU_BUTTON_1 = 0xfd8000, // button 1, "Debug: Create a monster"/"Debug: Full equipment", 40 bytes
            DEBUG_MENU_BUTTON_2 = 0xfd8040, // button 2, "Debug: Heel", 40 bytes
            DEBUG_MENU_BUTTON_3 = 0xfd8080, // button 3, "Debug: Show thud balls on path"/"Debug: Walk through walls", 40 bytes
            DEBUG_MENU_BUTTON_4 = 0xfd80c0, // button 4, "Debug: Turn off both backgrounds", 40 bytes
            DEBUG_MENU_BUTTON_5 = 0xfd8100, // button 5, "Debug: Show background 1 only", 40 bytes
            DEBUG_MENU_BUTTON_6 = 0xfd8140, // button 6, "Debug: Show background 2 only", 40 bytes
            DEBUG_MENU_BUTTON_7 = 0xfd8180, // button 7, "Debug: Show both backgrounds", 40 bytes
            DEBUG_MENU_BUTTON_8 = 0xfd81c0, // button 8, "Debug: Select map", 40 bytes
            DEBUG_MENU_BUTTON_9 = 0xfd8200, // button 9, "Debug: Mode 7 Flight", 40 bytes
            DEBUG_MENU_BUTTON_10 = 0xfd8240, // button 10, "Alchemist", 40 bytes
            DEBUG_MENU_BUTTON_11 = 0xfd8280, // button 11, "ROM Creation Date", 40 bytes

            HOTKEY_START = 0xfd82c0, // hotkey start, 40 bytes
            HOTKEY_START_L = 0xfd8300, // hotkey start+L, 40 bytes
            HOTKEY_START_R = 0xfd8340, // hotkey start+R, 40 bytes
            HOTKEY_B = 0xfd8380, // hotkey B, 40 bytes
            HOOK_MENU_CLOSE = 0xfd83c0, // hook menu close, 40 bytes
            HOTKEY_L = 0xfd8440, // hotkey L, 40 bytes
            HOTKEY_R = 0xfd8480, // hotkey R, 40 bytes
        }

        enum ADDRESS_ID {
            // map

            FADE_IN = 0x36, // reads: BOY_UNAVAILABLE+DOG_UNAVAILABLE, TRANSITION_ENTER_DIRECTION, DOG_READ, writes: VELOCITY+Z, TRANSITION_ENTER_DIRECTION

            FADE_OUT_CREDITS = 0x57,

            // transition

            TRANSITION_NORTH = 0x27,
            TRANSITION_NORTH_SHORT = 0x26,
            TRANSITION_NORTH_NORTH = 0x2a,
            TRANSITION_EAST = 0x1d,
            TRANSITION_EAST_SOUTH = 0x20, // act3 sewers entrance
            TRANSITION_SOUTH = 0x21,
            TRANSITION_SOUTH_SHORT = 0x22,
            TRANSITION_WEST = 0x19,
            TRANSITION_UNKNOWN_1 = 0x1f,
            TRANSITION_UNKNOWN_2 = 0x1e,
            TRANSITION_UNKNOWN_3 = 0x1a,
            TRANSITION_UNKNOWN_4 = 0x29,
            TRANSITION_UNKNOWN_5 = 0x2e,
            TRANSITION_UNKNOWN_6 = 0x2d,
            TRANSITION_UNKNOWN_7 = 0x1c,
            TRANSITION_UNKNOWN_8 = 0x28,

            UNKNOWN_TRANSITION_ENTER_HANDLER = 0x36, // reads: TRANSITION_ENTER_DIRECTION+BOY_UNAVAILABLE+DOG_UNAVAILABLE, does: walk by 1 tile or Z or VELOCITY

            WINGS_HELPER = 0x5b,

            // loot

            LOOT_SNIFF = 0x39,
            LOOT_GOURD = 0x3a,

            LOOT_DUST_REWARD = 0x172b, // includes the rng etc.

            LOOT_DIALOG_CURRENCY = 0x42, // reads: LOOT_AMOUNT_CURRENCY+CURRENCY_CURRENT, does: plots money lootet and currency
            LOOT_DIALOG_ITEM = 0x40, // reads: LOOT_ITEM, does: loot item with quantity 1(?)

            VANILLA_ETERNAL_DUST = 0x1b5d, // used for the boss rush

            NAME_CURRENCY = 0x51,

            // death
            BOY_FLOWER_SCREEN = 0x17ac, // "<0x22ea, 0x40> = True;"
            BOY_RAPTORS_SCREEN = 0x17b2, // "<0x22ed, 0x04> = True;"

            // dialogue

            NPC_DIALOGUE_START = 0x32, // control(ACTIVE, True) + face_each(SCRIPT_OWNER, ACTIVE)
            NPC_DIALOGUE_STOP = 0x33, // control(ACTIVE, False)

            OPEN_TEXTBOX_DEFAULT = 0x02, // x=0x0a y=0x02 w=0x14 h=0x07
            OPEN_TEXTBOX_1 = 0x04, // x=0x0a y=0x02 w=0x14 h=0x06
            OPEN_TEXTBOX_2 = 0x05, // x=0x0a y=0x02 w=0x14 h=0x04
            OPEN_TEXTBOX_3 = 0x06, // x=0x0a y=0x02 w=0x14 h=0x03
            OPEN_TEXTBOX_4 = 0x07, // x=0x02 y=0x02 w=0x14 h=0x07
            OPEN_TEXTBOX_5 = 0x09, // x=0x02 y=0x02 w=0x14 h=0x06
            OPEN_TEXTBOX_6 = 0x0a, // x=0x02 y=0x02 w=0x14 h=0x04
            OPEN_TEXTBOX_7 = 0x0b, // x=0x02 y=0x02 w=0x14 h=0x03
            OPEN_TEXTBOX_8 = 0x0d, // x=0x03 y=0x14 w=0x1a h=0x02 (unbordered?)
            OPEN_TEXTBOX_9 = 0x0e, // x=0x0a y=0x02 w=0x14 h=0x08
            OPEN_TEXTBOX_10 = 0x13, // x=0x02 y=0x02 w=0x14 h=0x08
            OPEN_TEXTBOX_11 = 0x18, // x=0x0c y=0x13 w=0x12 h=0x05
            OPEN_TEXTBOX_12 = 0x03, // x=0x0a y=0x02 w=0x14 h=0x08

            DIALOGUE_BUY_INGREDIENT = 0x54,
            DIALOGUE_SAVE = 0x4d,

            // music

            MUSIC_FADE_IN = 0x01, // (CHANGE_MUSIC=True;)
            MUSIC_FADE_OUT = 0x00, // (CHANGE_MUSIC=False;)

            // scripts

            BOMB_EXPLOSION = 0x1b66,

            OUTRO = 0x59, // starts in nobilia, but the boy

            VENDOR_EXCHANGE_CURRENCY_HELPER = 0x55,
            VENDOR_SHOPPING_CURRENCY_CHANGE_HELPER = 0x53,
            VENDOR_NOT_ENOUGH_CURRENCY_HELPER = 0x50,
            VENDOR_BUY_HELPER = 0x47,
            VENDOR_SELL_HELPER = 0x49,

            // unknown

            UNKNOWN_1 = 0x34, // "(5a) UNTRACED INSTR, checking message timer"
            UNKNOWN_2 = 0x35, // "(5b) UNTRACED INSTR, checking message timer"

            // VANILLA

            // bosses

            RIMSALA_STATUE_RESET_1 = 0xbb, // statue=$283d
            RIMSALA_STATUE_RESET_2 = 0xbc, // statue=$283f
            RIMSALA_STATUE_RESET_3 = 0xbd, // statue=$2841
            RIMSALA_STATUE_RESET_4 = 0xbe, // statue=$2843
            RIMSALA_STATUE_RESET_5 = 0xbf, // statue=$2845
            RIMSALA_STATUE_RESET_6 = 0xc0, // statue=$2847

            // events

            TINY_TRADE_TAPESTRY = 0xd4,

            // talk scripts

            VANILLA_TALK_STRONGHEART = 0x1863,

            // death scripts

            VANILLA_DEATH_GRAVEYARD_LIZARD_2 = 0x17d6,
            VANILLA_DEATH_GRAVEYARD_LIZARD_3 = 0x17d9,
            VANILLA_DEATH_GRAVEYARD_LIZARD_4 = 0x17dc,
        }

        enum IDLE_BEHAVIOR { // Character->"Unknown x03"
            DEFAULT = 0x00,

            HOVERING = 0x0c, // constant hovering, used: floating fan, puppets, mosquitos

            MAGMAR_ROLL_SHOOT = 0x10,
            MEGATAUR_ROLL = 0x1a,

            // weird

            DOG_IDLE = 0x06, // sniff around (extended with L and R), sit

            // crash

            VIPER_ROLL = 0x12, // used: vipers

            // unknown

            UNKNOWN_1 = 0x02, // used: carltron, bomb, speaker, fan, face, hearts, mungola, rimsala head, aquagoth, aegis, sitting npcs?, levitate entity, rock
            UNKNOWN_2 = 0x04, // used: boy
            UNKNOWN_3 = 0x08, // used: tiny tentacles, sphere bot, claws, flowers, snake statues
            UNKNOWN_4 = 0x0a, // used: walking npcs? (tiny, barker?, prof, tinker, gomi, horace, …)
            UNKNOWN_5 = 0x0e, // used: salabog, bone snake
            UNKNOWN_6 = 0x14, // used: rimsalas
            UNKNOWN_7 = 0x16, // used: "$0"?
            UNKNOWN_8 = 0x18, // used: minitaur
            UNKNOWN_9 = 0x1c, // used: tentacles

            // crash: 1e, 20, …
        }

        enum CHARACTER_FLAG_ENEMY { // Character->"Unknown x05" (same as FLAG_ENEMY?)
            NORMAL = 0x0000,
            INACTIVE_INVISIBLE = 0x0001,
            INVINCIBLE = 0x0002, // also friendly
            INACTIVE = 0x0020,
            MOSQUITO = 0x0040,
            PHASING = 0x0400,
            INVISBLE_INVINCIBLE_INACTIVE = 0x1000,

            INACTIVE_IMORTAL = 0x0022,

            // buggy

            UNKNOWN = 0x01, // invisible, follows after hit
        }
        enum CHARACTER_FLAG_SPECIAL { // Character->"Flags"
            STONE_LEVITATE = 0x0002,
            STONE_LEVITATE_INVISIBLE = 0x0005,
            BOMBABLE = 0x0004,
        }

        enum ATTACK_PROC { // Character->"Attack Proc.?"
            DEFAULT = 0x00,
            
            VORE = 0x0c, // flowers
            NO_KNOCKBACK = 0x0e, // mosquito (insect incense)
            
            POISON = 0x12, // "Son of Set" (1/4)
            POISON_SPIDER = 0x14, // spiders (1/4, insect incense)
            PLAGUE = 0x16, // rat
            POISON_SNAKE = 0x18, // "stone cobra" (100%)
            PLAGUE_CONFOUND = 0x1c, // monk (1/4, 1/4, level 5)

            BOY = 0x08, // grants weapon xp?
            DOG = 0x0a, // grants weapon xp?

            // weird
            PROJECTILE = 0x02,
            PIERCING = 0x04, // toaster projectiles? (deals little damage)
            ARMOR_PIERCING = 0x06, // bomb? (deals little damage)
            NO_KNOCKBACK = 0x10, // unused?
            GUARANTEED_HIT = 0x1a, // bomb? (deals a lot of damage)

            // crash: 1e, 20, …
        }

        enum ALCHEMY_TARGET {
            BOY = 0x0800, // atlas, call up, one up
            BOTH = 0x0802, // wings, escape, super heal
            BOY_DOG = 0x0a00, // petal, nectar, honey, essence, pixie dust
            BOY_DOG_BOTH = 0x0008, // barrier, cure, defend, force field, heal, miracle cure, reflect, regrowth, speed
            ENEMY_ALL = 0x2010, // acid rain, double drain, drain, explosion, fireball, fire power, flash, hard ball, lance, laser, lightning storm, nitro, slow burn, sting, stop

            // special
            DOG_DEAD_1 = 0x0214, // biscuit
            DOG_DEAD_2 = 0x0014, // revive
            LEVITATE = 0x2200, // levitate
            REVEALER = 0x0240, // revealer

            // weird
            MENU = 0x6600, // call beads, pouch

            // custom
            BOY_DOG_ALL_ENEMY = 0x2018,

            // special
            POINTER = 0x045BF5,
            SIZE = 0x02,
        }

        enum ARMOR_INDEX {
            ARMOR_1_1 = 0x01,
            ARMOR_1_2 = 0x02,
            ARMOR_1_3 = 0x03,
            ARMOR_2_1 = 0x04,
            ARMOR_2_2 = 0x05,
            ARMOR_2_3 = 0x06,
            ARMOR_3_1 = 0x07,
            ARMOR_3_2 = 0x08,
            ARMOR_3_3 = 0x09,
            ARMOR_4_1 = 0x0a,
            ARMOR_4_2 = 0x0b,
            ARMOR_4_3 = 0x0c,

            HELM_1_1 = 0x0d,
            HELM_1_2 = 0x0e,
            HELM_1_3 = 0x0f,
            HELM_2_1 = 0x10,
            HELM_2_2 = 0x11,
            HELM_2_3 = 0x12,
            HELM_3_1 = 0x13,
            HELM_3_2 = 0x14,
            HELM_3_3 = 0x15,
            HELM_4_1 = 0x16,
            HELM_4_2 = 0x17,
            HELM_4_3 = 0x18,

            ARMBAND_1_1 = 0x19,
            ARMBAND_1_2 = 0x1a,
            ARMBAND_1_3 = 0x1b,
            ARMBAND_2_1 = 0x1c,
            ARMBAND_2_2 = 0x1d,
            ARMBAND_2_3 = 0x1e,
            ARMBAND_3_1 = 0x1f,
            ARMBAND_3_2 = 0x20,
            ARMBAND_3_3 = 0x21,
            ARMBAND_4_1 = 0x22,
            ARMBAND_4_2 = 0x23,
            ARMBAND_4_3 = 0x24,
            
            COLLAR_1 = 0x25,
            COLLAR_2 = 0x26,
            COLLAR_3 = 0x27,
            COLLAR_4 = 0x28,
        }

        enum CHARACTER_INDEX {
            BOY = 0d0,
            DOG = 0d1,
            // …
            TUMBLING_WEED = 0d59,
            // …
            FLOWER_PURPLE = 0d109,
            // …
            THRAXX_HEART = 0d118,
            // …
            CARLTRON_ROBOT = 0d141,
        }

        enum CHARACTER_DATA {
            NAME_POINTER = 0x00,
            // …
            ATTACK = 0x19,
            DEFEND = 0x1b,
            MAGIC_DEFEND = 0x1d,
            // …
            HIT_RATE = 0x23,
            // …
            ATTACK_PROC = 0x30, // -> ATTACK_PROC
            // …

            // special
            POINTER = 0x0EB678,
            SIZE = 0d74,
        }

        enum WEAPON_DATA {
            ATTACK_BONUS = 0x00,
            NAME_POINTER = 0x02,
            // ??

            // special
            POINTER = 0x0438E6,
            SIZE = 0x24,
        }
        enum ARMOR_DATA {
            ARMOR_BONUS = 0x00,
            ARMOR_BONUS_TOOLTIP = 0x02,
            // ??

            // special
            POINTER = 0x043B02,
            SIZE = 0x0a,
        }
        enum ALCHEMY_COST_DATA {
            INGREDIENT_1 = 0x00,
            INGREDIENT_2 = 0x01,

            AMOUNT_1 = 0x02,
            AMOUNT_2 = 0x03,

            // special
            POINTER = 0x04601f,
            SIZE = 0x04,
        }
    };

    group ram() {
        enum MEMORY_TYPE {
            SRAM = 0x0,
            RAM = 0x1,
            TEMP_RESERVED = 0x2,
            TEMP = 0x3,
        }
        enum MEMORY_SIZE {
            FLAG = 0x0,
            BYTE = 0x1,
            WORD = 0x2,
        }

        enum MEMORY {
            // currency
            TALONS = <0x0ac6>,
            JEWELS = <0x0ac9>,
            GOLD = <0x0acc>,
            CREDITS = <0x0acf>,

            CURRENCY_CURRENT = (Byte) <0x2348>,

            PACIFIED = <0x23bf>,
            FAKE_HOUSE_ID = <0x234b>,

            DOG_WRITE = <0x2443>,
            DOG_READ = <0x2363>,
            QUESTION_ANSWER = <0x289d>,
            STRING_PARAMETER_1 = <0x2537>,
            STRING_PARAMETER_2 = <0x2539>,
            STRING_PARAMETER_3 = <0x253b>,

            // enemies
            NEXT_ENEMY_FOLLOWS_ENTITY = <0x2533>, // consumed after an enemy was added (e.g. BEE, CHAMELEON)

            NEXT_DAMAGE_NO_KNOCKBACK = <0x23d5>,
            
            Z_AFTER_TELEPORT = <0x23db>, // redundant with "entity[Z_LEVEL] = z;"

            NEXT_PROJECTILE_DAMAGE = <0x23d1>, // consumed after bomb explosion

            // sniff spot looting
            LOOT_ITEM = <0x2391>,
            LOOT_OBJECT = <0x2395>,
            LOOT_AMOUNT_CURRENCY = <0x2393>,
            LOOT_AMOUNT = <0x2461>,
            
            ENTITY_1 = <0x2835>,
            ENTITY_2 = <0x2837>,
            ENTITY_3 = <0x2839>,
            ENTITY_4 = <0x283b>,
            ENTITY_5 = <0x283d>,
            LAST_ENTITY = <0x0341>,

            BOY_LEVEL = <0x0A50>,
            BOY_CURRENT_HP = <0x4EB3>,
            BOY_XP_REQUIRED = <0x4F1D>,

            DOG_LEVEL = <0x0A9A>,
            DOG_XP_REQUIRED = <0x4FCB>,

            ENEMY_SPAWNER_QUANTITY = <0x2433>,
            ENEMY_SPAWNER_UNKNOWN_1 = <0x23c5>, // mostly 0x0280, once 0x0500
            ENEMY_SPAWNER_UNKNOWN_2 = <0x23dd>, // mostly 0x0000 and 0xffff, once 0x0064

            WINDWALKER_TYPE = <0x2355>,

            // music
            // CURRENT_MUSIC = <0x0E4B>, // buggy

            // weapons
            GAIN_WEAPON = <0x2441>,
            CURRENT_WEAPON = (Byte) <0x235F>,
            CURRENT_WEAPON_TYPE = (Byte) <0x2360>, // see WEAPON_TYPE

            // vendor

            VENDOR_RECOMMEND_CURRENCY_CHANGE = <0x240d>, // updated with call_id(VENDOR_RECOMMEND_CURRENCY_CHANGE);, 0->recommend change
            VENDOR_SHOP_ITEMS_BUY = <0x2459>,
            VENDOR_SHOP_ITEMS_SELL = <0x2457>,
            VENDOR_ENTITY = <0x2455>, // center of the ring menu

            // map

            WINDWALKER_LOCATION = <0x237b>, // see WINDWALKER_LOCATION
            WINDWALKER_LOCATION_HELPER = <0x237d>, // ?

            // CURRENT_MAP = (Byte) <0x0ADB>, // buggy, shows unknown memory

            CHANGE_MUSIC = <0x238d>,

            MAP_PALETTE = <0x2437>, // thraxx (0=orange, 7=white), waterfall (7=normal, 0=?), ivor/ebon (7=ebon/ivor, 4=?), greenhouse (6=dark?), storage (7=dark?)

            CAMERA_X_MIN = <0x2401>,
            CAMERA_X_MAX = <0x2403>, // CAMERA_X_MIN + 0d256
            CAMERA_Y_MIN = <0x2405>,
            CAMERA_Y_MAX = <0x2407>, // CAMERA_Y_MIN + 0d224

            CAMERA_BOUNDRY_X_START = <0x23e9>,
            CAMERA_BOUNDRY_X_END = <0x23ed>,
            CAMERA_BOUNDRY_Y_START = <0x23eb>,
            CAMERA_BOUNDRY_Y_END = <0x23ef>,

            CAMERA_PAN_X = <0x242b>,
            CAMERA_PAN_Y = <0x242d>,
            CAMERA_PAN_SPEED = <0x242f>, // default=0x80

            FOREGROUND_OFFSET_X = <0x241b>, // only used in dark forest
            FOREGROUND_OFFSET_Y = <0x241d>,

            TRANSITION_ENTER_DIRECTION = <0x238f>,

            // NPCs

            SHOP_RING_MENU_AND_POSITION_ID = <0x2459>,

            // ingredients

            WAX = (Byte) <0x22ff>,
            WATER = (Byte) <0x2300>,
            VINEGAR = (Byte) <0x2301>,
            ROOT = (Byte) <0x2302>,
            OIL = (Byte) <0x2303>,
            MUSHROOM = (Byte) <0x2304>,
            MUD_PEPPER = (Byte) <0x2305>,
            METEORITE = (Byte) <0x2306>,
            LIMESTONE = (Byte) <0x2307>,
            IRON = (Byte) <0x2308>,
            GUNPOWDER = (Byte) <0x2309>,
            GREASE = (Byte) <0x230a>,
            FEATHER = (Byte) <0x230b>,
            ETHANOL = (Byte) <0x230c>,
            DRY_ICE = (Byte) <0x230d>,
            CRYSTAL = (Byte) <0x230e>,
            CLAY = (Byte) <0x230f>,
            BRIMSTONE = (Byte) <0x2310>,
            BONE = (Byte) <0x2311>,
            ATLAS_AMULET = (Byte) <0x2312>,
            ASH = (Byte) <0x2313>,
            ACORN = (Byte) <0x2314>,

            // consumables
            PETAL = (Byte) <0x2315>,
            NECTAR = (Byte) <0x2316>,
            HONEY = (Byte) <0x2317>,
            DOG_BISCUIT = (Byte) <0x2318>,
            WINGS = (Byte) <0x2319>,
            HERBAL_ESSENCE = (Byte) <0x231a>,
            PIXIE_DUST = (Byte) <0x231b>,
            CALL_BEADS = (Byte) <0x231c>,

            // armor
            ARMOR_1_1 = (Byte) <0x231d>,
            ARMOR_1_2 = (Byte) <0x231e>,
            ARMOR_1_3 = (Byte) <0x231f>,
            ARMOR_2_1 = (Byte) <0x2320>,
            ARMOR_2_2 = (Byte) <0x2321>,
            ARMOR_2_3 = (Byte) <0x2322>,
            ARMOR_3_1 = (Byte) <0x2323>,
            ARMOR_3_2 = (Byte) <0x2324>,
            ARMOR_3_3 = (Byte) <0x2325>,
            ARMOR_4_1 = (Byte) <0x2326>,
            ARMOR_4_2 = (Byte) <0x2327>,
            ARMOR_4_3 = (Byte) <0x2328>,
            HELM_1_1 = (Byte) <0x2329>,
            HELM_1_2 = (Byte) <0x232a>,
            HELM_1_3 = (Byte) <0x232b>,
            HELM_2_1 = (Byte) <0x232c>,
            HELM_2_2 = (Byte) <0x232d>,
            HELM_2_3 = (Byte) <0x232e>,
            HELM_3_1 = (Byte) <0x232f>,
            HELM_3_2 = (Byte) <0x2330>,
            HELM_3_3 = (Byte) <0x2331>,
            HELM_4_1 = (Byte) <0x2332>,
            HELM_4_2 = (Byte) <0x2333>,
            HELM_4_3 = (Byte) <0x2334>,
            ARMBAND_1_1 = (Byte) <0x2335>,
            ARMBAND_1_2 = (Byte) <0x2336>,
            ARMBAND_1_3 = (Byte) <0x2337>,
            ARMBAND_2_1 = (Byte) <0x2338>,
            ARMBAND_2_2 = (Byte) <0x2339>,
            ARMBAND_2_3 = (Byte) <0x233a>,
            ARMBAND_3_1 = (Byte) <0x233b>,
            ARMBAND_3_2 = (Byte) <0x233c>,
            ARMBAND_3_3 = (Byte) <0x233d>,
            ARMBAND_4_1 = (Byte) <0x233e>,
            ARMBAND_4_2 = (Byte) <0x233f>,
            ARMBAND_4_3 = (Byte) <0x2340>,
            COLLAR_1 = (Byte) <0x2341>,
            COLLAR_2 = (Byte) <0x2342>,
            COLLAR_3 = (Byte) <0x2343>,
            COLLAR_4 = (Byte) <0x2344>,

            // ammo
            AMMO_1 = (Byte) <0x2345>,
            AMMO_2 = (Byte) <0x2346>,
            AMMO_3 = (Byte) <0x2347>,

            ANNIHILATION_AMULET = <0x2517>,
            BEAD = <0x2519>,
            CERAMIC_POT = <0x251b>,
            CHICKEN = <0x251d>,
            GOLDEN_JACKAL = <0x251f>,
            JEWELED_SCARAB = <0x2521>,
            LIMESTONE_TABLET = <0x2523>,
            PERFUME = <0x2525>,
            RICE = <0x2527>,
            SPICE = <0x2529>,
            SPOON = <0x252b>,
            TAPESTRY = <0x252d>,
            TICKET_FOR_EXHIBITION = <0x252f>,

            // alchemy
            ALCHEMY_REWARD_PRESELECTION = <0x2445>,

            SELECTED_ALCHEMY_0 = (Byte) <0x0ADA>,
            SELECTED_ALCHEMY_1 = (Byte) <0x0AD9>,
            SELECTED_ALCHEMY_2 = (Byte) <0x0AD8>,
            SELECTED_ALCHEMY_3 = (Byte) <0x0AD7>,
            SELECTED_ALCHEMY_4 = (Byte) <0x0AD6>,
            SELECTED_ALCHEMY_5 = (Byte) <0x0AD5>,
            SELECTED_ALCHEMY_6 = (Byte) <0x0AD4>,
            SELECTED_ALCHEMY_7 = (Byte) <0x0AD3>,
            SELECTED_ALCHEMY_8 = (Byte) <0x0AD2>,

            ALCHEMY_LEVEL_ATLAS = <0x2F9a>, // max=10
            ALCHEMY_LEVEL_DEFEND = <0x2FA6>, // max=10? good=3
            ALCHEMY_LEVEL_SPEED = <0x2Fd6>, // max=2? good=1, but buggy?

            // weapon level
            LEVEL_FIST = <0x0ADD>, // unused
            LEVEL_BAZOOKA = <0x0AF7>,
            LEVEL_DOG = <0x0B07>,
            LEVEL_1_SWORD = <0x0ADF>, // bone crusher
            LEVEL_1_AXE = <0x0AE7>,
            LEVEL_1_SPEAR = <0x0AEF>,
            LEVEL_2_SWORD = <0x0AE1>,
            LEVEL_2_AXE = <0x0AE9>,
            LEVEL_2_SPEAR = <0x0AF1>,
            LEVEL_3_SWORD = <0x0AE3>,
            LEVEL_3_AXE = <0x0AEB>,
            LEVEL_3_SPEAR = <0x0AF3>,
            LEVEL_4_SWORD = <0x0AE5>,
            LEVEL_4_AXE = <0x0AED>,
            LEVEL_4_SPEAR = <0x0AF5>,

            // rooms
            DARK_FOREST_XY = <0x2835>,
            DARK_FOREST_LAYOUT = <0x2839>,

            DESERT_X = (Byte) <0x22fd>,
            DESERT_Y = (Byte) <0x22fc>,

            // fade effect (used for wings and cutscenes)
            FADE_X = <0x23ad>, // usually 0x80 (center)
            FADE_Y = <0x23af>, // usually 0x70 (center)
            FADE_START = <0x23b1>, // usually 0xff (closing) or 0d2 (opening)
            FADE_STEP = <0x23b3>, // usually -0d3 (closing) or 0d3 (opening)
            FADE_TRIGGER = <0x23b5>, // usually 0d1 (TODO: sometimes 0-4 are being used), causes a lot of lag

            // debug
            DEBUG_MENU_COUNT = <0x0f5a>,

            // reserved/hack (not part of the original engine)
            CURRENT_MUSIC = (Byte) <0x2445>, // originally "<0x0E4B>"
            MUSIC_STACK_1 = (Byte) <0x2446>,
            MUSIC_STACK_2 = (Byte) <0x2447>,
            MUSIC_STACK_3 = (Byte) <0x2448>,
            MUSIC_STACK_4 = (Byte) <0x2449>,

            CURRENT_MAP = (Byte) <0x244a>, // originally "(Byte) <0x0ADB>"
            CURRENT_MAP_VARIANT = (Byte) <0x244b>, // has to be set during the transition, before the room was entered
            CURRENT_MAP_ENTRANCE_ID = (Byte) <0x244c>,

            // unknown
            UNKNOWN_ETERNAL_DUST_DROP_PROPERTY = <0x23d9>, // used in: boss rush (1=for eternal dust drops)

            UNKNOWN_1 = <0x23c1>, // used in: sandpits, bugmuck, bbm_2, swamp, pipemaze_rooms, waterfall, swamp_bridge, greenhouse (1=?)
            UNKNOWN_2 = <0x23d7>, // used in: sterling grab, reactor room (1=?)
        }

        enum FLAG {
            // system

            EMPTY_SRAM = <0x22ea, 0x04>, // intro skip

            SHOW_HUD = <0x22ea, 0x80>, // requires update_ui();

            DEBUG = <0x22eb, 0x08>,
            INTRO_DEMO_MODE = <0x22eb, 0x04>, // ?

            START_PRESSED = <0x22eb, 0x02>,

            IN_ANIMATION = <0x22eb, 0x20>, // 1 = animation/init room (also means that the boy didn't enter through a regular room transition)

            DOG_UNAVAILABLE = <0x2261, 0x01>,
            BOY_UNAVAILABLE = <0x2261, 0x02>,

            WINDWALKER_UNLOCKED = <0x22dc, 0x08>,

            // items

            // charms
            ARMOR_POLISH = <0x2261, 0x20>,
            CHOCOBO_EGG = <0x2261, 0x40>,
            INSECT_INCENSE = <0x2261, 0x80>,

            JADE_DISK = <0x2262, 0x01>,
            JAGUAR_RING = <0x2262, 0x02>,
            MAGIC_GOURD = <0x2262, 0x04>,
            MOXA_STICK = <0x2262, 0x08>,
            ORACLE_BONE = <0x2262, 0x10>,
            RUBY_HEART = <0x2262, 0x20>,
            SILVER_SHEATH = <0x2262, 0x40>,
            STAFF_OF_LIFE = <0x2262, 0x80>,

            SUN_STONE = <0x2263, 0x01>,
            THUGS_CLOAK = <0x2263, 0x02>,
            WIZARDS_COIN = <0x2263, 0x04>,

            DIAMOND_EYE = <0x2264, 0x01>,
            DIAMOND_EYES = <0x2264, 0x02>,
            GAUGE = <0x2264, 0x04>,
            WHEEL = <0x2264, 0x08>,
            QUEENS_KEY = <0x2264, 0x10>,
            ENERGY_CORE = <0x2264, 0x20>,

            // alchemy
            ACID_RAIN = <0x2258, 0x01>,
            ATLAS = <0x2258, 0x02>,
            BARRIER = <0x2258, 0x04>,
            CALL_UP = <0x2258, 0x08>,
            CORROSION = <0x2258, 0x10>,
            CRUSH = <0x2258, 0x20>,
            CURE = <0x2258, 0x40>,
            DEFEND = <0x2258, 0x80>,

            DOUBLE_DRAIN = <0x2259, 0x01>,
            DRAIN = <0x2259, 0x02>,
            ENERGIZE = <0x2259, 0x04>,
            ESCAPE = <0x2259, 0x08>,
            EXPLOSION = <0x2259, 0x10>,
            FIREBALL = <0x2259, 0x20>,
            FIRE_POWER = <0x2259, 0x40>,
            FLASH = <0x2259, 0x80>,

            FORCE_FIELD = <0x225a, 0x01>,
            HARD_BALL = <0x225a, 0x02>,
            HEAL = <0x225a, 0x04>,
            LANCE = <0x225a, 0x08>,
            LASER = <0x225a, 0x10>,
            LEVITATE = <0x225a, 0x20>,
            LIGHTNING_STORM = <0x225a, 0x40>,
            MIRACLE_CURE = <0x225a, 0x80>,

            NITRO = <0x225b, 0x01>,
            ONE_UP = <0x225b, 0x02>,
            REFLECT = <0x225b, 0x04>,
            REGROWTH = <0x225b, 0x08>,
            REVEALER = <0x225b, 0x10>,
            REVIVE = <0x225b, 0x20>,
            SLOW_BURN = <0x225b, 0x40>,
            SPEED = <0x225b, 0x80>,

            STING = <0x225c, 0x01>,
            STOP = <0x225c, 0x02>,
            SUPER_HEAL = <0x225c, 0x04>,

            // weapons
            SWORD_1 = <0x22DA, 0x02>, // "Bone Crusher"
            SWORD_2 = <0x22DA, 0x04>, // "Gladiator Sword"
            SWORD_3 = <0x22DA, 0x08>, // "Crusader Sword"
            SWORD_4 = <0x22DA, 0x10>, // "Neutron Blade"

            AXE_1 = <0x22DA, 0x20>, // "Spider's Claw"
            AXE_2 = <0x22DA, 0x40>, // "Bronze Axe"
            AXE_3 = <0x22DA, 0x80>, // "Knight Basher"
            AXE_4 = <0x22DB, 0x01>, // "Atom Smasher"

            SPEAR_1 = <0x22DB, 0x02>, // "Horn Spear"
            SPEAR_2 = <0x22DB, 0x04>, // "Bronze Spear"
            SPEAR_3 = <0x22DB, 0x08>, // "Lance"
            SPEAR_4 = <0x22DB, 0x10>, // "Laser Lance"

            BAZOOKA = <0x22DB, 0x20>, // "Bazooka"

            // loot

            LOOT_SUCCESSFUL = <0x22ea, 0x01>,

            // VANILLA

            // bosses

            RAPTORS = <0x225f, 0x40>,
            THRAXX = <0x2260, 0x10>,
            MAGMAR = <0x2260, 0x40>,
            SALABOG = <0x22f3, 0x20>,

            // events

            FLOWERS_CUTSCENE_WATCHED = <0x22ab, 0x40>,

            BLIMP_BRIDGE = <0x225f, 0x01>,

            // gourds

            GOURD_1 = <0x2268, 0x40>,
        }

        enum CUSTOM_MEMORY {
            // <0x28f9>
            START_ROCKET_JUMP_COUNT = (Byte) <0x28f9>,

            // <0x28f8>
            HOTKEY_START = (Byte) <0x28f8>,
            // <0x28f7>
            HOTKEY_START_L = (Byte) <0x28f7>,
            // <0x28f6>
            HOTKEY_START_R = (Byte) <0x28f6>,
            // <0x28f5>
            HOTKEY_L = (Byte) <0x28f5>,
            // <0x28f4>
            HOTKEY_R = (Byte) <0x28f4>,

            // <0x28e8>
            CURRENT_MAP = (Byte) <0x28e8>, // originally "(Byte) <0x0ADB>"
            // <0x28e7>
            CURRENT_MAP_VARIANT = (Byte) <0x28e7>, // has to be set during the transition, before the room was entered
            // <0x28e6>
            CURRENT_MAP_ENTRANCE_ID = (Byte) <0x28e6>,

            // <0x28e4>
            RETURN = <0x28e4>,
            // <0x28e2>
            INPUT_P1 = <0x28e2>,
        }
        enum CUSTOM_FLAG {
            // <0x28fb, x>
            NO_BOY = <0x28fb, 0x01>,
            NO_DOG = <0x28fb, 0x02>,

            NO_CURRENCY_DISPLAY = <0x28fb, 0x04>,

            NO_RUNNING = <0x28fb, 0x08>, // requires patch "temp_jaguar_ring"

            VANILLA_BOMB_DAMAGE = <0x28fb, 0x10>,

            // <0x28fa, x>
            START_MARIO_YUMP = <0x28fa, 0x01>,
            START_ROCKET_JUMP = <0x28fa, 0x02>,
            START_ISAAC_TEAR = <0x28fa, 0x04>,
            START_MARIO_FIREFLOWER = <0x28fa, 0x08>,
        }
    };

    group everscript() {
        group map() {
            enum MAP {
                // ACT 0

                PODUNK_65 = 0x31,
                MANSION_65 = 0x02,
                PODUNK_95 = 0x32,
                MANSION_95 = 0x03,
                
                // ACT 1

                // south jungle
                FLOWERS = 0x38,
                STRONGHEART_EXTERIOR = 0x33,
                STRONGHEART = 0x34,
                RAPTORS = 0x5c,

                // village
                VILLAGE = 0x25,
                VILLAGE_HUTS = 0x51,
                DEFEND = 0x26,

                // east jungle
                EAST_JUNGLE = 0x5b,
                FIREPIT_JUNGLE = 0x36,
                SANDPITS = 0x59,
                ACID_RAIN = 0x5a,
                BUGMUCK = 0x67,
                BBM_1 = 0x16,
                BBM_2 = 0x17,
                THRAXX = 0x18,

                // north jungle
                NORTH_JUNGLE = 0x41,
                GRAVEYARD = 0x27,
                VOLCANO_PATH = 0x69,
                VOLCANO_TOP = 0x52,
                SKY = 0x50,
                SWAMP_ENTRANCE = 0x66,
                SWAMP = 0x65,
                SALABOG = 0x01,
                VOLCANO_ROOMS = 0x3c,
                VOLCANO = 0x3b,
                PIPEMAZE = 0x3d,
                PIPEMAZE_ROOMS = 0x3e,
                MAGMAR = 0x3f,

                // ACT 2

                // crusticia
                CUTSCENE_RIVER = 0x53,
                CUTSCENE_WATERFALL = 0x6a,

                CRUSTICIA = 0x68,
                CRUSTICIA_CAVES = 0x30,

                // east
                BLIMP_EXTERIOR = 0x4f,
                BLIMP = 0x2e,
                FIREPIT_BEACH = 0x04,
                DESERT = 0x1b,

                // nobilia
                NOBILIA_MARKET = 0x0a,
                NOBILIA_NORTH = 0x1c,
                NOBILIA_SQUARE = 0x08,
                AEGIS = 0x09,
                FIREPIT_NOBILIA = 0x3a,
                NOBILIA_HOUSES = 0x0c,

                ARENA_ROOM = 0x1e,
                ARENA = 0x1d,

                PALACE_SNAKES = 0x4c,
                PALACE_EXTERIOR = 0x0b,
                PALACE = 0x4d,
                
                // west
                RIVER = 0x07,
                CROSSING = 0x05,
                HORACE = 0x2f,
                WATERFALL = 0x6b,
                OGLIN_CAVE = 0x4b,
                AQUAGOTH = 0x6d,

                HALLS_EXTERIOR = 0x2b,
                HALLS_CENTER = 0x29,
                HALLS_NW = 0x24,
                HALLS_SE = 0x2c,
                HALLS_SW = 0x23,
                HALLS_BRIDGE = 0x28,
                HALLS_NE = 0x2d,
                MEGATAUR = 0x2a,

                PYRAMID_EXTERIOR = 0x06,
                PYRAMID_CAVE = 0x64,
                TINY = 0x57,
                PYRAMID_1 = 0x55,
                PYRAMID_2 = 0x56,
                RIMSALA = 0x58,

                // ACT 3

                WELL = 0x6c,
                GATE = 0x76,

                FOOTKNIGHT = 0x19,
                CHESSBOARD_STAIRS = 0x1a,
                DARK_FOREST_ENTRANCE = 0x21,
                DARK_FOREST = 0x22,
                BAD_BOYS = 0x1f,
                TIMBERDRAKE = 0x20,
                CROSSING_ACT3 = 0x13,
                SWAMP_BRIDGE = 0x40,
                STERLING = 0x37,

                // ivor+ebon

                IVOR_EBON_1 = 0x7b,
                IVOR_EBON_2 = 0x7c,
                IVOR_EBON_HOUSES = 0x7d,
                IVOR_EBON_PRISON = 0x74,

                // ivor

                IVOR_MARKET = 0x4e,
                IVOR_TRAILERS_EXTERIOR = 0x62,
                IVOR_TRAILERS_INTERIOR = 0x63,

                IVOR_HALL = 0x6e,
                IVOR_THRONE = 0x78,
                MUNGOLA = 0x77,
                IVOR_BANQUET = 0x6f,
                IVOR_BRIDGE = 0x70,
                IVOR_ROOMS_1 = 0x71,
                IVOR_ROOMS_2 = 0x72,
                DOG_MAZE = 0x73,
                IVOR_STAIRS = 0x75,
                IVOR_SEWERS = 0x79,
                IVOR_SEWERS_EXTERIOR = 0x7a,

                // ebon

                EBON_COURT = 0x5d,
                EBON_COURT_SIDEROOMS = 0x5f,
                VERMINATOR = 0x5e,
                EBON_CELLAR = 0x60,
                EBON_HALL = 0x0d,
                EBON_SEWERS = 0x12,
                EBON_BANQUET = 0x0e,
                NARIS = 0x0f,
                EBON_THRONE = 0x11,
                EBON_GLASS = 0x10,
                TINKER = 0x14,
                TINKER_EXTERIOR = 0x39,

                // ACT 4

                OMNITOPIA_JUNKYARD = 0x49,
                OMNITOPIA_JAIL = 0x7e,
                OMNITOPIA_METROPLEX = 0x48,

                // omnitopia rooms

                OMNITOPIA_SHOPPING = 0x54,
                OMNITOPIA_CONTROL = 0x43,
                FACE = 0x45,
                OMNITOPIA_REACTOR = 0x42,
                OMNITOPIA_STORAGE = 0x47,
                OMNITOPIA_GREENHOUSE = 0x44,
                OMNITOPIA_ALARM = 0x00,
                OMNITOPIA_PROFESSOR = 0x46,
                CARLTRON = 0x4a,
                
                // MISC

                ACT1_2_CAVES = 0x35,
                BRIAN = 0x15,

                // special
                OPENING = 0x61,
                START = 0x00,
            }

            enum SPECIAL_SCRIPTS {
                LOOTING = 0xb1,
                REVEALER = 0xb2, // takes 0d8 * 0d60 (0d480) frames
                LEVITATE = 0xb3,
                SELECT_PRESSED = 0xb4,
                WINGS = 0xb5,
                UNKNOWN = 0xb6 // used inside and outside of the pyramids
            }

            enum SFX_EFFECT {
                RAIN = 0x0001,
                NIGHT = 0x0002,
                SHAKING = 0x003,
                SEPIA = 0x0004,
            }

            enum WINDWALKER_LOCATION {
                NONE = 0xffff, // e.g. no windwalker available

                ACT_1_VILLAGE = 0d0, // same room ID as ACT_1_VOLCANO
                ACT_1_VOLCANO = 0d1, // same room ID as ACT_1_VILLAGE

                ACT_2_CRUSTICIA = 0d2,
                ACT_2_NOBILIA = 0d3,

                ACT_3_TINKER = 0d4,

                BROKEN_TOP_RIGHT = 0x0028,
                BROKEN_BOTOTM_RIGHT = 0x000c,
            }
        };

        group dialog() {
            enum FONT {
                DEFAULT = 0x00,
                OUTRO = 0x02,
            }

            enum MESSAGE_BOX_TYPE {
                DEFAULT = 0x44,
                TRANSPARENT_CENTERED = 0x47,
            }
        };
        
        group audio() {
            enum MUSIC {
                // ambient
                JUNGLE_AMBIENT = 0x0a, // required: raptors
                JUNGLE_AMBIENT_BIRDS = 0x7a,
                BUGMUCK_AMBIENT_MELODY = 0x14,
                WING_AMBIENT_VOID = 0x6c, // used: desert
                WIND_AMBIENT_BIRDS = 0x68, // used: outside halls, dark forest to gomis tower
                WIND_AMBIENT_BIRDS_2 = 0x40, // used: firepits, nobilia (empty market, square), crossing
                WIND_AMBIENT_PLANE = 0x84, // used: firepits (plane takeoff/landing)
                WATER_AMBIENT_SEAGULLS = 0x3a, // used: around crusticia (with direct water access)
                SEWER_AMBIENT_WATER = 0x72, // used: act3 (sewers, prisons)
                SPACE_NOISE = 0x30, // used: prof, aegis fight?
                WATERFALL_AMBIENT = 0x46, // used: waterfall (act2, act3)
                SWAMP_AMBIENT = 0x0c, // used: swamp

                // theme
                MYSTERY = 0x4a, // used: podunk, act2 intro, nobilia (palace, square)
                INN_GUITAR = 0x42, // used: nobilia inn
                CAVE_AMBIENT_PIANO = 0x26, // used: defend guy, strongheart, blimp
                SPACE = 0x3e, // used: omnitopia
                EBON_KEEP = 0x62, // used: ebon keep
                HALLS_1 = 0x1e, // used: halls (until minitaur)
                HALLS_2 = 0x5e, // used: halls (before bridge)
                HALLS_3 = 0x66, // used: halls (bridge, monk)
                ACT3 = 0x60, // used: act3 outside
                PUPPET_SHOW = 0x58, // used: puppets

                // event
                BOSS = 0x24, // required: DRAGON_ROAR
                BOSS_JUNGLE = 0x32, // used: raptors
                BOSS_MINI = 0x5a, // used: graveyard, minitaur, monk (bronze spear), pyramid (bronze axe), DE, doubles, hallway, mungola
                BOSS_ARENA = 0x54, // used: vigor
                BOSS_DRUMS = 0x04, // used: thraxx

                // effect
                FANFARE = 0x36,
                FANFARE_ITEM = 0x78,
            }
            
            enum SOUND {
                NONE = 0x00,

                MENU_WHEEL_TURN = 0x02,
                MENU_WHEEL_OPEN = 0x04,
                MENU_WHEEL_CLOSE = 0x06,

                GORE_FLOWER = 0x08,
                HEAVY_IMPACT = 0x0a,

                AXE_ATTACK = 0x10, // ?
                SPIDER_ATTACK = 0x1a,
                FLOWER_VORE = 0x1c,

                SPEAR_ATTACK = 0x20, // same as sword?
                DOG_ATTACK = 0x24,

                AXE_ATTACK = 0x20, // ?
                SWORD_ATTACK = 0x2a,
                MECHANICAL_MOVEMENT = 0x2c, // same as wall hits? (used: halls boss bridge)
                HEAL_START = 0x2e,

                HEAL_END = 0x30,
                GORE_EXPLOSION = 0x32,
                TESLA = 0x34, // intro title reveal
                TELEPORTER = 0x36,
                CLICK_1 = 0x38, // ring turn, same as MENU_WHEEL_TURN?
                CLICK_2 = 0x3a, // inner menu?

                IMPACT = 0x3c, // same as HEAVY_IMPACT?
                GORE_MOSQUITO = 0x3e,

                PURCHASE = 0x40,
                CLICK_3 = 0x44, // looting an item, save state selection?
                UNKNOWN_ALCHEMY = 0x4c, // ?
                BIRD = 0x4e, // ???

                WEIRD_SOUND = 0x50, // ???
                PIPING_SOUND = 0x52,
                TEMPLE_BRIDGE_COLLAPSING = 0x54,
                MENU_WHEEL_OPEN_2 = 0x56, // same as MENU_WHEEL_OPEN?
                THRAXX_BRIDGE_COLLAPSING = 0x58,
                MAGMA_HARDENING = 0x5a, // same as switch triggered
                DOG_MAZE_HINT = 0x5c,
                SANDPIT_SWALLOW = 0x5e, // also: act3 vents

                MOSQUITO_ATTACK = 0x66,
                FLOWER_ATTACK = 0x68,

                SQUEEK = 0x6c, // used: well crank
                WATER_PLOP = 0x72, // used: well crank

                THRAXX_DAMAGE = 0x22, // music:0x04

                NITRO_START = 0x74,
                UNKNOWN_ALCHEMY_2 = 0x7e,

                HOVER_SOUNDS = 0x86,
                UNKNOWN_ALCHEMY_3 = 0x88,
                LEVITATE = 0x8a,
                UNKNOWN_ALCHEMY_4 = 0x8c,
                PROJECTILE_SHOOTING = 0x8e, // magmar puke
                UNKNOWN_ALCHEMY_5 = 0x90,
                UNKNOWN_ALCHEMY_6 = 0x92,
                UNKNOWN_ALCHEMY_7 = 0x96,
                UNKNOWN_ALCHEMY_8 = 0x98,
                ACT4_SWITCH = 0x9c,
                UNKNOWN_ALCHEMY_9 = 0x9e, // not alchemy?

                ACT4_DOOR_OPENING = 0xb2, // used: boss rush fan pushing
                FAN_ACTIVATED = 0xb2, // used: boss rush fan pushing
                CLICKING = 0xc6,

                // inaudible: 0c, 0e, 16, 18, 26, 28, 62
                
                // glitchy: 12, 14, 1e, 42, 46, 48, 4a, 60, 64, 70, 76, 78, 7c?, 80?, 84, 94, 9a
                DOOR = 0x46, // works for music: 40
                DRAGON_ROAR = 0x6a, // works for music: BOSS
                ARENA_CHEER = 0x6e, // works for music: BOSS_ARENA
                ELEVATOR_DOOR = 0x76, // works for music: halls? (used: halls open boss door?)
                VIGOR_ROLLING = 0x7a, // works for music: boss? (used: vigor rolling)

                // todo: b2
                // crash: 100
            }
        };

        group sprites() {
            enum CHARACTER {
                BOY = 0x50,
                DOG = 0x51,
                ACTIVE = 0x52,
                INACTIVE = 0x53,

                LAST_ENTITY = 0x2d,
                SCRIPT_OWNER = 0x2e,

                RANDOM = 0x2a,

                CAMERA_PAN_Y = 0x32, // ?
                CAMERA_PAN_X = 0x34, // ?

                // custom
                BOTH = 0x00,
                NONE = 0x01,
            }
            enum DOG {
                WOLF = 0x2,
                WOLF2 = 0x4,
                GREYHOUND = 0x6,
                POODLE = 0x8,
                PUPPER = 0xa,
                TOASTER = 0xc
            }

            enum ENEMY {
                // npc - act 1
                FIRE_EYES = 0x15, // #12, "Fire Eyes"
                EVIL_FIRE_EYES = 0x16, // #13, "Evil Fire Eyes"
                BLIMP = 0x17, // #11, "Harry"
                HARRY = 0x34, // #46, "Harry"
                
                VILLAGER_1_1 = 0x04, // #3, "Girl", girl, teal hair, bone in hair (lizard girl)
                VILLAGER_1_2 = 0x05, // #2, "Boy", boy, green hair (bee boy)
                VILLAGER_1_3 = 0x06, // #5, "Worman", woman, fruit in hair (consumables vendor)
                VILLAGER_1_4 = 0x07, // #4, "Man", man, green hair, no shirt (fire eye guard)
                VILLAGER_1_5 = 0x08, // #7, "Old woman", woman, teal hair, pink dress
                VILLAGER_1_6 = 0x09, // #6, "Old man", man, green hair, beard, bone as cain
                VILLAGER_1_7 = 0x12, // #10, "Alchemy", man, green hair, beard (hard ball guy) (palette conflict: tumbling_weed)
                VILLAGER_1_8 = 0x7e, // #35, "Strongheart", same as ^

                BEE = 0x02, // #8, "Child's Pet"
                CHAMELEON = 0x03, // #9, "Child's Pet"

                // npc - act 2
                HORACE = 0x45, // #22, "Horace"
                HORACE_EVIL = 0x62, // #37, "Horace's Twin"
                TINY = 0x46, // #45, "Tiny"

                VILLAGER_2_1 = 0x18, // #14, "Boy", boy, dark hair
                VILLAGER_2_2 = 0x19, // #15, "Girl", girl, red hair
                VILLAGER_2_3 = 0x1a, // #16, "Man", man, dark hair, beard, laurel crown
                VILLAGER_2_4 = 0x1b, // #17, "Woman", woman, red hair
                VILLAGER_2_5 = 0x1c, // #18, "Old man", man, white hair, beard, purple scarf
                VILLAGER_2_6 = 0x1d, // #19, "Old woman", woman, headscarf (trading vendor)
                VILLAGER_2_7 = 0x31, // #20, "Advisor", man, dark hair, beard, laurel crown, orange scarf
                VILLAGER_2_8 = 0x32, // #21, "Alchemy", same as VILLAGER_2_5 (Sting guy? Madronius brother? Drain guy?)
                VILLAGER_2_9 = 0x33, // #36, "Madronius", man, white hair, beard, green scarf

                BOXER_1 = 0x2d, // #50, "Mad Monk", left
                BOXER_2 = 0x2e, // #49, "Mad Monk", right
                DRUNK_1 = 0x2f, // #48, "Mad Monk", left
                DRUNK_2 = 0x30, // #47, "Mad Monk", right

                // npc - act 3
                QUEEN = 0x4c, // #42, "Camellia Bluegarden"
                QUEEN_EVIL = 0x4b, // #43, "White Queen", default seems to be the jumping animation
                KING = 0x54, // #32, "Legendary King"
                TINKER = 0x58, // #40, "Tinker Tinderbox"
                TINKER_TWIN = 0x81, // #39, "Gomi"

                VILLAGER_3_1 = 0x48, // #44, "Barker", man, purple dress (well guy, freakshow guy)
                VILLAGER_3_2 = 0x51, // #29, "Legendary boy", boy, dark hair (naris)
                VILLAGER_3_3 = 0x52, // #30, "Legendary girl", girl, blonde hair, teddy bear
                VILLAGER_3_4 = 0x53, // #31, "Legendary Grandma", woman, white hair, purple dress (regrowth woman)
                VILLAGER_3_5 = 0x55, // #33, "Legendary Man", man, white hair (naris old)
                VILLAGER_3_6 = 0x56, // #34, "Legendary Viking", viking

                // npc - act 4
                PROFESSOR = 0x57, // #41, "Professor Ruffleberg"
                CARLTRON = 0x5f, // #38, "Carltron"

                // enemy - act 1
                MOSQUITO = 0x0f, // #113, "Mosquito", slash(1-3=fly right?)
                FLOWER_PURPLE = 0x0b, // #109, "Wimpy Flower", slash(1-3=default attack)

                SKELESNAIL = 0x26, // #98, "Skelesnail", slash(1-3=default attack)

                MAGGOT = 0x0e, // #112, "Maggot", slash(1-3=default attack)
                BONE_SNAKE = 0x0a, // #105, "Tar Skull", slash(1-3=default attack + stuck)

                FLOWER_ORANGE = 0x0c, // #108, "Carniflower"

                SPIDER = 0x22, // #100, "Widowmaker"
                LIZARD = 0x29, // #92, "Viper"

                RAPTOR_GREEN = 0x2b, // #89, "Raptor", slash(1-3=default attack)
                
                FRIPPO = 0x21, // #99, "Frippo", slash(1-3=default attack)

                LANTERN_LIGHT = 0x37, // #86, "Will o' the Wisp", slash(1-3=idle?)

                // enemy - act 2
                MONK = 0x28, // #94, "Mad Monk", slash(1-3=default attack)
                PIRATE_ANCHOR = 0x27, // #93, "Rogue", slash(1-3=default attack)

                SPIDER_YELLOW = 0x23, // #101, "Sand Spider"
                TUMBLING_WEED = 0x73, // #59, "Tumble Weed", slash(1-3=jumping?)
                BUZZARD_1 = 0x74, // #103, "Bone Buzzard"

                DANCING_DEVIL_1 = 0x76, // #65, "Dancin' Fool", slash(1-3=default attack)
                SLIME_GREEN = 0x70, // #62, "Lime Slime", slash(1-3=default attack)
                RAT_RED = 0x7c, // #81, "Rat", slash(1-3=idle?)

                PYRAMID_GUARDIAN_1 = 0x39, // #96, "Son of Anhur"
                MUMMY = 0x72, // #60, "Mummy Cat"
                SNAKE_STATUE_LEFT = 0x59, // #55, "Stone Cobra", right facing
                SNAKE_STATUE_RIGHT = 0x5a, // #54, "Stone Cobra", left facing

                BUZZARD_BLACK = 0x63, // #52, "Skullclaw"
                DOG_1_BLACK = 0x61, // #51, "Bad Dawg", slash(1-3=default attack)
                LANTERN_LIGHT_RED = 0x64, // #53, "Will o' the Wisp"

                OGLIN = 0x6e, // #56, "Oglin", slash(1-3=default attack)

                TENTACLE_WHIP = 0x3f, // #72, "Tentacle", slash(1-3=default attack)
                TENTACLE_SPIKE = 0x4a, // #73, "Tiny Tentacle", slash(1-3=default attack)
                SPARK = 0x40, // #75, "", slash(1-3=idle?)

                // enemy - act 3
                HEDGEHOG = 0x50, // #57, "Hedgadillo", slash(1-3=default attack)

                RAT = 0x42, // #80, "Rat", storage room
                
                RAPTOR_BLACK = 0x6b, // #90, "Raptor"
                SPIDER_GREEN = 0x24, // #102, "Wood Mite"
                GUARD_BOT = 0x4e, // #69, "Guardbot", slash(1-3=shoot)

                BUZZARD_2 = 0x82, // #104, "Skullclaw", slash(1-3=default attack?)

                DRAKE = 0x6d, // #125, "Gargon"

                DRAKE_GREEN = 0x89, // #126, "Dragoil"
                SLIME = 0x71, // #63, "Blue Goo"
                MAGGOT_RED = 0x77, // #111, "Gore Grub"
                
                DANCING_DEVIL_2 = 0x75, // #64, "Dancin' Fool", hall fight

                // enemy - act 4
                TENTACLE_WHIP_2 = 0x8c, // #133, "Tentacle"
                TENTACLE_SPIKE_2 = 0x8d, // #134, "Tiny Tentacle"

                OWL_GREEN = 0x78, // #66, "Neo Greeble", slash(1-2=stone, 3=transform)
                SLIME_PINK = 0x6f, // #61, "Red Jelly Ball"
                
                RIMSALA = 0x7b, // #84, "Rimsala", slash(1-3=idle)
                GATE_BOT = 0x66, // #128, "Sphere Bot", slash(1-3=chain fire)

                FLOWER_BLACK = 0x6a, // #107, "Flowering Death"
                MOSQUITO_BLACK = 0x7a, // #114, "Mosquito"
                FAN_BOT = 0x69, // #127, "Floating Fan", slash(1-3=idle?)

                RAPTOR_TEAL = 0x79, // #136, "Raptor" (boss rush)
                RIMSALA_2 = 0x83, // #138, "Eye of Rimsala"
                DUSTER_BOT = 0x4d, // #70, "Mechaduster", slash(1-3=idle + hitbox?)
                DUSTER_BOT_2 = 0x8b, // #132, "Mechaduster"
                SPIDER_BLACK = 0x25, // #137, "Death Spider"

                // boss - act 0
                GUARD_BOT_INTRO = 0x80, // #68, "Guardbot"

                // boss - act 1
                RAPTOR_PURPLE = 0x0d, // #110, "Raptor"

                THRAXX_HEART = 0x14, // #118, "Thraxx's heart", slash(1-3=crash?)
                THRAXX_LEFT_ARM = 0x10, // #123, "Left Claw", slash(1-3=default attack)
                THRAXX_RIGHT_ARM = 0x11, // #122, "Right Claw"

                LIZARD_BLACK = 0x2a, // #91, "Viper Commander", slash(1-3=tongue)

                SALABOG = 0x2c, // #106, "Salabog", slash(1-2=bite, 3=fire)

                MAGMAR = 0x35, // #87, "Magmar", slash(1=duck, 2=shoot, 3=shoot air)

                // boss - act 2
                VIGOR = 0x3d, // #82, "Vigor", slash(1=bident, 2=boomerang)

                MINITAUR = 0x38, // #97, "Mini-Taur", slash(1-3=stomp)

                MEGATAUR = 0x36, // #88, "Megataur", slash(1=stomp, 2-3=breathing)

                PYRAMID_GUARDIAN_2 = 0x3a, // #95, "Son of Set"

                RIMSALA_HOLDER = 0x3c, // #85, "Rimsla", slash(1-3=idle)
                RIMSALA_GOLD = 0x3b, // #83, "Rimsla", slash(1-3=idle)
                RIMSALA_STATUTE_ENTITY = 0x5b, // #27, "Statue"

                AEGIS_ENTITY = 0x47, // #71, "Aegis"

                AQUAGOTH_ENTITY = 0x3e, // #74, "Aquagoth"

                // boss - act 3
                FOOTKNIGHT = 0x49, // #78, "FootKnight", slash(1-3=idle?)

                // BOY_BLACK
                OWL_BLACK = 0x4f, // #67, "Greeble"

                FORESTDRAKE = 0x43, // #76, "Timberdrake", slash(1=biting, 2=spear idle, 3=wing flap)

                VERMINATOR = 0x41, // #79, "Verminator", slash(1-3=crash?)

                STERLING = 0x44, // #77, "Sterling", slash(1=spear idle, 2=biting, 3=wing flap)

                MUNGOLA_ENTITY = 0x6c, // #115, "Mungola"
                PUPPET_1 = 0x67, // #116, "Old Nick", slash(1=dance, 2=jump, 3=kick)
                PUPPET_2 = 0x68, // #117, "Mephista", slash(1=dance, 2=jump, 3=kick)

                THRAXX2_HEART = 0x84, // #119, "Coleoptera's heart"
                THRAXX2_LEFT_ARM = 0x85, // #121, "Left Claw"
                THRAXX2_RIGHT_ARM = 0x86, // #120, "Right Claw"

                // boss - act 4
                FACE_ENTITY = 0x7d, // #124, "Face"

                FAN_ENTITY = 0x5c, // #129, "Fan"
                SPEAKER_ENTITY = 0x5d, // #130, "Speaker"
                BOY_BLACK = 0x60, // #58, "Bad Boy", slash(1=sword level 1, 2=sword level 2, 3=sword level 3)
                DOG_4_BLACK = 0x8e, // #139, "Dark Toaster", slash(1-2=default attack, 3=charged attack)
                MAGMAR_METAL = 0x7f, // #140, "Magmar"
                CARLTRON_ROBOT = 0x87, // #141, "Carltron's Robot", slash(1-3=idle?)

                // special
                PLACEHOLDER = 0x20, // #25, used for explosions, windwalker, etc.

                REVEALER_TARGET_ENTITY = 0x5e, // #28, "Bridge"
                STONE = 0x1e, // #23, "Rock"
                STONE_ROUND = 0x1f, // #24, "Rock"

                BOMB = 0x65, // #135, "Bomb"

                // misc
                BOY = 0x00, // #0, "<Boy Name>", behaves weird
                DOG = 0x01, // #1, "<Dog Name>", behaves weird

                UNKNOWN_1 = 0x13, // #??, unused? invisible
                UNKNOWN_2 = 0x88, // #??, invisible, used for: palace grounds 3x, related to the dog fountain cutscene
                UNKNOWN_3 = 0x8f, // #??, unused?

                RAT_RED_HARMLESS = 0x8a, // #131, "Rat"

                // unknown IDs = #26/""
            }
            enum FLAG_ENEMY {
                NORMAL = 0x0000,
                INACTIVE_INVISIBLE = 0x0001,
                INVINCIBLE = 0x0002, // set for most NPCs
                INACTIVE = 0x0020, // same as control(…)
                MOSQUITO = 0x0040,
                PHASING = 0x0400,
                INVISBLE_INVINCIBLE_INACTIVE = 0x1000,

                INACTIVE_IMORTAL = 0x0022,

                // special
                STONE_LEVITATE = 0x0002,
                STONE_LEVITATE_INVISIBLE = 0x0005,
                BOMBABLE = 0x0004,
            }
            enum SCRIPT_TRIGGER {
                B = 0x0040, // talk/loot
                DAMAGE = 0x0100, // <SCRIPT_OWNER>[HP] shows previous hp, script[0x9]=0x100, dead(<SCRIPT_OWNER>) shows 1->0
                DEATH = 0x0200, // <SCRIPT_OWNER>[HP] shows 0, script[0x9]=0x200, dead(<SCRIPT_OWNER>) shows 0
                
                // groups
                DAMAGE_DEATH = 0x0300, // <SCRIPT_OWNER>[HP] shows previous hp -> 0, script[0x9]=0x100->0x200, dead(<SCRIPT_OWNER>) shows 1->0 (used: Vigor, Rimsala statues, Sterling, green house black flowers)
                ALL = 0x0340,

                // unknown
                UNKNOWN_1 = 0x0000, // TODO (used: default loot script, boss rush dust loot)
                UNKNOWN_2 = 0x0001, // TODO (used: special scripts?)
            }

            enum DIRECTION {
                NORTH = 0x26,
                EAST = 0x1d,
                SOUTH = 0x21,
                WEST = 0x19,
                
                NONE = 0x00,
                UNKNOWN = 0x01
            }
            enum FACE_DIRECTION {
                NORTH = 0x00,
                NORTH_EAST = 0x02,
                EAST = 0x04,
                SOUTH_EAST = 0x06,
                SOUTH = 0x08,
                SOUTH_WEST = 0x0a,
                WEST = 0x0c,
                NORTH_WEST = 0x0e,

                NONE = 0xff,
            }
            enum TRANSITION_DIRECTION {
                NORTH = 0x04,
                EAST = 0x01,
                SOUTH = 0x03,
                WEST = 0x02,

                // todo: 00, 05, 0f, 10, 11, 12
            }

            enum WALK_TYPE {
                TILE_ABSOLUTE = 0x6c, // [Word]
                TILE_ABSOLUTE_DIRECT = 0x6e, // [Word]
                TILE_RELATIVE = 0x6d,
                TILE_RELATIVE_DIRECT = 0x6f,

                COORDINATE_ABSOLUTE = 0x9d,
                COORDINATE_ABSOLUTE_DIRECT = 0x73,
            }

            enum PALETTE {
                BOY_DEFAULT = 0x0cca,
                BOY_BAZOOKA = 0x0ccb,
                BOY_NON_BAZOOKA_WEAPON = 0x0c00,

                DOG_DEFAULT = 0x0e00,
                DOG_TOASTER = 0x0e00,

                // enemies
                MOSQUITO = 0x0400, // also: thraxx, sterling, carltron
                BAD_TOASTER = 0x4cb,
                MAGMAR = 0x4cd,
                FOOTKNIGHT = 0x4ce,

                // experimental
                BLACK = 0x0000,
                BLACK_2 = 0x0050,
            }

            enum STAMINA {
                PERCENTAGE_100 = 0x0400,
                PERCENTAGE_75 = 0x0300,
                PERCENTAGE_50 = 0x0200,
                PERCENTAGE_25 = 0x0100,
                PERCENTAGE_0 = 0x0000,
            }

            enum ATTRIBUTE_FLAGS {
                // ATTRIBUTE.FLAGS_1 (character+0x10)
                INVINCIBLE = 0x02, // see ATTRIBUTE_BITS.INVINCIBLE
                UNKNOWN = 0x04, // always set?
                DISABLED = 0x20, // examples: "control(NONE)", "walk(…)"
                IN_ANIMATION = 0x40, // examples: ANIMATION_ALL.SLASH_1, "animate(…)"
                UNKNOWN_2_1 = 0x80, // see ATTRIBUTE_BITS.UNKNOWN_2_1

                // ATTRIBUTE.FLAGS_2 (character+0x11)
                UNKNOWN = 0x01, // always set?
                LOADING_SCREEN = 0x08, // also ai following quickly?
                HEALED = 0x10, // examples: PETAL (Blue glow)
                NO_CLIP = 0x04, // see ATTRIBUTE_BITS.NO_CLIP
                INVINCIBLE_TEMP = 0x40, // see ATTRIBUTE_BITS.INVINCIBLE_TEMP

                // ATTRIBUTE.FLAGS_3 (character+0x12)
                AI_FOLLOWING = 0x04, // ai following?
                UNKNOWN_CAST = 0x38, // during cast on boy? (CRUSH, EXPLOSION, FLASH, FIREBALL)

                // ATTRIBUTE.FLAGS_4 (character+0x13
                UNKNOWN_CAST = 0x04, // during cast on boy? (CRUSH, EXPLOSION)
                ROOT = 0x10, // see ATTRIBUTE_BITS.ROOT
                SHIELD = 0x20, // shield halves damage
                UNKNOWN_1_2 = 0x40, // see ATTRIBUTE_BITS.UNKNOWN_1_2
                INVISIBLE = 0xc0, // see ATTRIBUTE_BITS.INVISIBLE
                
                // ATTRIBUTE.FLAGS_5 (character+0x14)
                AURA = 0x01, // aura invincibility
                FORCE_FIELD = 0x02, // force field prevents the next damage
                BARRIER = 0x04, // barrier invincibility
                ATLAS_GLITCH = 0x08, // atlas glitch invincibility
                REFLECT = 0x10, // reflect reflects all magic (spell target = source)
                MUTE = 0x20, // see ATTRIBUTE_BITS.MUTE

                // ATTRIBUTE.FLAGS_6 (character+0x15)
                WINGS = 0x01,
                DEAD = 0x04, // also set during KNOCKBACK, or being eaten by a flower
                AI_RUN = 0x08, // see ATTRIBUTE_BITS.AI_RUN
                CONFOUND = 0x40, // confound/disrupt reverse controls

                // ATTRIBUTE.FLAGS_7 (character+0x16)
                KNOCKBACK = 0x01, // also sets WALKING and DEAD?
                WALKING = 0x04,
                RUNNING = 0x08,
                IN_ANIMATION = 0x10,
                CASTING = 0x20, // also dodging?
            }
            enum OUTLINE {
                ATLAS = 0x0001, // red sinus
                AURA = 0x0002,
                BARRIER = 0x0004, // dark blue into teal
                SPEED = 0x0008,
                DEFEND = 0x0010, // purple sinus, fast
                ENERGIZE = 0x0020, // green and blue, very fast
                FORCE_FIELD = 0x0040,
                REFLECT = 0x0080,

                SHIELD = 0x0100,
                PIXIE_DUST = 0x0200,
                REGROWTH = 0x0400,
            }
            enum CHARACTER_TPYE {
                // npc - act 1
                FIRE_EYES = 0xB9F0,
                EVIL_FIRE_EYES = 0xBA3A,
                BLIMP = 0xB9A6,
                HARRY = 0xC3C4,
                
                VILLAGER_1_1 = 0xB756,
                VILLAGER_1_2 = 0xB70C,
                VILLAGER_1_3 = 0xB7EA,
                VILLAGER_1_4 = 0xB7A0,
                VILLAGER_1_5 = 0xB87E,
                VILLAGER_1_6 = 0xB834,
                VILLAGER_1_7 = 0xB95C,
                VILLAGER_1_8 = 0xC096,

                BEE = 0x0a70,
                CHAMELEON = 0xb8c8,

                // npc - act 2
                HORACE = 0xBCD4,
                HORACE_EVIL = 0xC12A,
                TINY = 0xC37A,

                VILLAGER_2_1 = 0xBA84,
                VILLAGER_2_2 = 0xBACE,
                VILLAGER_2_3 = 0xBB18,
                VILLAGER_2_4 = 0xBB62,
                VILLAGER_2_5 = 0xBBAC,
                VILLAGER_2_6 = 0xBBF6,
                VILLAGER_2_7 = 0xBC40,
                VILLAGER_2_8 = 0xBC8A,
                VILLAGER_2_9 = 0xC0E0,

                BOXER_1 = 0xC4EC,
                BOXER_2 = 0xC4A2,
                DRUNK_1 = 0xC458,
                DRUNK_2 = 0xC40E,

                // npc - act 3
                QUEEN = 0xC29C,
                QUEEN_EVIL = 0xC2E6,
                KING = 0xBFB8,
                TINKER = 0xC208,
                TINKER_TWIN = 0xC1BE,

                VILLAGER_3_1 = 0xC330,
                VILLAGER_3_2 = 0xBEDA,
                VILLAGER_3_3 = 0xBF24,
                VILLAGER_3_4 = 0xBF6E,
                VILLAGER_3_5 = 0xC002,
                VILLAGER_3_6 = 0xC04C,

                // npc - act 4
                PROFESSOR = 0xC252,
                CARLTRON = 0xC174,

                // enemy - act 1
                MOSQUITO = 0xD722,
                FLOWER_PURPLE = 0xD5FA,

                SKELESNAIL = 0xD2CC,

                MAGGOT = 0xD6D8,
                BONE_SNAKE = 0xD4D2,

                FLOWER_ORANGE = 0xD5B0,

                SPIDER = 0xD360,
                LIZARD = 0xD110,

                RAPTOR_GREEN = 0xD032,
                
                FRIPPO = 0xD316,

                LANTERN_LIGHT = 0xCF54,

                // enemy - act 2
                MONK = 0xD1A4,
                PIRATE_ANCHOR = 0xD15A,

                SPIDER_YELLOW = 0xD3AA,
                TUMBLING_WEED = 0xD43E,
                BUZZARD_1 = 0xD43E,

                DANCING_DEVIL_1 = 0xC942,
                SLIME_GREEN = 0xC864,
                RAT_RED = 0xCDE2,

                PYRAMID_GUARDIAN_1 = 0xD1EE,
                MUMMY = 0xC786,
                SNAKE_STATUE_LEFT = 0xC65E,
                SNAKE_STATUE_RIGHT = 0xC614,

                BUZZARD_BLACK = 0xC580,
                DOG_1_BLACK = 0xC536,
                LANTERN_LIGHT_RED = 0xC5CA,

                OGLIN = 0xC6A8,

                TENTACLE_WHIP = 0xCB48,
                TENTACLE_SPIKE = 0xCB92,
                SPARK = 0xCC26,

                // enemy - act 3
                HEDGEHOG = 0xC6F2,

                RAT = 0xCD98,
                
                RAPTOR_BLACK = 0xD07C,
                SPIDER_GREEN = 0xD3F4,
                GUARD_BOT = 0xCA6A,

                BUZZARD_2 = 0xD488,

                DRAKE = 0xDA9A,

                DRAKE_GREEN = 0xDAE4,
                SLIME = 0xC8AE,
                MAGGOT_RED = 0xD68E,
                
                DANCING_DEVIL_2 = 0xC8F8,

                // enemy - act 4
                TENTACLE_WHIP_2 = 0xDCEA,
                TENTACLE_SPIKE_2 = 0xDD34,

                OWL_GREEN = 0xC98C,
                SLIME_PINK = 0xC81A,
                
                RIMSALA = 0xCF0A,
                GATE_BOT = 0xDB78,

                FLOWER_BLACK = 0xD566,
                MOSQUITO_BLACK = 0xD76C,
                FAN_BOT = 0xDB2E,

                RAPTOR_TEAL = 0xDDC8,
                RIMSALA_2 = 0xDE5C,
                DUSTER_BOT = 0xCAB4,
                DUSTER_BOT_2 = 0xDCA0,
                SPIDER_BLACK = 0xDE12,

                // boss - act 0
                GUARD_BOT_INTRO = 0xCA20,

                // boss - act 1
                RAPTOR_PURPLE = 0xD644,

                THRAXX_HEART = 0xD894,
                THRAXX_LEFT_ARM = 0xD9BC,
                THRAXX_RIGHT_ARM = 0xDA06,

                LIZARD_BLACK = 0xD0C6,

                SALABOG = 0xD51C,

                MAGMAR = 0xCF9E,

                // boss - act 2
                VIGOR = 0xCE2C,

                MINITAUR = 0xD282,

                MEGATAUR = 0xCFE8,

                PYRAMID_GUARDIAN_2 = 0xD238,

                RIMSALA_HOLDER = 0xCE76,
                RIMSALA_GOLD = 0xCEC0,
                RIMSALA_STATUTE_ENTITY = 0xBE46,

                AEGIS_ENTITY = 0xCAFE,

                AQUAGOTH_ENTITY = 0xCBDC,

                // boss - act 3
                FOOTKNIGHT = 0xCD04,

                // BOY_BLACK
                OWL_BLACK = 0xC9D6,

                FORESTDRAKE = 0xCC70,

                VERMINATOR = 0xCD4E,

                STERLING = 0xCCBA,

                MUNGOLA_ENTITY = 0xD7B6,
                PUPPET_1 = 0xD800,
                PUPPET_2 = 0xD84A,

                THRAXX2_HEART = 0xD8DE,
                THRAXX2_LEFT_ARM = 0xD928,
                THRAXX2_RIGHT_ARM = 0xD972,

                // boss - act 4
                FACE_ENTITY = 0xDA50,

                FAN_ENTITY = 0xDBC2,
                SPEAKER_ENTITY = 0xDC0C,
                BOY_BLACK = 0xC73C,
                DOG_4_BLACK = 0xDEA6,
                MAGMAR_METAL = 0xDEF0,
                CARLTRON_ROBOT = 0xDF3A,

                // special
                PLACEHOLDER = 0xBDB2,

                REVEALER_TARGET_ENTITY = 0xBE90,
                STONE = 0xBD1E,
                STONE_ROUND = 0xBD68,

                BOMB = 0xDD7E,

                // misc
                BOY = 0x0a26, // extended struct
                DOG = 0x0a70, // extended struct

                UNKNOWN_1 = 0x0000, // invalid
                UNKNOWN_2 = 0xBDFC,
                UNKNOWN_3 = 0x2210,

                RAT_RED_HARMLESS = 0xDC56,
            }
            enum STATUS_ID {
                ATLAS = 0x00,
                AURA = 0x08,
                BARRIER = 0x10,
                DEFEND = 0x18,
                ENERGIZE = 0x20,
                FORCE_FIELD = 0x28,
                REFLECT = 0x30,
                SHIELD = 0x38,
                REGROWTH = 0x40,
                SPEED = 0x48,
                PIXIE_DUST = 0x50, // also REGENERATE
                CONFOUND = 0x60,
                DISRUPT = 0x68,
                SLOW_BURN = 0x70,
                CORROSION = 0x78,
                HYPNOTIZE = 0x80,
                PLAGUE = 0x88,
                POISON = 0x90,
                WINGS = 0x98,

                // special
                NONE = 0xff,
                MOST_RECENT = 0xff00
            }
            enum ATTRIBUTE {
                // See data crystals: 7E3DE5 to 7E4E88 = Monster/NPC data for the current room. Each Monster/NPC gets x8E bytes of data.

                POINTER_BEHAVIOR_CURRENT = 0x00, // ?

                POINTER_BEHAVIOR_BASE = 0x03, // ?

                POINTER_BODY_SPRITE_INFO = 0x06, // ? (3 bytes)
                POINTER_SHADOW_SPRITE_INFO = 0x09, // ? (3 bytes)

                PALETTE = 0x0b, // e.g. boy=0x000c, magmar=0x0004

                // used in the scripts
                MAX_HP = 0x0f, // <0x23e5>[0x0f] = boy max hp, <0x23e7>[0x0f] = dog max hp

                // see ATTRIBUTE_FLAGS (1 byte each)
                FLAGS_1 = 0x10,
                FLAGS_2 = 0x11,
                FLAGS_3 = 0x12,
                FLAGS_4 = 0x13,
                FLAGS_5 = 0x14,
                FLAGS_6 = 0x15,
                FLAGS_7 = 0x16,
                // positioning
                Z_LEVEL = 0x18, // used for stairs/bridges (0x10 = upper floor, 0x20 = lower floor, 0x60 = stairs?)
                X = 0x1a,
                Y = 0x1c,
                Z = 0x1e, // used for boss rush intro
                VELOCITY = 0x20, // used for wings (0xe0 signed), magmar, megataur, act2 intro, puppets, sterling flight
                FACE_DIRECTION = 0x22, // enum FACE_DIRECTION
                TARGET_LAST_WEAPON_DAMAGE = 0x24, // contains _entity_x
                HP = 0x2a,

                STAMINA = 0x2e, // enum STAMINA (seems to instantly regenerate during some animations?)
                GENERAL_PURPOSE = 0x30, // DOES NOT RESET WHEN THE SPRITE CHANGES! used for secret boss bombs (set to 0 for exploded bombs) and speakers (indexed from 2^0 to 2^8)
                UNKNOWN = 0x32, // TODO: used for secret boss and boss rush fans
                DAMAGE_TYPE = 0x36, // used for vigor (weapon: 0x4e89, dog: 0x4F37, magic and default: 0x0000)
                CURRENT_GROUND = 0x3c, // good: 10 (80?, 28?, 23?, 24?, 48) bad: 31 (22?, 26?, 63?) TODO: used in ebon keep sewers (seems to be based on the tile the character stands on)

                // status effect #1
                STATUS_ID_1 = 0x46,
                STATUS_TIMER_1 = 0x48,
                STATUS_BONUS_1 = 0x4a,
                // status effect #2
                STATUS_ID_2 = 0x4c,
                STATUS_TIMER_2 = 0x4e,
                STATUS_BONUS_2 = 0x50,
                // status effect #3
                STATUS_ID_3 = 0x52,
                STATUS_TIMER_3 = 0x54,
                STATUS_BONUS_3 = 0x56,
                // status effect #4
                STATUS_ID_4 = 0x58,
                STATUS_TIMER_4 = 0x5a,
                STATUS_BONUS_4 = 0x5c,

                NEXT_ENTITY = 0x5e, // ?
                TYPE = 0x60, // see CHARACTER_TPYE

                X_TILE = 0x62, // [byte, read_only]
                Y_TILE = 0x63, // [byte, read_only]

                ATTACHED_SCRIPT_ID = 0x66, // see "attach_script(…)"
                ATTACHED_SCRIPT_TRIGGER = 0x68, // see SCRIPT_TRIGGER
                
                POINTER_STATUS_ICON_SPRITE = 0x6e, // ?

                LAST_DAMAGE = 0x76, // only available for one frame?

                SCALING_LEVEL = 0x8a, // hack: level offset for all stats, but hp
                UNKNOWN = 0x8c, // ffff makes the enemy despawn, when he is off screen

                ///////////////////////////////////////////////////////////////////////////////////////////
                // BOY/DOG SPECIFIC
                ///////////////////////////////////////////////////////////////////////////////////////////

                POINTER_STATUS_BAR_INFO = 0x8e, // ?
                
                TOTAL_XP_REQUIRED = 0x94,

                // outline
                OUTLINE_ID = 0x9a, // see OUTLINE, has to be set to be changed while OUTLINE_PROGRESS==0
                OUTLINE_CHOICE = 0x9c, // ?
                OUTLINE_PROGRESS = 0x9e, // 0…30…0 (MSB decides about the direction)
                // status effect boosts
                BOOST_ATTACK = 0xa0,
                BOOST_DEFEND = 0xa2,
                BOOST_HIT = 0xa4,
                BOOST_EVADE = 0xa6,
                // BOOST_MAGIC_DEFEND = 0x??,

                PIXIE_DUST = 0xac, // 0x0000->0x0001 while pixie dust is active

                ///////////////////////////////////////////////////////////////////////////////////////////
                // weird
                ///////////////////////////////////////////////////////////////////////////////////////////
                
                PALETTE_BLACK_GREEN = 0x00,
                INVISIBLE = 0x05,
                TILE_GLITCH_1 = 0x06,
                INVISIBLE_OR_TILE_GLITCH = 0x07,
                TILE_GLITCH_3 = 0x0a,
                PALETTE_BLACK_OR_TILE_GLITCH = 0x0c,
                TILE_GLITCH_4 = 0x0d,
                WEIRD_KNOCKBACK = 0x12,
                TURN_NORTH = 0x22,

                ///////////////////////////////////////////////////////////////////////////////////////////
                // special
                ///////////////////////////////////////////////////////////////////////////////////////////
                
                _BOY = 0x4E89,
                _DOG = 0x4F37,

                _entity_0_1 = 0x3de5,
                _entity_0_2 = 0x3e73,
                _entity_0_3 = 0x3f01,
                _entity_0_4 = 0x3f8f,
                _entity_0_5 = 0x401d,
                _entity_0_6 = 0x40ab,

                _entity_1 = 0x4139,
                _entity_2 = 0x41fd,
                _entity_3 = 0x4255,
                _entity_4 = 0x42E3,
                _entity_5 = 0x4371,
                _entity_6 = 0x43FF,
                _entity_7 = 0x448D,
                _entity_8 = 0x451B,
                _entity_9 = 0x45A9,
                _entity_10 = 0x4637,
                _entity_11 = 0x46C5,
                _entity_12 = 0x4753,
                _entity_13 = 0x47E1,
                _entity_14 = 0x486F,
                _entity_15 = 0x48FD,
                _entity_16 = 0x498B,
                _entity_17 = 0x4A19,
                _entity_18 = 0x4AA7,
                _entity_19 = 0x4B35,
                _entity_20 = 0x4BC3,
                _entity_21 = 0x4C51,
                _entity_22 = 0x4CDF,
                _entity_24 = 0x4DFB,
            }
            enum ATTRIBUTE_BITS {
                // used by the game

                VINCIBLE_TEMP = 0x10,
                INVINCIBLE_TEMP = 0x12, // used for: outro, boss kills (doubles, drake, verminator)

                INVINCIBLE = 0x14,
                VINCIBLE = 0x16,

                UNROOT = 0x18,
                ROOT = 0x1a,

                UNKNOWN_1_1 = 0x1c,
                UNKNOWN_1_2 = 0x1e, // used for: dog enter/exit the upper level of act4

                NO_CLIP = 0x20,
                CLIP = 0x22,

                UNKNOWN_2_1 = 0x24, // used for: thraxx knockback
                UNKNOWN_2_2 = 0x26,

                INVISIBLE = 0x28,
                VISIBLE = 0x2a,

                UNMUTE = 0x2c,
                MUTE = 0x2e, // used for: boy during bazooka cutscene
                
                AI_RUN = 0x34,
                AI_WALK = 0x36,

                // unknown/weird

                TURN_NORTH = 0x00,
                TURN_EAST_1 = 0x02,
                TURN_EAST_2 = 0x04,
                TURN_EAST_3 = 0x06,
                TURN_SOUTH = 0x08,
                TURN_WEST_1 = 0x0a,
                TURN_WEST_2 = 0x0c,
                TURN_WEST_3 = 0x0e

                // CRASH: 38, 3a, …
            }

            enum DAMAGE_TYPE {
                BOY_ATTACK = 0x4e89,
                DOG_ATTACK = 0x4F37,
                MAGIC = 0x00,
                DEFAULT = 0x00,
            }

            enum THROWABLE {
                BEACH_BALL = 0x00,
                SPOON = 0x02,
                SPEAR = 0x04,
                MISSILE_2 = 0x06,
                LIGHTNING_BALL = 0x08, // salabog
                BIDENT = 0x0a, // vigor
                BOOMERANG = 0x0c, // vigor

                ONION = 0x0e,
                ONION = 0x10,
                BOTTLE = 0x12,
                BOTTLE_BROKEN = 0x14,
                CITRON = 0x16,
                ROCK = 0x18,

                LIGHTNING = 0x1a, // no damage
                BOMB_EXPLOSION = 0x1c, // piercing
                MISSILE = 0x1e, // carltron
                // CRASH: 20, 22, …
            }
        };

        group items() {
            enum ITEM {
                // special/groups
                NO_ITEM = 0x0000,
                NOTHING = 0x0001,

                ALL = 0x0010,
                INGREDIENTS = 0x0011,
                MONEY = 0x0012,
                TRADING_GOODS = 0x0013,
                WEAPON_LEVEL_2 = 0x0014,
                WEAPON_LEVEL_3 = 0x0015,
                DOG_LEVEL_2 = 0x0015,
                DOG_LEVEL_3 = 0x0016,
                BASICS = 0x0017,
                CONSUMABLES = 0x0018,
                ALCHEMY = 0x0019,
                WEAPONS = 0x001a,
                ARMOR = 0x001b,
                CHARMS = 0x001c,

                // charms
                ARMOR_POLISH = 0x0100,
                CHOCOBO_EGG = 0x0101,
                INSECT_INCENSE = 0x0102,
                JADE_DISK = 0x0103,
                JAGUAR_RING = 0x0104,
                MAGIC_GOURD = 0x0105,
                MOXA_STICK = 0x0106,
                ORACLE_BONE = 0x0107,
                RUBY_HEART = 0x0108,
                SILVER_SHEATH = 0x0109,
                STAFF_OF_LIFE = 0x010a,
                SUN_STONE = 0x010b,
                THUGS_CLOAK = 0x010c,
                WIZARDS_COIN = 0x010d,

                DIAMOND_EYE = 0x0110,
                DIAMOND_EYES = 0x0111,
                GAUGE = 0x0112,
                WHEEL = 0x0113,
                QUEENS_KEY = 0x0114,
                ENERGY_CORE = 0x0115,

                // weapon
                SWORD_1 = 0x0201,
                SWORD_2 = 0x0202,
                SWORD_3 = 0x0203,
                SWORD_4 = 0x0204,
                AXE_1 = 0x0211,
                AXE_2 = 0x0212,
                AXE_3 = 0x0213,
                AXE_4 = 0x0214,
                SPEAR_1 = 0x0221,
                SPEAR_2 = 0x0222,
                SPEAR_3 = 0x0223,
                SPEAR_4 = 0x0224,
                
                // alchemy
                ACID_RAIN = 0x0300,
                ATLAS = 0x0301,
                BARRIER = 0x0302,
                CALL_UP = 0x0303,
                CORROSION = 0x0304,
                CRUSH = 0x0305,
                CURE = 0x0306,
                DEFEND = 0x0307,

                DOUBLE_DRAIN = 0x0310,
                DRAIN = 0x0311,
                ENERGIZE = 0x0312,
                ESCAPE = 0x0313,
                EXPLOSION = 0x0314,
                FIREBALL = 0x0315,
                FIRE_POWER = 0x0316,
                FLASH = 0x0317,

                FORCE_FIELD = 0x0320,
                HARD_BALL = 0x0321,
                HEAL = 0x0322,
                LANCE = 0x0323,
                LASER = 0x0324,
                LEVITATE = 0x0325,
                LIGHTNING_STORM = 0x0326,
                MIRACLE_CURE = 0x0327,

                NITRO = 0x0330,
                ONE_UP = 0x0331,
                REFLECT = 0x0332,
                REGROWTH = 0x0333,
                REVEALER = 0x0334,
                REVIVE = 0x0335,
                SLOW_BURN = 0x0336,
                SPEED = 0x0337,

                STING = 0x0340,
                STOP = 0x0341,
                SUPER_HEAL = 0x0342,

                // consumables (same as 0x80X)
                PETAL = 0x0400,
                NECTAR = 0x0401,
                HONEY = 0x0402,
                BISCUIT = 0x0403,
                WINGS = 0x0404,
                HERBAL_ESSENCE = 0x0405,
                PIXIE_DUST = 0x0406,
                CALL_BEADS = 0x0407,

                // ingredients
                WAX = 0x0500,
                WATER = 0x501,
                VINEGAR = 0x502,
                ROOT = 0x503,
                OIL = 0x504,
                MUSHROOM = 0x505,
                MUD_PEPPER = 0x506,
                METEORITE = 0x507,
                LIMESTONE = 0x508,
                IRON = 0x509,
                GUNPOWDER = 0x50a,
                GREASE = 0x50b,
                FEATHER = 0x50c,
                ETHANOL = 0x50d,
                DRY_ICE = 0x50e,
                CRYSTAL = 0x50f,
                CLAY = 0x510,
                BRIMSTONE = 0x511,
                BONE = 0x512,
                ATLAS_AMULET = 0x513,
                ASH = 0x514,
                ACORN = 0x515,

                // tradable
                ANNIHILATION_AMULET = 0x601,
                BEAD = 0x602,
                CERAMIC_POT = 0x603,
                CHICKEN = 0x604,
                GOLDEN_JACKAL = 0x65,
                JEWELED_SCARAB = 0x606,
                LIMESTONE_TABLET = 0x607,
                PERFUME = 0x608,
                RICE = 0x609,
                SPICE = 0x60a,
                SPOON = 0x60b,
                TAPESTRY = 0x60c,
                TICKET_FOR_EXHIBITION = 0x60d,
            }

            enum INGREDIENT {
                WAX = 0x00,
                WATER = 0x01,
                VINEGAR = 0x02,
                ROOT = 0x03,
                OIL = 0x04,
                MUSHROOM = 0x05,
                MUD_PEPPER = 0x06,
                METEORITE = 0x07,
                LIMESTONE = 0x08,
                IRON = 0x09,
                GUNPOWDER = 0x0a,
                GREASE = 0x0b,
                FEATHER = 0x0c,
                ETHANOL = 0x0d,
                DRY_ICE = 0x0e,
                CRYSTAL = 0x0f,
                CLAY = 0x10,
                BRIMSTONE = 0x11,
                BONE = 0x12,
                ATLAS_AMULET = 0x13,
                ASH = 0x14,
                ACORN = 0x15,
            }

            enum SHOP_ITEM {
                // consumables
                PETAL = 0x00,
                NECTAR = 0x01,
                HONEY = 0x02,
                DOG_BISCUIT = 0x03,
                WINGS = 0x04,
                HERBAL_ESSENCE = 0x05,
                PIXIE_DUST = 0x06,
                CALL_BEADS = 0x07,

                // armor
                ARMOR_1_1 = 0x08,
                ARMOR_1_2 = 0x09,
                ARMOR_1_3 = 0x0a,
                ARMOR_2_1 = 0x0b,
                ARMOR_2_2 = 0x0c,
                ARMOR_2_3 = 0x0d,
                ARMOR_3_1 = 0x0e,
                ARMOR_3_2 = 0x0f,
                ARMOR_3_3 = 0x10,
                ARMOR_4_1 = 0x11,
                ARMOR_4_2 = 0x12,
                ARMOR_4_3 = 0x13,

                HELM_1_1 = 0x14,
                HELM_1_2 = 0x15,
                HELM_1_3 = 0x16,
                HELM_2_1 = 0x17,
                HELM_2_2 = 0x18,
                HELM_2_3 = 0x19,
                HELM_3_1 = 0x1a,
                HELM_3_2 = 0x1b,
                HELM_3_3 = 0x1c,
                HELM_4_1 = 0x1d,
                HELM_4_2 = 0x1e,
                HELM_4_3 = 0x1f,

                ARMBAND_1_1 = 0x20,
                ARMBAND_1_2 = 0x21,
                ARMBAND_1_3 = 0x22,
                ARMBAND_2_1 = 0x23,
                ARMBAND_2_2 = 0x24,
                ARMBAND_2_3 = 0x25,
                ARMBAND_3_1 = 0x26,
                ARMBAND_3_2 = 0x27,
                ARMBAND_3_3 = 0x28,
                ARMBAND_4_1 = 0x29,
                ARMBAND_4_2 = 0x2a,
                ARMBAND_4_3 = 0x2b,

                COLLAR_1 = 0x2c,
                COLLAR_2 = 0x2d ,
                COLLAR_3 = 0x2e,
                COLLAR_4 = 0x2f,

                // ingredients
                WAX = 0x30,
                WATER = 0x31,
                VINEGAR = 0x32,
                ROOT = 0x33,
                OIL = 0x34,
                MUSHROOM = 0x35,
                MUD_PEPPER = 0x36,
                METEORITE = 0x37,
                LIMESTONE = 0x38,
                IRON = 0x39,
                GUNPOWDER = 0x3a,
                GREASE = 0x3b,
                FEATHER = 0x3c,
                ETHANOL = 0x3d,
                DRY_ICE = 0x3e,
                CRYSTAL = 0x3f,
                CLAY = 0x40,
                BRIMSTONE = 0x41,
                BONE = 0x42,
                ATLAS_AMULET = 0x43,
                ASH = 0x44,
                ACORN = 0x45,

                // buggy: 00, 01, 02, 03, 04, 05, 06, 07
                CORROSION = 0x46,
                STING = 0x47,

                // crash: 50
            }

            enum CURRENCY {
                TALONS = 0x00,
                JEWELES = 0x03,
                GOLD_COINS = 0x06,
                CREDITS = 0x09
            }

            enum LOOT_REWARD {
                NOTHING = 0x0000,

                // currency
                MONEY = 0x0001,

                // ingredients
                WAX = 0x0200,
                WATER = 0x0201,
                VINEGAR = 0x0202,
                ROOTS = 0x0203,
                OIL = 0x0204,
                MUD_PEPPER = 0x0205,
                MUSHROOM = 0x0206,
                METEORITE = 0x0207,
                LIMESTONE = 0x0208,
                IRON = 0x0209,
                GUNPOWDER = 0x020A,
                GREASE = 0x020B,
                FEATHER = 0x020C,
                ETHANOL = 0x020D,
                DRY_ICE = 0x020E,
                CRYSTAL = 0x020F,
                CLAY = 0x0210,
                BRIMSTONE = 0x0211,
                BONE = 0x0212,
                ATLAS_MEDALLION = 0x0213,
                ASH = 0x0214,
                ACORNS = 0x0215,

                // armor
                ARMOR_1_1 = 0x0401,
                ARMOR_1_2 = 0x0402,
                ARMOR_1_3 = 0x0403,
                ARMOR_2_1 = 0x0404,
                ARMOR_2_2 = 0x0405,
                ARMOR_2_3 = 0x0406,
                ARMOR_3_1 = 0x0407,
                ARMOR_3_2 = 0x0408,
                ARMOR_3_3 = 0x0409,
                ARMOR_4_1 = 0x040a,
                ARMOR_4_2 = 0x040B,
                ARMOR_4_3 = 0x040c,

                HELM_1_1 = 0x040d,
                HELM_1_2 = 0x040e,
                HELM_1_3 = 0x040f,
                HELM_2_1 = 0x0410,
                HELM_2_2 = 0x0411,
                HELM_2_3 = 0x0412,
                HELM_3_1 = 0x0413,
                HELM_3_2 = 0x0414,
                HELM_3_3 = 0x0415,
                HELM_4_1 = 0x0416,
                HELM_4_2 = 0x0417,
                HELM_4_3 = 0x0418,

                ARMBAND_1_1 = 0x0419,
                ARMBAND_1_2 = 0x041a,
                ARMBAND_1_3 = 0x041b,
                ARMBAND_2_1 = 0x041c,
                ARMBAND_2_2 = 0x041d,
                ARMBAND_2_3 = 0x041e,
                ARMBAND_3_1 = 0x041f,
                ARMBAND_3_2 = 0x0420,
                ARMBAND_3_3 = 0x0421,
                ARMBAND_4_1 = 0x0422,
                ARMBAND_4_2 = 0x0423,
                ARMBAND_4_3 = 0x0424,
                
                COLLAR_1 = 0x0425,
                COLLAR_2 = 0x0426,
                COLLAR_3 = 0x0427,
                COLLAR_4 = 0x0428,

                // consumables
                PETAL = 0x0800,
                NECTAR = 0x0801,
                HONEY = 0x0802,
                BISCUIT = 0x0803,
                WINGS = 0x0804,
                HERBAL_ESSENCE = 0x0805,
                PIXIE_DUST = 0x0806,
                CALL_BEADS = 0x0807,

                // custom
                ANNIHILATION_AMULET = 0x1000,
                BEAD = 0x1001,
                CERAMIC_POT = 0x1002,
                CHICKEN = 0x1003,
                GOLDEN_JACKAL = 0x1004,
                JEWELED_SCARAB = 0x1005,
                LIMESTONE_TABLET = 0x1006,
                PERFUME = 0x1007,
                RICE = 0x1008,
                SPICE = 0x1009,
                SPOON = 0x100a,
                TAPESTRY = 0x100b,
                TICKET_FOR_EXHIBITION = 0x100c,
            }

            enum WEAPON_TYPE {
                SWORD = 0x00,
                AXE = 0x02,
                SPEAR = 0x04,
                BAZOOKA = 0x06,
            }
            enum WEAPON_INDEX {
                SWORD_1 = 0x02, // "Bone Crusher"
                SWORD_2 = 0x04, // "Gladiator Sword"
                SWORD_3 = 0x06, // "Crusader Sword"
                SWORD_4 = 0x08, // "Neutron Blade"

                AXE_1 = 0x0a, // "Spider's Claw"
                AXE_2 = 0x0c, // "Bronze Axe"
                AXE_3 = 0x0e, // "Knight Basher"
                AXE_4 = 0x10, // "Atom Smasher"

                SPEAR_1 = 0x12, // "Horn Spear"
                SPEAR_2 = 0x14, // "Bronze Spear"
                SPEAR_3 = 0x16, // "Lance"
                SPEAR_4 = 0x18, // "Laser Lance"

                BAZOOKA = 0x1a, // "Bazooka"
            }
            enum GAIN_WEAPON {
                SWORD_1 = 0x02,
                SWORD_2 = 0x04,
                SWORD_3 = 0x06,
                SWORD_4 = 0x08,

                AXE_1 = 0x0a,
                AXE_2 = 0x0c,
                AXE_3 = 0x0e,
                AXE_4 = 0x10,

                SPEAR_1 = 0x12,
                SPEAR_2 = 0x14,
                SPEAR_3 = 0x16,
                SPEAR_4 = 0x18,

                BAZOOKA = 0x1a,

                // weird
                UNKNOWN = 0x00,
                BAZOOKA = 0x1c, // only temporary
            }
        };

        group alchemy() {
            enum ALCHEMY_INDEX {
                ACID_RAIN = 0x00,
                ATLAS = 0x02,
                BARRIER = 0x04,
                CALL_UP = 0x06,
                CORROSION = 0x08,
                CRUSH = 0x0a,
                CURE = 0x0c,
                DEFEND = 0x0e,

                DOUBLE_DRAIN = 0x10,
                DRAIN = 0x12,
                ENERGIZE = 0x14,
                ESCAPE = 0x16,
                EXPLOSION = 0x18,
                FIREBALL = 0x1a,
                FIRE_POWER = 0x1c,
                FLASH = 0x1e,

                FORCE_FIELD = 0x20,
                HARD_BALL = 0x22,
                HEAL = 0x24,
                LANCE = 0x26,
                LASER = 0x28,
                LEVITATE = 0x2a,
                LIGHTNING_STORM = 0x2c,
                MIRACLE_CURE = 0x2f,

                NITRO = 0x30,
                ONE_UP = 0x32,
                REFLECT = 0x34,
                REGROWTH = 0x36,
                REVEALER = 0x38,
                REVIVE = 0x3a,
                SLOW_BURN = 0x3c,
                SPEED = 0x3e,

                STING = 0x40,
                STOP = 0x42,
                SUPER_HEAL = 0x44
            }
            enum ALCHEMY_PRESELECT_INDEX {
                ACID_RAIN = 0x00,
                FLASH = 0x17,
                CRUSH = 0x05,

                ATLAS = 0x01,
                BARRIER = 0x02,
                CALL_UP = 0x03,
                CORROSION = 0x04,
                CURE = 0x06,
                DEFEND = 0x07,

                DOUBLE_DRAIN = 0x10,
                DRAIN = 0x11,
                ENERGIZE = 0x12,
                ESCAPE = 0x13,
                EXPLOSION = 0x14,
                FIREBALL = 0x15,
                FIRE_POWER = 0x16,

                FORCE_FIELD = 0x20,
                HARD_BALL = 0x21,
                HEAL = 0x22,
                LANCE = 0x23,
                LASER = 0x24,
                LEVITATE = 0x25,
                LIGHTNING_STORM = 0x26,
                MIRACLE_CURE = 0x27,

                NITRO = 0x30,
                ONE_UP = 0x31,
                REFLECT = 0x32,
                REGROWTH = 0x33,
                REVEALER = 0x34,
                REVIVE = 0x35,
                SLOW_BURN = 0x36,
                SPEED = 0x37,

                STING = 0x40,
                STOP = 0x41,
                SUPER_HEAL = 0x42
            }

            enum CAST {
                // projectile
                FLASH = 0x02,
                FIREBALL = 0x16,

                // animation
                ACID_RAIN = 0x00,
                CRUSH = 0x04,
                DRAIN = 0x06,
                DOUBLE_DRAIN = 0x08,
                STING = 0x0a,
                LIGHTNING_STORM = 0x0c,
                EXPLOSION = 0x0e,
                COROSION = 0x10,
                NITRO = 0x12,
                SLOW_BURN = 0x22,
                HEAT_WAVE = 0x26,
                STORM = 0x28,
                PLAGUE = 0x2c,

                // debuff
                CONFOUND = 0x18,
                DISRUPT = 0x2a,
                STOP = 0x14,

                // heal/buff
                HEAL = 0x1c,
                ONE_UP = 0x20,
                CURE = 0x1a,
                MIRACLE_CURE = 0x1e,
                FORCE_FIELD = 0x24,

                // derpy
                WATER = 0x30
                // CRASH: 2e, 32, 34, 36, …
            }

            enum ALCHEMY_TYPE_PROJECTILE {
                // alchemy
                FIREBALL = 0x48f8, // [FIRE]
                FLASH = 0x4834, // [FIRE] same as flare
                HARD_BALL = 0x481b, // [EARTH]

                // call beads
                FLARE = 0x4834, // [FIRE] same as flash
            }
            enum ALCHEMY_TYPE_ANIMATION {
                // alchemy
                ACID_RAIN = 0x4d44, // [NATURE?] same as laser
                ATLAS = 0x4683, // same as heal/consumeable heals
                BARRIER = 0x5492,
                CALL_UP = 0x576d,
                // CORROSION = 0x0000,
                CRUSH = 0x50bf, // [EARTH]
                CURE = 0x45fa, // same as miracle cure
                DEFEND = 0x45ad,

                DOUBLE_DRAIN = 0x499D, // [MAGIC] same as drain (not 0x494d?)
                DRAIN = 0x499D, // [MAGIC] same as double drain (not 0x494d?)
                ENERGIZE = 0x532f,
                // ESCAPE = 0x0000,
                EXPLOSION = 0x47B6, // [FIRE] same as nitro (not 0x4786?)
                FIRE_POWER = 0x4834, // [FIRE] (not 0x52d4?)

                FORCE_FIELD = 0x56c6,
                HEAL = 0x4683, // atlas/heal/consumeable heals
                LANCE = 0x4f84, // [MAGIC]
                LASER = 0x4d44, // same as acid rain
                LEVITATE = 0x4fe0,
                LIGHTNING_STORM = 0x4e84, // [LIGHTNING]
                MIRACLE_CURE = 0x45fa, // same as cure

                NITRO = 0x47B6, // [FIRE] same as explosion (not 0x4786?)
                ONE_UP = 0x4727,
                REFLECT = 0x561b,
                REGROWTH = 0x529a,
                REVEALER = 0x4cab,
                REVIVE = 0x0000,
                // SLOW_BURN = 0x0000,
                SPEED = 0x4ee7,

                STING = 0x5014, // [NATURE?]
                STOP = 0x5588,
                SUPER_HEAL = 0x4683, // same as atlas/heal/consumeable heals

                // call beads
                // HEAT_WAVE = 0x0000,
                STORM = 0x4e12, // [LIGHTNING]
                LIFE_SPARK = 0x4683, // same as atlas/heal/consumeable heals

                CONFOUND = 0x51f0, // same as disrupt
                REGENERATE = 0x53d1,
                AURA = 0x5401,
                TIME_WARP = 0x5171,
                FIRST_AID = 0x4cd4, // same as restore
                
                PLAGUE = 0x0400,
                HYPNOTIZE = 0x4987,
                // SHOCK_WAVE = 0x0000,
                SHIELD = 0x5520,
                
                RESTORE = 0x4cd4, // same as first aid
                ELECTRA_BOLT = 0x4ec3, // [LIGHTNING]
                DISRUPT = 0x51f0, // same as confound

                // consumables
                PETAL = 0x4683, // atlas/heal/consumeable heals
                NECTAR = 0x4683, // atlas/heal/consumeable heals
                HONEY = 0x4683, // atlas/heal/consumeable heals
                DOG_BISCUIT = 0x0000,
                WINGS = 0x0000,
                HERBAL_ESSENCE = 0x45fa, // same as cure
                PIXIE_DUST = 0x53d1,
            }

            enum ALCHEMY_TYPE_GROUP {
                FIRE = 0x00,
                EARTH = 0x01,
                LIGHTNING = 0x02,
                MAGIC = 0x03,
                NATURE = 0x04,
            }
        };

        group animation() {
            enum ANIMATION_MODE {
                ONCE = 0x00,
                ONCE_FREEZE = 0x02,
                LOOP = 0x04,
                FREEZE = 0x06,

                PAUSE = 0x0a,
            }

            enum ANIMATION_ALL {
                INVISIBLE = 0x0010,

                DEFAULT = 0x8000,
                
                WALK_FORWARD = 0x8002,
                RUN_FORWARD = 0x8004,
                
                SLASH_1 = 0x8006,
                SLASH_2 = 0x8008,
                SLASH_3 = 0x800a,
                SLASH_1_3 = 0x800c,

                KNOCKBACK = 0x800e,

                CAST = 0x8014,
                BLOCK = 0x8016,

                SMALL = 0x001e, // unused/buggy

                // ENEMIES ONLY: 8010, 8012
                // CRASH: 8018, 801a, 801c, 801e
            }
            enum ANIMATION_BOY {
                SLEEP_UP = 0x001a,
                DRAGGED = 0x001c,
                SWIRL_ENTER = 0x0020,
                SWIRL_EXIT = 0x0022,
                LANDING = 0x0024, // todo
                FALL_1 = 0x0026, // arm waving
                FALL_2 = 0x0188, // salto
                SLEEP_DOWN = 0x0028,
                KNEEL = 0x002a,
                SLEEP_WATER = 0x002C,
                TELEPORT_IN = 0x002e,

                BOY_STICK_THROWING = 0x0014,
                BOY_STICK_HOLDING = 0x0016,
                LOOT = 0x0018,

                RAISE_BONE = 0x0178,
                RAISE_SWORD = 0x017e,
                RAISE_AXE = 0x0176,
                RAISE_SPEAR = 0x017a,
                RAISE_BAZOOKA = 0x0178,
            }
            enum ANIMATION_DOG {
                // act0
                ACT0_RUN = 0x0068,
                ACT0_STAND = 0x006a,
                ACT0_WALK = 0x006c,
                ACT0_BARK = 0x0170,
                ACT0_EATING = 0x01a0,

                // act1
                ACT1_STICK_RUNNING = 0x0030,
                ACT1_STICK_DROPPING = 0x0032,
                ACT1_SWIRL_ENTER = 0x0038,
                ACT1_BARK = 0x0172,
                
                ACT1_TINY = 0x0036,

                ACT1_DRAGGING = 0x0034,
                ACT1_SLEEP = 0x003a,
                ACT1_SIT = 0x003e,
                ACT1_FALL1 = 0x003c,
                ACT1_FALL2 = 0x0040,
                ACT1_FALL3 = 0x0042,
                ACT1_ANGRY = 0x0044,

                // act2
                ACT2_FALL = 0x0052,
                ACT2_LEAP = 0x0046,
                ACT2_SLEEP = 0x0048,
                ACT2_SIT = 0x004a,
                ACT2_DUCK = 0x004c,
                ACT2_FALL_1 = 0x004e,
                ACT2_FALL_2 = 0x0050,
                ACT2_FALL_3 = 0x0052,
                ACT2_FALL_4 = 0x0054,
                ACT2_SNIFF = 0x0056,
                ACT2_TELEPORT = 0x0058,
                ACT2_STANDING = 0x016e,
                
                // act3
                ACT3_SLEEP = 0x005a,
                ACT3_SIT = 0x005c,
                ACT3_STAND_1 = 0x005e,
                ACT3_STAND_2 = 0x0060,
                ACT3_STAND_3 = 0x0062,
                ACT3_FALL_1 = 0x0064,
                ACT3_FALL_2 = 0x0066,
                ACT3_BARK = 0x0174,
                ACT3_DAMAGE = 0x019e,
            }
            enum ANIMATION_ENEMY {
                // special
                GORE = 0x8010,
                DUST = 0x01a6,

                // bosses
                LIZARD_TALK = 0x0076,
                LIZARD_DUCK_1 = 0x0078,
                LIZARD_DUCK_2 = 0x007c,
                LIZARD_ROLL = 0x007a,

                MAGMAR_ROLL = ANIMATION_ALL.SLASH_1_3,
                MAGMAR_ENTER = 0x00ae,
                MAGMAR_DUCK = ANIMATION_ALL.SLASH_1,
                MAGMAR_SHOOT = ANIMATION_ALL.SLASH_2,
                MAGMAR_SHOOT_AIR = ANIMATION_ALL.SLASH_3,

                SALABOG_DUCK = 0x0072,
                SALABOG_STRAIGHT = 0x0074, // closes eyes, leans back
                SALABOG_FIRE = ANIMATION_ALL.SLASH_3,

                VIGOR_FLEX = 0x00ba,
                VIGOR_BIDENT = ANIMATION_ALL.SLASH_1,
                VIGOR_BOOMERANG = ANIMATION_ALL.SLASH_2,

                MINITAUR_STOMP = 0x00b2,

                MEGATAUR_STOMP = 0x0150,
                MEGATAUR_IDLE = 0x0152,
                MEGATAUR_DAMAGE = 0x0154,
                MEGATAUR_STILL = 0x0156,
                MEGATAUR_ENTER = 0x0158,
                MEGATAUR_EXIT = 0x015a,
                MEGATAUR_BREATH = 0x015c,
                MEGATAUR_DUCK = 0x015e,

                RIMSALA_1 = 0x00b6,
                RIMSALA_2 = 0x00b8,

                VERMINATOR_CAST_1 = ANIMATION_ALL.CAST,
                VERMINATOR_CAST_2 = 0x010a,
                VERMINATOR_SERCHING = 0x010c, // doesn't exist?
                VERMINATOR_DAMAGE = 0x010e,

                STERLING_ATTACK = 0x011e,
                STERLING_FLY_1 = 0x0120,
                STERLING_FLY_2 = 0x0122,
                STERLING_IDLE_1 = 0x0124,
                STERLING_IDLE_2 = 0x0126,

                TINY_FLEX = 0x00cc,
                TINY_JUGGLE = 0x00ce,
                TINY_THROW_1 = 0x00d0,
                TINY_THROW_2 = 0x00d2,

                // enemies
                TENTACLE_WHIP_ATTACK = 0x00e0,
                TENTACLE_ATTACK = 0x00e2,

                BLACK_OWL_ACTIVATE = ANIMATION_ALL.SLASH_1,
                BLACK_OWL_FUSION = ANIMATION_ALL.SLASH_3,
                BLACK_OWL_JUMP = ANIMATION_ALL.SLASH_1_3,

                PUPPET_1_JUMP_1 = 0x00e6,
                PUPPET_1_JUMP_2 = 0x00e8,
                PUPPET_1_ENTER = 0x00ea,
                PUPPET_1_DANGLING = 0x00ec,
                PUPPET_1_ATTACK = 0x00ee,
                PUPPET_1_DANCE = 0x00ee,

                PUPPET_2_JUMP = 0x00f2,
                PUPPET_2_ENTER = 0x00f4,
                PUPPET_2_DANGLING = 0x00f6,
                PUPPET_2_ATTACK_1 = 0x00f8,
                PUPPET_2_ATTACK_2 = 0x00fa,
                PUPPET_2_DANCE = 0x00fc,

                GATE_BOT_DEAD = 0x8012, 

                STONE_SNAKE_AWAKE_LEFT = 0x0166,
                STONE_SNAKE_AWAKE_RIGHT = 0x0168,
                STONE_SNAKE_UNKNOWN = 0x016a,

                // npcs
                DAVID_SEARCHING = 0x0000,

                KING_ROCKING = 0x00fe,

                CECIL = 0x0110,

                VILLAGER_FREAKSHOW_1 = 0x0112, // Barker holding his cain

                TINKER_1 = 0x0136,
                TINKER_2 = 0x0138,

                CARLTRON_TALK = 0x013a,
                CARLTRON_LYING = 0x013c,
                CARLTRON_GESTURING = 0x013e,
                CARLTRON_CLEANING = 0x01a4,
                CARLTRON_DROPPING = 0x0140,
                CARLTRON_SMUG = 0x0142,

                PIRATE_VILLAGER_1 = 0x0080, // boxer right
                PIRATE_VILLAGER_2 = 0x0082, // boxer left
                PIRATE_VILLAGER_3 = 0x0084, // drinking left
                PIRATE_VILLAGER_4 = 0x0086, // drinking up 1
                PIRATE_VILLAGER_5 = 0x008a, // drinking up 2
                PIRATE_VILLAGER_6 = 0x008c, // barkeeper
                PIRATE_VILLAGER_7 = 0x008e, // tiny/pirate lifting?
            }
            enum ANIMATION_PLACEHOLDER {
                // effects
                EXPLOSION_1 = 0x0002,
                EXPLOSION_2 = 0x0004,
                EXPLOSION_3 = 0x0006,

                EXPLOSION_GREEN_1 = 0x0104,
                EXPLOSION_GREEN_2 = 0x0106,
                EXPLOSION_GREEN_3 = 0x0108,

                GORE_GREEN = 0x0090,
                GORE_RED = 0x0092,
                GORE_EXPLODE = 0x0094,

                TELEPORT_OUT = 0x00c8,
                TELEPORT_IN = 0x00ca,

                LEAVES_FALLING_1 = 0x0008,
                LEAVES_FALLING_2 = 0x000a,

                INVISIBLE_FADE = 0x000e,

                // objects
                LAVA_BLUB = 0x00b0,

                ENERGY_CORE_CLOSED = 0x00bc,
                ENERGY_CORE_OPENING = 0x00be,
                ENERGY_CORE_OPEN = 0x00c0,

                LIFT_MOVING = 0x0070,

                LIFT_CORD_VERTICAL = 0x00aa,

                ELEVATOR = 0x00b4,

                BUCKET = 0x00e4,

                WINDWALKER_IDLE = 0x014e,

                SPACESHIP_IDLE = 0x0144,
                SPACESHIP_BACK = 0x0146,
                SPACESHIP_TOP = 0x0148,
                SPACESHIP_FIRE_PARTS_1 = 0x014a,
                SPACESHIP_FIRE_PARTS_2 = 0x014c,

                ROCKET_IDLE = 0x0198,

                SHELL_BOAT = 0x006e,

                PILLAR_VIGOR = 0x009a,

                SKELETON_SHIP_1 = 0x009c,
                SKELETON_SHIP_2 = 0x009e,
                SKELETON_SHIP_3 = 0x00a0,
                SKELETON_SHIP_ROW_1 = 0x00a2,
                SKELETON_SHIP_ROW_2 = 0x00a4,

                AEGIS_MASK_1 = 0x00c6,
                AEGIS_MASK_2 = 0x00c2,
                AEGIS_MASK_3 = 0x00c4,

                DIAMOND_EYE_1 = 0x019a,
                DIAMOND_EYE_2 = 0x019c,

                CROWN = 0x0100,
                SCEPTER = 0x0102,

                POT = 0x0196,

                // npcs
                EVIL_HORACE_BACK_1 = 0x00a6,
                EVIL_HORACE_BACK_2 = 0x00a8,
                EVIL_HORACE_SHRUG = 0x0180,
                EVIL_HORACE_LAUGHING = 0x0182,

                EVIL_FIRE_EYES_TURNING = 0x00ac,

                FIRE_EYES_CAST = 0x0096,

                EVIL_QUEEN_FALLING = 0x0162,
                EVIL_QUEEN_ANGRY = 0x0164,
                EVIL_QUEEN_STANDING = 0x0160, // unused/buggy

                COLLOSEUM_VILLAGER_1 = 0x0098,

                MARKET_2_VILLAGER_1 = 0x011a,
                MARKET_2_VILLAGER_2 = 0x011c,

                COOK_RUNNING = 0x0116,
                COOK_COOKING = 0x0118,

                PIG_RUNNING = 0x00dc,
                PIG_STAND = 0x00de,

                PIGOODLE_RUNNING_SOUTH = 0x00d4,
                PIGOODLE_RUNNING_EAST = 0x00d6,
                PIGOODLE_RUNNING_WEST = 0x00d8,
                PIGOODLE_STAND = 0x00da,

                // environment
                SANDPIT_PUKE = 0x000c,

                // podunk old
                PODUNK_VILLAGER_1 = 0x0128,
                PODUNK_VILLAGER_2 = 0x0190,
                PODUNK_VILLAGER_3 = 0x0192,

                CAT_CLEANING_1 = 0x012c,
                CAT_CLEANING_2 = 0x012e,
                CAT_LOOKING = 0x0130,
                CAT_RUNNING = 0x0132,

                DOVES_1 = 0x018c, // 1 right looking
                DOVES_2 = 0x018e, // 2 right looking
                DOVES_3 = 0x018a, // 1 right looking

                // podunk new
                PODUNK_VILLAGER_4 = 0x0134,
                PODUNK_VILLAGER_5 = 0x0194,

                // intro
                SPARK_LEFT = 0x0184,
                LOGO = 0x0186

                // UNIDENTIFIED: 1e, 7e (butterfly-esque), 114 (half the cooks face?)
                // INVISIBLE: 0e, 12, 12a
                // CRASH: 72, 74, 1a2, 1a8
            }
        };
    };
};

// BASICS

group functions() {
    group system() {
        fun reboot() {
            code(0xab, "// (ab) Reset game");
        }

        fun update_ui() {
            code(0x83, "// (83) Change visible layers, ... based on $7e0f80..7e0f83");
        }
        
        fun hide_non_dialog_layers() {
            <0x235b> = 0x04;
            <0x235c> = 0x00;
            <0x235e> = 0x00;
            <0x235d> = 0x00;

            code(0x82, "// (82) Also change visible layers?");
        }

        fun boot_into_loading_screen() {
            // triggers after the next `end();`
            // only works of no game has been loaded(?)

            set(<0x22ea, 0x08>);

            set(<0x22ea, 0x10>);
            set(<0x22ea, 0x20>);
        }
    };

    group calculation_helper() {
        fun address(address) {
            if(address >= 0x960000) {
                code(address - 0x960000);
            } else if(address >= 0x958000) {
                code(address - 0x958000);
            } else if(address >= 0x950000) {
                code(address - 0x950000);
            } else if(address >= 0x948000) {
                code(address - 0x948000);
            } else if(address >= 0x940000) {
                code(address - 0x940000);
            } else if(address >= 0x938000) {
                code(address - 0x938000);
            } else if(address >= 0x930000) {
                code(address - 0x930000);
            } else if(address >= 0x928000) {
                code(address - 0x928000);
            } else if(address >= 0x2834) {
                code(address - 0x2834);
            } else if(address >= 0x2258) {
                code(address - 0x2258);
            }
        }

        fun arg(index) {
            code(0x00 + index);
        }
        fun arg_signed(index) {
            code(0x92, arg(index));
        }

        fun param(value) {
            // writes arg0…arg20

            if(value is Word) {
                if(value < 0x00) {
                    code(0xd0 + value);
                } else if(value <= 0x0f) {
                    code(0xb0 + value);
                } else if(value <= 0x1e) {
                    code(0xd0 + value);
                } else if(value <= 0xff) {
                    code(0x82, 0x00 + value); // TODO: only works with len(value)==1
                } else if(value <= 0xffff) {
                    code(0x84, 0x0000 + value);
                }
            } else {
                calculate(value);
            }
        }

        fun entity(character:CHARACTER) {
            // sometimes writes arg0…arg20

            if(character is Arg) {
                code(0x80 + 0x12, character);
            } else if(character is Word) {
                if(character >= 0x2834) {
                    code(0x80 + 0x0d, character - 0x2834);
                } else if(character >= 0x2258) {
                    code(0x80 + 0x08, character - 0x2258);
                } else {
                    code(0x80 + character);
                }
            } else if(character is Memory) {
                calculate(character); // TODO: should terminate?
            }
        }
        fun entity_t(character:CHARACTER) {
            // sometimes writes arg0…arg20

            if(character is Arg) {
                code(0x80 + 0x12, character);
            } else if(character is Word) {
                if(character >= 0x2834) {
                    code(0x80 + 0x0d, character - 0x2834);
                } else if(character >= 0x2258) {
                    code(0x80 + 0x08, character - 0x2258);
                } else {
                    code(0x80 + character);
                }
            } else if(character is Memory) {
                calculate(character);
            }
        }

        fun modulo(number, modulo, divider) {
            while(number >= modulo) {
                number -= modulo;

                if((divider is Memory) || (divider is Arg)) {
                    divider++;
                }
            }
        }
    };

    group everscript_commands() {
        fun _subtext(id) { // debug copy
            code(0x52, install_string(id), "// (52) SHOW TEXT 066f FROM 0x91d66f compressed UNWINDOWED c03ad9> 'Received Jaguar Ring'");
        }

        fun end() {
            code(0x00, "// (00) END (return)");
        }

        fun _nop() {
            code("// _NOP");
        }
        fun nop() {
            code(0x4d, "// NOP");
        }

        fun yield() {
            code(0x3a, "// (3a) YIELD (break out of script loop, continue later)");
        }

        fun sleep(ticks) {
            if(ticks is Word) {
                if(ticks <= 0xff) {
                    code(0xa7, ticks, "// (a7) SLEEP 59 TICKS");
                } else {
                    code(0xa8, ticks, "// (a8) SLEEP 899 TICKS");
                }
            } else {
                code(0x3b, calculate(ticks), "// (3b) SLEEP (RAND & 3) + 4 TICKS");
            }
        }

        fun call_id(script_id:ADDRESS_ID) {
            code(0xa3, script_id, "// (a3) CALL 'Unnamed Global script 0x3d' (0x3d)");
        }

        fun call_async(script_address) {
            code(0x07, address(script_address), "// (07) CALL 0x92a3e7");
        }

        fun tile_animate(index, to, state) {
            code(0x62, index, 0x0000 + to, 0x0000 + state, "// (62) UNTRACED INSTR vals 0x03 0x00ff 0x0000");
        }

        group audio() {
            fun sound(sound_effect:SOUND) {
                code(0x30, sound_effect, "// (30) PLAY SOUND EFFECT 0x58 ??");
            }
            @install()
            @weak()
            fun _smart_sound(sound_effect:SOUND) {
                if(sound_effect == SOUND.PURCHASE) {
                    if(MEMORY.CURRENT_MUSIC == MUSIC.SEWER_AMBIENT_WATER) {
                        nop();
                    } else {
                        sound(sound_effect);
                        end();
                    }
                }

                if(SYSTEM.WITH_DEBUG_SOUND) {
                    MEMORY.STRING_PARAMETER_1 = sound_effect;
                    MEMORY.STRING_PARAMETER_2 = MEMORY.CURRENT_MUSIC;
                    _subtext("invalid sound [MEM1] for map [MEM2]");
                    sleep(0d60);
                }
            }
            fun smart_sound(sound_effect:SOUND) {
                if(sound_effect == SOUND.PURCHASE) {
                    _smart_sound(sound_effect);
                } else {
                    sound(sound_effect);
                }
            }
            fun music(music:MUSIC) {
                code(0x33, music, "// PLAY MUSIC 0x12");
            }
            fun volume(volume) {
                code(0x86, param(volume), "// (86) SET AUDIO volume to 0x64");
            }
            fun music_volume(music:MUSIC, volume) {
                music(music);
                volume(volume);
            }
            fun music_fade(on) {
                if(False) {
                    if(on == True) {
                        call_id(MUSIC_FADE_IN);
                    } else {
                        call_id(MUSIC_FADE_OUT);
                    }
                } else {
                    if(on == True) {
                        MEMORY.CHANGE_MUSIC = False;
                        code(0x58, "// (58) FADE IN VOLUME");
                    } else {
                        MEMORY.CHANGE_MUSIC = True;
                        code(0x59, "// (59) FADE OUT VOLUME");
                    }
                }
            }
            fun fade_to_music(music:MUSIC) {
                music_fade(False);
                music_volume(music, 0xff);
            }

            @install()
            @weak()
            fun clear_music_stack() {
                MEMORY.MUSIC_STACK_1 = 0d0;
                MEMORY.MUSIC_STACK_2 = 0d0;
                MEMORY.MUSIC_STACK_3 = 0d0;
                MEMORY.MUSIC_STACK_4 = 0d0;
            }
            @install()
            @weak()
            fun play_music(music:MUSIC, force, without_fade) {
                if(SYSTEM.WITH_DEBUG_MUSIC) {
                    MEMORY.STRING_PARAMETER_1 = music;

                    _subtext("play_music([MEM1])");
                }

                MEMORY.MUSIC_STACK_1 = music;

                // if((MEMORY.CHANGE_MUSIC > 0d0) || (MEMORY.CURRENT_MUSIC != music)) {
                if((MEMORY.CURRENT_MUSIC != music) || (MEMORY.CURRENT_MUSIC == MUSIC.FANFARE) || (MEMORY.CURRENT_MUSIC == MUSIC.FANFARE_ITEM)) {
                    if!(without_fade) {
                        code(0x59, "// (59) FADE OUT VOLUME");
                    }

                    if(music == MUSIC.JUNGLE_AMBIENT) { // ambient
                        music(JUNGLE_AMBIENT);
                    } else if(music == MUSIC.JUNGLE_AMBIENT_BIRDS) {
                        music(JUNGLE_AMBIENT_BIRDS);
                    } else if(music == MUSIC.BUGMUCK_AMBIENT_MELODY) {
                        music(BUGMUCK_AMBIENT_MELODY);
                    } else if(music == MUSIC.WIND_AMBIENT_BIRDS) {
                        music(WIND_AMBIENT_BIRDS);
                    } else if(music == MUSIC.WIND_AMBIENT_BIRDS_2) {
                        music(WIND_AMBIENT_BIRDS_2);
                    } else if(music == MUSIC.WIND_AMBIENT_PLANE) {
                        music(WIND_AMBIENT_PLANE);
                    } else if(music == MUSIC.WATER_AMBIENT_SEAGULLS) {
                        music(WATER_AMBIENT_SEAGULLS);
                    } else if(music == MUSIC.SEWER_AMBIENT_WATER) {
                        music(SEWER_AMBIENT_WATER);
                    } else if(music == MUSIC.SPACE_NOISE) {
                        music(SPACE_NOISE);
                    } else if(music == MUSIC.WATERFALL_AMBIENT) {
                        music(WATERFALL_AMBIENT);
                    } else if(music == MUSIC.SWAMP_AMBIENT) {
                        music(SWAMP_AMBIENT);
                    } else if(music == MUSIC.MYSTERY) { // theme
                        music(MYSTERY);
                    } else if(music == MUSIC.INN_GUITAR) {
                        music(INN_GUITAR);
                    } else if(music == MUSIC.CAVE_AMBIENT_PIANO) {
                        music(CAVE_AMBIENT_PIANO);
                    } else if(music == MUSIC.SPACE) {
                        music(SPACE);
                    } else if(music == MUSIC.EBON_KEEP) {
                        music(EBON_KEEP);
                    } else if(music == MUSIC.HALLS_1) {
                        music(HALLS_1);
                    } else if(music == MUSIC.HALLS_2) {
                        music(HALLS_2);
                    } else if(music == MUSIC.HALLS_3) {
                        music(HALLS_3);
                    } else if(music == MUSIC.ACT3) {
                        music(ACT3);
                    } else if(music == MUSIC.PUPPET_SHOW) {
                        music(PUPPET_SHOW);
                    } else if(music == MUSIC.BOSS) { // event
                        music(BOSS);
                    } else if(music == MUSIC.BOSS_JUNGLE) {
                        music(BOSS_JUNGLE);
                    } else if(music == MUSIC.BOSS_MINI) {
                        music(BOSS_MINI);
                    } else if(music == MUSIC.BOSS_ARENA) {
                        music(BOSS_ARENA);
                    } else if(music == MUSIC.BOSS_DRUMS) {
                        music(BOSS_DRUMS);
                    } else if(music == MUSIC.FANFARE) { // effect
                        music(FANFARE);
                    } else if(music == MUSIC.FANFARE_ITEM) {
                        music(FANFARE_ITEM);
                    } else if(music == MUSIC.WING_AMBIENT_VOID) {
                        music(WING_AMBIENT_VOID);
                    } else {
                        if(True) {
                            MEMORY.STRING_PARAMETER_1 = music;
                            _subtext("unknown music: [MEM1]");
                            nop();
                        }

                        music(0d0);
                    }
                    MEMORY.CURRENT_MUSIC = music;

                    if!(without_fade) {
                        code(0x58, "// (58) FADE IN VOLUME");
                    }
                }
            }
            @install()
            @weak()
            fun push_music(music:MUSIC, clear_stack) {
                if(SYSTEM.WITH_DEBUG_MUSIC) {
                    MEMORY.STRING_PARAMETER_1 = music;
                    MEMORY.STRING_PARAMETER_2 = clear_stack;
                    
                    _subtext("push_music([MEM1], [MEM2])");
                    sleep(0d60);
                }

                if(clear_stack > 0d0) {
                    clear_music_stack();
                }

                if(MEMORY.MUSIC_STACK_4 != 0d0) {
                    nop();
                }
                if(MEMORY.MUSIC_STACK_3 != 0d0) {
                    MEMORY.MUSIC_STACK_4 = MEMORY.MUSIC_STACK_3;
                }
                if(MEMORY.MUSIC_STACK_2 != 0d0) {
                    MEMORY.MUSIC_STACK_3 = MEMORY.MUSIC_STACK_2;
                }
                if(MEMORY.MUSIC_STACK_1 != 0d0) {
                    MEMORY.MUSIC_STACK_2 = MEMORY.MUSIC_STACK_1;
                }

                play_music(music);
            }
            @install()
            @weak()
            fun pop_music() {
                if(SYSTEM.WITH_DEBUG_MUSIC) {
                    _subtext("pop_music()");
                }

                if(MEMORY.MUSIC_STACK_4 != 0d0) {
                    MEMORY.MUSIC_STACK_3 = MEMORY.MUSIC_STACK_4;
                    MEMORY.MUSIC_STACK_4 = 0d0;
                }
                if(MEMORY.MUSIC_STACK_3 != 0d0) {
                    MEMORY.MUSIC_STACK_2 = MEMORY.MUSIC_STACK_3;
                    MEMORY.MUSIC_STACK_3 = 0d0;
                }
                if(MEMORY.MUSIC_STACK_2 != 0d0) {
                    MEMORY.MUSIC_STACK_1 = MEMORY.MUSIC_STACK_2;
                    MEMORY.MUSIC_STACK_2 = 0d0;
                }

                play_music(MEMORY.MUSIC_STACK_1);
            }

            fun music_enter(music, volume) {
                if(False) {
                    if((MEMORY.CHANGE_MUSIC != 0x00) || (!FLAG.IN_ANIMATION)) { // hack: loading resets CHANGE_MUSIC, but entering the rooms requires it to be set
                        music_fade(False);
                        music_volume(music, volume);
                        
                        if(volume == 0xff) {
                            music_fade(True);
                            volume(volume);
                        }
                    }
                } else {
                    push_music(music, True);
                }
            }
        };

        group character_manipulation() {
            fun control(character:CHARACTER, control) {
                if(control is Word) {
                    if(character == CHARACTER.BOY) {
                        if(control) {
                            code(0xbd, "// (bd) BOY = Player controlled");
                        } else {
                            code(0xbc, "// (bc) Stop/disable boy (and SELECT button)");
                        }
                    } else if(character == CHARACTER.DOG) {
                        if(control) {
                            code(0xbf, "// (bf) DOG = Player controlled");
                        } else {
                            code(0xbe, "// (be) Stop/disable doggo (and SELECT button)");
                        }
                    } else {
                        if(control) {
                            code(0x2a, entity_t(character), "// (2a) Make $2841 script controlled");
                        } else {
                            code(0x2b, entity_t(character), "// (2b) Make $2835 player/AI controlled");
                        }
                    }
                } else {
                    if(character == CHARACTER.NONE) {
                        code(0xc0, "// (c0) BOY+DOG = STOPPED");
                    } else if(character == CHARACTER.BOTH) {
                        code(0xc1, "// (c1) BOY+DOG = Player controlled");
                    } else if(character == CHARACTER.BOY) {
                        code(0xbd, "// (bd) BOY = Player controlled");
                        code(0xbe, "// (be) Stop/disable doggo (and SELECT button)");
                    } else if(character == CHARACTER.DOG) {
                        code(0xbf, "// (bf) DOG = Player controlled");
                        code(0xbc, "// (bc) Stop/disable boy (and SELECT button)");
                    } else {
                        if(control) {
                            code(0x2a, entity_t(character), "// (2a) Make $2841 script controlled");
                        } else {
                            code(0x2b, entity_t(character), "// (2b) Make $2835 player/AI controlled");
                        }
                    }
                }
            }
            @install()
            @weak()
            fun _control(character:CHARACTER, control) {
                if((character == CHARACTER.BOY) && !FLAG.BOY_UNAVAILABLE) {
                    control(BOY, True);
                } else if((character == CHARACTER.DOG) && !FLAG.DOG_UNAVAILABLE) {
                    control(DOG, True);
                } else if((character == CHARACTER.BOTH) && !FLAG.DOG_UNAVAILABLE) {
                    if(!FLAG.BOY_UNAVAILABLE) {
                        control(BOY, True);
                    }
                    if(!FLAG.DOG_UNAVAILABLE) {
                        control(DOG, True);
                    } 
                }
            }

            fun wait(character:CHARACTER) {
                if(character == CHARACTER.NONE) {
                    nop();
                } else if(character == CHARACTER.BOTH) {
                    code(0x2e, entity_t(BOY), "// (2e) Wait for boy (d0) to reach destination");
                    code(0x2e, entity_t(DOG), "// (2e) Wait for boy (d0) to reach destination");
                } else {
                    code(0x2e, entity_t(character), "// (2e) Wait for boy (d0) to reach destination");
                }
            }

            fun walk(character:CHARACTER, walk_type:WALK_TYPE, x, y, wait_for:CHARACTER, unlock:CHARACTER) {
                if((walk_type == WALK_TYPE.TILE_ABSOLUTE) || (walk_type == WALK_TYPE.TILE_ABSOLUTE_DIRECT)) {
                    if((x is Word) || (y is Word)) {
                        code(walk_type, entity_t(character), x, y, "// (6e) Make $2841 walk to x=0x01,y=0x1c");
                    } else {
                        code(WALK_TYPE.COORDINATE_ABSOLUTE_DIRECT, entity_t(character), calculate(x << 0d3), calculate(y << 0d3), "// (6e) Make $2841 walk to x=0x01,y=0x1c");
                    }
                } else {
                    code(walk_type, entity_t(character), param(x), param(y), "// (6e) Make $2841 walk to x=0x01,y=0x1c");
                }

                if(wait_for != CHARACTER.NONE) {
                    wait(wait_for);

                    if(unlock is Word) {
                        if(unlock != CHARACTER.NONE) {
                            if((unlock == CHARACTER.BOTH) || (unlock == CHARACTER.BOY) || (unlock == CHARACTER.DOG)) {
                                control(unlock);
                            } else {
                                control(unlock, False);
                            }
                        }
                    } else if((unlock is Memory) || (unlock is Arg)) {
                        control(unlock, False);
                    }
                }
            }

            fun entity_script_controlled(character:CHARACTER) {
                code(0x2a, entity_t(character), "// (2a) Make $283b script controlled");
            }

            fun attach_to_script(character:CHARACTER) {
                code(0x4e, entity_t(character), "// (4e) ATTACH entity last entity ($0341) TO SCRIPT");
            }
        };

        group map_manipulation() {
            fun fade_out() {
                code(0x27, "// (27) Fade-out screen (WRITE $0b83=0x8000)");
            }
            fun fade_out_black() {
                code(0x82, "// (82) Also change visible layers?");
            }
            fun load_map(map:MAP, x, y) {
                code(0x22, x, y, map, 0x00, "// (22) CHANGE MAP = 0x34 @ [ 0x0090 | 0x0118 ]: ...");
            }
            fun prepare_transition(direction_in, direction_out) {
                // MEMORY.TRANSITION_ENTER_DIRECTION = 0x03;
                fade_out();
                call_id(direction_out); // TODO: 4x4 combinations, not 4
                sleep(0x10);
            }

            fun transition(map:MAP, x, y, direction_in:DIRECTION, direction_out:DIRECTION, change_music, new_music:MUSIC) {
                if(False) {
                    if(<ACTIVE>[Z] > 0d0) {
                        end();
                    }
                }

                if(False) {
                    if(change_music) {
                        music_fade(False);

                        MEMORY.CHANGE_MUSIC = 0x01;
                    }
                } else {
                    if(new_music is Word) {
                        if(MEMORY.CURRENT_MUSIC != new_music) {
                            music_fade(False);
                        }
                    }
                }

                attach_to_script(<ACTIVE>);

                if(direction_in == direction_out) {
                    if(direction_out != DIRECTION.NONE) {
                        call_id(direction_out); // TODO: 4x4 combinations, not 4
                    }
                } else {
                    if(direction_out != DIRECTION.NONE) {
                        if(direction_out == DIRECTION.NORTH) {
                            MEMORY.TRANSITION_ENTER_DIRECTION = TRANSITION_DIRECTION.NORTH;
                        } else if(direction_out == DIRECTION.EAST) {
                            MEMORY.TRANSITION_ENTER_DIRECTION = TRANSITION_DIRECTION.EAST;
                        } else if(direction_out == DIRECTION.SOUTH) {
                            MEMORY.TRANSITION_ENTER_DIRECTION = TRANSITION_DIRECTION.SOUTH;
                        } else if(direction_out == DIRECTION.WEST) {
                            MEMORY.TRANSITION_ENTER_DIRECTION = TRANSITION_DIRECTION.WEST;
                        }
                    }

                    if(direction_in != DIRECTION.NONE) {
                        if(direction_in == DIRECTION.NORTH) {
                            walk(ACTIVE, TILE_RELATIVE_DIRECT, 0x00, -0x02, NONE, NONE);
                        } else if(direction_in == DIRECTION.EAST) {
                            walk(ACTIVE, TILE_RELATIVE_DIRECT, 0x02, 0x00, NONE, NONE);
                        } else if(direction_in == DIRECTION.SOUTH) {
                            walk(ACTIVE, TILE_RELATIVE_DIRECT, 0x00, 0x02, NONE, NONE);
                        } else if(direction_in == DIRECTION.WEST) {
                            walk(ACTIVE, TILE_RELATIVE_DIRECT, -0x02, 0x00, NONE, NONE);
                        }
                        sleep(0d20);
                    }
                }

                if(False) {
                    if(direction_out == DIRECTION.NONE) {
                        FLAG.IN_ANIMATION = False;
                    } else {
                        FLAG.IN_ANIMATION = True;
                    }
                } else {
                    FLAG.IN_ANIMATION = True;
                }

                load_map(map, x, y);
            }

            fun _teleport(character:CHARACTER, x, y) {
                if(character == CHARACTER.BOTH) {
                    code(0x43, entity_t(BOY), calculate(x), calculate(y), "// (42) Teleport $2835 to a7, b9");
                    code(0x43, entity_t(DOG), calculate(x), calculate(y), "// (42) Teleport $2835 to a7, b9");
                } else {
                    code(0x43, entity_t(character), calculate(x), calculate(y), "// (42) Teleport $2835 to a7, b9");
                }
            }
            fun teleport(character:CHARACTER, x, y) {
                if((x is Word) && (y is Word)) {
                    if(x > 0xff) {
                        throw("teleport.x > 0xff");
                    } else if(y > 0xff) {
                        throw("teleport.y > 0xff");
                    }

                    if(character == CHARACTER.BOTH) {
                        code(0x20, x, y, "// (20) Teleport both to 43 93");
                    } else {
                        code(0x42, entity_t(character), x, y, "// (42) Teleport $2835 to a7, b9");
                    }
                } else {
                    if(character == CHARACTER.BOTH) {
                        code(0x43, entity_t(BOY), calculate(x << 0d0003), calculate(y << 0d0003), "// (42) Teleport $2835 to a7, b9");
                        code(0x43, entity_t(DOG), calculate(x << 0d0003), calculate(y << 0d0003), "// (42) Teleport $2835 to a7, b9");
                    } else {
                        code(0x43, entity_t(character), calculate(x << 0d0003), calculate(y << 0d0003), "// (42) Teleport $2835 to a7, b9");
                    }
                }
            }
            fun teleport_relative(character:CHARACTER, x, y) {
                code(0xb9, entity_t(character), calculate(x), calculate(y), "// (b9) Teleport $2835 by x:signed arg9, y:signed arg3 - signed arg5");
            }

            fun teleport_screen(dx, dy) { // scren=0d512/0d512
                code(0x96, param(dx), param(dy), "// (96) Teleport player by 0, 2 screens");
            }
            
            fun change_z(entity:CHARACTER, z) { // redundant: same as entity[Z_LEVEL]=z
                MEMORY.Z_AFTER_TELEPORT = z;
                teleport(entity, entity[X], entity[Y]);
            }

            fun _init_map(x_start, y_start, x_end, y_end) {
                MEMORY.CAMERA_BOUNDRY_X_START = x_start;
                MEMORY.CAMERA_BOUNDRY_X_END = x_end;
                MEMORY.CAMERA_BOUNDRY_Y_START = y_start;
                MEMORY.CAMERA_BOUNDRY_Y_END = y_end;
            }
            fun init_map(x_start, y_start, x_end, y_end) {
                code(0x1b, address(0x23e9), address(0x23eb), x_start, y_start, "// (1b) WRITE MAP X start ($23e9) = 0x0000  (1b) WRITE MAP Y start ($23eb) = 0x0010");
                code(0x1b, address(0x23ed), address(0x23ef), x_end, y_end, "// (1b) WRITE MAP X end   ($23ed) = 0x0400  (1b) WRITE MAP Y end   ($23ef) = 0x04b0");
            }

            fun set_args(arg1, arg2, value1, value2) {
                code(0xae, arg1, arg2, value1, value2, "// (ae) UNTRACED INSTR, vals 00 02 1b 1b modifies current script");
            }

            fun tile_flashing(p1, p2, p3, p4) {
                // p1=0 -> rain is black
                code(0xb6, param(p1), param(p2), param(p3), param(p4), "// (b6) START TILE FLASHING 10 1 15 0");
            }

            fun price(index, rate, drop, quantity) {
                if(index == 0x1) {
                    <0x239b> = rate;
                    <0x23a1> = drop;
                    <0x23a7> = quantity;
                } else if(index == 0x2) {
                    <0x239d> = rate;
                    <0x23a3> = drop;
                    <0x23a9> = quantity;
                } else if(index == 0x3) {
                    <0x239f> = rate;
                    <0x23a5> = drop;
                    <0x23ab> = quantity;
                }
            }

            fun color_filter(color, saturation) {
                if(False) {
                    code(0xb4, 0x05, param(0x00), param(0x00), param(0x00), param(color), param(saturation), address(0x92d93e), "// (b4) CALL Absolute (24bit) script 0x92d93e ('Unnamed ABS script 0x92d93e')  WITH 5 ARGS 0, 0, 0, 0x84, 0x90");
                } else {
                    // code(0x97, param(0x00), param(0x00), param(0x00), param(saturation), param(color), param(0x00), param(0x01), "// (97) UNTRACED INSTR 0x97, 7 sub-instrs: signed arg0, signed arg2, signed arg4, signed arg8, signed arg6, 0, 1");
                    code(0x97, param(0x00), param(0x00), param(0x00), param(saturation), param(color), param(0x11), param(0xef), "// (97) UNTRACED INSTR 0x97, 7 sub-instrs: signed arg0, signed arg2, signed arg4, signed arg8, signed arg6, 17, 0xef");
                }
            }
            fun color_filter_fade_to(color, saturation) { // creates a lot of lag
                code(0xb4, 0x05, param(0x00), param(0x00), param(0x00), param(color), param(saturation), address(0x92da2d), "// (b4) CALL Absolute (24bit) script 0x92da2d ('Unnamed ABS script 0x92da2d')  WITH 5 ARGS 0, 0, 0, 0x84, 0x90");
            }
            fun color_filter_fade_from(color, saturation) { // creates a lot of lag
                code(0xb4, 0x05, param(0x00), param(0x00), param(0x00), param(color), param(saturation), address(0x92d9a4), "// (b4) CALL Absolute (24bit) script 0x92d9a4 ('Unnamed ABS script 0x92d9a4')  WITH 5 ARGS 0, 0, 0, 0x84, 0x90");
            }

            fun brightness(brightness) {
                code(0x91, param(brightness), "// (91) Sets brightness to 0");
            }

            fun sfx_effect(effect:SFX_EFFECT, on) {
                if(effect == SFX_EFFECT.RAIN) {
                    if(on) {
                        if(False) {
                            call(ADDRESS.RAIN);
                        } else {
                            <0x23c9> = 0x01;
                            <0x23cb> = 0x20;

                            tile_flashing(0x0a, 0x01, 0x0f, 0x00);
                        }
                    } else {
                        nop();
                    }
                } else if(effect == SFX_EFFECT.NIGHT) {
                    if(on == True) {
                        color_filter(0x2000, 0x90);
                    } else {
                        color_filter(0x00, 0x00);
                    }
                } else if(effect == SFX_EFFECT.SHAKING) {
                    if(on == True) {
                        code(0x8d, 0x01, "// (8d) 01 Start screen shaking");
                        <0x2409> = 0x0001; // (18) WRITE SCREEN SHAKING MAGNITUDE X
                        <0x240b> = 0x0001; // (18) WRITE SCREEN SHAKING MAGNITUDE Y
                    } else {
                        code(0x8d, 0x00, "// (8d) 01 Start screen shaking");
                    }
                } else if(effect == SFX_EFFECT.SEPIA) {
                    if(on == True) {
                        color_filter(0x84, 0x90);
                    } else {
                        color_filter(0x00, 0x00);
                    }
                }
            }

            fun object(index, value) {
                code(0x5c, param(index), param(value), "// (5c) SET OBJ 5 STATE = val:1 (load/unload)");
            }

            fun special_script(script:SPECIAL_SCRIPTS, id) {
                if(script == SPECIAL_SCRIPTS.LOOTING) {
                    code(0x3f, param(0x01), 0x0040, 0x0000 + id, "// (3f) WRITE $0ea2+0=0x40, $0eac+0=0x172b (unknown): Unknown 0eac+0 (set in lots of places)?");
                } else if(script == SPECIAL_SCRIPTS.REVEALER) {
                    code(0x3f, param(0x02), 0x0001, 0x0000 + id, "// (3f) WRITE $0ea2+2=0x01, $0eac+2=0x1959 (unknown): Unnamed Short script 0x1959?");
                } else if(script == SPECIAL_SCRIPTS.LEVITATE) {
                    code(0x3f, param(0x03), 0x0001, 0x0000 + id, "// (3f) WRITE $0ea2+4=0x01, $0eac+4=0x17b5 (unknown): Unnamed Short script 0x17b5?");
                } else if(script == SPECIAL_SCRIPTS.SELECT_PRESSED) {
                    code(0x3f, param(0x04), 0x0001, 0x0000 + id, "// (3f) WRITE $0ea2+6=0x01, $0eac+6=0x1878 (unknown): Unnamed Short script 0x1878?");
                } else if(script == SPECIAL_SCRIPTS.WINGS) {
                    code(0x3f, param(0x05), 0x0001, 0x0000 + id, "// (3f) WRITE $0ea2+8=0x01, $0eac+8=0x178e (unknown): BBM Wings?");
                }
            }

            fun _fade_in() {
                code(0x26, "// (26) UNTRACED INSTR, writing to VRAM"); // fades brightness to `brightness(0x??)`
            }
            fun fade_in() {
                // handles default loot script
                // handles transition animation (walk x/y into direction z)
                // enables/disables BOY/DOG, based on BOY_UNAVAILABLE/DOG_UNAVAILABLE
                // fades in bridghtness

                if(False) {
                    call(ADDRESS.FADE_IN_AND_DEFAULT_LOOT_DUST_REWARD);
                } else if(True) {
                    special_script(LOOTING, ADDRESS_ID.LOOT_DUST_REWARD);
                    call_id(FADE_IN);
                } else if(False) {
                    _fade_in();
                } else {
                    call_id(FADE_IN);
                }

                if(True) {
                    FLAG.IN_ANIMATION = False;
                }
            }

            fun show_hud(show) {
                if(show == True) {
                    if(False) {
                        call(ADDRESS.STATUS_BAR_SHOW);
                    } else {
                        set(FLAG.SHOW_HUD);
                        update_ui();
                    }
                } else {
                    if(False) {
                        call(ADDRESS.STATUS_BAR_HIDE);
                    } else {
                        unset(FLAG.SHOW_HUD);
                        update_ui();
                    }
                }
            }

            fun save_dialog(slot, vanilla_location_id) { // buggy
                <0x2449> = slot; // ?
                code(0xa3, vanilla_location_id, "// (a3) CALL 'Actual save dialog' (0x4e)");
            }
            fun save(id) {
                code(0x8c, install_string(id), "// (a3) CALL 'Actual save dialog' (0x4e)");
            }

            enum CAMERA_PAN_TYPE {
                COORDINATE_CORNER = 0d0,
                COORDINATE_CENTER = 0d1,
                
                TILE_CENTER = 0d2,
            }

            fun set_camera(type:CAMERA_PAN_TYPE, x, y, speed) {
                if(type == CAMERA_PAN_TYPE.COORDINATE_CORNER) {
                    MEMORY.CAMERA_PAN_X = x;
                    MEMORY.CAMERA_PAN_Y = y;
                    MEMORY.CAMERA_PAN_SPEED = speed;
                } else if(type == CAMERA_PAN_TYPE.COORDINATE_CENTER) {
                    MEMORY.CAMERA_PAN_X = x - (0d256 / 0d2);
                    MEMORY.CAMERA_PAN_Y = y - (0d224 / 0d2);
                    MEMORY.CAMERA_PAN_SPEED = speed;
                } else if(type == CAMERA_PAN_TYPE.TILE_CENTER) {
                    MEMORY.CAMERA_PAN_X = (x << 0d3) - (0d256 / 0d2 - 0d4);
                    MEMORY.CAMERA_PAN_Y = (y << 0d3) - (0d224 / 0d2 - 0d4);
                    MEMORY.CAMERA_PAN_SPEED = speed;
                }
            }
            fun set_camera_entity(entity, speed) {
                set_camera(COORDINATE_CENTER, entity[X], entity[Y], speed);
            }
            fun free_camera() {
                MEMORY.CAMERA_PAN_X = 0xffff;
                MEMORY.CAMERA_PAN_SPEED = 0x80;
            }

            fun desert_screen(x, y) {
                MEMORY.DESERT_X = x;
                MEMORY.DESERT_Y = y;
            }
        };

        group sprite() {
            fun animate(character:CHARACTER, mode:ANIMATION_MODE, id:ANIMATION_ALL) {
                code(0x78, entity_t(character), 0x0000 + id, param(mode), "// (78) UNTRACED INSTR for $2846, 0x0010 2 changes sprite/animation/...?");
            }
            fun smart_animate(character:CHARACTER, mode:ANIMATION_MODE, id:ANIMATION_ALL) {
                if(character is Word) {
                    animate(character, mode, id);
                } else {
                    if((id == ANIMATION_BOY.FALL_1) || (id == ANIMATION_DOG.ACT1_FALL2)) {
                        if(character == <BOY>) {
                            animate(character, mode, ANIMATION_BOY.FALL_1);
                        } else {
                            animate(character, mode, ANIMATION_DOG.ACT1_FALL2);
                        }
                    } else if((id == ANIMATION_BOY.LANDING) || (id == ANIMATION_DOG.ACT1_ANGRY)) {
                        if(character == <BOY>) {
                            animate(character, mode, ANIMATION_BOY.LANDING);
                        } else {
                            animate(character, mode, ANIMATION_DOG.ACT1_ANGRY);
                        }
                    } else if((id == ANIMATION_BOY.SLEEP_DOWN) || (id == ANIMATION_DOG.ACT1_SLEEP)) {
                        if(character == <BOY>) {
                            animate(character, mode, ANIMATION_BOY.SLEEP_DOWN);
                        } else {
                            animate(character, mode, ANIMATION_DOG.ACT1_SLEEP);
                        }
                    } else if((id == ANIMATION_BOY.SWIRL_EXIT) || (id == ANIMATION_BOY.SWIRL_EXIT)) { // TODO
                        if(character == <BOY>) {
                            animate(character, mode, ANIMATION_BOY.SWIRL_EXIT);
                        } else {
                            animate(character, mode, ANIMATION_BOY.SWIRL_EXIT); // TODO
                        }
                    }
                }
            }

            fun _add_enemy(enemy:ENEMY, x, y, flags:FLAG_ENEMY) {
                if(flags is Word) {
                    code(0xa2, 0x0000 + enemy * 0x02, 0x0000 + flags, calculate(x), calculate(y), "// (a2) SPAWN NPC 0x00ca>>1, flags 0x20, x:$23b9, y:$23bb");
                } else {
                    code(0xa2, 0x0000 + enemy * 0x02, 0x0000, calculate(x), calculate(y), "// (a2) SPAWN NPC 0x00ca>>1, flags 0x20, x:$23b9, y:$23bb");
                }
            }
            fun add_enemy(enemy:ENEMY, x, y, flags:FLAG_ENEMY) {
                if((x is Word) && (y is Word)) {
                    if(flags is Word) {
                        code(0x3c, 0x0000 + enemy * 0x02, 0x0000 + flags, x, y, "// (ba) LOAD NPC 0b at 49 79");
                    } else {
                        code(0xba, enemy, x, y, "// (ba) LOAD NPC 0b at 49 79");
                    }
                } else {
                    if(flags is Word) {
                        code(0xa2, 0x0000 + enemy * 0x02, 0x0000 + flags, calculate((x) * 0x0008), calculate((y) * 0x0008), "// (a2) SPAWN NPC 0x00ca>>1, flags 0x20, x:$23b9, y:$23bb");
                    } else {
                        code(0xa2, 0x0000 + enemy * 0x02, 0x0000, calculate(x * 0x0008), calculate(y * 0x0008), "// (a2) SPAWN NPC 0x00ca>>1, flags 0x20, x:$23b9, y:$23bb");
                    }
                }
            }

            fun _add_placeholder(animation:ANIMATION_PLACEHOLDER, x, y, mode:ANIMATION_MODE) {
                _add_enemy(PLACEHOLDER, x, y, INVINCIBLE);
                
                if(mode is Word) {
                    animate(LAST_ENTITY, mode, animation);
                } else {
                    animate(LAST_ENTITY, LOOP, animation);
                }
            }
            fun add_placeholder(animation:ANIMATION_PLACEHOLDER, x, y, mode:ANIMATION_MODE) {
                add_enemy(PLACEHOLDER, x, y, INVINCIBLE);
                
                if(mode is Word) {
                    animate(LAST_ENTITY, mode, animation);
                } else {
                    animate(LAST_ENTITY, LOOP, animation);
                }
            }

            fun add_enemy_spawner(enemy:ENEMY, x, y, quantity) {
                if(quantity is Word) {
                    MEMORY.ENEMY_SPAWNER_QUANTITY = quantity;
                }

                code(0xc2, enemy, x, y, "// (c2) Add NPC 0x71 spawner at 0x13,0x09");
            }

            fun player_control(character:CHARACTER) {
                code(0x98, entity_t(character), "// (98) SWITCH CHAR TO boy");
            }

            fun available(character:CHARACTER) {
                // TODO: parameter bug
                
                if(character == CHARACTER.BOY) {
                    // teleport(DOG, 0x00, 0x00);
                    
                    unset(FLAG.BOY_UNAVAILABLE);
                    set(FLAG.DOG_UNAVAILABLE);

                    code(0xbd, "// (bd) BOY = Player controlled");
                    player_control(character);
                    code(0xbe, "// (be) Stop/disable doggo (and SELECT button)");
                } else if(character == CHARACTER.DOG) {
                    // teleport(BOY, 0x00, 0x00);
                    
                    set(FLAG.BOY_UNAVAILABLE);
                    unset(FLAG.DOG_UNAVAILABLE);

                    code(0xbf, "// (bf) DOG = Player controlled");
                    player_control(character);
                    code(0xbc, "// (bc) Stop/disable boy (and SELECT button)");
                } else if(character == CHARACTER.BOTH) {
                    unset(FLAG.BOY_UNAVAILABLE);
                    unset(FLAG.DOG_UNAVAILABLE);

                    code(0xc1, "// (c1) BOY+DOG = Player controlled");
                } else if(character == CHARACTER.NONE) {
                    set(FLAG.BOY_UNAVAILABLE);
                    set(FLAG.DOG_UNAVAILABLE);

                    // code(0xbe, "// (be) Stop/disable doggo (and SELECT button)");
                    // code(0xbc, "// (bc) Stop/disable boy (and SELECT button)");
                }
            }

            fun clear_status_effects() {
                code(0xaa, "// (aa) Clear boy and dog statuses");
            }

            fun cure() {
                code(0xaa, "// (aa) Clear boy and dog statuses");
            }

            fun heal(character:CHARACTER, amount, animation) {
                if(animation == False) {
                    if(character == CHARACTER.BOTH) {
                        code(0x95, entity_t(BOY), param(amount), "// (95) HEAL dog FOR 0x03e7 = 999");
                        code(0x95, entity_t(DOG), param(amount), "// (95) HEAL dog FOR 0x03e7 = 999");
                    } else {
                        code(0x95, entity_t(character), param(amount), "// (95) HEAL dog FOR 0x03e7 = 999");
                    }
                } else {
                    if(character == CHARACTER.BOTH) {
                        code(0x94, entity_t(BOY), 0x08, 0x8d, 0x01, 0x29, 0x3f, 0x1a, 0xd5, "// (94) HEAL boy FOR *($23e5 + 15) WITH ANIMATION = health");
                        code(0x94, entity_t(DOG), 0x08, 0x8f, 0x01, 0x29, 0x3f, 0x1a, 0xd5, "// (94) HEAL dog FOR *($23e7 + 15) WITH ANIMATION = health");
                    } else if(character == CHARACTER.BOY) {
                        code(0x94, entity_t(BOY), 0x08, 0x8d, 0x01, 0x29, 0x3f, 0x1a, 0xd5, "// (94) HEAL boy FOR *($23e5 + 15) WITH ANIMATION = health");
                    } else if(character == CHARACTER.DOG) {
                        code(0x94, entity_t(DOG), 0x08, 0x8f, 0x01, 0x29, 0x3f, 0x1a, 0xd5, "// (94) HEAL dog FOR *($23e7 + 15) WITH ANIMATION = health");
                    } else {
                        code(0x94, entity_t(character), param(amount), "// (94) HEAL dog FOR *($23e7 + 15) WITH ANIMATION = health");
                    }
                }
            }
            fun full_heal(character:CHARACTER, animation) {
                if(animation == False) {
                    heal(character, 0d999, animation);
                } else {
                    heal(character, 0x00, animation);
                }
            }

            fun select_alchemy(alchemy_index:ALCHEMY_PRESELECT_INDEX) {
                if(alchemy_index is Word) {
                    MEMORY.ALCHEMY_REWARD_PRESELECTION = alchemy_index;
                }
                code(0x63, "// (63) SHOW ALCHEMY SELECTION SCREEN");
            }

            fun cast(character:CHARACTER, target:CHARACTER, spell:CAST, level) {
                if(target == CHARACTER.BOTH) {
                    code(0xac, entity_t(character), param(spell), param(level), entity_t(BOY), entity_t(DOG), 0xb0, "// (ac) $283d CASTS SPELL 22 POWER 0x64 ON boy if alive");
                } else {
                    code(0xac, entity_t(character), calculate(spell), calculate(level), entity_t(target), 0xb0, "// (ac) $283d CASTS SPELL 22 POWER 0x64 ON boy if alive");
                }
            }

            fun _face(character, direction:FACE_DIRECTION) {
                character[FACE_DIRECTION] = direction;
            }
            fun face(character:CHARACTER, direction:DIRECTION) {
                if(direction == DIRECTION.NORTH) {
                    code(0x74, entity_t(character), "// (74) MAKE boy FACE NORTH");
                } else if(direction == DIRECTION.EAST) {
                    code(0x77, entity_t(character), "// (77) MAKE boy FACE EAST");
                } else if(direction == DIRECTION.SOUTH) {
                    code(0x75, entity_t(character), "// (75) MAKE boy FACE SOUTH");
                } else if(direction == DIRECTION.WEST) {
                    code(0x76, entity_t(character), "// (76) MAKE boy FACE WEST");
                }
            }

            fun face_each(character:CHARACTER, character2:CHARACTER) {
                code(0x71, entity_t(character), entity_t(character2), "// (71) Make $2835 and controlled char face each other");
            }
            fun face_target(character:CHARACTER, target:CHARACTER) {
                code(0x70, entity_t(character), entity_t(target), "// (70) Make $2835 face boy");
            }

            fun attach_script(character:CHARACTER, flag:SCRIPT_TRIGGER, id) {
                if(flag == SCRIPT_TRIGGER.B) {
                    if(character == CHARACTER.BOTH) {
                        code(0x3d, entity_t(BOY), 0x0000 + id, "// (3d) WRITE $285b+x66=0x1b72, $285b+x68=0x0040 (talk script): Prof. Ruffelburg");
                        code(0x3d, entity_t(DOG), 0x0000 + id, "// (3d) WRITE $285b+x66=0x1b72, $285b+x68=0x0040 (talk script): Prof. Ruffelburg");
                    } else {
                        code(0x3d, entity_t(character), 0x0000 + id, "// (3d) WRITE $285b+x66=0x1b72, $285b+x68=0x0040 (talk script): Prof. Ruffelburg");
                    }
                } else {
                    if(character == CHARACTER.BOTH) { // TODO: forced_memory=True when character=<memory>
                        code(0x3f, entity_t(BOY), 0x0000 + flag, 0x0000 + id, "// (3f) WRITE last entity ($0341)+x68=0x300, last entity ($0341)+x66=0x181e (set script): Magmar damage");
                        code(0x3f, entity_t(DOG), 0x0000 + flag, 0x0000 + id, "// (3f) WRITE last entity ($0341)+x68=0x300, last entity ($0341)+x66=0x181e (set script): Magmar damage");
                    } else {
                        code(0x3f, entity_t(character), 0x0000 + flag, 0x0000 + id, "// (3f) WRITE last entity ($0341)+x68=0x300, last entity ($0341)+x66=0x181e (set script): Magmar damage");
                    }
                }
            }

            fun destroy(character:CHARACTER) {
                if(character > 0x00) {
                    code(0x9b, entity_t(character), "// (9b) DESTROY/DEALLOC ENTITY $283e");
                }
            }

            fun damage(character:CHARACTER, value, animation, no_knockbac) {
                if(no_knockbac is Word) {
                    if(no_knockbac > 0d0) {
                        MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                    }
                }

                if(animation) {
                    if(character == CHARACTER.BOTH) {
                        code(0x92, entity_t(BOY), param(value), "// (92) DAMAGE boy FOR 5 WITH ANIMATION");
                        code(0x92, entity_t(DOG), param(value), "// (92) DAMAGE boy FOR 5 WITH ANIMATION");
                    } else {
                        code(0x92, entity_t(character), param(value), "// (92) DAMAGE boy FOR 5 WITH ANIMATION");
                    }
                } else {
                    if(character == CHARACTER.BOTH) {
                        code(0x93, entity_t(BOY), param(value), "// (93) DAMAGE $2843 FOR 0x03e8");
                        code(0x93, entity_t(DOG), param(value), "// (93) DAMAGE $2843 FOR 0x03e8");
                    } else {
                        code(0x93, entity_t(character), param(value), "// (93) DAMAGE $2843 FOR 0x03e8");
                    }
                }
            }

            fun reset_general_purpose(entity) {
                entity[GENERAL_PURPOSE] = 0d0;
            }

            fun attribute_bit(character:CHARACTER, attribute:ATTRIBUTE_BITS) {
                code(0xa9, entity_t(character), param(attribute), "// (a9) UNTRACED INSTR modifies entity dog bits 0x20");
            }

            fun attribute(character:CHARACTER, attribute:ATTRIBUTE_BITS, on) {
                if(attribute == ATTRIBUTE_BITS.INVINCIBLE) {
                    if(on) {
                        attribute_bit(character, INVINCIBLE);
                    } else {
                        attribute_bit(character, VINCIBLE);
                    }
                } else if(attribute == ATTRIBUTE_BITS.INVINCIBLE_TEMP) {
                    if(on) {
                        attribute_bit(character, INVINCIBLE_TEMP);
                    } else {
                        attribute_bit(character, VINCIBLE_TEMP);
                    }
                } else if(attribute == ATTRIBUTE_BITS.ROOT) {
                    if(on) {
                        attribute_bit(character, ROOT);
                    } else {
                        attribute_bit(character, UNROOT);
                    }
                } else if(attribute == ATTRIBUTE_BITS.UNKNOWN_1_2) {
                    if(on) {
                        attribute_bit(character, UNKNOWN_1_2);
                    } else {
                        attribute_bit(character, UNKNOWN_1_1);
                    }
                } else if(attribute == ATTRIBUTE_BITS.NO_CLIP) {
                    if(on) {
                        attribute_bit(character, NO_CLIP);
                    } else {
                        attribute_bit(character, CLIP);
                    }
                } else if(attribute == ATTRIBUTE_BITS.UNKNOWN_2_1) {
                    if(on) {
                        attribute_bit(character, UNKNOWN_2_1);
                    } else {
                        attribute_bit(character, UNKNOWN_2_2);
                    }
                } else if(attribute == ATTRIBUTE_BITS.INVISIBLE) {
                    if(on) {
                        attribute_bit(character, INVISIBLE);
                    } else {
                        attribute_bit(character, VISIBLE);
                    }
                } else if(attribute == ATTRIBUTE_BITS.MUTE) {
                    if(on) {
                        attribute_bit(character, MUTE);
                    } else {
                        attribute_bit(character, UNMUTE);
                    }
                } else if(attribute == ATTRIBUTE_BITS.AI_RUN) {
                    if(on) {
                        attribute_bit(character, AI_RUN);
                    } else {
                        attribute_bit(character, AI_WALK);
                    }
                }
            }

            fun heel(character) {
                eval("18 61 01 50 29 6a 1a d5 // (18) WRITE $23b9 = boy.x");
                eval("18 63 01 50 29 6c 1a d5 // $23bb = boy.y");

                code(0xaf, 0x04, entity_t(character), entity_t(0x23b9), entity_t(0x23bb), 0xd0 + 0x14, address(0x99cc1e), "// (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");
            }

            fun _drag(enemy:CHARACTER, x, y, z) {
                // eval("af 04 8d 02 00 88 61 01 88 63 01 e0 1e cc 03 // (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");

                if(z is Word) {
                    code(0xaf, 0x04, entity_t(enemy), calculate(x), calculate(y), calculate(z), address(0x99cc1e), "// (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");
                } else {
                    code(0xaf, 0x04, entity_t(enemy), calculate(x), calculate(y), 0xd0 + 0x14, address(0x99cc1e), "// (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");
                }
            }
            fun drag(enemy:CHARACTER, x, y, z) {
                // eval("af 04 8d 02 00 88 61 01 88 63 01 e0 1e cc 03 // (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");

                if(z is Word) {
                    code(0xaf, 0x04, entity_t(enemy), calculate(x << 0d0003), calculate(y << 0d0003), calculate(z), address(0x99cc1e), "// (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");
                } else {
                    code(0xaf, 0x04, entity_t(enemy), calculate(x << 0d0003), calculate(y << 0d0003), 0xd0 + 0x14, address(0x99cc1e), "// (af) CALL Absolute (24bit) script 0x99cc1e ('Unnamed ABS script 0x99cc1e') WITH 4 ARGS $2836, $23b9, $23bb, 20");
                }
            }
        };

        group projectile() {
            fun projectile(source:CHARACTER, throwable:THROWABLE, source_x, source_y, target_x, target_y, z, overshoot) {
                // (b5) REVEAL ENTITY?? args 26 $2869 $24ab + 20 $24af - 0x30 0 signed arg0 signed arg2 0x3c // thraxx eye
                // (b5) REVEAL ENTITY?? args 26 boy $2890 $2894 0 $2898 $289a 30 // aegis
                // (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20 // vigor mob
                // (b5) REVEAL ENTITY?? args 26 boy $2839 $283b 0 $283d - 8 $283f 1 // professor
                // (b5) REVEAL ENTITY?? args 26 boy $24ab $24af - 0x28 0 $2861 $2863 - 16 0x78 // boss rush

                // (b5) REVEAL ENTITY?? args 28 boy signed arg0 signed arg2 0 0x32 0x32 0 // bomb 1
                // (b5) REVEAL ENTITY?? args 28 entity attached to script? signed arg0 signed arg2 0 0x32 0x28 0 // bomb 2

                // (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20 // vigor mob
                // (b5) REVEAL ENTITY?? args 30 entity attached to script? signed arg0 signed arg2 0x0140 signed arg0 signed arg2 + 0x20 0 // carltron missile
                // (b5) REVEAL ENTITY?? args 28 entity attached to script? signed arg10 signed arg12 0 0x46 0x32 0 // carltron stomp

                code(0xb5, param(throwable), entity_t(source), calculate(source_x), calculate(source_y), param(overshoot), calculate(target_x), calculate(target_y), param(z), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }

            fun shoot_entity_absolute(entity:CHARACTER, projectile:THROWABLE, x, y, z, overshoot) {
                code(0xb5, param(projectile), entity_t(entity), calculate(entity[X]), calculate(entity[Y]), param(overshoot), calculate(x), calculate(y), calculate(z), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }
            fun shoot_entity_relative(entity:CHARACTER, projectile:THROWABLE, x, y, z, overshoot) {
                code(0xb5, param(projectile), entity_t(entity), calculate(entity[X]), calculate(entity[Y]), param(overshoot), calculate(entity[X] + x), calculate(entity[Y] + y), calculate(z), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }
            fun shoot_entity_entity(entity:CHARACTER, projectile:THROWABLE, target:CHARACTER, z, overshoot) { // TODO: target=BOY crashes
                code(0xb5, param(projectile), entity_t(entity), calculate(entity[X]), calculate(entity[Y]), param(overshoot), calculate(target[X]), calculate(target[Y]), calculate(z), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }
            fun shoot_entity_entity_offset(entity:CHARACTER, projectile:THROWABLE, target:CHARACTER, offset_x, offset_y, z, overshoot) { // TODO: target=BOY crashes
                code(0xb5, param(projectile), entity_t(entity), calculate(entity[X]), calculate(entity[Y]), param(overshoot), calculate(target[X] + offset_x), calculate(target[Y] + offset_y), calculate(z), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }

            fun shoot_entity_offset_relative(entity:CHARACTER, projectile:THROWABLE, offset_x, offset_y, x, y, z, overshoot) {
                code(0xb5, param(projectile), entity_t(entity), calculate(entity[X] + offset_x), calculate(entity[Y] + offset_y), param(overshoot), calculate(entity[X] + (offset_x + x)), calculate(entity[Y] + (offset_y + y)), param(z), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }

            fun bomb_absolute(entity:CHARACTER, x, y, size, damage) {
                if(damage is Word) {
                    MEMORY.NEXT_PROJECTILE_DAMAGE = damage;
                }
                
                code(0xb5, param(THROWABLE.BOMB_EXPLOSION), entity_t(entity), calculate(x), calculate(y), param(0x00), param(size), param(size), param(0x00), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }
            fun bomb_entity(entity:CHARACTER, size, damage) {
                if(damage is Word) {
                    MEMORY.NEXT_PROJECTILE_DAMAGE = damage;
                }

                code(0xb5, param(THROWABLE.BOMB_EXPLOSION), entity_t(entity), calculate(entity[X]), calculate(entity[Y]), param(0x00), param(size), param(size), param(0x00), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }
            fun bomb_entity_entity(entity:CHARACTER, entity_target:CHARACTER, size, damage) {
                if(damage is Word) {
                    MEMORY.NEXT_PROJECTILE_DAMAGE = damage;
                }
                
                code(0xb5, param(THROWABLE.BOMB_EXPLOSION), entity_t(entity), calculate(entity_target[X]), calculate(entity_target[Y]), param(0x00), param(size), param(size), param(0x00), "// (b5) REVEAL ENTITY?? args $2849 $2835 $2477 $2479 10 signed arg4 signed arg6 20");
            }
        };

        group strings() {
            fun font(font:FONT) {
                code(0x9a, param(font), "// (9a) CHANGE FONT TO 2");
            }

            fun await_answer() {
                // eval("1d 69 00 30 ac // (1d) WRITE $289d = Dialog response (preselect 0)");

                code(0x1d, 0x289d - 0x2834, 0xac30, "// (1d) WRITE $289d = Dialog response (preselect 0)");
            }

            fun open_message_box(type:MESSAGE_BOX_TYPE, x, y, w, h) {
                if(type == MESSAGE_BOX_TYPE.DEFAULT) {
                    code(0x44, 0x00, x, y, w, h, "// (44) UNTRACED INSTR, Open messagebox? slot=0x00 x=0x0a y=0x02 w=0x14 h=0x0c");
                } else {
                    code(0x47, 0x00, x, y, w, h, "// (47) UNTRACED INSTR, Open messagebox? slot=0x00 x=0x04 y=0x04 w=0x18 h=0x14");
                }
            }

            fun text_start() {
                control(NONE); // TODO: ACTIVE only?

                if(True) {
                    call_id(OPEN_TEXTBOX_DEFAULT);
                } else {
                    open_message_box(DEFAULT, 0x0a, 0x02, 0x14, 0x07);
                }
            }
            fun text(id) {
                code(0x51, install_string(id), "// (51) SHOW TEXT 10bf FROM 0x91e0bf compressed WINDOWED c14dd8> '[0x97][0x8b]Goat[LF]' '[0x8b]Chicken[LF]' '[0x8b]Basket'");
            }
            fun text_end() {
                code(0x55, "// (55) CLEAR TEXT");
            }
            fun text_box(x, lines) {
                if(lines == 0d01) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d02);
                } else if(lines == 0d02) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d04);
                } else if(lines == 0d03) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d05);
                } else if(lines == 0d04) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d07);
                } else if(lines == 0d05) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d08);
                } else if(lines == 0d06) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d10);
                } else if(lines == 0d07) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d11);
                } else if(lines == 0d08) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d13);
                } else if(lines == 0d09) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d14);
                } else if(lines == 0d10) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d16);
                } else if(lines == 0d11) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d17);
                } else if(lines == 0d12) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d19);
                } else if(lines == 0d13) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d20);
                } else if(lines == 0d14) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d22);
                } else if(lines == 0d15) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d23);
                } else if(lines == 0d16) {
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d25);
                } else if(lines == 0d17) { // too big
                    open_message_box(DEFAULT, x, 0x02, 0x14, 0d26);
                } else {
                    open_message_box(DEFAULT, x, 0d2, 0d20, 0d7);
                }
            }
            fun smart_text_box(entity, lines) {
                if(<ACTIVE>[X] > entity[X]) {
                    text_box(0d2, lines);
                } else {
                    text_box(0d10, lines);
                }
            }

            fun subtext(id) {
                code(0x52, install_string(id), "// (52) SHOW TEXT 066f FROM 0x91d66f compressed UNWINDOWED c03ad9> 'Received Jaguar Ring'");
            }
            fun clear_subtext() {
                // TODO: clear + disable?

                code(0x5a, "// (5a) UNTRACED INSTR, checking message timer");
            }
            fun enable_subtext(enable) {
                if(enable) {
                    code(0x80, "// (80) UNHIDE? UNWINDOWED TEXT");
                } else {
                    code(0x81, "// (81) HIDE UNWINDOWED TEXT");
                }
            }

            fun _question(id, lines) {
                if(lines is Word) {
                    text_box(0d10, lines);
                } else {
                    text_box(0d10, 0d4);
                }
                text(id);
                await_answer();
                text_end();
            }
            fun question(id, lines) {
                control(NONE);

                if(lines is Word) {
                    _question(id, lines);
                } else {
                    _question(id);
                }

                control(BOTH);
            }

            fun _dialog(id) {
                text_start();

                text(id);

                text_end();
            }
            fun dialog(id) {
                _dialog(id);

                control(BOTH);
            }

            fun conversation_start(face_each_other) {
                if(False) {
                    if(<ACTIVE>[Z_LEVEL] != npc[Z_LEVEL]) {
                        end();
                    }
                }
                if(script[0x9] == 0x200) {
                    end();
                }

                clear_subtext();

                control(NONE); // TODO: ACTIVE only?
                
                if(face_each_other is Word) {
                    if(face_each_other) {
                        // arg[0x0e] = entity[FACE_DIRECTION];

                        control(SCRIPT_OWNER, True);

                        face_each(ACTIVE, SCRIPT_OWNER);
                    } else {
                        face_target(ACTIVE, SCRIPT_OWNER);
                    }
                } else {
                    face_target(ACTIVE, SCRIPT_OWNER);
                }
            }
            fun conversation_end(face_each_other) {
                control(BOTH);

                if(face_each_other is Word) {
                    if(face_each_other) {
                        control(SCRIPT_OWNER, False);
                    }
                }
            }
            fun conversation(face_each_other, callback) {
                conversation_start(face_each_other);

                callback();

                conversation_end(face_each_other);
            }
            fun conversation_dialog(id, lines) {
                if(lines is Word) {
                    smart_text_box(<SCRIPT_OWNER>, lines);
                } else {
                    smart_text_box(<SCRIPT_OWNER>, 0d4);
                }
                text(id);
                text_end();
            }
            fun conversation_question(id, lines) {
                if(lines is Word) {
                    smart_text_box(<SCRIPT_OWNER>, lines);
                } else {
                    smart_text_box(<SCRIPT_OWNER>, 0d4);
                }
                text(id);
                await_answer();
                text_end();
            }

            @install()
            @weak()
            fun print_time() {
                arg[0x10] = time[0d0];
                arg[0x12] = time[0d2];

                modulo(arg[0x10], 0d60, arg[0x16]); // frames->seconds
                arg[0x14] = arg[0x10]; // frames

                modulo(arg[0x16], 0d60, arg[0x18]); // seconds->minutes

                modulo(arg[0x18], 0d60, arg[0x1a]); // minutes->hours

                if(True) {
                    while(arg[0x12] > 0d0) {
                        arg[0x12]--;

                        // 18m + 12s + 16f

                        arg[0x18] += 0d18;
                        arg[0x16] += 0d12;
                        arg[0x14] += 0d16;
                    }

                    modulo(arg[0x14], 0d60, arg[0x16]); // frames->seconds
                    modulo(arg[0x16], 0d60, arg[0x18]); // seconds->minutes
                    modulo(arg[0x18], 0d60, arg[0x1a]); // minutes->hours
                }

                MEMORY.STRING_PARAMETER_1 = arg[0x1a];
                MEMORY.STRING_PARAMETER_2 = arg[0x18];
                MEMORY.STRING_PARAMETER_3 = arg[0x16];

                if(True) {
                    text("[MEM1]:[MEM2]:[MEM3]");
                }
            }

            fun outro_start() {
                // example: outro_text_box("header[LF]", "text1[LF]text2");

                fade_out();
                sleep(0d15);

                hide_non_dialog_layers();

                open_message_box(TRANSPARENT_CENTERED, 0x04, 0x04, 0x18, 0x14);

                brightness(0d0);
                sleep(0d4);
                _fade_in();
            }
            fun outro_end(stay_open) {
                if(False) {
                    call_id(FADE_OUT_CREDITS);
                } else {
                    if(True) { // stay_open !is Word
                        sleep(0d600);
                        fade_out();
                        text_end();
                    }
                }
            }
            fun outro_text_box(text_header, text_content, stay_open) {
                outro_start();

                font(OUTRO);
                text(text_header);

                font(DEFAULT);
                text(text_content);

                outro_end(False);
            }
            fun outro_stats(progress, bosses, collectibles, stay_open) {
                outro_start();

                font(OUTRO);
                text("Time:[LF]");

                font(DEFAULT);
                print_time();

                sleep(0d120);

                if(True) {
                    font(OUTRO);
                    text("[LF][LF]Progress:[LF]");

                    font(DEFAULT);
                    MEMORY.STRING_PARAMETER_1 = progress;
                    text("[MEM1]");

                    sleep(0d120);
                }

                if(True) {
                    font(OUTRO);
                    text("[LF][LF]Bosses:[LF]");

                    font(DEFAULT);
                    MEMORY.STRING_PARAMETER_1 = bosses;
                    text("[MEM1]");

                    sleep(0d120);
                }

                if(True) {
                    font(OUTRO);
                    text("[LF][LF]Collectibles:[LF]");

                    font(DEFAULT);
                    MEMORY.STRING_PARAMETER_1 = collectibles;
                    text("[MEM1]");

                    sleep(0d120);
                }

                outro_end(False);
            }

            fun debug_marker() {
                <0x2834> = 0xffff;
            }

            fun debug_subtext(text) {
                if(SYSTEM.WITH_DEBUG_SUBTEXT) {
                    if(False) {
                        open_message_box(TRANSPARENT_CENTERED, 0x01, 0x01, 0x10, 0x04);
                        
                        text(text);

                        text_end();
                    } else {
                        font(OUTRO);
                        subtext(text);
                        yield();
                        font(DEFAULT);
                    }
                }
            }
            fun debug_z_level() {
                while(True) {
                    MEMORY.STRING_PARAMETER_1 = <BOY>[Z_LEVEL] & 0xff;
                    MEMORY.STRING_PARAMETER_2 = <DOG>[Z_LEVEL] & 0xff;

                    debug_subtext("z_level = [MEM1] / [MEM2]");

                    sleep(0d10);
                }
            }
            fun debug_tile() {
                while(True) {
                    MEMORY.STRING_PARAMETER_1 = <BOY>[CURRENT_GROUND] & 0xff;
                    MEMORY.STRING_PARAMETER_2 = <DOG>[CURRENT_GROUND] & 0xff;

                    debug_subtext("tile = [MEM1] / [MEM2]");

                    sleep(0d10);
                }
            }

            fun debug_status_effects_helper() {
                set(FLAG.ATLAS);
                MEMORY.SELECTED_ALCHEMY_0 = ALCHEMY_INDEX.ATLAS;
                set(FLAG.BARRIER);
                MEMORY.SELECTED_ALCHEMY_1 = ALCHEMY_INDEX.BARRIER;
                set(FLAG.DEFEND);
                MEMORY.SELECTED_ALCHEMY_2 = ALCHEMY_INDEX.DEFEND;

                set(FLAG.ENERGIZE);
                MEMORY.SELECTED_ALCHEMY_3 = ALCHEMY_INDEX.ENERGIZE;
                set(FLAG.FORCE_FIELD);
                MEMORY.SELECTED_ALCHEMY_4 = ALCHEMY_INDEX.FORCE_FIELD;
                set(FLAG.SPEED);
                MEMORY.SELECTED_ALCHEMY_5 = ALCHEMY_INDEX.SPEED;
            }
        };

        group currency() {
            fun currency_get(type:CURRENCY, amount) {
                if(amount is Word) {
                    code(0x7c, param(type), 0x000000 + amount, "// (7c) Give 50 Talons (moniez)");
                } else {
                    code(0x84, param(type), calculate(amount), "// (84) Give $2393 Credits (moniez)");
                }
            }
            fun currency_take(type:CURRENCY, amount) {
                if(amount is Word) {
                    code(0x7d, param(type), 0x000000 + amount, "// (7d) Take 10 Talons (moniez)");
                } else {
                    code(0x85, param(type), calculate(amount), "// (85) Take $2447 Jewels (moniez)");
                }
            }
            fun currency_convert(from_amount, from_type:CURRENCY, to_amount, to_type:CURRENCY) {
                code(0x7e, param(from_amount), param(from_type), param(to_amount), param(to_type), "// (7e) Exchange 1 Gold Coins to 8 Credits (moniez)");
            }
            fun show_currency(show) {
                if(show == True) {
                    enable_subtext(False);
                    yield();

                    if(False) {
                        code(0x55, "// (55) CLEAR TEXT"); // TODO: workaround, in case a subtext is being shown and would cause a crash
                        yield();
                    }

                    code(0x9f, "// (9f) PREPARE CURRENCY DISPLAY");
                    code(0xa0, "// (a0) SHOW CURRENCY AMOUNT");
                } else {
                    code(0xa1, "// (a1) HIDE CURRENCY DISPLAY");
                    enable_subtext(True);
                }
            }
        };

        group items() {
            fun fanfare_start() {
                control(NONE);

                music_fade(True);
            }
            fun fanfare_end() {
                sleep(0x08);

                call(0x92bf33); // (29) CALL 0x92bf33 Hold up weapon

                sleep(0d200);

                control(BOTH);

                // MEMORY.CHANGE_MUSIC = 0x01; // TODO: should change music directly
            }

            fun fanfare_boss(push_music) {
                fanfare_start();

                if(push_music is Word) {
                    if(push_music) {
                        push_music(FANFARE);
                    } else {
                        play_music(FANFARE);
                    }
                } else {
                    play_music(FANFARE);
                }

                fanfare_end();
            }
            fun fanfare_item(push_music) {
                fanfare_start();

                if(push_music is Word) {
                    if(push_music) {
                        push_music(FANFARE_ITEM);
                    } else {
                        play_music(FANFARE_ITEM);
                    }
                } else {
                    play_music(FANFARE_ITEM);
                }

                fanfare_end();

                if(push_music is Word) {
                    if(push_music) {
                        pop_music();
                    }
                }
            }

            fun unlock_armor(unlocked) {
                if(unlocked == True) {
                    MEMORY.ARMOR_1_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_1_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_1_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_2_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_2_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_2_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_3_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_3_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_3_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_4_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_4_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMOR_4_3 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_1_1 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_1_2 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_1_3 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_2_1 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_2_2 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_2_3 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_3_1 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_3_2 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_3_3 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_4_1 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_4_2 = SYSTEM.ITEM_MAX;
                    MEMORY.HELM_4_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_1_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_1_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_1_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_2_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_2_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_2_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_3_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_3_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_3_3 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_4_1 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_4_2 = SYSTEM.ITEM_MAX;
                    MEMORY.ARMBAND_4_3 = SYSTEM.ITEM_MAX;
                    MEMORY.COLLAR_1 = SYSTEM.ITEM_MAX;
                    MEMORY.COLLAR_2 = SYSTEM.ITEM_MAX;
                    MEMORY.COLLAR_3 = SYSTEM.ITEM_MAX;
                    MEMORY.COLLAR_4 = SYSTEM.ITEM_MAX;
                } else {
                    MEMORY.ARMOR_1_1 = 0x00;
                    MEMORY.ARMOR_1_2 = 0x00;
                    MEMORY.ARMOR_1_3 = 0x00;
                    MEMORY.ARMOR_2_1 = 0x00;
                    MEMORY.ARMOR_2_2 = 0x00;
                    MEMORY.ARMOR_2_3 = 0x00;
                    MEMORY.ARMOR_3_1 = 0x00;
                    MEMORY.ARMOR_3_2 = 0x00;
                    MEMORY.ARMOR_3_3 = 0x00;
                    MEMORY.ARMOR_4_1 = 0x00;
                    MEMORY.ARMOR_4_2 = 0x00;
                    MEMORY.ARMOR_4_3 = 0x00;
                    MEMORY.HELM_1_1 = 0x00;
                    MEMORY.HELM_1_2 = 0x00;
                    MEMORY.HELM_1_3 = 0x00;
                    MEMORY.HELM_2_1 = 0x00;
                    MEMORY.HELM_2_2 = 0x00;
                    MEMORY.HELM_2_3 = 0x00;
                    MEMORY.HELM_3_1 = 0x00;
                    MEMORY.HELM_3_2 = 0x00;
                    MEMORY.HELM_3_3 = 0x00;
                    MEMORY.HELM_4_1 = 0x00;
                    MEMORY.HELM_4_2 = 0x00;
                    MEMORY.HELM_4_3 = 0x00;
                    MEMORY.ARMBAND_1_1 = 0x00;
                    MEMORY.ARMBAND_1_2 = 0x00;
                    MEMORY.ARMBAND_1_3 = 0x00;
                    MEMORY.ARMBAND_2_1 = 0x00;
                    MEMORY.ARMBAND_2_2 = 0x00;
                    MEMORY.ARMBAND_2_3 = 0x00;
                    MEMORY.ARMBAND_3_1 = 0x00;
                    MEMORY.ARMBAND_3_2 = 0x00;
                    MEMORY.ARMBAND_3_3 = 0x00;
                    MEMORY.ARMBAND_4_1 = 0x00;
                    MEMORY.ARMBAND_4_2 = 0x00;
                    MEMORY.ARMBAND_4_3 = 0x00;
                    MEMORY.COLLAR_1 = 0x00;
                    MEMORY.COLLAR_2 = 0x00;
                    MEMORY.COLLAR_3 = 0x00;
                    MEMORY.COLLAR_4 = 0x00;
                }
            }
            fun unlock_weapons(unlocked) {
                if(unlocked == True) {
                    <0x22DA> = 0xff;
                    <0x22DB> = 0xff;

                    MEMORY.AMMO_1 = 0xff;
                    MEMORY.AMMO_2 = 0xff;
                    MEMORY.AMMO_3 = 0xff;
                } else {
                    <0x22DA> = 0x00;
                    <0x22DB> = 0x00;

                    MEMORY.AMMO_1 = 0x00;
                    MEMORY.AMMO_2 = 0x00;
                    MEMORY.AMMO_3 = 0x00;
                }
            }
            fun unlock_alchemy(unlocked) {
                if(unlocked == True) {
                    <0x2258> = 0xff;
                    <0x2259> = 0xff;
                    <0x225A> = 0xff;
                    <0x225B> = 0xff;
                    <0x225C> = 0xff;
                    <0x225D> = 0xff;
                } else {
                    <0x2258> = 0x00;
                    <0x2259> = 0x00;
                    <0x225A> = 0x00;
                    <0x225B> = 0x00;
                    <0x225C> = 0x00;
                    <0x225D> = 0x00;
                }
            }
            fun unlock_charms(unlocked) {
                if(unlocked == True) {
                    <0x2261> = 0xf4;
                    <0x2262> = 0xff;
                    <0x2263> = 0xff;
                    <0x2264> = 0xff;
                } else {
                    <0x2261> = 0x00;
                    <0x2262> = 0x00;
                    <0x2263> = 0x00;
                    <0x2264> = 0x00;
                }
            }
            fun unlock_consumables(amount) {
                MEMORY.PETAL = amount;
                MEMORY.NECTAR = amount;
                MEMORY.HONEY = amount;
                MEMORY.DOG_BISCUIT = amount;
                MEMORY.WINGS = amount;
                MEMORY.HERBAL_ESSENCE = amount;
                MEMORY.PIXIE_DUST = amount;
                MEMORY.CALL_BEADS = amount;
            }
            fun unlock_ingredients(amount) {
                MEMORY.WAX = amount;
                MEMORY.WATER = amount;
                MEMORY.VINEGAR = amount;
                MEMORY.ROOT = amount;
                MEMORY.OIL = amount;
                MEMORY.MUSHROOM = amount;
                MEMORY.MUD_PEPPER = amount;
                MEMORY.METEORITE = amount;
                MEMORY.LIMESTONE = amount;
                MEMORY.IRON = amount;
                MEMORY.GUNPOWDER = amount;
                MEMORY.GREASE = amount;
                MEMORY.FEATHER = amount;
                MEMORY.ETHANOL = amount;
                MEMORY.DRY_ICE = amount;
                MEMORY.CRYSTAL = amount;
                MEMORY.CLAY = amount;
                MEMORY.BRIMSTONE = amount;
                MEMORY.BONE = amount;
                MEMORY.ATLAS_AMULET = amount;
                MEMORY.ASH = amount;
                MEMORY.ACORN = amount;
            }
            fun unlock_money(amount) {
                currency_get(TALONS, amount);
                currency_get(JEWELES, amount);
                currency_get(GOLD_COINS, amount);
                currency_get(CREDITS, amount);
            }
            // ui breaks with 0xff and 0xffff
            fun unlock_trading_goods(amount) {
                MEMORY.ANNIHILATION_AMULET = amount;
                MEMORY.BEAD = amount;
                MEMORY.CERAMIC_POT = amount;
                MEMORY.CHICKEN = amount;
                MEMORY.GOLDEN_JACKAL = amount;
                MEMORY.JEWELED_SCARAB = amount;
                MEMORY.LIMESTONE_TABLET = amount;
                MEMORY.PERFUME = amount;
                MEMORY.RICE = amount;
                MEMORY.SPICE = amount;
                MEMORY.SPOON = amount;
                MEMORY.TAPESTRY = amount;
                MEMORY.TICKET_FOR_EXHIBITION = amount;
            }
            fun unlock_weapon_level(level) {
                MEMORY.LEVEL_FIST = level;
                MEMORY.LEVEL_BAZOOKA = level;
                MEMORY.LEVEL_1_SWORD = level;
                MEMORY.LEVEL_1_AXE = level;
                MEMORY.LEVEL_1_SPEAR = level;
                MEMORY.LEVEL_2_SWORD = level;
                MEMORY.LEVEL_2_AXE = level;
                MEMORY.LEVEL_2_SPEAR = level;
                MEMORY.LEVEL_3_SWORD = level;
                MEMORY.LEVEL_3_AXE = level;
                MEMORY.LEVEL_3_SPEAR = level;
                MEMORY.LEVEL_4_SWORD = level;
                MEMORY.LEVEL_4_AXE = level;
                MEMORY.LEVEL_4_SPEAR = level;
            }

            fun _unlock(item:ITEM) {
                if(item == ITEM.ACID_RAIN) { // alchemy (32)
                    set(FLAG.ACID_RAIN);
                } else if(item == ITEM.FLASH) {
                    set(FLAG.FLASH);
                } else if(item == ITEM.CRUSH) {
                    set(FLAG.CRUSH);
                } else if(item == ITEM.ATLAS) {
                    set(FLAG.ATLAS);
                } else if(item == ITEM.BARRIER) {
                    set(FLAG.BARRIER);
                } else if(item == ITEM.CALL_UP) {
                    set(FLAG.CALL_UP);
                } else if(item == ITEM.CORROSION) {
                    set(FLAG.CORROSION);
                } else if(item == ITEM.CURE) {
                    set(FLAG.CURE);
                } else if(item == ITEM.DEFEND) {
                    set(FLAG.DEFEND);
                } else if(item == ITEM.DOUBLE_DRAIN) {
                    set(FLAG.DOUBLE_DRAIN);
                } else if(item == ITEM.DRAIN) {
                    set(FLAG.DRAIN);
                } else if(item == ITEM.ENERGIZE) {
                    set(FLAG.ENERGIZE);
                } else if(item == ITEM.ESCAPE) {
                    set(FLAG.ESCAPE);
                } else if(item == ITEM.EXPLOSION) {
                    set(FLAG.EXPLOSION);
                } else if(item == ITEM.FIREBALL) {
                    set(FLAG.FIREBALL);
                } else if(item == ITEM.FIRE_POWER) {
                    set(FLAG.FIRE_POWER);
                } else if(item == ITEM.FORCE_FIELD) {
                    set(FLAG.FORCE_FIELD);
                } else if(item == ITEM.HARD_BALL) {
                    set(FLAG.HARD_BALL);
                } else if(item == ITEM.HEAL) {
                    set(FLAG.HEAL);
                } else if(item == ITEM.LANCE) {
                    set(FLAG.LANCE);
                } else if(item == ITEM.LASER) {
                    set(FLAG.LASER);
                } else if(item == ITEM.LEVITATE) {
                    set(FLAG.LEVITATE);
                } else if(item == ITEM.LIGHTNING_STORM) {
                    set(FLAG.LIGHTNING_STORM);
                } else if(item == ITEM.MIRACLE_CURE) {
                    set(FLAG.MIRACLE_CURE);
                } else if(item == ITEM.NITRO) {
                    set(FLAG.NITRO);
                } else if(item == ITEM.ONE_UP) {
                    set(FLAG.REFLECT);
                } else if(item == ITEM.REGROWTH) {
                    set(FLAG.REGROWTH);
                } else if(item == ITEM.REVEALER) {
                    set(FLAG.REVEALER);
                } else if(item == ITEM.REVIVE) {
                    set(FLAG.REVIVE);
                } else if(item == ITEM.SLOW_BURN) {
                    set(FLAG.SLOW_BURN);
                } else if(item == ITEM.SPEED) {
                    set(FLAG.SPEED);
                } else if(item == ITEM.STING) {
                    set(FLAG.STING);
                } else if(item == ITEM.STOP) {
                    set(FLAG.STOP);
                } else if(item == ITEM.SUPER_HEAL) {
                    set(FLAG.SUPER_HEAL);
                } else if(item == ITEM.DOG_LEVEL_2) { // weapon level (?)
                    MEMORY.LEVEL_DOG = 0x0200;
                } else if(item == ITEM.DOG_LEVEL_3) {
                    MEMORY.LEVEL_DOG = 0x0300;
                } else if(item == ITEM.SWORD_1) { // weapons(4+4+4)
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_1;
                } else if(item == ITEM.SWORD_2) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_2;
                } else if(item == ITEM.SWORD_3) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_3;
                } else if(item == ITEM.SWORD_4) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_4;
                } else if(item == ITEM.AXE_1) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_1;
                } else if(item == ITEM.AXE_2) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_2;
                } else if(item == ITEM.AXE_3) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_3;
                } else if(item == ITEM.AXE_4) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_4;
                } else if(item == ITEM.SPEAR_1) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_1;
                } else if(item == ITEM.SPEAR_2) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_2;
                } else if(item == ITEM.SPEAR_3) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_3;
                } else if(item == ITEM.SPEAR_4) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_4;
                } else if(item == ITEM.ARMOR_POLISH) { // charms (14+6)
                    set(FLAG.ARMOR_POLISH);
                } else if(item == ITEM.CHOCOBO_EGG) {
                    set(FLAG.CHOCOBO_EGG);
                } else if(item == ITEM.INSECT_INCENSE) {
                    set(FLAG.INSECT_INCENSE);
                } else if(item == ITEM.JADE_DISK) {
                    set(FLAG.JADE_DISK);
                } else if(item == ITEM.JAGUAR_RING) {
                    set(FLAG.JAGUAR_RING);
                } else if(item == ITEM.MAGIC_GOURD) {
                    set(FLAG.MAGIC_GOURD);
                } else if(item == ITEM.MOXA_STICK) {
                    set(FLAG.MOXA_STICK);
                } else if(item == ITEM.ORACLE_BONE) {
                    set(FLAG.ORACLE_BONE);
                } else if(item == ITEM.RUBY_HEART) {
                    set(FLAG.RUBY_HEART);
                } else if(item == ITEM.SILVER_SHEATH) {
                    set(FLAG.SILVER_SHEATH);
                } else if(item == ITEM.STAFF_OF_LIFE) {
                    set(FLAG.STAFF_OF_LIFE);
                } else if(item == ITEM.SUN_STONE) {
                    set(FLAG.SUN_STONE);
                } else if(item == ITEM.THUGS_CLOAK) {
                    set(FLAG.THUGS_CLOAK);
                } else if(item == ITEM.WIZARDS_COIN) {
                    set(FLAG.WIZARDS_COIN);
                } else if(item == ITEM.DIAMOND_EYE) {
                    set(FLAG.DIAMOND_EYE);
                } else if(item == ITEM.DIAMOND_EYES) {
                    set(FLAG.DIAMOND_EYES);
                } else if(item == ITEM.GAUGE) {
                    set(FLAG.GAUGE);
                } else if(item == ITEM.WHEEL) {
                    set(FLAG.WHEEL);
                } else if(item == ITEM.QUEENS_KEY) {
                    set(FLAG.QUEENS_KEY);
                } else if(item == ITEM.ENERGY_CORE) {
                    set(FLAG.ENERGY_CORE);
                } else if(item == ITEM.PETAL) { // consumables (8)
                    MEMORY.PETAL++;
                } else if(item == ITEM.NECTAR) {
                    MEMORY.NECTAR++;
                } else if(item == ITEM.HONEY) {
                    MEMORY.HONEY++;
                } else if(item == ITEM.BISCUIT) {
                    MEMORY.DOG_BISCUIT++;
                } else if(item == ITEM.WINGS) {
                    MEMORY.WINGS++;
                } else if(item == ITEM.HERBAL_ESSENCE) {
                    MEMORY.HERBAL_ESSENCE++;
                } else if(item == ITEM.PIXIE_DUST) {
                    MEMORY.PIXIE_DUST++;
                } else if(item == ITEM.CALL_BEADS) {
                    MEMORY.CALL_BEADS++;
                } else if(item == ITEM.MONEY) { // misc
                    unlock_money(0d6666666);
                } else if(item == ITEM.ALL) { // groups
                    unlock_money(0d6666666);
                    unlock_alchemy(True);
                    unlock_charms(True);
                    unlock_trading_goods(0x0063);
                    unlock_ingredients(SYSTEM.ITEM_MAX);
                    unlock_consumables(SYSTEM.ITEM_MAX);
                    unlock_armor(True);
                    unlock_weapons(True);
                } else if(item == ITEM.TRADING_GOODS) {
                    unlock_trading_goods(0x0063);
                } else if(item == ITEM.CONSUMABLES) {
                    unlock_consumables(SYSTEM.ITEM_MAX);
                } else if(item == ITEM.ALCHEMY) {
                    unlock_alchemy(True);
                } else if(item == ITEM.WEAPONS) {
                    unlock_weapons(True);
                } else if(item == ITEM.ARMOR) {
                    unlock_armor(True);
                } else if(item == ITEM.CHARMS) {
                    unlock_charms(True);
                } else if(item == ITEM.BASICS) {
                    set(FLAG.JAGUAR_RING);
                    MEMORY.GAIN_WEAPON = 0x14;
                } else if(item == ITEM.INGREDIENTS) {
                    unlock_ingredients(SYSTEM.ITEM_MAX);
                } else if(item == ITEM.WEAPON_LEVEL_2) {
                    unlock_weapon_level(0x0200);
                } else if(item == ITEM.WEAPON_LEVEL_3) {
                    unlock_weapon_level(0x0300);
                }
            }
            @install()
            @weak()
            fun unlock(item:ITEM) {
                _unlock(item);
            }

            fun _reward(item:ITEM, without_fanfare) {
                if(item == ITEM.ARMOR_POLISH) { // charms
                    subtext("Armor Polish"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.CHOCOBO_EGG) {
                    subtext("Chocobo Egg"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.INSECT_INCENSE) {
                    subtext("Insect Incense"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.JADE_DISK) {
                    subtext("Jade Disk"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.JAGUAR_RING) {
                    subtext("Jaguar Ring"); // subtext(0x066f);
                    
                    unlock(item);
                } else if(item == ITEM.MAGIC_GOURD) {
                    subtext("Magic Gourd"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.MOXA_STICK) {
                    subtext("Moxa Stick"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.ORACLE_BONE) {
                    subtext("Oracle Bone"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.RUBY_HEART) {
                    subtext("Ruby Heart"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.SILVER_SHEATH) {
                    subtext("Silver Sheath"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.STAFF_OF_LIFE) {
                    subtext("Staff of Life"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.SUN_STONE) {
                    subtext("Sun Stone"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.THUGS_CLOAK) {
                    subtext("Thug's Cloak"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.WIZARDS_COIN) {
                    subtext("Wizard's Coin"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.DIAMOND_EYE) {
                    subtext("Diamond Eye"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.DIAMOND_EYES) {
                    subtext("Diamond Eyes"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.GAUGE) {
                    subtext("Gauge"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.WHEEL) {
                    subtext("Wheel"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.QUEENS_KEY) {
                    subtext("Queen's Key"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.ENERGY_CORE) {
                    subtext("Energy Core"); // ?
                    
                    unlock(item);
                } else if(item == ITEM.SWORD_1) { // weapons
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_1;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.SWORD_2) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_2;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.SWORD_3) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_3;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.SWORD_4) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SWORD_4;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.AXE_1) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_1;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.AXE_2) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_2;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.AXE_3) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_3;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.AXE_4) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.AXE_4;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.SPEAR_1) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_1;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.SPEAR_2) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_2;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.SPEAR_3) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_3;
                    // unlock(item);
                    
                    // subtext(0x2247);
                } else if(item == ITEM.SPEAR_4) {
                    MEMORY.GAIN_WEAPON = GAIN_WEAPON.SPEAR_4;
                    
                    // subtext(0x05b8);
                } else if(item == ITEM.ACID_RAIN) { // alchemy
                    unlock(item);
                    
                    subtext("Learned Acid Rain"); // subtext(0x059d);
                } else if(item == ITEM.ATLAS) {
                    set(FLAG.ATLAS);
                    
                    subtext("Learned Atlas");
                } else if(item == ITEM.BARRIER) {
                    set(FLAG.BARRIER);
                    
                    subtext("Learned Barrier");
                } else if(item == ITEM.CALL_UP) {
                    set(FLAG.CALL_UP);
                    
                    subtext("Learned Call Up");
                } else if(item == ITEM.CORROSION) {
                    set(FLAG.CORROSION);
                    
                    subtext("Learned Corrosion");
                } else if(item == ITEM.CRUSH) {
                    set(FLAG.CRUSH);
                    
                    subtext("Learned Crush");
                } else if(item == ITEM.CURE) {
                    set(FLAG.CURE);
                    
                    subtext("Learned Cure");
                } else if(item == ITEM.DEFEND) {
                    set(FLAG.DEFEND);
                    
                    subtext("Learned Defend");
                } else if(item == ITEM.DOUBLE_DRAIN) {
                    set(FLAG.DOUBLE_DRAIN);
                    
                    subtext("Learned Double Drain");
                } else if(item == ITEM.DRAIN) {
                    set(FLAG.DRAIN);
                    
                    subtext("Learned Drain");
                } else if(item == ITEM.ENERGIZE) {
                    set(FLAG.ENERGIZE);
                    
                    subtext("Learned Energize");
                } else if(item == ITEM.ESCAPE) {
                    set(FLAG.ESCAPE);
                    
                    subtext("Learned Escape");
                } else if(item == ITEM.EXPLOSION) {
                    set(FLAG.EXPLOSION);
                    
                    subtext("Learned Explosion");
                } else if(item == ITEM.FIREBALL) {
                    set(FLAG.FIREBALL);
                    
                    subtext("Learned Fireball");
                } else if(item == ITEM.FIRE_POWER) {
                    set(FLAG.FIRE_POWER);
                    
                    subtext("Learned Fire Power");
                } else if(item == ITEM.FLASH) {
                    set(FLAG.FLASH);
                    
                    subtext("Learned Flash"); // subtext(0x0963);
                } else if(item == ITEM.FORCE_FIELD) {
                    set(FLAG.FORCE_FIELD);
                    
                    subtext("Learned Force Field");
                } else if(item == ITEM.HARD_BALL) {
                    set(FLAG.HARD_BALL);
                    
                    subtext("Learned Hard Ball"); // subtext(0x0651);
                } else if(item == ITEM.HEAL) {
                    set(FLAG.HEAL);
                    
                    subtext("Learned Heal");
                } else if(item == ITEM.LANCE) {
                    set(FLAG.LANCE);
                    
                    subtext("Learned Lance");
                } else if(item == ITEM.LASER) {
                    set(FLAG.LASER);
                    
                    subtext("Learned Laser");
                } else if(item == ITEM.LEVITATE) {
                    set(FLAG.LEVITATE);
                    
                    subtext("Learned Levitate");
                } else if(item == ITEM.LIGHTNING_STORM) {
                    set(FLAG.LIGHTNING_STORM);
                    
                    subtext("Learned Lightning Storm");
                } else if(item == ITEM.MIRACLE_CURE) {
                    set(FLAG.MIRACLE_CURE);
                    
                    subtext("Learned Miracle Cure");
                } else if(item == ITEM.NITRO) {
                    set(FLAG.NITRO);
                    
                    subtext("Learned Nitro");
                } else if(item == ITEM.ONE_UP) {
                    set(FLAG.ONE_UP);
                    
                    subtext("Learned One Up");
                } else if(item == ITEM.REFLECT) {
                    set(FLAG.REFLECT);
                    
                    subtext("Learned Reflect");
                } else if(item == ITEM.REGROWTH) {
                    set(FLAG.REGROWTH);
                    
                    subtext("Learned Regrowth");
                } else if(item == ITEM.REVEALER) {
                    set(FLAG.REVEALER);
                    
                    subtext("Learned Revealer");
                } else if(item == ITEM.REVIVE) {
                    set(FLAG.REVIVE);
                    
                    subtext("Learned Revive");
                } else if(item == ITEM.SLOW_BURN) {
                    set(FLAG.SLOW_BURN);
                    
                    subtext("Learned Slow Burn");
                } else if(item == ITEM.SPEED) {
                    set(FLAG.SPEED);
                    
                    subtext("Learned speed");
                } else if(item == ITEM.STING) {
                    set(FLAG.STING);
                    
                    subtext("Learned Sting");
                } else if(item == ITEM.STOP) {
                    set(FLAG.STOP);
                    
                    subtext("Learned Stop");
                } else if(item == ITEM.SUPER_HEAL) {
                    set(FLAG.SUPER_HEAL);
                    
                    subtext("Learned Super Heal");
                } else if(item == ITEM.PETAL) { // consumables
                    MEMORY.LOOT_ITEM = LOOT_REWARD.PETAL;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                    
                } else if(item == ITEM.NECTAR) {
                    MEMORY.LOOT_ITEM = LOOT_REWARD.NECTAR;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                    
                } else if(item == ITEM.BISCUIT) {
                    MEMORY.LOOT_ITEM = LOOT_REWARD.BISCUIT;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                    
                } else if(item == ITEM.WINGS) {
                    MEMORY.LOOT_ITEM = LOOT_REWARD.WINGS;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                    
                } else if(item == ITEM.HERBAL_ESSENCE) {
                    MEMORY.LOOT_ITEM = LOOT_REWARD.HERBAL_ESSENCE;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                    
                } else if(item == ITEM.PIXIE_DUST) {
                    MEMORY.LOOT_ITEM = LOOT_REWARD.PIXIE_DUST;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                    
                } else if(item == ITEM.CALL_BEADS) {
                    MEMORY.LOOT_ITEM = LOOT_REWARD.CALL_BEADS;
                    MEMORY.LOOT_OBJECT = 0xff;
                    call_id(LOOT_GOURD);
                } else if(item == ITEM.TICKET_FOR_EXHIBITION) { // tradable
                    MEMORY.TICKET_FOR_EXHIBITION++;

                    subtext("Found a ticket");
                }

                if(without_fanfare is Word) {
                    if!(without_fanfare) {
                        fanfare_item();
                    }
                } else {
                    fanfare_item();
                }
            }
            @install()
            @weak()
            fun reward(item:ITEM, push_music) {
                _reward(item, True);
                
                if(push_music > 0d0) {
                    fanfare_item(True);

                    pop_music();
                } else {
                    fanfare_item();
                }
            }
        };

        group shop() {
            fun add_shop_item(item:SHOP_ITEM, price) {
                code(0x89, param(item), param(price), "// (89) Add item 0x31 priced 0x32 to shop menu");
            }

            fun clear_shop() {
                code(0x88, "// (88) Clear shopping ring");
            }

            fun await_buy_result() {
                // (18) WRITE $23b9 = $2455 Shop buy result  18 61 01 08 fd 01 da

                // 0 = cancel
                // 1 = upper limit
                // 2 = too expensive

                // same as "<0x23b9> = <0x$2455>;", but with a "0x5a (Run shop: buy, get result)" at the end

                code(0x18, 0x23b9 - 0x2258, 0x08, 0x2455 - 0x2258, 0x80 + 0x5a, "// (18) WRITE $23b9 = $2455 Shop buy result");
            }
            fun await_sell_result() {
                // (18) WRITE $23b9 = $2455 Shop sell result  18 61 01 08 fd 01 db

                // 0 = cancel
                // 1 = nothing to sell -> close menu
                // 2 = nothing to sell -> can't open menu
                // 3 = armor currently equipped

                // same as "<0x23b9> = <0x$2455>;", but with a "0x5b (sell)" at the end

                code(0x18, 0x23b9 - 0x2258, 0x08, 0x2455 - 0x2258, 0x80 + 0x5b, "// (18) WRITE $23b9 = $2455 Shop sell result");
            }

            fun shop_buy(entity, shopping_items) {
                // TODO: broken, once the consumables menu was opened (afterwards you can sell infinite items)

                clear_subtext();

                MEMORY.VENDOR_ENTITY = entity;
                // <0x2459> = 0x00;
                
                // <0x22ee, 0x02> = False;
                // <0x22ed, 0x02> = False;
                clear_shop();

                shopping_items();

                await_buy_result();

                <0x22ee, 0x02> = True;
            }

            fun shop_sell(entity, shopping_items) {
                clear_subtext();
                clear_shop();
                
                MEMORY.VENDOR_ENTITY = entity;
                // <0x2457> = 0xc;

                shopping_items();

                await_sell_result();
            }
        };
    };

    group complex() {
        group error_messages() {
            @install()
            @weak()
            fun installed_error_contraption() {
                subtext("Locked by some contraption.");
            }
            @install()
            @weak()
            fun installed_error_unknown() {
                subtext("…");
            }
            fun error_wrong_weapon() {
                subtext("(Wrong weapon…)");
            }

            fun error_walk_back(exit_direction:DIRECTION) {
                if(exit_direction == DIRECTION.NORTH) {
                    walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, -0d2, ACTIVE, BOTH);
                } else if(exit_direction == DIRECTION.EAST) {
                    walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d2, 0d0, ACTIVE, BOTH);
                } else if(exit_direction == DIRECTION.SOUTH) {
                    walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, 0d2, ACTIVE, BOTH);
                } else if(exit_direction == DIRECTION.WEST) {
                    walk(ACTIVE, TILE_RELATIVE_DIRECT, -0d2, 0d0, ACTIVE, BOTH);
                }
            }
            fun error_dead_end(exit_direction:DIRECTION) {
                subtext("Does not open.");

                error_walk_back(exit_direction);
            }
            fun error_contraption(exit_direction:DIRECTION) {
                subtext("Locked by some contraption.");

                error_walk_back(exit_direction);
            }
            fun error_wrong_side(exit_direction:DIRECTION) {
                subtext("Does not open from this side.");

                error_walk_back(exit_direction);
            }
            fun error_switch(exit_direction:DIRECTION) {
                subtext("Does not move.");

                error_walk_back(exit_direction);
            }
            fun error_locked(exit_direction:DIRECTION) {
                subtext("Locked.");

                error_walk_back(exit_direction);
            }
            @install()
            @weak()
            fun installed_error_locked(exit_direction:DIRECTION) {
                subtext("Locked.");

                error_walk_back(exit_direction);
            }
            fun error_dlc(exit_direction:DIRECTION) {
                subtext("DLC area…");

                error_walk_back(exit_direction);
            }
            fun error_unknown(exit_direction:DIRECTION) {
                subtext("…");

                error_walk_back(exit_direction);
            }
        };

        group trading() {
            fun _item_pay(item_memory:MEMORY, count, dry) {
                if(item_memory >= count) {
                    if!(dry) {
                        item_memory -= count;
                    }
                    CUSTOM_MEMORY.RETURN = True;
                }
                end();
            }
            @install()
            @weak()
            fun item_pay(type:ITEM, count, dry) {
                CUSTOM_MEMORY.RETURN = False;

                if(type == ITEM.MONEY) {
                    if_currency(MEMORY.CURRENCY_CURRENT >= count) {
                        if!(dry) {
                            currency_take(MEMORY.CURRENCY_CURRENT, count);
                        }
                        CUSTOM_MEMORY.RETURN = True;
                    }
                    end();
                } else if(type == ITEM.PETAL) { // consumables
                    _item_pay(PETAL, count, dry);
                } else if(type == ITEM.NECTAR) {
                    _item_pay(NECTAR, count, dry);
                } else if(type == ITEM.HONEY) {
                    _item_pay(HONEY, count, dry);
                } else if(type == ITEM.BISCUIT) {
                    _item_pay(DOG_BISCUIT, count, dry);
                } else if(type == ITEM.WINGS) {
                    _item_pay(WINGS, count, dry);
                } else if(type == ITEM.HERBAL_ESSENCE) {
                    _item_pay(HERBAL_ESSENCE, count, dry);
                } else if(type == ITEM.PIXIE_DUST) {
                    _item_pay(PIXIE_DUST, count, dry);
                } else if(type == ITEM.CALL_BEADS) {
                    _item_pay(CALL_BEADS, count, dry);
                } else if(type == ITEM.WAX) { // ingredients
                    _item_pay(WAX, count, dry);
                } else if(type == ITEM.WATER) {
                    _item_pay(WATER, count, dry);
                } else if(type == ITEM.VINEGAR) {
                    _item_pay(VINEGAR, count, dry);
                } else if(type == ITEM.ROOT) {
                    _item_pay(ROOT, count, dry);
                } else if(type == ITEM.OIL) {
                    _item_pay(OIL, count, dry);
                } else if(type == ITEM.MUSHROOM) {
                    _item_pay(MUSHROOM, count, dry);
                } else if(type == ITEM.MUD_PEPPER) {
                    _item_pay(MUD_PEPPER, count, dry);
                } else if(type == ITEM.METEORITE) {
                    _item_pay(METEORITE, count, dry);
                } else if(type == ITEM.LIMESTONE) {
                    _item_pay(LIMESTONE, count, dry);
                } else if(type == ITEM.IRON) {
                    _item_pay(IRON, count, dry);
                } else if(type == ITEM.GUNPOWDER) {
                    _item_pay(GUNPOWDER, count, dry);
                } else if(type == ITEM.GREASE) {
                    _item_pay(GREASE, count, dry);
                } else if(type == ITEM.FEATHER) {
                    _item_pay(FEATHER, count, dry);
                } else if(type == ITEM.ETHANOL) {
                    _item_pay(ETHANOL, count, dry);
                } else if(type == ITEM.DRY_ICE) {
                    _item_pay(DRY_ICE, count, dry);
                } else if(type == ITEM.CRYSTAL) {
                    _item_pay(CRYSTAL, count, dry);
                } else if(type == ITEM.CLAY) {
                    _item_pay(CLAY, count, dry);
                } else if(type == ITEM.BRIMSTONE) {
                    _item_pay(BRIMSTONE, count, dry);
                } else if(type == ITEM.BONE) {
                    _item_pay(BONE, count, dry);
                } else if(type == ITEM.ATLAS_AMULET) { // tradables
                    _item_pay(ATLAS_AMULET, count, dry);
                } else if(type == ITEM.ASH) {
                    _item_pay(ASH, count, dry);
                } else if(type == ITEM.ACORN) {
                    _item_pay(ACORN, count, dry);
                } else if(type == ITEM.ANNIHILATION_AMULET) {
                    _item_pay(ANNIHILATION_AMULET, count, dry);
                } else if(type == ITEM.BEAD) {
                    _item_pay(BEAD, count, dry);
                } else if(type == ITEM.CERAMIC_POT) {
                    _item_pay(CERAMIC_POT, count, dry);
                } else if(type == ITEM.CHICKEN) {
                    _item_pay(CHICKEN, count, dry);
                } else if(type == ITEM.GOLDEN_JACKAL) {
                    _item_pay(GOLDEN_JACKAL, count, dry);
                } else if(type == ITEM.JEWELED_SCARAB) {
                    _item_pay(JEWELED_SCARAB, count, dry);
                } else if(type == ITEM.LIMESTONE_TABLET) {
                    _item_pay(LIMESTONE_TABLET, count, dry);
                } else if(type == ITEM.PERFUME) {
                    _item_pay(PERFUME, count, dry);
                } else if(type == ITEM.RICE) {
                    _item_pay(RICE, count, dry);
                } else if(type == ITEM.SPICE) {
                    _item_pay(SPICE, count, dry);
                } else if(type == ITEM.SPOON) {
                    _item_pay(SPOON, count, dry);
                } else if(type == ITEM.TAPESTRY) {
                    _item_pay(TAPESTRY, count, dry);
                } else if(type == ITEM.TICKET_FOR_EXHIBITION) {
                    _item_pay(TICKET_FOR_EXHIBITION, count, dry);
                } else {
                    MEMORY.STRING_PARAMETER_1 = type;
                    debug_subtext("unknown item #[MEM1]");
                }
            }

            @install()
            @weak()
            fun item_to_string(type:ITEM) {
                if(type == ITEM.PETAL) { // consumables
                    text("Petal");
                } else if(type == ITEM.NECTAR) {
                    text("Nectar");
                } else if(type == ITEM.HONEY) {
                    text("Honey");
                } else if(type == ITEM.BISCUIT) {
                    text("Biscuit");
                } else if(type == ITEM.WINGS) {
                    text("Wings");
                } else if(type == ITEM.HERBAL_ESSENCE) {
                    text("Herbal Essence");
                } else if(type == ITEM.PIXIE_DUST) {
                    text("Pixie Dust");
                } else if(type == ITEM.CALL_BEADS) {
                    text("Call Beads");
                } else if(type == ITEM.WAX) { // ingredients
                    text("Wax");
                } else if(type == ITEM.WATER) {
                    text("Water");
                } else if(type == ITEM.VINEGAR) {
                    text("Vinegar");
                } else if(type == ITEM.ROOT) {
                    text("Root");
                } else if(type == ITEM.OIL) {
                    text("Oil");
                } else if(type == ITEM.MUSHROOM) {
                    text("Mushroom");
                } else if(type == ITEM.MUD_PEPPER) {
                    text("Mud Pepper");
                } else if(type == ITEM.METEORITE) {
                    text("Meteroite");
                } else if(type == ITEM.LIMESTONE) {
                    text("Limestone");
                } else if(type == ITEM.IRON) {
                    text("Iron");
                } else if(type == ITEM.GUNPOWDER) {
                    text("Gunpowder");
                } else if(type == ITEM.GREASE) {
                    text("Grease");
                } else if(type == ITEM.FEATHER) {
                    text("Feather");
                } else if(type == ITEM.ETHANOL) {
                    text("Ethanol");
                } else if(type == ITEM.DRY_ICE) {
                    text("Dry Ice");
                } else if(type == ITEM.CRYSTAL) {
                    text("Crystal");
                } else if(type == ITEM.CLAY) {
                    text("Clay");
                } else if(type == ITEM.BRIMSTONE) {
                    text("Brimstone");
                } else if(type == ITEM.BONE) {
                    text("Bone");
                } else if(type == ITEM.ATLAS_AMULET) {
                    text("Atlas Amulet");
                } else if(type == ITEM.ASH) {
                    text("Ash");
                } else if(type == ITEM.ACORN) {
                    text("Acron");
                } else if(type == ITEM.ANNIHILATION_AMULET) {
                    text("Annihilation Amulet");
                } else if(type == ITEM.BEAD) {
                    text("Beads");
                } else if(type == ITEM.CERAMIC_POT) {
                    text("Ceramic Pot");
                } else if(type == ITEM.CHICKEN) {
                    text("Chicken");
                } else if(type == ITEM.GOLDEN_JACKAL) {
                    text("Golden Jackal");
                } else if(type == ITEM.JEWELED_SCARAB) {
                    text("Jeweled Scarab");
                } else if(type == ITEM.LIMESTONE_TABLET) {
                    text("Limestone Tablet");
                } else if(type == ITEM.PERFUME) {
                    text("Perfume");
                } else if(type == ITEM.RICE) {
                    text("Rice");
                } else if(type == ITEM.SPICE) {
                    text("Spice");
                } else if(type == ITEM.SPOON) {
                    text("Spoon");
                } else if(type == ITEM.TAPESTRY) {
                    text("Tapestry");
                } else if(type == ITEM.TICKET_FOR_EXHIBITION) {
                    text("Ticket");
                } else if(type == ITEM.MONEY) { // misc
                    if(False) {
                        text("Money");
                    } else {
                        call_id(NAME_CURRENCY);
                    }
                } else {
                    MEMORY.STRING_PARAMETER_1 = type;
                    text("Unknown item2string #[MEM1]");
                }
            }
            @install()
            @weak()
            fun trading_error(in_1_type:ITEM, in_2_type:ITEM, in_3_type:ITEM) {
                text_start();
                text("you don't have enough ");

                if(in_1_type > 0d0) {
                    if(arg[0x10] > 0d0) {
                        text(" and ");
                    }
                    arg[0x10]++;

                    item_to_string(in_1_type);
                }
                if(in_2_type > 0d0) {
                    if(arg[0x10] > 0d0) {
                        text(" and ");
                    }
                    arg[0x10]++;

                    item_to_string(in_2_type);
                }
                if(in_3_type > 0d0) {
                    if(arg[0x10] > 0d0) {
                        text(" and ");
                    }
                    arg[0x10]++;

                    item_to_string(in_3_type);
                }

                text("![B]");
                text_end();
            }

            @install()
            @weak()
            fun trade_items(out_type:ITEM, out_count, in_1_type:ITEM, in_1_count, in_2_type:ITEM, in_2_count, in_3_type:ITEM, in_3_count) {
                if(in_1_type != ITEM.NO_ITEM) {
                    item_pay(in_1_type, in_1_count, True);

                    if!(CUSTOM_MEMORY.RETURN) {
                        // subtext("insufficient fond #1");
                        arg[0x10] = in_1_type;
                        // end();
                    }
                }
                if(in_2_type != ITEM.NO_ITEM) {
                    item_pay(in_2_type, in_2_count, True);

                    if!(CUSTOM_MEMORY.RETURN) {
                        // subtext("insufficient fond #2");
                        arg[0x12] = in_2_type;
                        // end();
                    }
                }
                if(in_3_type != ITEM.NO_ITEM) {
                    item_pay(in_3_type, in_3_count, True);

                    if!(CUSTOM_MEMORY.RETURN) {
                        // subtext("insufficient fond #3");
                        arg[0x14] = in_3_type;
                        // end();
                    }
                }

                if((arg[0x10] > 0d0) || (arg[0x12] > 0d0) || (arg[0x14] > 0d0)) {
                    trading_error(arg[0x10], arg[0x12], arg[0x14]);

                    CUSTOM_MEMORY.RETURN = False;
                    end();
                }

                if(in_1_type != ITEM.NO_ITEM) {
                    item_pay(in_1_type, in_1_count);
                }
                if(in_2_type != ITEM.NO_ITEM) {
                    item_pay(in_2_type, in_2_count);
                }
                if(in_3_type != ITEM.NO_ITEM) {
                    item_pay(in_3_type, in_3_count);
                }

                CUSTOM_MEMORY.RETURN = True;

                if(out_type != ITEM.NO_ITEM) {
                    MEMORY.STRING_PARAMETER_1 = out_count;

                    if(out_type == ITEM.PETAL) {
                        MEMORY.PETAL += out_count;
                        subtext("Gained [MEM1] Petal");
                    } else if(out_type == ITEM.NECTAR) {
                        MEMORY.NECTAR += out_count;
                        subtext("Gained [MEM1] Nectar");
                    } else if(out_type == ITEM.HONEY) {
                        MEMORY.HONEY += out_count;
                        subtext("Gained [MEM1] Honey");
                    } else if(out_type == ITEM.BISCUIT) {
                        MEMORY.DOG_BISCUIT += out_count;
                        subtext("Gained [MEM1] Biscuit");
                    } else if(out_type == ITEM.WINGS) {
                        MEMORY.WINGS += out_count;
                        subtext("Gained [MEM1] Wings");
                    } else if(out_type == ITEM.HERBAL_ESSENCE) {
                        MEMORY.HERBAL_ESSENCE += out_count;
                        subtext("Gained [MEM1] Herbal Essence");
                    } else if(out_type == ITEM.PIXIE_DUST) {
                        MEMORY.PIXIE_DUST += out_count;
                        subtext("Gained [MEM1] Pixie Dust");
                    } else if(out_type == ITEM.CALL_BEADS) {
                        MEMORY.CALL_BEADS += out_count;
                        subtext("Gained [MEM1] Call Beads");
                    } else if(out_type == ITEM.WAX) {
                        MEMORY.WAX += out_count;
                        subtext("Gained [MEM1] Wax");
                    } else if(out_type == ITEM.WATER) {
                        MEMORY.WATER += out_count;
                        subtext("Gained [MEM1] Water");
                    } else if(out_type == ITEM.VINEGAR) {
                        MEMORY.VINEGAR += out_count;
                        subtext("Gained [MEM1] Vinegar");
                    } else if(out_type == ITEM.ROOT) {
                        MEMORY.ROOT += out_count;
                        subtext("Gained [MEM1] Root");
                    } else if(out_type == ITEM.OIL) {
                        MEMORY.OIL += out_count;
                        subtext("Gained [MEM1] Oil");
                    } else if(out_type == ITEM.MUSHROOM) {
                        MEMORY.MUSHROOM += out_count;
                        subtext("Gained [MEM1] Mushroom");
                    } else if(out_type == ITEM.MUD_PEPPER) {
                        MEMORY.MUD_PEPPER += out_count;
                        subtext("Gained [MEM1] Mud Pepper");
                    } else if(out_type == ITEM.METEORITE) {
                        MEMORY.METEORITE += out_count;
                        subtext("Gained [MEM1] Meteorite");
                    } else if(out_type == ITEM.LIMESTONE) {
                        MEMORY.LIMESTONE += out_count;
                        subtext("Gained [MEM1] Limestone");
                    } else if(out_type == ITEM.IRON) {
                        MEMORY.IRON += out_count;
                        subtext("Gained [MEM1] Iron");
                    } else if(out_type == ITEM.GUNPOWDER) {
                        MEMORY.GUNPOWDER += out_count;
                        subtext("Gained [MEM1] Gunpowder");
                    } else if(out_type == ITEM.GREASE) {
                        MEMORY.GREASE += out_count;
                        subtext("Gained [MEM1] Grease");
                    } else if(out_type == ITEM.FEATHER) {
                        MEMORY.FEATHER += out_count;
                        subtext("Gained [MEM1] Feather");
                    } else if(out_type == ITEM.ETHANOL) {
                        MEMORY.ETHANOL += out_count;
                        subtext("Gained [MEM1] Ethanol");
                    } else if(out_type == ITEM.DRY_ICE) {
                        MEMORY.DRY_ICE += out_count;
                        subtext("Gained [MEM1] Dry Ice");
                    } else if(out_type == ITEM.CRYSTAL) {
                        MEMORY.CRYSTAL += out_count;
                        subtext("Gained [MEM1] Crystal");
                    } else if(out_type == ITEM.CLAY) {
                        MEMORY.CLAY += out_count;
                        subtext("Gained [MEM1] Clay");
                    } else if(out_type == ITEM.BRIMSTONE) {
                        MEMORY.BRIMSTONE += out_count;
                        subtext("Gained [MEM1] Brimstone");
                    } else if(out_type == ITEM.BONE) {
                        MEMORY.BONE += out_count;
                        subtext("Gained [MEM1] Bone");
                    } else if(out_type == ITEM.ATLAS_AMULET) {
                        MEMORY.ATLAS_AMULET += out_count;
                        subtext("Gained [MEM1] Atlas Amulet");
                    } else if(out_type == ITEM.ASH) {
                        MEMORY.ASH += out_count;
                        subtext("Gained [MEM1] Ash");
                    } else if(out_type == ITEM.ACORN) {
                        MEMORY.ACORN += out_count;
                        subtext("Gained [MEM1] Acron");
                    } else if(out_type == ITEM.ANNIHILATION_AMULET) {
                        MEMORY.ANNIHILATION_AMULET += out_count;
                        subtext("Gained [MEM1] Annihilation Amulet");
                    } else if(out_type == ITEM.BEAD) {
                        MEMORY.BEAD += out_count;
                        subtext("Gained [MEM1] Bead");
                    } else if(out_type == ITEM.CERAMIC_POT) {
                        MEMORY.CERAMIC_POT += out_count;
                        subtext("Gained [MEM1] Ceramic Pot");
                    } else if(out_type == ITEM.CHICKEN) {
                        MEMORY.CHICKEN += out_count;
                        subtext("Gained [MEM1] Chicken");
                    } else if(out_type == ITEM.GOLDEN_JACKAL) {
                        MEMORY.GOLDEN_JACKAL += out_count;
                        subtext("Gained [MEM1] Golden Jackal");
                    } else if(out_type == ITEM.JEWELED_SCARAB) {
                        MEMORY.JEWELED_SCARAB += out_count;
                        subtext("Gained [MEM1] Jeweled Scarab");
                    } else if(out_type == ITEM.LIMESTONE_TABLET) {
                        MEMORY.LIMESTONE_TABLET += out_count;
                        subtext("Gained [MEM1] Limestone Tablet");
                    } else if(out_type == ITEM.PERFUME) {
                        MEMORY.PERFUME += out_count;
                        subtext("Gained [MEM1] Perfume");
                    } else if(out_type == ITEM.RICE) {
                        MEMORY.RICE += out_count;
                        subtext("Gained [MEM1] Rice");
                    } else if(out_type == ITEM.SPICE) {
                        MEMORY.SPICE += out_count;
                        subtext("Gained [MEM1] Spice");
                    } else if(out_type == ITEM.SPOON) {
                        MEMORY.SPOON += out_count;
                        subtext("Gained [MEM1] Spoon");
                    } else if(out_type == ITEM.TAPESTRY) {
                        MEMORY.TAPESTRY += out_count;
                        subtext("Gained [MEM1] Tapestry");
                    } else if(out_type == ITEM.TICKET_FOR_EXHIBITION) {
                        MEMORY.TICKET_FOR_EXHIBITION += out_count;
                        subtext("Gained [MEM1] Ticket");
                    } else if(out_type == ITEM.MONEY) {
                        currency_get(TALONS, out_count);
                        subtext("Gained [MEM1] Souls");
                    } else {
                        MEMORY.STRING_PARAMETER_1 = out_type;
                        debug_subtext("unknown item #[MEM1]");
                    }
                }
            }
        };

        @install()
        @weak()
        fun cast_team(character, spell:CAST, level, skip_dead_dog, rand_range) {
            if(rand_range > 0d0) {
                arg[0x10] = randrange(rand_range);
            } else {
                arg[0x10] = randrange(0d4);
            }

            if(arg[0x10] == 0d0) {
                cast(character, BOY, spell, level);
            } else if(arg[0x10] == 0d1) {
                if(skip_dead_dog == True && <DOG>[HP] <= 0d0) {
                    cast(character, BOY, spell, level);
                } else {
                    cast(character, DOG, spell, level);
                }
            } else {
                cast(character, BOTH, spell, level);
            }
        }

        fun loot(animation:ADDRESS_ID, flag, object_id, reward:LOOT_REWARD, amount, next) {
            if!(flag) {
                if(reward < 0x1000) {
                    MEMORY.LOOT_ITEM = reward;

                    MEMORY.LOOT_OBJECT = object_id;

                    if(reward < 0x0100) { 
                        if(amount > 0d0) {
                            MEMORY.LOOT_AMOUNT_CURRENCY = amount;
                        }
                    } else {
                        if(amount > 0d1) {
                            MEMORY.LOOT_AMOUNT = amount - 0d1;
                        }
                    }

                    call_id(animation);
                    
                    if(next > 0d0) {
                        MEMORY.LOOT_AMOUNT = next;
                    }

                    if(FLAG.LOOT_SUCCESSFUL) {
                        set(flag);
                    }
                } else {
                    if(reward == LOOT_REWARD.SPOON) {
                        MEMORY.SPOON++;
                        call_id(LOOT_GOURD);
                        object[object_id] = 0x01;
                        set(flag);

                        subtext("Found a spoon");
                    } else if(reward == LOOT_REWARD.TICKET_FOR_EXHIBITION) {
                        MEMORY.TICKET_FOR_EXHIBITION++;
                        call_id(LOOT_GOURD);
                        object[object_id] = 0x01;
                        set(flag);

                        subtext("Found a ticket");
                    }
                }
            }
        }

        group metroidvania() {
            fun vanilla_grass_cutter(object_id) {
                if(<ACTIVE> == <BOY>) {
                    animate(BOY, ONCE, ANIMATION_ALL.SLASH_2);

                    if((MEMORY.CURRENT_WEAPON_TYPE == WEAPON_TYPE.AXE) || (MEMORY.CURRENT_WEAPON_TYPE == WEAPON_TYPE.SPEAR)) {

                        object[object_id] = 0x01;
                    } else {
                        error_wrong_weapon();
                    }
                }
            }

            fun guard_spear_2(direction:DIRECTION, x, y) {
                if(False) {
                    call(0x9793ad);
                } else {
                    if(<ACTIVE> == <DOG>) {
                        end();
                    }

                    face(BOY, direction);
                    animate(BOY, ONCE, ANIMATION_ALL.SLASH_1_3);

                    if(MEMORY.CURRENT_WEAPON_TYPE != WEAPON_TYPE.SPEAR) {
                        if(x is Word || x is Memory || y is Word || y is Memory) {
                            set_camera(COORDINATE_CORNER, x, y, 0x80 >> 0d2);

                            wait(CAMERA_PAN_Y);

                            MEMORY.CAMERA_PAN_SPEED = 0x80;
                            free_camera();
                        }

                        error_wrong_weapon();
                        end();
                    }

                    if(MEMORY.CURRENT_WEAPON < WEAPON_INDEX.SPEAR_2) {
                        error_wrong_weapon();
                        end();
                    }
                }
            }

            fun axe2_wall_enemy(flag, enemy) {
                if(<ACTIVE> == <BOY>) {
                    animate(BOY, ONCE, ANIMATION_ALL.SLASH_2);

                    if((MEMORY.CURRENT_WEAPON_TYPE == WEAPON_TYPE.AXE) && (MEMORY.CURRENT_WEAPON >= WEAPON_INDEX.AXE_2)) {
                        _add_enemy(PLACEHOLDER, <BOY>[X] - 0x10, <BOY>[Y] - 0x10);
                        animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.EXPLOSION_1);

                        _add_enemy(PLACEHOLDER, <BOY>[X] + 0x20, <BOY>[Y] - 0x20);
                        animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.EXPLOSION_1);

                        sleep(0d4);

                        // sound(THRAXX_BRIDGE_COLLAPSING);

                        destroy(enemy);
                        set(flag);
                    } else {
                        error_wrong_weapon();
                    }
                }
            }
            fun axe2_wall(flag, object) {
                if(<ACTIVE> == <BOY>) {
                    animate(BOY, ONCE, ANIMATION_ALL.SLASH_2);

                    if((MEMORY.CURRENT_WEAPON_TYPE == WEAPON_TYPE.AXE) && (MEMORY.CURRENT_WEAPON >= WEAPON_INDEX.AXE_2)) {
                        _add_enemy(PLACEHOLDER, <BOY>[X] - 0x10, <BOY>[Y] - 0x10);
                        animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.EXPLOSION_1);

                        _add_enemy(PLACEHOLDER, <BOY>[X] + 0x20, <BOY>[Y] - 0x20);
                        animate(LAST_ENTITY, ONCE, ANIMATION_PLACEHOLDER.EXPLOSION_1);

                        sleep(0d4);

                        sound(THRAXX_BRIDGE_COLLAPSING);

                        object = 0x01;
                        set(flag);
                    } else {
                        error_wrong_weapon();
                    }
                }
            }

            @install()
            @weak()
            @async()
            fun _rimsala_gate(entity) {
                attach_to_script(entity);

                arg[0x10] = <SCRIPT_OWNER>[Y];

                while!(<SCRIPT_OWNER>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                    <SCRIPT_OWNER>[Y] = arg[0x10];
                    if(<SCRIPT_OWNER>[X] < (<ACTIVE>[X] - 0d10)) {
                        teleport_relative(SCRIPT_OWNER, 0d5, 0d0);
                    } else if(<SCRIPT_OWNER>[X] > (<ACTIVE>[X] + 0d10)) {
                        teleport_relative(SCRIPT_OWNER, -0d5, 0d0);
                    }

                    yield();
                }
            }
            fun rimsala_gate(x, y, deactivated, trigger) {
                if!(deactivated) {
                    add_enemy(RIMSALA_GOLD, x, y, BOMBABLE);
                    attach_script(LAST_ENTITY, DAMAGE, trigger);

                    _rimsala_gate(<LAST_ENTITY>);
                } else {
                    add_enemy(RIMSALA_GOLD, x, y, INACTIVE_IMORTAL);
                }
            }
        };

        group combat() {
            @install()
            @weak()
            fun vanilla_bomb_explosion() {
                if(script[0x9] != 0x200) {
                    if(False) {
                        <SCRIPT_OWNER>[GENERAL_PURPOSE] = 0d0;
                    }

                    end();
                }

                sleep(0d10);
                
                bomb_entity(<SCRIPT_OWNER>, 0d50, 0d200);
                if(CUSTOM_FLAG.VANILLA_BOMB_DAMAGE) {
                    bomb_entity_entity(BOY, <SCRIPT_OWNER>, 0d50, 0d2000);
                } else {
                    bomb_entity_entity(BOY, <SCRIPT_OWNER>, 0d50);
                }
            }
        };

        @install()
        @weak()
        fun reset_alchemy_types() {
            // projectile
            <0x3567> = 0x0000;
            <0x35dd> = 0x0000;
            <0x3653> = 0x0000;
            <0x36c9> = 0x0000;
            <0x373f> = 0x0000;
            <0x37b5> = 0x0000;
            <0x382b> = 0x0000;
            <0x38a1> = 0x0000;

            // animation
            <0x3367> = 0x0000;
            <0x33a7> = 0x0000;
            <0x33e7> = 0x0000;
            <0x3427> = 0x0000;
            <0x3467> = 0x0000;
            <0x34a7> = 0x0000;
            <0x34e7> = 0x0000;
            <0x3527> = 0x0000;
        }
        fun check_alchemy_type_projectile(type:ALCHEMY_TYPE_PROJECTILE, counter) {
            if(
                (<0x3567> == type) ||
                (<0x35dd> == type) ||
                (<0x3653> == type) ||
                (<0x36c9> == type) ||
                (<0x373f> == type) ||
                (<0x37b5> == type) ||
                (<0x382b> == type) ||
                (<0x38a1> == type)
            ) {
                counter++;
            }
        }
        fun check_alchemy_type_animation(type:ALCHEMY_TYPE_ANIMATION, counter) {
            if(
                (<0x3367> == type) ||
                (<0x33a7> == type) ||
                (<0x33e7> == type) ||
                (<0x3427> == type) ||
                (<0x3467> == type) ||
                (<0x34a7> == type) ||
                (<0x34e7> == type) ||
                (<0x3527> == type)
            ) {
                counter++;
            }
        }
        fun check_damage_type(type:ALCHEMY_TYPE_GROUP, counter) {
            if(type == ALCHEMY_TYPE_GROUP.FIRE) {
                check_alchemy_type_projectile(FIREBALL, counter);
                check_alchemy_type_projectile(FLASH, counter);
                check_alchemy_type_projectile(FLARE, counter);

                check_alchemy_type_animation(EXPLOSION, counter);
                check_alchemy_type_animation(FIRE_POWER, counter);
                check_alchemy_type_animation(NITRO, counter);
            } else if(type == ALCHEMY_TYPE_GROUP.EARTH) {
                check_alchemy_type_projectile(HARD_BALL, counter);

                check_alchemy_type_animation(CRUSH, counter);
            } else if(type == ALCHEMY_TYPE_GROUP.LIGHTNING) {
                check_alchemy_type_animation(LIGHTNING_STORM, counter);
                check_alchemy_type_animation(STORM, counter);
                check_alchemy_type_animation(ELECTRA_BOLT, counter);
            } else if(type == ALCHEMY_TYPE_GROUP.MAGIC) {
                check_alchemy_type_animation(DOUBLE_DRAIN, counter);
                check_alchemy_type_animation(DRAIN, counter);
                check_alchemy_type_animation(LANCE, counter);
            } else if(type == ALCHEMY_TYPE_GROUP.NATURE) {
                check_alchemy_type_animation(ACID_RAIN, counter);
                check_alchemy_type_animation(STING, counter);
            }
        }

        fun find_all(type:CHARACTER_TPYE, callback) {
            var current_id = arg[0x10]; // TODO: shouldn't use foreign memory
            current_id = 0x3de5;

            var found_entity = arg[0x12];

            while(current_id <= 0x4DFB) {
                if(current_id[TYPE] == type) {
                    callback(current_id);
                }

                current_id += 0x8e;
                yield();
            }
        }

        group map_manipulation() {
            fun check_fake_wall(entity, direction:DIRECTION) {
                if(direction == DIRECTION.NORTH) {
                    if(entity[Y] < (MEMORY.CAMERA_BOUNDRY_Y_START + 0d24)) {
                        entity[Y] = MEMORY.CAMERA_BOUNDRY_Y_START + 0d24;
                    }
                } else if(direction == DIRECTION.EAST) {
                    if(entity[X] > (MEMORY.CAMERA_BOUNDRY_X_END - 0d4)) {
                        entity[X] = MEMORY.CAMERA_BOUNDRY_X_END - 0d4;
                    }
                } else if(direction == DIRECTION.SOUTH) {
                    if(entity[Y] > (MEMORY.CAMERA_BOUNDRY_Y_END - 0d4)) {
                        entity[Y] = MEMORY.CAMERA_BOUNDRY_Y_END - 0d4;
                    }
                } else if(direction == DIRECTION.WEST) {
                    if(entity[X] < (MEMORY.CAMERA_BOUNDRY_X_START + 0d4)) {
                        entity[X] = MEMORY.CAMERA_BOUNDRY_X_START + 0d4;
                    }
                }
            }
            @install()
            @weak()
            @async()
            fun fake_walls() {
                while(True) {
                    check_fake_wall(<ACTIVE>, NORTH);
                    check_fake_wall(<INACTIVE>, NORTH);
                    yield();

                    check_fake_wall(<ACTIVE>, EAST);
                    check_fake_wall(<INACTIVE>, EAST);
                    yield();

                    check_fake_wall(<ACTIVE>, SOUTH);
                    check_fake_wall(<INACTIVE>, SOUTH);
                    yield();

                    check_fake_wall(<ACTIVE>, WEST);
                    check_fake_wall(<INACTIVE>, WEST);
                    yield();
                }
            }

            @install()
            @weak()
            @async()
            fun no_clip_box(x_start, y_start, x_end, y_end) {
                while(True) {
                    if(!CUSTOM_FLAG.START_MARIO_YUMP) {
                        if(
                            (<ACTIVE>[X] >= x_start) && (<ACTIVE>[X] <= x_end) &&
                            (<ACTIVE>[Y] >= y_start) && (<ACTIVE>[Y] <= y_end)
                        ) {
                            attribute(ACTIVE, NO_CLIP, True);
                        } else {
                            attribute(ACTIVE, NO_CLIP, False);
                        }
                    }

                    // debug_memory(<BOY>[Z], 0d0);

                    yield();
                }
            }

            fun _fake_pit_scanner(x_start, y_start, x_end, y_end, guard_north, guard_east, guard_south, guard_west, callback) {
                while(True) {
                    if(!CUSTOM_FLAG.START_MARIO_YUMP) {
                        if(arg[0x10] != <ACTIVE>) {
                            attribute(arg[0x10], NO_CLIP, False);
                            arg[0x10] = False;
                        }

                        if(
                            (<ACTIVE>[X] >= x_start) && (<ACTIVE>[X] <= x_end) &&
                            (<ACTIVE>[Y] >= y_start) && (<ACTIVE>[Y] <= y_end)
                        ) {
                            if((!arg[0x10]) && !(<ACTIVE>[FLAGS_2] & ATTRIBUTE_FLAGS.NO_CLIP)) {
                                arg[0x10] = <ACTIVE>;
                                attribute(ACTIVE, NO_CLIP, True);
                            } else if(
                                (<ACTIVE>[X] >= (x_start + 0d10)) && (<ACTIVE>[X] <= (x_end - 0d10)) &&
                                (<ACTIVE>[Y] >= (y_start + 0d10)) && (<ACTIVE>[Y] <= (y_end - 0d10))
                            ) {
                                callback();
                            }
                        } else {
                            if((arg[0x10]) && (<ACTIVE>[FLAGS_2] & ATTRIBUTE_FLAGS.NO_CLIP)) {
                                arg[0x10] = False;
                                attribute(ACTIVE, NO_CLIP, False);

                                if(guard_north && (<ACTIVE>[Y] <= y_start)) {
                                    <ACTIVE>[Y] += 0d2;
                                } else if(guard_east && (<ACTIVE>[X] >= x_end)) {
                                    <ACTIVE>[X] -= 0d2;
                                } else if(guard_south && (<ACTIVE>[Y] >= y_end)) {
                                    <ACTIVE>[Y] -= 0d2;
                                } else if(guard_west && (<ACTIVE>[X] <= x_start)) {
                                    <ACTIVE>[X] += 0d2;
                                }
                            }
                        }
                    }

                    // debug_memory(<BOY>[Z], 0d0);

                    yield();
                }
            }
            @install()
            @weak()
            @async()
            fun fake_pit_scanner(x_start, y_start, x_end, y_end, guard_north, guard_east, guard_south, guard_west) {
                _fake_pit_scanner(x_start, y_start, x_end, y_end, guard_north, guard_east, guard_south, guard_west, { nop(); });
            }
        };

        group sprite_stacking() {
            @install()
            @weak()
            @async()
            fun stack_sprite(entity_mount, entity_rider, offset_x, offset_y) {
                while!(dead(entity_mount)) {
                    entity_rider[X] = entity_mount[X] + offset_x;
                    entity_rider[Y] = entity_mount[Y] - offset_y;

                    yield();
                }
            }
        };
    };

    group cutscenes() {
        group object_interaction() {
            enum OBJECT_ANIMATOR_MODE {
                BRIDGE_HALLS = 0d0,
                SWITCH_GROUND_HALLS = 0d1,
                SWITCH_SPEAR_HALLS = 0d2,
                GATE_HALLS = 0d3,
                REVEALER = 0d4,
            }

            fun _object_animator_simple(object_id, value_active, value_inactive, sound_id:SOUND, active, delay, instant) {
                if!((instant is Word) && instant) {
                    smart_sound(sound_id);

                    if(active) {
                        object[object_id] = value_active;
                    } else {
                        object[object_id] = value_inactive;
                    }

                    sleep(0d10);
                } else {
                    if(active) {
                        object[object_id] = value_active;
                    } else {
                        object[object_id] = value_inactive;
                    }
                }
            }
            fun _object_animator(object_id, from, to, sound_id:SOUND, delay, instant) {
                if!((instant is Word) && instant) {
                    if(from < to) {
                        while(arg[0x10] <= to) {
                            arg[0x10]++;

                            sleep(delay);
                            smart_sound(sound_id);

                            object[object_id] = arg[0x10];
                        }
                    } else {
                        arg[0x10] = from;

                        while(arg[0x10] > to) {
                            arg[0x10]--;

                            sleep(delay);
                            smart_sound(sound_id);

                            object[object_id] = arg[0x10];
                        }

                        sleep(delay);
                        smart_sound(sound_id);

                        object[object_id] = arg[0x10];
                    }
                } else {
                    object[object_id] = to;
                }
            }
            fun _object_animator_revealer(object_id, count, delay, instant) {
                while(arg[0x10] < count) {
                    object[object_id + arg[0x10]] = 0x7e;
                    arg[0x10]++;

                    if!((instant is Word) && instant) {
                        if(arg[0x10] < count) {
                            sleep(delay);
                        }
                    }
                }
            }
            fun object_animator(mode:OBJECT_ANIMATOR_MODE, flag, object_id, value, instant) {
                if(mode == OBJECT_ANIMATOR_MODE.SWITCH_GROUND_HALLS) {
                    _object_animator_simple(object_id, 0x7e, 0x00, MAGMA_HARDENING, value, 0d10, instant);
                    
                    if(flag is Memory) {
                        flag = True;
                    }
                } else if(mode == OBJECT_ANIMATOR_MODE.SWITCH_SPEAR_HALLS) {
                    _object_animator_simple(object_id, 0x01, 0x00, MECHANICAL_MOVEMENT, value, 0d10, instant);
                    
                    if(flag is Memory) {
                        flag = True;
                    }
                } else if(mode == OBJECT_ANIMATOR_MODE.BRIDGE_HALLS) {
                    if(value) {
                        if(flag is Memory) {
                            flag = True;
                        }

                        _object_animator(object_id, 0d1, 0d8, MECHANICAL_MOVEMENT, 0d8, instant);
                    } else {
                        _object_animator(object_id, 0d7, 0d0, MECHANICAL_MOVEMENT, 0d8, instant);

                        if(flag is Memory) {
                            flag = False;
                        }
                    }
                } else if(mode == OBJECT_ANIMATOR_MODE.GATE_HALLS) {
                    if(value) {
                        if(flag is Memory) {
                            flag = True;
                        }

                        _object_animator(object_id, 0d1, 0d3, ELEVATOR_DOOR, 0d20, instant);
                    } else {
                        _object_animator(object_id, 0d2, 0d0, ELEVATOR_DOOR, 0d20, instant);

                        if(flag is Memory) {
                            flag = False;
                        }
                    }
                } else if(mode == OBJECT_ANIMATOR_MODE.REVEALER) {
                    if(value) {
                        if(flag is Memory) {
                            flag = True;
                        }

                        _object_animator_revealer(object_id, value, 0d30, instant);
                    } else {
                        _object_animator_revealer(object_id, value, 0d30, instant);

                        if(flag is Memory) {
                            flag = False;
                        }
                    }
                }
            }
            fun restore_object_animator(mode:OBJECT_ANIMATOR_MODE, flag, object_id) {
                if(mode == OBJECT_ANIMATOR_MODE.SWITCH_GROUND_HALLS) {
                    _object_animator_simple(object_id, 0x7e, 0x00, MAGMA_HARDENING, flag, 0d10, True);
                } else if(mode == OBJECT_ANIMATOR_MODE.SWITCH_SPEAR_HALLS) {
                    _object_animator_simple(object_id, 0x01, 0x00, MECHANICAL_MOVEMENT, flag, 0d10, True);
                } else if(mode == OBJECT_ANIMATOR_MODE.BRIDGE_HALLS) {
                    if(flag) {
                        _object_animator(object_id, 0d1, 0d8, MECHANICAL_MOVEMENT, 0d8, True);
                    } else {
                        _object_animator(object_id, 0d7, 0d0, MECHANICAL_MOVEMENT, 0d8, True);
                    }
                } else if(mode == OBJECT_ANIMATOR_MODE.GATE_HALLS) {
                    if(flag) {
                        _object_animator(object_id, 0d1, 0d3, ELEVATOR_DOOR, 0d20, True);
                    } else {
                        _object_animator(object_id, 0d2, 0d0, ELEVATOR_DOOR, 0d20, True);
                    }
                } else if(mode == OBJECT_ANIMATOR_MODE.REVEALER) {
                    if(flag) {
                        _object_animator_revealer(object_id, value, 0d30, True);
                    } else {
                        _object_animator_revealer(object_id, value, 0d30, True);
                    }
                }
            }
        };

        group act_3() {
            fun vanilla_a3_stairs_helper(object_id, x, y, upwards) {
                if!(
                    (<INACTIVE>[X] < (0d13 * 0d0008)) ||
                    ((<INACTIVE>[X] > (0d33 * 0d0008)) && (<INACTIVE>[X] < (0d68 * 0d0008)))
                ) {
                    control(NONE);
                    walk(INACTIVE, TILE_ABSOLUTE, x, y, INACTIVE, BOTH);
                }

                if(upwards) {
                    object[object_id] = 0x01;
                } else {
                    object[object_id] = 0x00;
                }
            }
        };

        fun fake_loot() {
            animate(BOY, ONCE, ANIMATION_BOY.LOOT);
            sleep(0d15);
            sound(CLICK_3);
            sleep(0d15);
        }

        fun fake_loot_gourd() {
            sound(CLICK_3);
        }

        fun fake_b() {
            animate(ACTIVE, ONCE, SLASH_1);
        }

        fun crash_land(character:CHARACTER) {
            if(character == CHARACTER.BOY) {
                <BOY>[Z] = 0x1068;
                animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
                sleep(0x60);
                <BOY>[VELOCITY] = 0x10;
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);
                sleep(0x10);
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);
                sleep(0x10);
                animate(BOY, ONCE, ANIMATION_BOY.KNEEL);
            } else if(character == CHARACTER.DOG) {
                <DOG>[Z] = 0x1068;
                animate(DOG, LOOP, ANIMATION_DOG.ACT1_FALL1);
                sleep(0x60);
                <DOG>[VELOCITY] = 0x10;
                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_SLEEP);
                sleep(0x10);
                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_FALL1);
                sleep(0x10);
                animate(DOG, ONCE, ANIMATION_DOG.ACT1_SIT);
            } else if(character == CHARACTER.BOTH) {
                <BOY>[Z] = 0x1068;
                animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
                <DOG>[Z] = 0x1068;
                animate(DOG, LOOP, ANIMATION_DOG.ACT1_FALL1);
                sleep(0x60);
                <BOY>[VELOCITY] = 0x10;
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_UP);
                <DOG>[VELOCITY] = 0x10;
                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT1_SLEEP);
                sleep(0x10);
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SLEEP_DOWN);
                animate(DOG, ONCE, ANIMATION_DOG.ACT1_FALL1);
                sleep(0x10);
                animate(BOY, ONCE, ANIMATION_BOY.KNEEL);
            }
        }
        @install()
        @weak()
        @async()
        fun crash_both() {
            <DOG>[X] -= 0x20;
            <DOG>[Y] -= 0x20;

            crash_land(BOTH);
        }

        fun character_selection(character:CHARACTER) {
            if(character == CHARACTER.BOY) {
                available(BOY);
                teleport(DOG, 0x00, 0x00);
            } else if(character == CHARACTER.DOG) {
                available(DOG);
                teleport(BOY, 0x00, 0x00);

                attach_script(DOG, DEATH, reference(boy_death));
            }
        }

        fun animate_boy_kneel() { // see mungola cutscene
            animate(BOY, ONCE_FREEZE, ANIMATION_BOY.LOOT);
            sleep(0d10);
            animate(BOY, PAUSE, DEFAULT);
        }

        fun animate_eternal_dust() {
            MEMORY.UNKNOWN_ETERNAL_DUST_DROP_PROPERTY = 0x0001;
            animate(SCRIPT_OWNER, ONCE, ANIMATION_ENEMY.DUST);
            sleep(0d60);
            MEMORY.UNKNOWN_ETERNAL_DUST_DROP_PROPERTY = 0x0001;
            animate(SCRIPT_OWNER, FREEZE, ANIMATION_ENEMY.DUST);
        }

        fun animate_falling(character:CHARACTER) {
            if(character == <BOY>) {
                animate(character, LOOP, ANIMATION_BOY.FALL_1);
            } else {
                animate(character, LOOP, ANIMATION_DOG.ACT1_FALL1);
            }
        }
        fun animate_landing(character:CHARACTER, with_shake) {
            if(with_shake) {
                sfx_effect(SHAKING, True);
            }
            
            if(character == <BOY>) {
                animate(character, ONCE, ANIMATION_BOY.LANDING);
            } else {
                animate(character, ONCE, DEFAULT);
            }

            if(with_shake) {
                sleep(0d20);

                sfx_effect(SHAKING, False);
            }
        }

        fun guard_z() {
            if((<ACTIVE>[Z] > 0d0) || CUSTOM_FLAG.START_MARIO_YUMP || CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT > 0d0) {
                end();
            }
        }

        fun check_range_old(entity_1, entity_2, x, y, callback) {
            if(entity_1[X] < entity_2[X]) {
                arg[0x10] = entity_2[X] - entity_1[X];
            } else {
                arg[0x10] = entity_1[X] - entity_2[X];
            }

            if(entity_1[Y] < entity_2[Y]) {
                arg[0x12] = entity_2[Y] - entity_1[Y];
            } else {
                arg[0x12] = entity_1[Y] - entity_2[Y];
            }
            
            if(False) {
                MEMORY.STRING_PARAMETER_1 = arg[0x10];
                MEMORY.STRING_PARAMETER_2 = arg[0x12];
                // MEMORY.STRING_PARAMETER_3 = m3;

                _subtext("memory = [MEM1] / [MEM2] / [MEM3]");
                sleep(0d60);
            }

            if((arg[0x10] <= x) && (arg[0x12] <= y)) {
                callback();
            }
        }
        fun check_range(entity_1, entity_2, x, y, callback) {
            if!(entity_2[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                if(entity_1[X] < entity_2[X]) {
                    arg[0x10] = entity_2[X] - entity_1[X];
                } else {
                    arg[0x10] = entity_1[X] - entity_2[X];
                }

                if(entity_1[Y] < entity_2[Y]) {
                    arg[0x12] = entity_2[Y] - entity_1[Y];
                } else {
                    arg[0x12] = entity_1[Y] - entity_2[Y];
                }
                
                if(False) {
                    MEMORY.STRING_PARAMETER_1 = arg[0x10];
                    MEMORY.STRING_PARAMETER_2 = arg[0x12];
                    // MEMORY.STRING_PARAMETER_3 = m3;

                    _subtext("memory = [MEM1] / [MEM2] / [MEM3]");
                }

                if((arg[0x10] <= x) && (arg[0x12] <= y)) {
                    callback();

                    while(<ACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                        yield();
                    }
                }
            }
        }
        fun range_checker(entity_1, entity_2, x, y, callback) {
            attach_to_script(entity_1);

            while!(dead(<SCRIPT_OWNER>)) {
                check_range(<SCRIPT_OWNER>, entity_2, x, y, callback);

                yield();
            }
        }
        fun grounded_range_checker(entity_1, entity_2, x, y, callback) {
            attach_to_script(entity_1);

            while!(dead(<SCRIPT_OWNER>)) {
                if!((entity_2[Z] > 0d0) || CUSTOM_FLAG.START_MARIO_YUMP || CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT > 0d0) {
                    check_range(<SCRIPT_OWNER>, entity_2, x, y, callback);
                }

                yield();
            }
        }
        fun conditional_range_checker(entity_1, entity_2, x, y, condition, callback) {
            arg[0x00] = entity_1;
            arg[0x02] = entity_2;

            attach_to_script(entity_1);

            while!(dead(<SCRIPT_OWNER>)) {
                if(condition) {
                    check_range(<SCRIPT_OWNER>, entity_2, x, y, callback);
                }

                yield();
            }
        }

        fun generic_switch_floor(object_id, active) {
            sound(MAGMA_HARDENING);

            if(active) {
                object[object_id] = 0x7e;
            } else {
                object[object_id] = 0x00;
            }
        }

        @install()
        @weak()
        fun generic_act1_volcano_pressure_plate_jump(entity, z, end, step) {
            if(entity[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) {
                end();
            }

            arg[0x10] = -(z);
            arg[0x12] = entity[X] << 0d4;
            arg[0x14] = entity[Y] << 0d4;

            smart_animate(entity, LOOP, ANIMATION_BOY.FALL_1);

            while(signed arg[0x10] < end) {
                arg[0x10]++;

                arg[0x12] += step;
                arg[0x14] += signed arg[0x10];

                _teleport(entity, arg[0x12] >> 0d4, arg[0x14] >> 0d4);
                yield();
            }

            smart_animate(entity, ONCE, ANIMATION_BOY.LANDING);
        }

        fun _generic_act1_volcano_pressure_plate_walk(entity, x, y, object_id, object_state, z, end, step) {
            walk(entity, TILE_ABSOLUTE, x, y, entity, NONE);

            object[object_id] = object_state;
            tile_animate(0x01, 0xff, 0x08);

            generic_act1_volcano_pressure_plate_jump(entity, z, end, step);

            if(object_id == 0x05) {
                object[object_id] = 0x01;
            } else {
                object[object_id] = 0x00;
            }

            control(entity, False);
        }
        @install()
        @weak()
        @async()
        fun generic_act1_volcano_pressure_plate_walk(entity, x, y, object_id, object_state, z, end, step) {
            _generic_act1_volcano_pressure_plate_walk(entity, x, y, object_id, object_state, z, end, step);
        }
        fun generic_act1_volcano_pressure_plate(x, y, object_id, object_state, z, end, step) {
            control(ACTIVE, True);

            while(<INACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                yield();
            }
            control(INACTIVE, True);

            generic_act1_volcano_pressure_plate_walk(<ACTIVE>, x, y, object_id, object_state, z, end, step);

            _generic_act1_volcano_pressure_plate_walk(<INACTIVE>, x, y, object_id, object_state, z, end, step);
        }

        fun _generic_act1_volcano_cave_hole_walk(entity) {
            smart_animate(entity, LOOP, ANIMATION_BOY.FALL_1);

            while(arg[0x10] < 0d19) {
                arg[0x10]++;

                _teleport(entity, entity[X], entity[Y] + 0d4);

                yield();
            }

            smart_animate(entity, ONCE, ANIMATION_BOY.LANDING);

            control(entity, False);
        }
        @install()
        @weak()
        @async()
        fun generic_act1_volcano_cave_hole_walk(entity) {
            sleep(0d44);

            _generic_act1_volcano_cave_hole_walk(entity);
        }
        @install()
        @weak()
        fun generic_act1_volcano_cave_hole(x_in, y_in, x_out, y_out, skip_wait_inactive) {
            control(ACTIVE, True);

            walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, -0d1, ACTIVE, NONE);

            while(<INACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                yield();
            }
            control(INACTIVE, True);


            set_camera(TILE_CENTER, x_out, y_out, 0x20);
            teleport(ACTIVE, x_out, y_out);
            face(ACTIVE, SOUTH);

            wait(CAMERA_PAN_Y);

            if!(skip_wait_inactive) {
                walk(INACTIVE, TILE_ABSOLUTE, x_in, y_in, INACTIVE, NONE);
                walk(INACTIVE, TILE_RELATIVE_DIRECT, 0d0, -0d1, INACTIVE, NONE);
            }

            teleport(INACTIVE, x_out, y_out);
            face(INACTIVE, SOUTH);

            generic_act1_volcano_cave_hole_walk(<INACTIVE>);
            _generic_act1_volcano_cave_hole_walk(<ACTIVE>);

            free_camera();
        }

        @install()
        @weak()
        fun generic_act2_dog_bridge_jump(direction:DIRECTION, x, y) {
            if(<ACTIVE> != <DOG>) {
                end();
            }

            control(NONE);
            // wait(DOG);

            attribute(DOG, NO_CLIP, True);

            walk(DOG, TILE_ABSOLUTE, x, y, DOG);
            face(DOG, direction);

            animate(DOG, ONCE, ANIMATION_DOG.ACT2_LEAP);
            wait(DOG);

            if(direction == DIRECTION.EAST) {
                walk(DOG, TILE_RELATIVE, 0d1, 0d0, DOG);
            } else {
                walk(DOG, TILE_RELATIVE, -0d1, 0d0, DOG);
            }

            attribute(DOG, NO_CLIP, False);

            control(BOTH);
        }

        @install()
        @weak()
        fun generic_yeet(character:CHARACTER, direction:DIRECTION, depth) {
            if((<ACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) > 0d0) {
                end();
            }

            control(NONE);

            if(character == <BOY>) {
                animate(character, LOOP, ANIMATION_BOY.LANDING);
                sleep(0d05);
                animate(character, LOOP, ANIMATION_BOY.FALL_1);
            } else {
                animate(character, LOOP, ANIMATION_DOG.ACT1_FALL1);
            }

            character[VELOCITY] = 0d30;

            if(direction == DIRECTION.NORTH) {
                arg[0x10] = character[Y] - 0d50;
                while(character[Y] > arg[0x10]) {
                    character[Y] -= 0d01;

                    yield();
                }
            } else if(direction == DIRECTION.EAST) {
                arg[0x10] = character[X] + 0d50;
                while(character[X] < arg[0x10]) {
                    character[X]++;

                    yield();
                }
            } else if(direction == DIRECTION.SOUTH) {
                arg[0x10] = character[Y] + 0d50;
                while(character[Y] < arg[0x10]) {
                    character[Y]++;

                    yield();
                }
            } else {
                arg[0x10] = character[X] - 0d50;
                while(character[X] > arg[0x10]) {
                    character[X] -= 0d01;

                    yield();
                }
            }

            arg[0x10] = character[Y] + 0d30;
            while(character[Y] < arg[0x10]) {
                character[Y] += 0d02;

                yield();
            }
        }

        @install()
        @weak()
        fun generic_yeet_waterfall() {
            control(NONE);

            animate(BOY, LOOP, ANIMATION_BOY.LANDING);
            sleep(0x05);

            animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
            <BOY>[VELOCITY] = 0x20;

            arg[0x00] = <BOY>[X] + 0x30;
            while(<BOY>[X] < arg[0x00]) {
                <BOY>[X]++;

                yield();
            }

            arg[0x02] = <BOY>[Y] + 0x40;
            while(<BOY>[Y] < arg[0x02]) {
                <BOY>[Y] += 0x02;

                yield();
            }
        }

        @install()
        @weak()
        fun generic_fall(depth, cutoff) {
            yield();
            control(NONE);

            attribute_bit(BOY, ROOT, True);
            attribute_bit(DOG, ROOT, True);

            if(<ACTIVE>[FACE_DIRECTION] == DIRECTION.NORTH) {
                teleport(INACTIVE, <ACTIVE>[X] + 0x10, <ACTIVE>[Y]);
            } else if(<ACTIVE>[FACE_DIRECTION] == DIRECTION.EAST) {
                teleport(INACTIVE, <ACTIVE>[X], <ACTIVE>[Y] + 0x10);
            } else if(<ACTIVE>[FACE_DIRECTION] == DIRECTION.SOUTH) {
                teleport(INACTIVE, <ACTIVE>[X] - 0x10, <ACTIVE>[Y]);
            } else {
                teleport(INACTIVE, <ACTIVE>[X] - 0x10, <ACTIVE>[Y]);
            }

            <INACTIVE>[Z_LEVEL] = <ACTIVE>[Z_LEVEL];

            // teleport(INACTIVE, <ACTIVE>[X], <ACTIVE>[Y]);

            animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
            animate(DOG, LOOP, ANIMATION_DOG.ACT1_FALL1);

            arg[0x12] = <ACTIVE>[X];
            arg[0x14] = <ACTIVE>[Y] + depth;

            while(<ACTIVE>[Y] < arg[0x14]) {
                <ACTIVE>[Y] += 0x02;
                <INACTIVE>[Y] += 0x02;

                if((cutoff > 0x00) && (<ACTIVE>[Y] >= cutoff)) {
                    attribute_bit(BOY, INVISIBLE, True);
                    attribute_bit(DOG, INVISIBLE, True);
                }

                yield();
            }

            attribute_bit(BOY, INVISIBLE, True);
            attribute_bit(DOG, INVISIBLE, True);
        }

        fun _generic_fall_gomi(character:CHARACTER, x, y, depth, falling_damage) {
            attach_to_script(character);

            walk(SCRIPT_OWNER, COORDINATE_ABSOLUTE_DIRECT, x, y, SCRIPT_OWNER);
            if(True) { // vanilla workaround: when the active player lands the inactive one's walk() is interrupted and the falling animation starts
                _teleport(SCRIPT_OWNER, x, y);
            }

            // face(character, SOUTH);
            animate_falling(character);

            while(character[Y] < depth) {
                character[Y] += 0d4;
                yield();
            }

            animate_landing(character, True);

            if(falling_damage > 0d0) {
                damage(SCRIPT_OWNER, falling_damage, True);
            }
        }
        @install()
        @weak()
        @async()
        fun _generic_fall_gomi_async(character:CHARACTER, x, y, depth, falling_damage) {
            _generic_fall_gomi(character, x, y, depth, falling_damage);
        }
        @install()
        @weak()
        fun _generic_fall_gomi_sync(character:CHARACTER, x, y, depth, falling_damage) {
            _generic_fall_gomi(character, x, y, depth, falling_damage);
        }
        @install()
        @weak()
        fun generic_fall_gomi(x, y, depth, falling_damage) {
            control(NONE);

            x *= 0d8;
            y *= 0d8;

            _generic_fall_gomi_async(<INACTIVE>, x + 0d8, y, depth, falling_damage);
            _generic_fall_gomi_sync(<ACTIVE>, x - 0d8, y, depth, falling_damage);

            control(BOTH);
        }

        fun generic_elevator_gomi(x_in, y_in, object_id_in, object_state_in, x_out, y_out, object_id_out, object_state_out) {
            control(NONE);

            walk(ACTIVE, TILE_ABSOLUTE, x_in, y_in, NONE, NONE);
            walk(INACTIVE, TILE_ABSOLUTE_DIRECT, x_in, y_in, BOTH, NONE);

            sleep(0d32);

            face(ACTIVE, NORTH);
            face(INACTIVE, NORTH);

            object[object_id_in] = object_state_in; // open elevator_bottom
            sleep(0d10);

            walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, -0d2, NONE, NONE);
            walk(INACTIVE, TILE_RELATIVE_DIRECT, 0d0, -0d2, BOTH, BOTH);

            face(ACTIVE, SOUTH);
            face(INACTIVE, SOUTH);

            animate(ACTIVE, LOOP, INVISIBLE);
            animate(INACTIVE, LOOP, INVISIBLE);

            object[object_id_in] = 0x00; // open elevator_bottom

            teleport(BOTH, x_out, y_out - 0d2);
            
            set_camera_entity(<ACTIVE>, 0x20);
            wait(CAMERA_PAN_Y);

            object[object_id_out] = object_state_out; // open elevator_bottom
            sleep(0d10);

            animate(ACTIVE, ONCE, DEFAULT);
            animate(INACTIVE, ONCE, DEFAULT);

            walk(ACTIVE, TILE_RELATIVE_DIRECT, 0d0, 0d2, NONE, NONE);
            walk(INACTIVE, TILE_RELATIVE_DIRECT, 0d0, 0d2, BOTH, NONE);
            sleep(0d10);

            object[object_id_out] = 0x00; // open elevator_bottom
            
            walk(ACTIVE, TILE_RELATIVE_DIRECT, -0d1, 0d1, NONE, NONE);
            walk(INACTIVE, TILE_RELATIVE_DIRECT, 0d1, 0d1, BOTH, NONE);

            free_camera();

            control(BOTH);
        }

        @install()
        @weak()
        fun pit_act2_between(height) {
            if(False) { // [0x05] Antiqua - Between 'mids and halls
                call(0x98b4b5);
            } else {
                control(NONE);

                <0x24ab> = <ACTIVE>[X];
                <0x24af> = <ACTIVE>[Y];

                <0x249d> = 0x0128;
                <0x249f> = height;

                animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
                animate(DOG, LOOP, ANIMATION_DOG.ACT2_FALL_4);

                yield();

                MEMORY.Z_AFTER_TELEPORT = 0x0020;
                teleport(BOY, <0x24ab> + 0x08, <0x24af>);
                yield();
                MEMORY.Z_AFTER_TELEPORT = 0x0020;
                teleport(DOG, <0x24ab> - 0x08, <0x24af>);
                yield();

                while(<0x24af> < <0x249f>) {
                    MEMORY.Z_AFTER_TELEPORT = 0x0020;
                    teleport(BOY, <0x24ab> + 0x08, <0x24af>);
                    yield();
                    MEMORY.Z_AFTER_TELEPORT = 0x0020;
                    teleport(DOG, <0x24ab> - 0x08, <0x24af>);
                    yield();

                    <0x24af> += 0x02;
                }

                // animate(BOY, LOOP, ANIMATION_ALL.INVISIBLE);
                // animate(DOG, LOOP, ANIMATION_ALL.INVISIBLE);
                attribute(BOY, INVISIBLE, True);
                attribute(DOG, INVISIBLE, True);
                attribute(BOY, ROOT, True);
                attribute(DOG, ROOT, True);
                yield();

                set(<0x22ed, 0x80>);
            }
        }

        @install()
        @weak()
        fun pit_act3_sewers() {
            if(True) { // [0x7a] Gothica - Ivor Tower Sewers Exterior (landing spot)
                call(0x98b4b5);
            } else { // buggy
                control(NONE);
                
                <0x24ab> = <0x2421> << 0x04;
                <0x24af> = <0x2423> << 0x04;

                if(<ACTIVE> == CHARACTER.BOY) {
                    animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
                } else {
                    animate(DOG, LOOP, ANIMATION_DOG.ACT3_FALL_2);
                }

                <0x24a7> = 0xfffe;

                while(<0x24a7> < 0x22) {
                    <0x24af> += <0x24a7>;
                    <0x24ab> += 0x10;

                    teleport(ACTIVE, <0x24ab> >> 0x04, <0x24af> >> 0x04);
                    yield();

                    <0x24a7>++;
                }

                if(<ACTIVE> == CHARACTER.BOY) {
                    animate(BOY, LOOP, ANIMATION_BOY.LANDING);
                } else {
                    animate(DOG, LOOP, ANIMATION_DOG.ACT3_SIT);
                }

                <0x24a7> = 0xfffe;

                while(<0x24a7> < 0x22) {
                    <0x24af> += <0x24a7>;
                    <0x24ab> += 0x10;

                    teleport(ACTIVE, <0x24ab> >> 0x04, <0x24af> >> 0x04);
                    yield();

                    <0x24a7>++;
                }

                if(<ACTIVE> == CHARACTER.BOY) {
                    animate(BOY, ONCE, ANIMATION_BOY.LANDING);
                } else {
                    animate(DOG, ONCE, ANIMATION_DOG.ACT3_SIT);
                }
            }
        }

        fun door_act4_airlock(x, y, door) {
            control(NONE);

            walk(ACTIVE, TILE_ABSOLUTE_DIRECT, x, y, ACTIVE);
            control(NONE);

            face(ACTIVE, SOUTH);
            door = 0x7e;
            sound(0xb0);

            sleep(0x14);

            arg[0x00] = <ACTIVE>[Y] + 0d40;
            while(<ACTIVE>[Y] < arg[0x00]) {
                <ACTIVE>[Y] += 0x02;
                yield();
            }

            door = 0x00;
            sound(0xb0);

            sleep(0x10);
        }
        @install()
        @weak()
        @async()
        fun door_act4_airlock_reverse(x, y, door) {
            control(NONE);
            face(ACTIVE, SOUTH);

            arg[0x10] = <ACTIVE>[Y];
            <ACTIVE>[Y] += 0d40;

            object[door] = 0x7e;
            sound(0xb0);

            sleep(0x14);

            while(<ACTIVE>[Y] > arg[0x10]) {
                <ACTIVE>[Y] -= 0x02;
                yield();
            }

            sleep(0x10);

            object[door] = 0x00;
            sound(0xb0);

            control(BOTH);
        }

        @install()
        @weak()
        fun vanilla_act3_sewer_door(object_id) {
            control(NONE);

            object[object_id] = 0x7e;
            sound(DOOR);

            sleep(0d30);

            walk(SCRIPT_OWNER, TILE_RELATIVE, 0d0, -0d1, NONE, NONE);

            sleep(0d15);
        }

        fun _generic_open_doors(open, with_sound) {
            if(with_sound > 0d0) {
                sound(DOOR);
            }

            if(open) {
                tile_animate(0x20, 0xff, 0x02);
            } else {
                tile_animate(0x20, 0xff, 0x00);
            }
        }
        @install()
        @weak()
        @async()
        fun _generic_door(close, with_sound) {
            // works for: nobilia market (both at once), nobilia square

            _generic_open_doors(True, with_sound);

            if(close > 0d0) {
                sleep(0d20);
                _generic_open_doors(False, with_sound);
            }
        }
        fun generic_door(close, with_sound) {
            _generic_door(close, with_sound);

            if(close == 0d0) {
                sleep(0d30);
            }
        }
        
        fun _generic_object_door_open(door_object, open, with_sound) {
            if(with_sound > 0d0) {
                sound(DOOR);
            }

            if(open) {
                object[door_object] = 0x01;
            } else {
                object[door_object] = 0x0;
            }
        }
        @install()
        @weak()
        @async()
        fun _generic_object_door(door_object, close, with_sound) {
            _generic_object_door_open(door_object, True, with_sound);

            if(close > 0d0) {
                sleep(0d40);
                _generic_object_door_open(door_object, False, with_sound);
            }
        }
        fun generic_object_door(door_object, close, with_sound) {
            _generic_object_door(door_object, close, with_sound);
            // sleep(0d30);

            if(close == 0d0) {
                control(NONE);
                sleep(0d20);
            }
        }
        
        fun teleporter_animation_in(entity) {
            sound(TELEPORTER);
            _add_placeholder(TELEPORT_IN, entity[X], entity[Y], ONCE);

            sleep(0d30);

            animate(entity, ONCE, ANIMATION_ALL.DEFAULT);
        }
        fun teleporter_animation_out(entity) {
            sound(TELEPORTER);
            _add_placeholder(TELEPORT_OUT, entity[X], entity[Y], ONCE);

            if(entity == <DOG>) {
                animate(DOG, ONCE_FREEZE, ANIMATION_DOG.ACT2_TELEPORT);
            } else {
                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.TELEPORT_IN);
            }

            wait(entity);
        }
        @install()
        @weak()
        @async()
        fun teleporter_in(direction:DIRECTION) {
            control(NONE);

            animate(ACTIVE, ONCE_FREEZE, ANIMATION_ALL.INVISIBLE);
            animate(INACTIVE, ONCE_FREEZE, ANIMATION_ALL.INVISIBLE);

            teleporter_animation_in(<ACTIVE>);
            if(direction == DIRECTION.NORTH) {
                walk(ACTIVE, TILE_RELATIVE, -0d1, -0d2, ACTIVE, NONE);
                face(ACTIVE, NORTH);
            } else if(direction == DIRECTION.EAST) {
                walk(ACTIVE, TILE_RELATIVE, 0d2, -0d1, ACTIVE, NONE);
                face(ACTIVE, EAST);
            } else if(direction == DIRECTION.SOUTH) {
                walk(ACTIVE, TILE_RELATIVE, 0d1, 0d2, ACTIVE, NONE);
                face(ACTIVE, SOUTH);
            } else if(direction == DIRECTION.WEST) {
                walk(ACTIVE, TILE_RELATIVE, -0d2, 0d1, ACTIVE, NONE);
                face(ACTIVE, WEST);
            }

            teleporter_animation_in(<INACTIVE>);
            if(direction == DIRECTION.NORTH) {
                walk(INACTIVE, TILE_RELATIVE, -0d2, 0d1, BOTH, NONE);
                face(INACTIVE, NORTH);
            } else if(direction == DIRECTION.EAST) {
                walk(INACTIVE, TILE_RELATIVE, 0d2, 0d1, BOTH, NONE);
                face(INACTIVE, EAST);
            } else if(direction == DIRECTION.SOUTH) {
                walk(INACTIVE, TILE_RELATIVE, -0d1, 0d2, BOTH, NONE);
                face(INACTIVE, SOUTH);
            } else if(direction == DIRECTION.WEST) {
                walk(INACTIVE, TILE_RELATIVE, -0d2, -0d1, BOTH, NONE);
                face(INACTIVE, SOUTH);
            }

            control(BOTH);
        } 
        @install()
        @weak()
        fun teleporter_out(x, y) {
            control(NONE);

            walk(ACTIVE, TILE_ABSOLUTE, x, y, ACTIVE);
            face(ACTIVE, SOUTH);
            teleporter_animation_out(<ACTIVE>);
            
            walk(INACTIVE, TILE_ABSOLUTE, x, y, INACTIVE);
            face(INACTIVE, SOUTH);
            teleporter_animation_out(<INACTIVE>);

            sleep(0d50);
        }

        fun scene_raptors_death_escape() {
            control(NONE);

            // boy collapses
            animate(BOY, LOOP, ANIMATION_BOY.SLEEP_UP);

            eval("18 1f 02 50 29 6a 1a d5 // (18) WRITE $2477 = *(boy + 26)");
            eval("18 21 02 50 29 6c 1a d5 // (18) WRITE $2479 = *(boy + 28)");

            eval("18 1f 02 08 1f 02 29 02 20 9a // (18) WRITE $2477 = $2477 + 0x20");

            eval("73 d1 88 1f 02 88 21 02 // (73) Make dog walk to $2477,$2479 directly");

            // dog walks to boy and looks west
            wait(DOG);
            face(DOG, WEST);
            sleep(0x3c);

            // dog drags boy east
            animate(BOY, LOOP, ANIMATION_BOY.DRAGGED);
            animate(DOG, LOOP, ANIMATION_DOG.ACT1_DRAGGING);

            eval("43 d0 08 1f 02 29 02 20 9b 88 21 02 // (43) Teleport boy to x:$2477 - 0x20, y:$2479");
            eval("43 d1 88 1f 02 88 21 02 // (43) Teleport dog to x:$2477, y:$2479");
            sleep(0x0f);

            eval("18 1f 02 08 1f 02 29 32 9a // (18) WRITE $2477 = $2477 + 2");

            // repeat 19 times
            eval("1a 00 12 00 29 31 9a // (1a) WRITE SCRIPT arg0 = signed arg0 + 1");
            eval("09 12 00 29 62 9f 07 00 // (09) IF (signed arg0 > 18) == FALSE THEN SKIP 7 (to 0x939069)");

            // fade out
            call(0x93907e);
            eval("04 02 00 // (04) SKIP 2 (to 0x93906b)");
            eval("05 cb // (05) SKIP -53 (to 0x939034)");

            fade_out();
        }

        fun explode_boss(x, y, radius) {
            <0x23bb> = x;
            <0x23b9> = y;
            
            code(0xb4, 0x03, entity_t(0x23bb), entity_t(0x23b9), 0xb0 + radius, address(0x92df1c), "// (b4) CALL Absolute (24bit) script 0x92df1c ('Unnamed ABS script 0x92df1c') WITH 3 ARGS $23b9, $23bb, 5");

            sleep(0xf0);
            call(ADDRESS.FADE_TO_WHITE);

            call(ADDRESS.EXPLODE_BOSS_STOP);
            call(0x92d752);
        }
        fun explode_last_entity(radius) {
            <0x2834> = <LAST_ENTITY>;

            eval("18 45 02 0d 00 00 29 6a 1a d5 // (18) WRITE $249d = *($2834 + 26)");
            eval("18 47 02 0d 00 00 29 6c 1a d5 // (18) WRITE $249f = *($2834 + 28)");
            
            code(0xb4, 0x03, entity_t(0x249d), entity_t(0x249f), param(radius), address(0x92df1c), "// (b4) CALL Absolute (24bit) script 0x92df1c ('Unnamed ABS script 0x92df1c') WITH 3 ARGS $23b9, $23bb, 5");

            sleep(0xf0);
            call(ADDRESS.FADE_TO_WHITE);

            call(ADDRESS.EXPLODE_BOSS_STOP);
            call(0x92d752);
        }

        fun dog_fountain() {
            call(0x96d5d7);
        }

        group sandpit() {
            fun vanilla_desert_sandpit(callback) {
                if(<ACTIVE> != <BOY>) {
                    end();
                }
                if(<BOY>[GENERAL_PURPOSE] > 0d0) {
                    end();
                }
                <BOY>[GENERAL_PURPOSE] = 0d1;

                while((<BOY>[CURRENT_GROUND] & 0xff) != 0x10) {
                    callback(arg[0x10]);

                    yield();
                    arg[0x10]++;
                }

                <BOY>[GENERAL_PURPOSE] = 0d0;
            }
            fun vanilla_desert_sandpit_in(x, y) {
                control(NONE);
                // <BOY>[GENERAL_PURPOSE] = 0d2;
                face(BOY, SOUTH);

                sleep(0d45);

                animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SWIRL_ENTER);

                sleep(0d60);

                object[0x03] = 0x7e;
                yield();

                // animate(BOY, ONCE_FREEZE, ANIMATION_BOY.SWIRL_ENTER);

                MEMORY.CAMERA_PAN_SPEED = 0d16;
                teleport(BOY, x, y);
                wait(CAMERA_PAN_Y);
                wait(CAMERA_PAN_X);
                free_camera();

                animate(BOY, ONCE, DEFAULT);

                control(BOY);
            }

            @install()
            @weak()
            @async()
            fun vanilla_sandpit_puke(entity) {
                smart_animate(entity, LOOP, ANIMATION_BOY.SWIRL_EXIT);
                face(entity, SOUTH);
                entity[VELOCITY] = 0d50;

                sleep(0d50);

                smart_animate(entity, LOOP, ANIMATION_BOY.FALL_1);

                sleep(0d50);

                smart_animate(entity, ONCE, ANIMATION_BOY.LANDING);
            }
            
            fun vanilla_desert_sandpit_out(x, y) {
                add_placeholder(SANDPIT_PUKE, x, y, ONCE);
                attach_to_script(LAST_ENTITY);

                if(<BOY>[GENERAL_PURPOSE] >= 0d2) {
                    <BOY>[GENERAL_PURPOSE] = 0d0;

                    teleport(BOY, x, y);
                    vanilla_sandpit_puke(<BOY>);
                }

                if(<DOG>[GENERAL_PURPOSE] >= 0d2) {
                    <DOG>[GENERAL_PURPOSE] = 0d0;
                    
                    teleport(DOG, x, y);
                    vanilla_sandpit_puke(<DOG>);
                }

                free_camera();

                wait(SCRIPT_OWNER);
                destroy(SCRIPT_OWNER);
            }
        };
    };

    group start_gimmicks() {
        fun drop_bomb(costs_ingredients) {
            if((<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) || (<BOY>[FLAGS_2] & ATTRIBUTE_FLAGS.HEALED)) {
                end();
            }
            if(<BOY>[STAMINA] < STAMINA.PERCENTAGE_75) {
                end();
            }

            if(costs_ingredients) {
                if(MEMORY.IRON < 0x04) {
                    if(False) {
                        MEMORY.STRING_PARAMETER_1 = MEMORY.IRON;
                        MEMORY.STRING_PARAMETER_2 = 0x04;

                        subtext("not enought iron([MEM1]<[MEM2])");
                    }

                    end();
                }
                if(MEMORY.GREASE < 0x02) {
                    if(False) {
                        MEMORY.STRING_PARAMETER_1 = MEMORY.GUNPOWDER;
                        MEMORY.STRING_PARAMETER_2 = 0x02;

                        subtext("not enought gunpowder([MEM1]<[MEM2])");
                    }
                    end();
                }

                MEMORY.IRON -= 0x04;
                MEMORY.GUNPOWDER -= 0x02;
            }

            animate(BOY, ONCE, ANIMATION_BOY.LOOT);

            _add_enemy(BOMB, <BOY>[X], <BOY>[Y]);
            attach_to_script(LAST_ENTITY);
            attach_script(SCRIPT_OWNER, DEATH, reference(vanilla_bomb_explosion));

            <BOY>[STAMINA] = STAMINA.PERCENTAGE_0;

            sleep(0d130);

            damage(SCRIPT_OWNER, 0d9999, False);

            sleep(0d60);
            
            destroy(SCRIPT_OWNER);
        }

        @install()
        @weak()
        fun _isaac_tear(costs_ingredients) {
            if((<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) || (<BOY>[FLAGS_2] & ATTRIBUTE_FLAGS.HEALED)) {
                end();
            }
            if(<BOY>[STAMINA] < STAMINA.PERCENTAGE_75) {
                end();
            }
            
            if(costs_ingredients) {
                if(MEMORY.WATER < 0x04) {
                    if(False) {
                        MEMORY.STRING_PARAMETER_1 = MEMORY.WATER;
                        MEMORY.STRING_PARAMETER_2 = 0x04;

                        subtext("not enought water([MEM1]<[MEM2])");
                    }

                    end();
                }

                MEMORY.WATER -= 0x04;
            }

            if(False) {
                animate(BOY, ONCE_FREEZE, DEFAULT);
            } else {
                if(((<BOY>[STATUS_ID_1] & 0xff) != STATUS_ID.ENERGIZE) && ((<BOY>[STATUS_ID_2] & 0xff) != STATUS_ID.ENERGIZE) && ((<BOY>[STATUS_ID_3] & 0xff) != STATUS_ID.ENERGIZE) && ((<BOY>[STATUS_ID_4] & 0xff) != STATUS_ID.ENERGIZE)) {
                    animate(BOY, ONCE, ANIMATION_BOY.LANDING);
                }
            }
            
            if(<BOY>[FACE_DIRECTION] == 0x00) {
                shoot_entity_offset_relative(BOY, ONION, 0x00, -0x15, 0x00, -0x60, 0x10, 0x0a);
            } else if(<BOY>[FACE_DIRECTION] == 0x04) {
                shoot_entity_offset_relative(BOY, ONION, 0x00, -0x15, 0x60, 0x00, 0x10, 0x0a);
            } else if(<BOY>[FACE_DIRECTION] == 0x08) {
                shoot_entity_offset_relative(BOY, ONION, 0x00, -0x15, 0x00, 0x60, 0x10, 0x0a);
            } else {
                shoot_entity_offset_relative(BOY, ONION, 0x00, -0x15, -0x60, 0x00, 0x10, 0x0a);
            }

            if(False) {
                sleep(0d10);

                if((<BOY>[FLAGS_7] & ATTRIBUTE_FLAGS.KNOCKBACK) == 0d0) {
                    animate(BOY, ONCE, DEFAULT);
                }
            }
            
            <BOY>[STAMINA] = STAMINA.PERCENTAGE_0;
        }
        @install()
        @weak()
        fun isaac_tear(costs_ingredients) {
            if(CUSTOM_FLAG.START_ISAAC_TEAR) {
                end();
            }
            CUSTOM_FLAG.START_ISAAC_TEAR = True;

            arg[0x10] = <BOY>[FACE_DIRECTION];

            while(CUSTOM_MEMORY.INPUT_P1 & 0x1000) {
                _face(<BOY>, arg[0x10]);

                _isaac_tear(costs_ingredients);

                yield();
            }

            CUSTOM_FLAG.START_ISAAC_TEAR = False;
        }

        @install()
        @weak()
        fun rocket_jump() {
            if(CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT >= 0d3) {
                end();
            } else {
                MEMORY.NEXT_DAMAGE_NO_KNOCKBACK = True;
                damage(BOY, CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT * 0d5, True);

                CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT++;
            }

            if(True) {
                _add_placeholder(EXPLOSION_1, <BOY>[X], <BOY>[Y]);
                arg[0x10] = <LAST_ENTITY>;
            }

            arg[0x12] = <BOY>[X];
            arg[0x14] = <BOY>[Y];

            if(True) {
                animate(BOY, LOOP, ANIMATION_BOY.FALL_2);
            }

            while(True) {
                if(False) {
                    <BOY>[Z] = 0d100; // TODO: drops by 1/f instead of staying at 100
                }

                if(<BOY>[HP] <= 0d0) {
                    destroy(arg[0x10]);
                    CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT--;
                    end();
                }

                if(CUSTOM_FLAG.START_MARIO_YUMP && (CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT == 0d1)) {
                    arg[0x16] = True;
                }

                arg[0x18] = <BOY>[X];
                arg[0x1a] = <BOY>[Y];

                if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                    teleport_relative(BOY, 0d0, -0d4);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH_EAST) {
                    teleport_relative(BOY, 0d3, -0d3);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                    teleport_relative(BOY, 0d4, 0d0);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH_EAST) {
                    teleport_relative(BOY, 0d3, 0d3);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                    teleport_relative(BOY, 0d0, 0d4);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH_WEST) {
                    teleport_relative(BOY, -0d3, 0d3);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                    teleport_relative(BOY, -0d4, 0d0);
                } if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH_WEST) {
                    teleport_relative(BOY, -0d3, -0d3);
                }

                if((<BOY>[X] == arg[0x18]) && (<BOY>[Y] == arg[0x1a])) {
                    if(arg[0x16]) {
                        arg[0x20] = <BOY>[FACE_DIRECTION];
                        control(NONE);
                        // attribute(BOY, INVISIBLE, True);

                        animate(BOY, ONCE, ANIMATION_ALL.DEFAULT);

                        sleep(0d5);

                        arg[0x1c] = <BOY>[X];
                        arg[0x1e] = <BOY>[Y];

                        if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                            walk(BOY, COORDINATE_ABSOLUTE, <BOY>[X], <BOY>[Y] + 0d24, NONE, NONE);
                        } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                            walk(BOY, COORDINATE_ABSOLUTE, <BOY>[X] - 0d24, <BOY>[Y], NONE, NONE);
                        } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                            walk(BOY, COORDINATE_ABSOLUTE, <BOY>[X], <BOY>[Y] - 0d24, NONE, NONE);
                        } else {
                            walk(BOY, COORDINATE_ABSOLUTE, <BOY>[X] + 0d24, <BOY>[Y], NONE, NONE);
                        }

                        sleep(0d10);

                        if((arg[0x1c] == <BOY>[X]) && (arg[0x1e] == <BOY>[Y])) {
                            _teleport(BOY, arg[0x12], arg[0x14]);

                            damage(BOY, 0d1, True);
                        } else {
                            <BOY>[X] = arg[0x1c];
                            <BOY>[Y] = arg[0x1e];
                            _face(<BOY>, arg[0x20]);
                        }

                        // attribute(BOY, INVISIBLE, False);
                        control(BOTH);
                    }
                    
                    animate(BOY, ONCE, ANIMATION_BOY.LANDING);

                    destroy(arg[0x10]);
                    CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT--;
                    end();
                }

                yield();
            }
        }

        @install()
        @weak()
        fun mario_yump(costs_ingredients) {
            if(CUSTOM_FLAG.START_MARIO_YUMP) {
                end();
            }

            if(CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT <= 0d0) {
                if((<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) || (<BOY>[FLAGS_2] & ATTRIBUTE_FLAGS.HEALED)) {
                    end();
                }
            }

            if(False) {
                if(<BOY>[Z] > 0d0) {
                    end();
                }
            }

            if(costs_ingredients) {
                if!(FLAG.DEBUG) {
                    if(MEMORY.WINGS <= 0d0) {
                        subtext("Cannot be used without wings");
                        end();
                    }
                }

                if(MEMORY.MUSHROOM < 0d1) {
                    if(False) {
                        MEMORY.STRING_PARAMETER_1 = MEMORY.MUSHROOM;
                        MEMORY.STRING_PARAMETER_2 = 0d1;

                        subtext("not enought water([MEM1]<[MEM2])");
                    }

                    end();
                }

                MEMORY.MUSHROOM -= 0d1;
            }

            CUSTOM_FLAG.START_MARIO_YUMP = True;
            CUSTOM_FLAG.NO_RUNNING = True;
            yield();

            arg[0x10] = <BOY>[X];
            arg[0x12] = <BOY>[Y];
            <BOY>[VELOCITY] = 0d30;
            attribute(BOY, NO_CLIP, True);

            sleep(0d60);
            // animate(BOY, LOOP, ANIMATION_BOY.FALL_1);

            // debug_memory(<BOY>[FACE_DIRECTION], <BOY>[FACE_DIRECTION]);

            // if((<BOY>[CURRENT_GROUND] & 0xff) != 0x10) {
            if(CUSTOM_MEMORY.START_ROCKET_JUMP_COUNT <= 0d0) {
                if(False) {
                    MEMORY.STRING_PARAMETER_1 = <BOY>[CURRENT_GROUND] & 0xff;
                    debug_subtext("yump damage: [MEM1]");
                }

                control(NONE);
                attribute(BOY, INVISIBLE, True);

                yield();

                arg[0x14] = <BOY>[X];
                arg[0x16] = <BOY>[Y];

                if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                    walk(BOY, TILE_RELATIVE, 0d0, -0d1, NONE, NONE);
                    face(BOY, DIRECTION.NORTH);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                    walk(BOY, TILE_RELATIVE, 0d1, 0d0, NONE, NONE);
                    face(BOY, DIRECTION.EAST);
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                    walk(BOY, TILE_RELATIVE, 0d0, 0d1, NONE, NONE);
                    face(BOY, DIRECTION.SOUTH);
                } else {
                    walk(BOY, TILE_RELATIVE, -0d1, 0d0, NONE, NONE);
                    face(BOY, WEST);
                }

                sleep(0d3);

                if((arg[0x14] == <BOY>[X]) && (arg[0x16] == <BOY>[Y])) {
                    <BOY>[X] = arg[0x10];
                    <BOY>[Y] = arg[0x12];

                    damage(BOY, 0d1, True);
                } else {
                    <BOY>[Y] = arg[0x16];
                    <BOY>[X] = arg[0x14];
                }

                attribute(BOY, INVISIBLE, False);

                bomb_entity(BOY, 0d30);
                sound(HEAVY_IMPACT);

                control(BOTH);
            }


            // animate(BOY, LOOP, ANIMATION_ALL.DEFAULT);
            attribute(BOY, NO_CLIP, False);
            // walk(BOY, TILE_RELATIVE, 0x00, 0x00, NONE);
            // debug_memory(<0x2834>, <BOY>[X]);
            // sleep(0x30);
            // debug_memory(<0x2836>, <BOY>[Y]);


            if(True) {
                CUSTOM_FLAG.START_MARIO_YUMP = False;
                CUSTOM_FLAG.NO_RUNNING = False;
            }
        }

        fun windwalker_rocket() {
            if((<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) || (<BOY>[FLAGS_2] & ATTRIBUTE_FLAGS.HEALED)) {
                end();
            }

            shoot_entity_offset_relative(BOY, ONION, 0x10, 0x00, 0x00ff, 0x00, 0x10, 0xff);
            sound(PROJECTILE_SHOOTING);
        }

        @install()
        @weak()
        fun quantum_jump() {
            arg[0x10] = <BOY>[X];
            arg[0x12] = <BOY>[Y];

            if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                teleport_screen(0d0, -0d1);

                if(<BOY>[Y] < arg[0x12]) {
                    arg[0x14] = True;
                }
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                teleport_screen(0d1, 0d0);

                if(<BOY>[X] > arg[0x10]) {
                    arg[0x14] = True;
                }
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                teleport_screen(0d0, 0d1);

                if(<BOY>[Y] > arg[0x12]) {
                    arg[0x14] = True;
                }
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                teleport_screen(-0d1, 0d0);

                if(<BOY>[X] < arg[0x10]) {
                    arg[0x14] = True;
                }
            }

            if((arg[0x10] == <BOY>[X]) && (arg[0x12] == <BOY>[Y])) {
                MEMORY.STRING_PARAMETER_1 = arg[0x14];

                debug_subtext("nay = [MEM1]");
            } else {
                MEMORY.STRING_PARAMETER_1 = arg[0x14];

                debug_subtext("yay = [MEM1]");
            }
        }

        fun dodge_roll() {
            if(False) {
                control(NONE);
            }

            animate(BOY, ONCE_FREEZE, ANIMATION_BOY.LANDING);

            if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                arg[0x12] = 0d3;
                arg[0x14] = 0d0;
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                arg[0x12] = 0d0;
                arg[0x14] = 0d3;
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                arg[0x12] = -0d3;
                arg[0x14] = 0d0;
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                arg[0x12] = 0d0;
                arg[0x14] = -0d3;
            }

            while(arg[0x10] < 0d10) {
                arg[0x10]++;

                teleport_relative(BOY, arg[0x12], arg[0x14]);
                yield();
            }

            animate(BOY, ONCE, DEFAULT);
            
            if(False) {
                control(BOTH);
            }
        }

        @install()
        @weak()
        fun cycle_weapon() {
            if(FLAG.SWORD_4) {
                arg[0x10] = GAIN_WEAPON.SWORD_4;
            } else if(FLAG.SWORD_3) {
                arg[0x10] = GAIN_WEAPON.SWORD_3;
            } else if(FLAG.SWORD_2) {
                arg[0x10] = GAIN_WEAPON.SWORD_2;
            } else if(FLAG.SWORD_1) {
                arg[0x10] = GAIN_WEAPON.SWORD_1;
            }

            if(FLAG.AXE_4) {
                arg[0x12] = GAIN_WEAPON.AXE_4;
            } else if(FLAG.AXE_3) {
                arg[0x12] = GAIN_WEAPON.AXE_3;
            } else if(FLAG.AXE_2) {
                arg[0x12] = GAIN_WEAPON.AXE_2;
            } else if(FLAG.AXE_1) {
                arg[0x12] = GAIN_WEAPON.AXE_1;
            }

            if(FLAG.SPEAR_4) {
                arg[0x14] = GAIN_WEAPON.SPEAR_4;
            } else if(FLAG.SPEAR_3) {
                arg[0x14] = GAIN_WEAPON.SPEAR_3;
            } else if(FLAG.SPEAR_2) {
                arg[0x14] = GAIN_WEAPON.SPEAR_2;
            } else if(FLAG.SPEAR_1) {
                arg[0x14] = GAIN_WEAPON.SPEAR_1;
            }
            
            if((MEMORY.CURRENT_WEAPON >= WEAPON_INDEX.SWORD_1) && (MEMORY.CURRENT_WEAPON <= WEAPON_INDEX.SWORD_4)) {
                if(arg[0x10] > MEMORY.CURRENT_WEAPON) {
                    MEMORY.GAIN_WEAPON = arg[0x10];
                } else if(arg[0x12]) {
                    MEMORY.GAIN_WEAPON = arg[0x12];
                } else if(arg[0x14]) {
                    MEMORY.GAIN_WEAPON = arg[0x14];
                }
            } else if((MEMORY.CURRENT_WEAPON >= WEAPON_INDEX.AXE_1) && (MEMORY.CURRENT_WEAPON <= WEAPON_INDEX.AXE_4)) {
                if(arg[0x12] > MEMORY.CURRENT_WEAPON) {
                    MEMORY.GAIN_WEAPON = arg[0x12];
                } else if(arg[0x14]) {
                    MEMORY.GAIN_WEAPON = arg[0x14];
                } else if(arg[0x10]) {
                    MEMORY.GAIN_WEAPON = arg[0x10];
                }
            } else if((MEMORY.CURRENT_WEAPON >= WEAPON_INDEX.SPEAR_1) && (MEMORY.CURRENT_WEAPON <= WEAPON_INDEX.SPEAR_4)) {
                if(arg[0x14] > MEMORY.CURRENT_WEAPON) {
                    MEMORY.GAIN_WEAPON = arg[0x14];
                } else if(arg[0x10]) {
                    MEMORY.GAIN_WEAPON = arg[0x10];
                } else if(arg[0x12]) {
                    MEMORY.GAIN_WEAPON = arg[0x12];
                }
            }
        }

        fun enor_pearl() {
            sleep(0d20);

            arg[0x10] = <BOY>[X];
            arg[0x12] = <BOY>[Y];
            sleep(0d3);
            arg[0x14] = <BOY>[X] - arg[0x10];
            arg[0x16] = <BOY>[Y] - arg[0x12];

            debug_memory(arg[0x14], arg[0x16]);

            _add_placeholder(DIAMOND_EYE_1, <BOY>[X] - 0d10, <BOY>[Y]);
            attach_to_script(LAST_ENTITY);
            <SCRIPT_OWNER>[VELOCITY] = 0d50;

            yield();
            while(<SCRIPT_OWNER>[Z] > 0d0) {
                <SCRIPT_OWNER>[X] += arg[0x14];
                <SCRIPT_OWNER>[Y] += arg[0x16];

                sleep(0d3);
            }

            teleporter_animation_out(<BOY>);
            destroy(SCRIPT_OWNER);
            wait(BOY);
            _teleport(BOY, <SCRIPT_OWNER>[X], <SCRIPT_OWNER>[Y]);
            teleporter_animation_in(<BOY>);
        }

        fun bone_whip() {
            _add_enemy(BONE_SNAKE, <BOY>[X] - 0d10, <BOY>[Y], INACTIVE_IMORTAL);
            face(LAST_ENTITY, WEST);
            animate(LAST_ENTITY, ONCE, ANIMATION_ALL.SLASH_1);
            sleep(0d100);
            destroy(LAST_ENTITY);
        }

        fun dash_teleport() {
            if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                arg[0x10] = 0d0;
                arg[0x12] = -0d5;
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                arg[0x10] = 0d5;
                arg[0x12] = 0d0;
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                arg[0x10] = 0d0;
                arg[0x12] = 0d5;
            } else {
                arg[0x10] = -0d5;
                arg[0x12] = 0d0;
            }

            while((<BOY>[X] != arg[0x14]) || (<BOY>[Y] != arg[0x16])) {
                arg[0x14] = <BOY>[X];
                arg[0x16] = <BOY>[Y];

                teleport_relative(BOY, arg[0x10], arg[0x12]);
                // yield();
            }

            teleporter_animation_in(<BOY>);
        }

        fun hookshot() {
            _add_enemy(SPIDER_YELLOW, <BOY>[X] - 0d10, <BOY>[Y], INACTIVE_IMORTAL);
            face(LAST_ENTITY, WEST);
            yield();

            while((<LAST_ENTITY>[X] != arg[0x10]) || (<LAST_ENTITY>[Y] != arg[0x12])) {
                arg[0x10] = <LAST_ENTITY>[X];
                arg[0x12] = <LAST_ENTITY>[Y];

                teleport_relative(LAST_ENTITY, -0d1, 0d0);

                if(<LAST_ENTITY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                    _face(<LAST_ENTITY>, EAST);
                } else if(<LAST_ENTITY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                    _face(<LAST_ENTITY>, SOUTH);
                } else if(<LAST_ENTITY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                    _face(<LAST_ENTITY>, WEST);
                } else if(<LAST_ENTITY>[FACE_DIRECTION] == FACE_DIRECTION.WEST) {
                    _face(<LAST_ENTITY>, NORTH);
                }

                yield();
            }

            subtext("drag");

            if(True) {
                find_all(STONE_ROUND, {
                    if(False) {
                        _drag(<LAST_ENTITY>, <BOY>[X], <BOY>[Y]);
                    } else {
                        _drag(<BOY>, <LAST_ENTITY>[X] + 0d16, <LAST_ENTITY>[Y] + 0d16);

                        _teleport(BOY, <BOY>[X], <BOY>[Y]);

                        destroy(LAST_ENTITY);
                    }
                    end();
                });
                
            } if(False) {

                arg[0x14]; // TODO: shouldn't use foreign memory
                arg[0x14] = 0x3de5;

                while(arg[0x14] <= 0x4DFB) {
                    if((arg[0x14][TYPE] >= 0d51) && (arg[0x14][TYPE] < 0d141)) {
                        if!(arg[0x14][FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                            arg[0x16]++;

                            MEMORY.STRING_PARAMETER_1 = arg[0x14][TYPE];
                            subtext("[MEM1]");

                            sleep(0d60);

                            _teleport(arg[0x14], <LAST_ENTITY>[X], <LAST_ENTITY>[Y]);
                        }
                    }

                    arg[0x14] += 0x8e;
                    yield();
                }

                MEMORY.STRING_PARAMETER_1 = arg[0x16];
                subtext("[MEM1]");

                end();
            } else {
                check_range_old(<LAST_ENTITY>, <DOG>, 0d25, 0d25, {
                    subtext("dog");

                    arg[0x18] = <DOG>;
                });


                if(arg[0x18]) {
                    _drag(<LAST_ENTITY>, <BOY>[X], <BOY>[Y]);
                    _teleport(LAST_ENTITY, <LAST_ENTITY>[X], <LAST_ENTITY>[Y]);

                    _drag(<DOG>, <BOY>[X], <BOY>[Y]);
                    _teleport(DOG, <DOG>[X], <DOG>[Y]);

                    destroy(LAST_ENTITY);
                } else {
                    if(False) {
                        _drag(<LAST_ENTITY>, <BOY>[X], <BOY>[Y]);
                    } else {
                        _drag(<BOY>, <LAST_ENTITY>[X] + 0d16, <LAST_ENTITY>[Y] + 0d16);

                        _teleport(BOY, <BOY>[X], <BOY>[Y]);

                        // destroy(LAST_ENTITY);
                    }
                }
            }
        }

        fun mario_fireflower() {
            if((<BOY>[FLAGS_1] & ATTRIBUTE_FLAGS.IN_ANIMATION) || (<BOY>[FLAGS_2] & ATTRIBUTE_FLAGS.HEALED)) {
                end();
            }
            if(<BOY>[STAMINA] < STAMINA.PERCENTAGE_50) {
                end();
            }
            
            animate(BOY, ONCE, ANIMATION_BOY.LANDING);

            if(<BOY>[FACE_DIRECTION] == 0x00) {
                shoot_entity_offset_relative(BOY, LIGHTNING_BALL, 0d0, -0d10, 0d0, -0d100, 0d40, 0x0a);
            } else if(<BOY>[FACE_DIRECTION] == 0x04) {
                shoot_entity_offset_relative(BOY, LIGHTNING_BALL, 0d0, -0d10, 0d100, 0d0, 0d40, 0x0a);
            } else if(<BOY>[FACE_DIRECTION] == 0x08) {
                shoot_entity_offset_relative(BOY, LIGHTNING_BALL, 0d0, -0d10, 0d0, 0d100, 0d40, 0x0a);
            } else {
                shoot_entity_offset_relative(BOY, LIGHTNING_BALL, 0d0, -0d10, -0d100, 0d0, 0d40, 0x0a);
            }

            <BOY>[STAMINA] = STAMINA.PERCENTAGE_0;
        }

        fun zelda_power_glove_stop(level) {
            if(level < 0d3) {
                CUSTOM_FLAG.NO_RUNNING = False;
            }
            if(level == 0d1) {
                attribute(BOY, ROOT, False);
            }

            animate(BOY, ONCE, ANIMATION_BOY.LANDING);
            wait(BOY);

            <SCRIPT_OWNER>[GENERAL_PURPOSE] = False;
            end();
        }

        @install()
        @weak()
        @async()
        fun _zelda_power_glove(level) {
            if(level == 0d0) {
                subtext("!");

                arg[0x12] = <BOY>[FACE_DIRECTION];

                arg[0x14] = <SCRIPT_OWNER>[X];
                arg[0x16] = <SCRIPT_OWNER>[Y];

                while(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                    arg[0x10]++;

                    arg[0x18] = <SCRIPT_OWNER>[X];
                    arg[0x1a] = <SCRIPT_OWNER>[Y];

                    if(arg[0x12] == FACE_DIRECTION.NORTH) {
                        _teleport(SCRIPT_OWNER, arg[0x14], <BOY>[Y] - 0d20);

                        if((<SCRIPT_OWNER>[Y] > arg[0x1a]) || (<BOY>[X] > (arg[0x18] + 0d15)) || (<BOY>[X] < (arg[0x18] - 0d15))) {
                            zelda_power_glove_stop(level);
                        }
                    } else if(arg[0x12] == FACE_DIRECTION.EAST) {
                        _teleport(SCRIPT_OWNER, <BOY>[X] + 0d20, arg[0x16]);

                        if((<SCRIPT_OWNER>[X] < arg[0x18]) || (<BOY>[Y] > (arg[0x1a] + 0d15)) || (<BOY>[Y] < (arg[0x1a] - 0d15))) {
                            zelda_power_glove_stop(level);
                        }
                    } else if(arg[0x12] == FACE_DIRECTION.SOUTH) {
                        _teleport(SCRIPT_OWNER, arg[0x14], <BOY>[Y] + 0d20);

                        if((<SCRIPT_OWNER>[Y] < arg[0x1a]) || (<BOY>[X] > (arg[0x18] + 0d15)) || (<BOY>[X] < (arg[0x18] - 0d15))) {
                            zelda_power_glove_stop(level);
                        }
                    } else {
                        _teleport(SCRIPT_OWNER, <BOY>[X] - 0d20, arg[0x16]);

                        if((<SCRIPT_OWNER>[X] > arg[0x18]) || (<BOY>[Y] > (arg[0x1a] + 0d15)) || (<BOY>[Y] < (arg[0x1a] - 0d15))) {
                            zelda_power_glove_stop(level);
                        }
                    }

                    yield();
                }

                zelda_power_glove_stop(level);
            }

            while(CUSTOM_MEMORY.INPUT_P1 & 0x8000) {
                arg[0x10]++;

                _teleport(SCRIPT_OWNER, <BOY>[X], <BOY>[Y] - 0d20);

                yield();
            }

            if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                _teleport(SCRIPT_OWNER, <BOY>[X], <BOY>[Y] - 0d20);
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                _teleport(SCRIPT_OWNER, <BOY>[X] + 0d20, <BOY>[Y]);
            } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                _teleport(SCRIPT_OWNER, <BOY>[X], <BOY>[Y] + 0d20);
            } else {
                _teleport(SCRIPT_OWNER, <BOY>[X] - 0d20, <BOY>[Y]);
            }

            if((level >= 0d3) && (arg[0x10] < 0d10)) {
                if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.NORTH) {
                    arg[0x12] = 0d0;
                    arg[0x14] = -0d2;
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.EAST) {
                    arg[0x12] = 0d2;
                    arg[0x14] = 0d0;
                } else if(<BOY>[FACE_DIRECTION] == FACE_DIRECTION.SOUTH) {
                    arg[0x12] = 0d0;
                    arg[0x14] = 0d2;
                } else {
                    arg[0x12] = -0d2;
                    arg[0x14] = 0d0;
                }

                while((arg[0x16] != <SCRIPT_OWNER>[X]) || (arg[0x18] != <SCRIPT_OWNER>[Y])) {
                    arg[0x16] = <SCRIPT_OWNER>[X];
                    arg[0x18] = <SCRIPT_OWNER>[Y];

                    teleport_relative(SCRIPT_OWNER, arg[0x12], arg[0x14]);

                    yield();
                }

                <SCRIPT_OWNER>[GENERAL_PURPOSE] = False;
            } else {
                if(level < 0d3) {
                    CUSTOM_FLAG.NO_RUNNING = False;
                }
                if(level == 0d1) {
                    attribute(BOY, ROOT, False);
                }

                animate(BOY, ONCE, ANIMATION_BOY.LANDING);
                wait(BOY);

                <SCRIPT_OWNER>[GENERAL_PURPOSE] = False;
            }
        }
        fun zelda_power_glove(level) {
            if(<SCRIPT_OWNER>[GENERAL_PURPOSE] != 0d0) {
                fake_b();
                end();
            }

            <SCRIPT_OWNER>[GENERAL_PURPOSE] = True;

            animate(BOY, ONCE, ANIMATION_BOY.LANDING);

            if(level == 0d1) {
                attribute(BOY, ROOT, True);
            }
            if(level < 0d3) {
                CUSTOM_FLAG.NO_RUNNING = True;

                while((CUSTOM_MEMORY.INPUT_P1 & 0x8000) && (arg[0x10] < 0d120)) {
                    arg[0x10]++;

                    animate(BOY, ONCE, ANIMATION_BOY.LANDING);

                    yield();
                }
            } else {
                arg[0x10] = 0d120;
            }

            wait(BOY);

            if(False) {
                MEMORY.STRING_PARAMETER_1 = arg[0x10];
                _subtext("memory = [MEM1] / [MEM2] / [MEM3]");
            }

            if(arg[0x10] >= 0d120) {
                _zelda_power_glove(level);
            } else {
                if(level < 0d3) {
                    CUSTOM_FLAG.NO_RUNNING = False;
                }
                if(level == 0d1) {
                    attribute(BOY, ROOT, False);
                }
                <SCRIPT_OWNER>[GENERAL_PURPOSE] = False;
                end();
            }
        }
    };

    group debug_helper() {
        @install()
        @weak()
        fun _debug_boy() {
            MEMORY.STRING_PARAMETER_1 = <BOY>[X];
            MEMORY.STRING_PARAMETER_2 = <BOY>[Y];

            debug_subtext("boy = [MEM1]/[MEM2]");
        }
        @install()
        @weak()
        fun debug_boy() {
            MEMORY.STRING_PARAMETER_1 = <BOY>[X] / 0x08;
            MEMORY.STRING_PARAMETER_2 = <BOY>[Y] / 0x08;

            debug_subtext("boy = [MEM1]/[MEM2]");
        }

        fun debug_memory(m1, m2) {
            MEMORY.STRING_PARAMETER_1 = m1;
            MEMORY.STRING_PARAMETER_2 = m2;
            // MEMORY.STRING_PARAMETER_3 = m3;

            debug_subtext("memory = [MEM1] / [MEM2] / [MEM3]");
        }
        fun debug_memory3(m1, m2, m3) {
            MEMORY.STRING_PARAMETER_1 = m1;
            MEMORY.STRING_PARAMETER_2 = m2;
            MEMORY.STRING_PARAMETER_3 = m3;

            debug_subtext("memory = [MEM1] / [MEM2] / [MEM3]");
        }

        fun test_stuff() {
            unlock(INGREDIENTS);

            unlock(REVEALER);
            unlock(LEVITATE);

            select_alchemy();
        }

        fun test_map_palettes() {
            <0x2437> = 0x0000;
            sleep(0x30);
            <0x2437> = 0x0001;
            sleep(0x30);
            <0x2437> = 0x0002;
            sleep(0x30);
            <0x2437> = 0x0003;
            sleep(0x30);
            <0x2437> = 0x0004;
            sleep(0x30);
            <0x2437> = 0x0005;
            sleep(0x30);
            <0x2437> = 0x0006;
            sleep(0x30);
            <0x2437> = 0x0007;
            sleep(0x30);
            <0x2437> = 0x0008;
            sleep(0x30);
            <0x2437> = 0x0009;
            sleep(0x30);
            <0x2437> = 0x000a;
            sleep(0x30);
            <0x2437> = 0x000b;
            sleep(0x30);
            <0x2437> = 0x000c;
            sleep(0x30);
            <0x2437> = 0x000d;
            sleep(0x30);
            <0x2437> = 0x000e;
            sleep(0x30);
            <0x2437> = 0x000f;
            sleep(0x30);
        }

        fun empty_check(name, memory) {
            if(memory > 0x00) {
                MEMORY.STRING_PARAMETER_1 = memory;

                debug_subtext("not empty: [MEM1]");
                sleep(0d30);
                debug_subtext(name);
                end();
            }
        }

        fun test_palette(enemy:ENEMY, initial_value, remove) {
            teleport(DOG, 0xff, 0xff);
            // attribute(BOY, INVINCIBLE_TEMP, True);
            <BOY>[HP] = SYSTEM.HP_MAX;

            <0x2702> = <0x2704> + initial_value;
            <0x2704> += 0d2;

            debug_memory(<0x2702>, 0d0);

            _add_enemy(enemy, <BOY>[X], <BOY>[Y] - 0d30);
            attribute(LAST_ENTITY, ROOT, True);
            attach_to_script(LAST_ENTITY);

            MEMORY.PACIFIED = False;

            if(remove) {
                sleep(0d120);

                damage(SCRIPT_OWNER, 0d999, True);
                sleep(0d30);
                destroy(SCRIPT_OWNER);
            }
        }

        fun test_trading() {
            question_max("deal?[CHOICE]+5 rice[CHOICE]2 rice -> 1 spice[CHOICE]1 spice -> 5 souls[CHOICE]pay 10 souls[CHOICE]2 rice + 1 spice -> 10 souls", 0d10);

            if(MEMORY.QUESTION_ANSWER == 0d0) {
                trade_items(RICE, 0d5);
            } else if(MEMORY.QUESTION_ANSWER == 0d1) {
                trade_items(SPICE, 0d1, RICE, 0d2);
            } else if(MEMORY.QUESTION_ANSWER == 0d2) {
                trade_items(MONEY, 0d5, SPICE, 0d1);
            } else if(MEMORY.QUESTION_ANSWER == 0d3) {
                item_pay(MONEY, 0d10);
                // trade_items(MONEY, 0d5, SPICE, 0d1);
            } else if(MEMORY.QUESTION_ANSWER == 0d4) {
                trade_items(MONEY, 0d10, RICE, 0d2, SPICE, 0d1);
            }

            control(BOTH);
        }
    };

    group ai_moves() {
        // projectile

        fun ring_shoot(entity, projectile, x, y, with_sound) {
            if(dead(entity)) {
                end();
            }
            if(with_sound > 0d0) {
                sound(PROJECTILE_SHOOTING);
            }

            shoot_entity_relative(entity, projectile, x, y, 0x14, 0x00);
        }
        @install()
        @weak()
        fun ai_move_projectile_ring(entity, projectile:THROWABLE, radius, step, pause, timer, with_double, with_sound) {
            control(entity, True);
            face(entity, EAST);

            arg[0x10] = 0x0100;
            arg[0x12] = 0x0000;

            while(timer > 0d0) {
                timer--;

                while(arg[0x12] < radius) {
                    ring_shoot(entity, projectile, arg[0x10], arg[0x12], with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, -(arg[0x10]), -(arg[0x12]), with_sound);
                    }
                    sleep(pause);
                    arg[0x12] += step;
                }
                while(arg[0x10] > 0x00) {
                    ring_shoot(entity, projectile, arg[0x10], arg[0x12], with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, -(arg[0x10]), -(arg[0x12]), with_sound);
                    }
                    sleep(pause);
                    arg[0x10] -= step;
                }

                face(entity, SOUTH);
                while(arg[0x10] < radius) {
                    ring_shoot(entity, projectile, -(arg[0x10]), arg[0x12], with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, arg[0x10], -(arg[0x12]), with_sound);
                    }
                    sleep(pause);
                    arg[0x10] += step;
                }
                while(arg[0x12] > 0x00) {
                    ring_shoot(entity, projectile, -(arg[0x10]), arg[0x12], with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, arg[0x10], -(arg[0x12]), with_sound);
                    }
                    sleep(pause);
                    arg[0x12] -= step;
                }

                face(entity, WEST);
                while(arg[0x12] < radius) {
                    ring_shoot(entity, projectile, -(arg[0x10]), -(arg[0x12]), with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, arg[0x10], arg[0x12], with_sound);
                    }
                    sleep(pause);
                    arg[0x12] += step;
                }
                while(arg[0x10] > 0x00) {
                    ring_shoot(entity, projectile, -(arg[0x10]), -(arg[0x12]), with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, arg[0x10], arg[0x12], with_sound);
                    }
                    sleep(pause);
                    arg[0x10] -= step;
                }

                face(entity, NORTH);
                while(arg[0x10] < radius) {
                    ring_shoot(entity, projectile, arg[0x10], -(arg[0x12]), with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, -(arg[0x10]), arg[0x12], with_sound);
                    }
                    sleep(pause);
                    arg[0x10] += step;
                }
                while(arg[0x12] > 0x00) {
                    ring_shoot(entity, projectile, arg[0x10], -(arg[0x12]), with_sound);
                    if(with_double) {
                        yield();
                        ring_shoot(entity, projectile, -(arg[0x10]), arg[0x12], with_sound);
                    }
                    sleep(pause);
                    arg[0x12] -= step;
                }
            }

            control(entity, False);
        }

        fun toss_shoot(entity, projectile:THROWABLE, target, delta_x, delta_y) {
            shoot_entity_absolute(entity, projectile, target[X] + delta_x, target[Y] + delta_y, 0d50, 0d0);
        }
        @install()
        @weak()
        fun ai_move_projectile_toss(entity, projectile:THROWABLE, target, count) {
            face(entity, SOUTH);

            while(arg[0x10] < count) {
                arg[0x10]++;

                arg[0x12] = arg[0x10] + (randrange(0d3) * arg[0x10]);
                if(rand(0x1)) {
                    arg[0x12] = 0d0 - arg[0x12];
                }

                arg[0x14] = arg[0x10] + (randrange(0d3) * arg[0x10]);
                if(rand(0x1)) {
                    arg[0x14] = 0d0 - arg[0x14];
                }

                toss_shoot(entity, projectile, target, arg[0x12], arg[0x14]);
                
                if(arg[0x10] < count) {
                    sleep(0d5 + randrange(0d8));
                }
            }
        }

        fun puke_shoot(entity, projectile:THROWABLE, target, delta_x, delta_y) {
            shoot_entity_absolute(entity, projectile, target[X] + delta_x, target[Y] + delta_y, 0d30 + randrange(0d20), 0d10);
        }
        @install()
        @weak()
        fun ai_move_projectile_puke(entity, projectile:THROWABLE, target, count) {
            face_target(entity, target);

            puke_shoot(entity, projectile, target, 0d0, 0d0);
            arg[0x10]++;

            while(arg[0x10] < count) {
                arg[0x10]++;

                puke_shoot(entity, projectile, target, randrange(0x40), randrange(0x20));

                if(arg[0x10] < count) {
                    sleep(randrange(0d10));
                }
            }
        }

        @install()
        @weak()
        fun ai_move_projectile_splash(entity, projectile:THROWABLE) {
            shoot_entity_relative(entity, projectile, 0d30 + randrange(0d30), 0d30 + randrange(0d30), 0d30 + randrange(0d15), 0d10);
            shoot_entity_relative(entity, projectile, 0d30 + randrange(0d30), 0d30 + randrange(0d30), 0d30 + randrange(0d15), 0d10);

            shoot_entity_relative(entity, projectile, -0d30 - randrange(0d30), 0d30 + randrange(0d30), 0d30 + randrange(0d15), 0d10);
            shoot_entity_relative(entity, projectile, -0d30 - randrange(0d30), 0d30 + randrange(0d30), 0d30 + randrange(0d15), 0d10);

            shoot_entity_relative(entity, projectile, -0d30 - randrange(0d30), -0d30 - randrange(0d30), 0d30 + randrange(0d15), 0d10);
            shoot_entity_relative(entity, projectile, -0d30 - randrange(0d30), -0d30 - randrange(0d30), 0d30 + randrange(0d15), 0d10);

            shoot_entity_relative(entity, projectile, 0d30 + randrange(0d30), -0d30 - randrange(0d30), 0d30 + randrange(0d15), 0d10);
            shoot_entity_relative(entity, projectile, 0d30 + randrange(0d30), -0d30 - randrange(0d30), 0d30 + randrange(0d15), 0d10);
        }

        @install()
        @weak()
        fun ai_move_projectile_x(entity, projectile:THROWABLE, radius) {
            shoot_entity_relative(entity, projectile, radius, -(radius), 0x10, 0xff); // north east
            shoot_entity_relative(entity, projectile, -(radius), -(radius), 0x10, 0xff); // north west
            shoot_entity_relative(entity, projectile, radius, radius, 0x10, 0xff); // south east
            shoot_entity_relative(entity, projectile, -(radius), radius, 0x10, 0xff); // south west
        }

        @install()
        @weak()
        fun ai_move_projectile_plus(entity, projectile:THROWABLE, radius) {
            shoot_entity_relative(entity, projectile, 0x00, -(radius), 0x10, 0xff); // north
            shoot_entity_relative(entity, projectile, radius, 0x00, 0x10, 0xff); // east
            shoot_entity_relative(entity, projectile, 0x00, radius, 0x10, 0xff); // south
            shoot_entity_relative(entity, projectile, -(radius), 0x00, 0x10, 0xff); // west
        }

        @install()
        @weak()
        fun ai_move_projectile_star(entity, projectile:THROWABLE, radius) {
            ai_move_projectile_x(entity, projectile, (radius * 0d2) / 0d3);

            ai_move_projectile_plus(entity, projectile, radius);
        }

        @install()
        @weak()
        fun ai_move_tesla(entity, target) {
            sound(TESLA);

            shoot_entity_entity(entity, LIGHTNING, target, 0d15, 0d0);
            damage(target, 0d10, True);
        }

        // bombs

        @install()
        @weak()
        fun ai_move_bomb_toss(entity, projectile:THROWABLE, target) {
            shoot_entity_entity(entity, ONION, target, 0x2a, 0x1a);
            arg[0x10] = target[X];
            arg[0x12] = target[Y];
            sleep(0d80);

            bomb_absolute(entity, arg[0x10], arg[0x12], 0x60, 0d0);

            _add_placeholder(ANIMATION_PLACEHOLDER.EXPLOSION_GREEN_1, arg[0x10], arg[0x12]);
            arg[0x14] = <LAST_ENTITY>;

            sleep(0d35);
            destroy(arg[0x14]);
        }
        @install()
        @weak()
        fun ai_move_bomb_enemy(entity) {
            bomb_entity(entity, 0d110, 0d10);

            add_placeholder(ANIMATION_PLACEHOLDER.EXPLOSION_GREEN_1, entity[X], entity[Y]);
            arg[0x10] = <LAST_ENTITY>;
            sleep(0d35);

            destroy(arg[0x10]);
        }
        @install()
        @weak()
        fun ai_bombardement(direction:DIRECTION) {
            if(direction == DIRECTION.WEST) {
                arg[0x12] = <BOY>[X] + 0d300;
            } else {
                if(<BOY>[X] > 0d300) {
                    arg[0x12] = <BOY>[X] - 0d300;
                } else {
                    arg[0x12] = 0d0;
                }
            }
            arg[0x14] = <BOY>[Y];

            _add_enemy(BEE, arg[0x12], arg[0x14], INACTIVE_IMORTAL);
            if(direction == DIRECTION.WEST) {
                face(LAST_ENTITY, WEST);
            } else {
                face(LAST_ENTITY, EAST);
            }

            arg[0x10] = <LAST_ENTITY>;

            while(True) {
                if(direction == DIRECTION.WEST) {
                    arg[0x10][X] -= 0d3;
                } else {
                    arg[0x10][X] += 0d3;
                }


                if(direction == DIRECTION.WEST) {
                    if(<BOY>[X] > 0d310) {
                        if(arg[0x10][X] < (<BOY>[X] - 0d300)) {
                            destroy(arg[0x10]);
                            end();
                        }
                    } else {
                        if(arg[0x10][X] <= 0d10) {
                            destroy(arg[0x10]);
                            end();
                        }
                    }
                } else {
                    if(arg[0x10][X] > (<BOY>[X] + 0d300)) {
                        destroy(arg[0x10]);
                        end();
                    }
                }

                if(False) {
                    sleep(0d20);
                    debug_memory(arg[0x10][X], arg[0x10][Y]);
                } else {
                    sleep(0d2);
                }

                arg[0x16]++;
                if(arg[0x16] >= 0d10) {
                    arg[0x16] = 0d0;

                    bomb_entity(arg[0x10], 0d50, 0d10);
                    // sound(GORE_EXPLOSION);
                }
            }
        }

        // movement

        @install()
        @weak()
        fun ai_move_charge_right(entity, target, speed, count) {
            control(entity, True);

            attribute(entity, ROOT, True);
            animate(entity, LOOP, ANIMATION_ENEMY.LIZARD_ROLL);
            face(entity, EAST);

            while(count > 0d0) {
                while(entity[X] < 0x200) {
                    entity[X] += speed;
                    bomb_entity(entity, 0d10, 0d10);

                    yield();
                }

                count--;

                entity[X] = 0d0;
                entity[Y] = target[Y];

                animate(entity, LOOP, ANIMATION_ENEMY.LIZARD_ROLL);
            }

            arg[0x10] = <BOY>[X];

            while(entity[X] < arg[0x10]) {
                entity[X] += speed;
                bomb_entity(entity, 0d10, 0d10);

                yield();
            }

            animate(entity, ONCE, ANIMATION_ENEMY.LIZARD_DUCK_1);

            arg[0x10] = entity[X] - 0d20;

            while(entity[X] > arg[0x10]) {
                entity[X]--;

                sleep(0d2);
            }

            attribute(entity, ROOT, False);
            animate(entity, ONCE, DEFAULT);
            control(entity, False);
        }

        // scripts

        @install()
        @weak()
        fun sterling_grab(sterling, with_roar, drop_x, drop_y, falling_threshold, damage_boy) {
            attach_to_script(sterling);

            if(False) {
                debug_subtext("sterling grab");
            }
            
            control(sterling, True);

            if(False) {
                <0x283d> = sterling;
                call(0x99992d);

                control(sterling, False);
                end();
            }

            // <0x2834> = 0xffff;

            if(dead(<SCRIPT_OWNER>)) {
                control(sterling, False);
                end();
            }
            
            control(NONE);
            player_control(BOY);
            attribute(BOY, ROOT, True);
            attribute(SCRIPT_OWNER, ROOT, True);

            // sterling flying

            attribute(SCRIPT_OWNER, INVINCIBLE, True);
            animate(SCRIPT_OWNER, LOOP, ANIMATION_ENEMY.STERLING_FLY_2);

            arg[0x10] = <SCRIPT_OWNER>[X];
            arg[0x12] = <SCRIPT_OWNER>[Y];

            arg[0x14] = <BOY>[X] - 0x06;
            arg[0x16] = <BOY>[Y] - 0x1f;

            arg[0x18] = 0x1e;
            arg[0x12] -= 0x10;

            val dx_grab = signed arg[0x1a];
            val dy_grab = signed arg[0x1c];

            dx_grab = arg[0x14] - arg[0x10];
            dy_grab = arg[0x16] - arg[0x12];

            arg[0x1e] = (dx_grab << 0x04) / arg[0x18];
            arg[0x20] = (dy_grab << 0x04) / arg[0x18];

            arg[0x22] = arg[0x10] << 0x04;
            arg[0x24] = arg[0x16] << 0x04;

            <SCRIPT_OWNER>[VELOCITY] = arg[0x18] / 0x02;
            arg[0x12] = 0x00;

            while(arg[0x12] <= arg[0x18]) {
                arg[0x22] += arg[0x1e];
                arg[0x24] += arg[0x20];
                arg[0x26] = 0x0000;
                _teleport(<SCRIPT_OWNER>, arg[0x22] >> 0x04, arg[0x24] >> 0x04);
                _teleport(BOY, arg[0x14], arg[0x16]); // lock boy in position
                yield();
                arg[0x12]++;
            }

            // sterling reached boy

            // if(dead(<SCRIPT_OWNER>)) {
            //     subtext("dead 2");
            //     end();
            // }

            // call(0x99988a);

            if(False) {
                debug_memory(arg[0x1e], arg[0x20]);
                // subtext("test 2");
                // end();
            }

            arg[0x10] = <BOY>[X];
            arg[0x12] = <BOY>[Y];

            if(True) {
                arg[0x14] = drop_x << 0x03; // drop_x
                arg[0x16] = drop_y << 0x03; // drop_y
            } else if(arg[0x10] == 0x01) {
                arg[0x14] = 0x00f8;
                arg[0x16] = 0x00e8;
                face(BOY, WEST);
                face(SCRIPT_OWNER, WEST);
            } else {
                arg[0x14] = 0x02d8;
                arg[0x16] = 0x00e8;
                face(BOY, EAST);
                face(SCRIPT_OWNER, EAST);
            }

            yield();

            animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
            arg[0x18] = 0x004b;
            arg[0x12] -= 0x10;
            arg[0x26] = 0x0010;
            _teleport(BOY, arg[0x10], arg[0x12]);

            arg[0x26] = 0x0000;
            _teleport(SCRIPT_OWNER, arg[0x10] - 0x06, arg[0x12] - 0x1f);

            val dx = signed arg[0x1a];
            val dy = signed arg[0x1c];

            dx = arg[0x14] - arg[0x10];
            dy = arg[0x16] - arg[0x12];

            if(False) {
                debug_memory(dx, dy);
                sleep(0d120);
            }

            arg[0x1e] = (dx << 0x04) / arg[0x18];
            arg[0x20] = (dy << 0x04) / arg[0x18];

            arg[0x22] = arg[0x10] << 0x04;
            arg[0x24] = arg[0x12] << 0x04;

            <BOY>[VELOCITY] = arg[0x18] / 0x02;
            <SCRIPT_OWNER>[VELOCITY] = arg[0x18] / 0x02;

            arg[0x12] = 0x00;

            while(arg[0x12] <= arg[0x18]) {
                arg[0x22] += arg[0x1e];
                arg[0x24] += arg[0x20];
                arg[0x26] = 0x0010;
                _teleport(<BOY>, arg[0x22] >> 0x04, arg[0x24] >> 0x04);
                arg[0x26] = 0x0000;
                _teleport(<SCRIPT_OWNER>, (arg[0x22] >> 0x04) - 0x06, (arg[0x24] >> 0x04) - 0x1f);
                yield();
                arg[0x12]++;

                if(False) {
                    debug_memory(arg[0x22], arg[0x24]);
                    sleep(0d60);
                }
            }

            // sterling reached drop

            sleep(0x1d);
            if(with_roar) {
                call(0x99988a);
            }

            arg[0x10] = <BOY>[X];
            arg[0x12] = <BOY>[Y];

            if(True) {
                // arg[0x14] = 0x00f8;
                arg[0x16] = falling_threshold; // falling_threshold
                // arg[0x16] = arg[0x12] + falling_threshold;
            } else if(arg[0x10] == 0x01) {
                arg[0x14] = 0x00f8;
                arg[0x16] = 0x01e8;
            } else {
                arg[0x14] = 0x02d8;
                arg[0x16] = 0x0258;
            }

            animate(BOY, LOOP, ANIMATION_BOY.FALL_1);
            // _teleport(<BOY>, arg[0x10], arg[0x12]);

            if(False) {
                debug_subtext("drop boy");
                sleep(0d60);
                debug_memory(arg[0x12], arg[0x16]);
                sleep(0d60);
            }

            while(arg[0x12] < arg[0x16]) {
                _teleport(<BOY>, arg[0x10], arg[0x12]);
                yield();
                arg[0x12] += 0x04;
            }

            // boy dropped

            sfx_effect(SHAKING, True);

            animate(BOY, ONCE, ANIMATION_BOY.LANDING);
            attribute(BOY, ROOT, False);
            control(BOTH);

            if(True) { // otherwise it triggers the exits and not boy_death()
                sleep(0d03);
            }

            <0x23d7> = 0x0001;
            damage(BOY, damage_boy, True);
            sleep(0x0e);

            sfx_effect(SHAKING, False);


            if(False) { // teleport to default position
                <0x24ab> = 0x0158;
                <0x24af> = 0x00e8;

                _teleport(<SCRIPT_OWNER>, <0x24ab>, <0x24af>);
            }

            yield();
            animate(SCRIPT_OWNER, ONCE, ANIMATION_ALL.DEFAULT);
            attribute(SCRIPT_OWNER, INVINCIBLE, False);
            attribute(<SCRIPT_OWNER>, ROOT, False);

            sleep(0d120);

            control(sterling, False);
        }

        @install()
        @weak()
        fun sterling_grab_3d(sterling, with_roar, drop_x, drop_y, falling_threshold, damage_boy) {
            // debug_subtext("+walk");
            walk(sterling, TILE_ABSOLUTE_DIRECT, drop_x, drop_y, True);
            control(sterling, True);
            // debug_subtext("-walk");
        }
        
        @install()
        @weak()
        @async()
        fun attach_sterling_script(entity, with_roar, stomp_radius, drop_x, drop_y, falling_threshold, damage_boy) {
            if(False) {
                <0x283d> = entity;
                
                call(0x9997a7); // (07) CALL 0x9997a7 Sterling battle over, Gomi introduction
            } else {
                if(False) {
                    debug_memory(entity, stomp_radius);
                    sleep(0d60);
                }

                while!(dead(entity)) {
                    if((<ACTIVE>[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) == 0d0) {
                        if!(entity[FLAGS_1] & ATTRIBUTE_FLAGS.DISABLED) {
                            arg[0x10] = entity[X];
                            arg[0x12] = entity[Y];
                            arg[0x14] = <BOY>[X];
                            arg[0x16] = <BOY>[Y];

                            if(arg[0x10] < arg[0x14]) {
                                arg[0x18] = arg[0x14] - arg[0x10];
                            } else {
                                arg[0x18] = arg[0x10] - arg[0x14];
                            }

                            if(arg[0x12] < arg[0x16]) {
                                arg[0x1a] = arg[0x16] - arg[0x12];
                            } else {
                                arg[0x1a] = arg[0x12] - arg[0x16];
                            }

                            // yield();

                            if((arg[0x18] <= stomp_radius) && (arg[0x1a] <= stomp_radius)) {
                                // arg[0x20]++;
                                // debug_memory(arg[0x20], 0x00);

                                // <BOY>[GENERAL_PURPOSE] = 0d1;
                                control(NONE);

                                if(with_roar) {
                                    call_async(ADDRESS.STERLING_ROAR);
                                }
                                if(True) {
                                    sterling_grab(entity, with_roar, drop_x, drop_y, falling_threshold, damage_boy);
                                } else {
                                    sterling_grab_3d(entity, with_roar, drop_x, drop_y, falling_threshold, damage_boy);
                                }
                            } else {
                                sleep(0d4);
                            }
                        }
                    }

                    yield();

                    if(False) {
                        debug_memory(arg[0x18], arg[0x1a]);
                        sleep(0d60);
                    }
                }
            }
        }
    };

    group experimental() {
        fun sand_tunnel() {
            // TODO: extract script, add parameters
            call(0x939fd2);
        }

        fun bonfire_activate(x, y, id) {
            // add_enemy(LANTERN_LIGHT, x, y, INACTIVE_IMORTAL);
            // attach_script(LAST_ENTITY, B, 0x181e);
            // entity_script_controlled(LAST_ENTITY);

            add_enemy(LANTERN_LIGHT_RED, 0x00, 0x00, INACTIVE);
            <LAST_ENTITY>[0x1a] = x;
            <LAST_ENTITY>[0x1c] = y;
            attach_script(LAST_ENTITY, DAMAGE, id);
        }
        fun bonfire_dialog() {
            control(NONE);
            color_filter(0x84, 0x90);
            sleep(0x10);
            animate(BOY, LOOP, ANIMATION_BOY.SLEEP_DOWN);
            color_filter(0x84, 0x66);
            sleep(0x10);
            color_filter(0x55, 0x55);
            animate(BOY, LOOP, ANIMATION_BOY.SLEEP_UP);
            yield();

            // question("[0x96][0x8b]test[LF][0x8b]test[LF][0x8b]test");

            color_filter(0x84, 0x90);
            sleep(0x10);
            color_filter(0x84, 0x66);
            sleep(0x10);
            color_filter(0x00, 0x00);
        }

        fun cannonball() {
            add_enemy(0x6a, 0x1e, 0x21, 0x0000); // ENEMY.MAGMAR
            <0x2846> = <LAST_ENTITY>;
            animate(0x2846, LOOP, ANIMATION_ENEMY.MAGMAR_ROLL);
            
            while(0x01) {
                sleep(0x70);

                teleport(0x2846, 0x1e, 0x21);
            }
        }

        fun homing_cannonball() {
            add_enemy(0x6a, 0x1e, 0x21, 0x0000); // ENEMY.MAGMAR
            <0x2846> = <LAST_ENTITY>;
            animate(0x2846, LOOP, ANIMATION_ENEMY.MAGMAR_ROLL);
            
            while(0x01) {
                eval("18 21 02 50 29 6c 1a d5 // (18) WRITE $2479 = *(boy + 28)");
                eval("18 21 02 08 21 02 29 3f 9b // (18) WRITE $2477 = $2477 + 2");

                eval("18 1f 02 08 1f 02 29 32 9a // (18) WRITE $2477 = $2477 + 2");

                // teleport(0x2846, 0x1e, 0x21);
                code(0x43, entity_t(0x2846), entity_t(0x2477), entity_t(0x2479), "// (42) Teleport $2835 to a7, b9");

                sleep(0x02);
            }
        }

        fun show_shop(ingredient_id) {
            // call_id(NPC_DIALOGUE_START);
            call_id(OPEN_TEXTBOX_DEFAULT);
            <0x2459> = ingredient_id;
            call_id(DIALOGUE_BUY_INGREDIENT);
            // call_id(NPC_DIALOGUE_STOP);
        }

        fun code() {
            while(True) {
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0800) {
                    yield();
                }
                subtext("up");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0800) {
                    yield();
                }
                subtext("up");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0400) {
                    yield();
                }
                subtext("down");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0400) {
                    yield();
                }
                subtext("down");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0200) {
                    yield();
                }
                subtext("left");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0100) {
                    yield();
                }
                subtext("right");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0200) {
                    yield();
                }
                subtext("left");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0100) {
                    yield();
                }
                subtext("right");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x8000) {
                    yield();
                }
                subtext("b");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0080) {
                    yield();
                }
                subtext("a");
                
                while(CUSTOM_MEMORY.INPUT_P1 != 0x0000) {
                    yield();
                }
                while(CUSTOM_MEMORY.INPUT_P1 != 0x1000) {
                    yield();
                }
                subtext("start");

                sleep(0d60);

                subtext("yay");
                
                yield();
            }
        }

        @install()
        @weak()
        fun track_speed(character, time) {
            arg[0x10] = character[X];
            arg[0x12] = character[Y];

            while(True) {
                sleep(0d60 * time);

                arg[0x14] = character[X];
                arg[0x16] = character[Y];

                arg[0x14] = (signed arg[0x14] - signed arg[0x10]) / time;
                arg[0x16] = (signed arg[0x16] - signed arg[0x12]) / time;

                if(signed arg[0x14] < 0d0) {
                    arg[0x14] = -(arg[0x14]);
                }
                if(signed arg[0x16] < 0d0) {
                    arg[0x16] = -(arg[0x16]);
                }

                debug_memory(arg[0x14], arg[0x16]);

                character[X] = arg[0x10];
                character[Y] = arg[0x12];
            }
        }

        // fun unique_drop_test() {
        //     _add_enemy(MOSQUITO, <BOY>[X], <BOY>[Y] - 0d20);
        //     if!(<0x2834, 0x01>) {
        //         attach_script(LAST_ENTITY, DEATH, reference(@install() {
        //             attach_script(SCRIPT_OWNER, B, reference(@install() {
        //                 loot(LOOT_SNIFF, <0x2834, 0x01>, 0xff, PETAL, 0d1, 0d0);
        // 
        //                 destroy(SCRIPT_OWNER);
        //             }));
        //             
        //             animate_eternal_dust();
        //         }));
        //     }
        // }
    };
};